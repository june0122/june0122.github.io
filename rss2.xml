<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>카미유 테크 블로그</title>
    <link>http://june0122.github.io/</link>
    
    <atom:link href="http://june0122.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 24 Aug 2021 11:32:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[Android] Jetpack Compose 기초 - 수명 주기</title>
      <link>http://june0122.github.io/2021/08/23/android-compose-lifecycle/</link>
      <guid>http://june0122.github.io/2021/08/23/android-compose-lifecycle/</guid>
      <pubDate>Mon, 23 Aug 2021 12:40:47 GMT</pubDate>
      
      <description>컴포저블의 수명 주기는 ① 컴포지션 시작, ② 0회 이상 리컴포지션, ③ 컴포지션 종료 이벤트로 정의된다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="수명-주기-개요"><a class="markdownIt-Anchor" href="#수명-주기-개요"></a> 수명 주기 개요</h2><h4 id="컴포지션smallcompositionsmall"><a class="markdownIt-Anchor" href="#컴포지션smallcompositionsmall"></a> 컴포지션<small>(composition)</small></h4><ul><li><strong>UI를 기술하는 컴포저블의 트리 구조</strong><ul><li><small>원문에서 describe를 사용하는데 이는 설명보다는 기술(記述), 즉 '어떤 것을 기록한다’는 의미로 해석하는 것이 좋을 것 같다.</small></li></ul></li><li>컴포저블을 실행하여 생성되며 앱의 UI를 기술한다.</li><li>Jetpack Compose가 컴포저블을 실행할 때 빌드한 UI에 대한 설명</li></ul><p>Jetpack Compose는 처음으로 컴포저블을 실행할 때, 즉 초기 컴포지션<small>(initial composition)</small> 때, 컴포지션에서 UI를 기술하기 위해 호출하는 <strong>컴포저블을 추적</strong>한다. 앱의 상태가 변경되면 Jetpack Compose는 <strong>리컴포지션</strong>을 예약한다. 리컴포지션은 Jetpack Compose가 상태 변경에 따라 변경될 수 있는 컴포저블을 재실행한 다음, 변경사항을 반영하도록 컴포지션을 업데이트하는 것이다.</p><p>컴포지션은 초기 컴포지션을 통해서만 생성되고 리컴포지션을 통해서만 업데이트될 수 있다. 컴포지션을 수정하는 유일한 방법은 리컴포지션을 통하는 것이다.</p><blockquote><p>요점 : 컴포저블의 수명 주기는 ① 컴포지션 시작, ② 0회 이상 리컴포지션, ③ 컴포지션 종료 이벤트로 정의된다.</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/130401469-5b2bcac3-4a39-4e43-a16a-005786817d37.png'></p><p>리컴포지션은 일반적으로 <code>State&lt;T&gt;</code> 객체가 변경되면 트리거된다. Compose는 이러한 객체를 추적하고 컴포지션에서 특정 <code>State&lt;T&gt;</code>를 읽는 모든 컴포저블 및 호출하는 컴포저블 중 <em>건너뛸 수 없는</em> 모든 컴포저블을 실행한다.</p><blockquote><p>참고 : 컴포저블의 수명 주기는 뷰, 활동 및 프래그먼트의 수명 주기보다 간단하다. 컴포저블이 수명 주기가 더 복잡한 외부 리소스를 관리하거나 이와 상호작용해야 하는 경우 <a href="https://developer.android.com/jetpack/compose/side-effects#state-effect-use-cases">Effect API</a>를 사용해야 한다.</p></blockquote><p>컴포저블이 여러 번 호출되면 컴포지션에 여러 인스턴스가 배치된다. 컴포지션의 각 호출에는 자체 수명 주기가 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyComposable</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        Text(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        Text(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>위 코드의 컴포지션 내 <code>MyComposable</code>의 표현</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/130402716-3f66abc7-9c33-418e-848c-158f7e9d6c71.png'></p><p>컴포저블이 여러 번 호출되면 컴포지션에 여러 인스턴스가 배치된다. 색상이 다른 요소는 해당 요소가 별도의 인스턴스임을 나타낸다.</p><h2 id="컴포지션-내-컴포저블의-분석"><a class="markdownIt-Anchor" href="#컴포지션-내-컴포저블의-분석"></a> 컴포지션 내 컴포저블의 분석</h2><p>컴포지션 내 컴포저블의 인스턴스는 <b>호출 사이트<small>(call site)</small></b>로 식별된다. Compose 컴파일러는 각 호출 사이트를 고유한 것으로 간주한다. 여러 호출 사이트에서 컴포저블을 호출하면 컴포지션에 컴포저블의 여러 인스턴스가 생성된다.</p><blockquote><p>핵심 용어: 호출 사이트는 컴포저블이 호출되는 <em>소스 코드 위치</em>다. 호출 사이트는 컴포지션 내부에서의 위치에 영향을 미치므로 UI 트리에도 영향을 미친다.</p></blockquote><p>리컴포지션 시 컴포저블이 이전 컴포지션 시 호출한 것과 다른 컴포저블을 호출하는 경우, Compose는 <strong>호출되거나 호출되지 않은 컴포저블을 식별하며</strong> 두 컴포지션 모두에서 호출된 컴포저블의 경우 <strong>입력이 변경되지 않은 경우 재구성하지 않는다.</strong></p><p>부수 효과를 컴포저블과 연결하기 위해서는 리컴포지션마다 다시 시작하는 대신 완료할 수 있도록 ID를 유지하는 것이 중요하다.</p><p>다음 예를 참고하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LoginScreen</span><span class="params">(showError: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (showError) &#123;</span><br><span class="line">        LoginError()</span><br><span class="line">    &#125;</span><br><span class="line">    LoginInput() <span class="comment">// 호출 사이트는 LoginInput이 컴포지션 내부에서 배치되는 위치에 영향을 준다</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LoginInput</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>위의 코드에서 <code>LoginScreen</code>은 <code>LoginError</code> 컴포저블을 조건부로 호출하며 항상 <code>LoginInput</code> 컴포저블을 호출한다. 각 호출에는 고유한 호출 사이트 및 컴파일러가 호출을 고유하게 식별하는 데 사용하는 소스 위치가 있다.</p><blockquote><p><code>showError</code> 플래그가 <code>true</code>로 변경된 경우 앞의 코드가 재구성되는 방식을 보여주는 다이어그램. <code>LoginError</code> 컴포저블이 추가되지만 다른 컴포저블은 재구성되지 않는다.</p></blockquote><p align = 'center'><img width = '700' src = 'https://user-images.githubusercontent.com/39554623/130406707-f05431af-f4f6-4b0c-aa9e-a62da32daf94.png'></p><p>위 그림은 상태가 변경되고 리컴포지션이 발생할 때 컴포지션 내 LoginScreen의 표현을 담고 있으며, 색상이 동일하면 재구성되지 않았음을 의미한다.</p><p><code>LoginInput</code>이 첫 번째로 호출되었다가 두 번째로 호출되었지만 <code>LoginInput</code> 인스턴스는 여러 리컴포지션에 걸쳐 유지된다. 또한 <code>LoginInput</code>에는 리컴포지션 간에 변경된 매개변수가 없으므로 Compose가 <code>LoginInput</code> 호출을 건너뛴다.</p><h3 id="스마트-리컴포지션에-도움이-되는-정보-추가"><a class="markdownIt-Anchor" href="#스마트-리컴포지션에-도움이-되는-정보-추가"></a> 스마트 리컴포지션에 도움이 되는 정보 추가</h3><p>컴포저블을 여러 번 호출하면 컴포저블이 컴포지션에도 여러 번 추가된다. 동일한 호출 사이트에서 컴포저블을 여러 번 호출하는 경우, Compose가 각 컴포저블 호출을 고유하게 식별할 수 있는 정보가 없으므로 인스턴스를 구분하기 위해 호출 사이트 외에 실행 순서가 사용된다. 이 동작만 필요한 경우도 있지만, 경우에 따라 원치 않는 동작이 발생할 수도 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MoviesScreen</span><span class="params">(movies: <span class="type">List</span>&lt;<span class="type">Movie</span>&gt;)</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        <span class="keyword">for</span> (movie <span class="keyword">in</span> movies) &#123;</span><br><span class="line">            <span class="comment">// MovieOverview 컴포저블은 for loop의 인덱스 위치가 지정된 컴포지션에 배치된다</span></span><br><span class="line">            MovieOverview(movie)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 예에서 Compose는 호출 사이트 외에 실행 순서를 사용하여 컴포지션에서 인스턴스를 구분한다. 새 <code>movie</code>가 리스트의 하단에 추가된 경우 Compose는 인스턴스의 리스트 내 위치가 변경되지 않았고 따라서 인스턴스의 <code>movie</code> 입력이 동일하므로 컴포지션에 이미 있는 인스턴스를 재사용할 수 있다.</p><blockquote><p>리스트의 하단에 새 요소가 추가된 경우의 컴포지션 내 <code>MoviesScreen</code>의 표현. 이때 컴포지션의 <code>MovieOverview</code> 컴포저블은 재사용할 수 있다. <code>MovieOverview</code>의 색상이 동일하면 컴포저블이 재구성되지 않았음을 의미한다.</p></blockquote><p align = 'center'><img width = '700' src = 'https://user-images.githubusercontent.com/39554623/130410236-3eb502b3-0b48-4145-9330-c0d62d3a5c0d.png'></p><p>하지만 리스트의 상단 또는 가운데에 항목을 추가하거나, 항목을 삭제하거나 재정렬하여 <code>movies</code> 리스트가 변경되면 리스트에서 입력 매개변수의 위치가 변경된 모든 <code>MovieOverview</code> 호출에서 리컴포지션이 발생한다. 이는 예를 들어 <code>MovieOverview</code>가 부수 효과를 사용하여 영화 이미지를 가져오는 경우 매우 중요하다. 효과가 적용되는 동안 리컴포지션이 발생하면 효과가 취소되고 다시 시작된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MovieOverview</span><span class="params">(movie: <span class="type">Movie</span>)</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        <span class="comment">// 부수 작용은 본문의 뒷부분에서 설명한다.</span></span><br><span class="line">        <span class="comment">// MovieOverview가 재구성하면</span></span><br><span class="line">        <span class="comment">// 이미지 가져오기가 진행되는 동안 취소되고 다시 시작된다.</span></span><br><span class="line">        <span class="keyword">val</span> image = loadNetworkImage(movie.url)</span><br><span class="line">        MovieHeader(image)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>리스트 상단에 새 요소가 추가될 때의 컴포지션 내 <code>MoviesScreen</code>의 표현. <code>MovieOverview</code> 컴포저블은 재사용할 수 없으며 모든 부수 효과가 다시 시작된다. <code>MovieOverview</code>의 색상이 다르면 컴포저블이 재구성되었음을 의미한다.</p></blockquote><p align = 'center'><img width = '700' src = 'https://user-images.githubusercontent.com/39554623/130410373-76719b6f-5f3b-4487-bb86-f4c5408c6fda.png'></p><p>이상적으로 <code>MovieOverview</code> 인스턴스의 ID는 인스턴스에 전달된 <code>movie</code>의 ID에 연결된 것으로 간주된다. 영화 리스트를 재정렬하는 경우 다른 영화 인스턴스로 각 <code>MovieOverview</code> 컴포저블을 재구성하는 대신 컴포지션 트리 내 인스턴스를 재정렬하는 것이 이상적이다. Compose는 트리의 특정 부분을 식별하는데 사용할 값을 런타임에 알릴 수 있는 방법인 <a href="https://github.com/june0122/TIL/blob/master/ANDROID/Documentation/Compose/key%20composable.md">key</a> 컴포저블을 제공한다.</p><p><code>key</code> 컴포저블 호출로 코드 블록을 래핑하고 하나 이상의 값을 전달하면, 이러한 값이 컴포지션에서 인스턴스를 식별하는 데 함께 사용된다. <code>key</code> 값은 <i>전역적으로<small>(globally)</small></i> 고유하지 않아도 되며, 호출 사이트에서의 컴포저블 호출 간에만 고유하면 된다. 따라서 이 예에서 각 <code>movie</code>에는 <code>movies</code> 사이에 고유한 <code>key</code>가 있어야 한다. 앱의 다른 위치에 있는 다른 컴포저블과 이 <code>key</code>를 공유하는 것은 괜찮다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MoviesScreen</span><span class="params">(movies: <span class="type">List</span>&lt;<span class="type">Movie</span>&gt;)</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        <span class="keyword">for</span> (movie <span class="keyword">in</span> movies) &#123;</span><br><span class="line">            key(movie.id) &#123; <span class="comment">// 이 movie의 고유한 ID</span></span><br><span class="line">                MovieOverview(movie)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서 리스트의 요소가 변경되더라도, Compose는 개별 <code>MovieOverview</code> 호출을 인식하고 재사용할 수 있다.</p><blockquote><p>리스트에 새 요소가 추가될 때 컴포지션 내 <code>MoviesScreen</code>의 표현. <code>MovieOverview</code> 컴포저블에는 고유 키가 있으므로 Compose가 변경되지 않은 <code>MovieOverview</code> 인스턴스를 인식하고 재사용할 수 있다. 인스턴스의 부수 효과는 계속 실행된다.</p></blockquote><p align = 'center'><img width = '700' src = 'https://user-images.githubusercontent.com/39554623/130410492-72e043e3-5136-404b-814c-17b7222a88d8.png'></p><blockquote><p>요점 : <code>key</code> 컴포저블을 사용하면 Compose가 컴포지션에서 컴포저블 인스턴스를 식별할 수 있다. 이 기능은 여러 컴포저블이 동일한 호출 사이트에서 호출되고 부수 효과 또는 내부 상태가 포함되어 있을 때 중요하다.</p></blockquote><p>일부 컴포저블에는 <code>key</code> 컴포저블 지원 기능이 내장되어 있다. 예를 들어 <code>LazyColumn</code>의 경우 <code>items</code> DSL에 맞춤 <code>key</code>를 지정할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MoviesScreen</span><span class="params">(movies: <span class="type">List</span>&lt;<span class="type">Movie</span>&gt;)</span></span> &#123;</span><br><span class="line">    LazyColumn &#123;</span><br><span class="line">        items(movies, key = &#123; movie -&gt; movie.id &#125;) &#123; movie -&gt;</span><br><span class="line">            MovieOverview(movie)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="입력이-변경되지-않은-경우-건너뛰기"><a class="markdownIt-Anchor" href="#입력이-변경되지-않은-경우-건너뛰기"></a> 입력이 변경되지 않은 경우 건너뛰기</h3><p>컴포지션에 이미 컴포저블이 있는 경우, 모든 입력이 안정적이고 변경되지 않았으면 리컴포지션을 건너뛸 수 있다.</p><p>안정적인 타입<small>(stable type)</small>은 다음 계약을 준수해야 한다.</p><ul><li><code>equals</code> 결과가 동일한 두 인스턴스의 경우 항상 동일하다.</li><li>타입의 공개 속성이 변경되면 컴포지션에 알림이 전송된다.</li><li>모든 공개 속성 타입도 안정적이다.</li></ul><p><code>@Stable</code> 주석을 사용하여 안정적이라고 명시되지 않더라도 Compose 컴파일러가 안정적인 것으로 간주하며 이 계약에 포함되는 중요한 일반 타입이 있다.</p><ul><li>모든 원시 값 유형: <code>Boolean</code>, <code>Int</code>, <code>Long</code>, <code>Float</code>, <code>Char</code> 등</li><li>문자열</li><li>모든 함수 유형(람다)</li></ul><p>이 타입들은 모두 변경할 수 없으므로 stable 계약을 준수할 수 있다. 변경할 수 없는 타입은 절대 변경되지 않으므로 Composition에 변경사항을 알리지 않아도 되며 따라서 이<br />계약을 훨씬 더 쉽게 준수할 수 있다.</p><blockquote><p>참고 : 완전히 변경 불가능한 모든 타입은 안전하게 안정적인 타입으로 간주할 수 있습니다.</p></blockquote><p>안정적이지만 변경할 수 있는 한 가지 중요한 타입은 Compose의 <code>MutableState</code> 타입이다. 값이 <code>MutableState</code>로 유지되는 경우, <code>State</code>의 <code>.value</code> 속성이 변경되면 Compose에 알림이 전송되므로 상태 객체는 전체적으로 안정적인 것으로 간주된다.</p><p>컴포저블에 매개변수로 전달된 모든 타입이 안정적인 경우, UI 트리 내 컴포저블 위치를 기반으로 매개변수 값이 동일한지 비교한다. 이전 호출 이후 모든 값이 변경되지 않은 경우 리컴포지션을 건너뛴다.</p><blockquote><p>요점 : 모든 입력이 안정적이고 변경되지 않은 경우 Compose는 컴포저블의 리컴포지션을 건너뛴다. 비교에서는 <code>equals</code> 메서드를 사용한다.</p></blockquote><p>Compose는 증명할 수 있는 경우에만 타입을 안정적인 것으로 간주한다. 예를 들어 인터페이스는 일반적으로 안정적이지 않은 것으로 간주되며, 구현이 변경 불가능한 변경할 수 있는 공개 속성이 있는 타입도 안정적이지 않다<small>(types with mutable public properties whose implementation could be immutable are not stable either.)</small>.</p><p>Compose가 타입이 안정적이라고 추론할 수 없지만 안정적인 것으로 간주하도록 하려면 <a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/Stable"><code>@Stable</code></a> 어노테이션으로 표시한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 타입을 stable로 표시하여 건너뛰기 및 스마트 리컴포지션을 선호하게 한다.</span></span><br><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UiState</span>&lt;<span class="type">T : Result&lt;T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> value: T?</span><br><span class="line">    <span class="keyword">val</span> exception: Throwable?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> hasError: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = exception != <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드에서는 <code>UiState</code>가 인터페이스이므로 Compose가 일반적으로 이 타입을 안정적이지 않은 것으로 간주할 수 있다. <code>@Stable</code> 어노테이션을 추가하면 Compose가 이 타입이 안정적임을 알게 되고 스마트 리컴포지션을 선호하게 된다. 즉, 인터페이스가 매개변수 유형으로 사용되는 경우 Compose가 모든 구현을 안정적인 것으로 간주함을 뜻한다.</p><blockquote><p>요점 : Compose가 타입의 안정성을 추론할 수 없다면 Compose가 스마트 재구성을 선호하도록 타입에 <code>@Stable</code> 어노테이션을 단다.</p></blockquote><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li>Android developers : <a href="https://developer.android.com/jetpack/compose/lifecycle#skipping">Lifecycle of composables</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Compose/">Compose</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Jetpack/">Jetpack</category>
      
      <category domain="http://june0122.github.io/tags/Compose/">Compose</category>
      
      
      <comments>http://june0122.github.io/2021/08/23/android-compose-lifecycle/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Jetpack Compose 기초 - 상태 관리</title>
      <link>http://june0122.github.io/2021/08/23/android-compose-managing-state/</link>
      <guid>http://june0122.github.io/2021/08/23/android-compose-managing-state/</guid>
      <pubDate>Mon, 23 Aug 2021 12:37:19 GMT</pubDate>
      
      <description>Jetpack Compose를 사용하면 Android 앱에서 상태를 저장하고 사용하는 위치와 방법을 명시적으로 나타낼 수 있다. 이 가이드에서는 상태와 컴포저블 간의 관계에 관해 그리고 보다 손쉬운 상태 처리를 위해 Jetpack Compose에서 제공되는 API에 관해 집중적으로 설명한다.</description>
      
      
      
      <content:encoded><![CDATA[<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HelloContent</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(modifier = Modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">        Text(</span><br><span class="line">            text = <span class="string">&quot;Hello!&quot;</span>,</span><br><span class="line">            modifier = Modifier.padding(bottom = <span class="number">8.</span>dp),</span><br><span class="line">            style = MaterialTheme.typography.h5</span><br><span class="line">        )</span><br><span class="line">        OutlinedTextField(</span><br><span class="line">            value = <span class="string">&quot;&quot;</span>,</span><br><span class="line">            onValueChange = &#123; &#125;,</span><br><span class="line">            label = &#123; Text(text = <span class="string">&quot;Name&quot;</span>) &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HelloContent</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(modifier = Modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">        <span class="comment">// mutableStateOf() creates a mutable state, which is an observable type in Compose</span></span><br><span class="line">        <span class="comment">// 이 값이 변경되면 해당 값을 읽는 컴포저블 함수들의 재구성이 스케쥴 된다.</span></span><br><span class="line">        <span class="keyword">var</span> name <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="string">&quot;&quot;</span>) &#125;</span><br><span class="line">        </span><br><span class="line">        Text(</span><br><span class="line">            text = <span class="string">&quot;Hello, <span class="variable">$name</span>!&quot;</span>,</span><br><span class="line">            modifier = Modifier.padding(bottom = <span class="number">8.</span>dp),</span><br><span class="line">            style = MaterialTheme.typography.h5</span><br><span class="line">        )</span><br><span class="line">        OutlinedTextField(</span><br><span class="line">            value = name,</span><br><span class="line">            onValueChange = &#123; name = it &#125;,</span><br><span class="line">            label = &#123; Text(text = <span class="string">&quot;Name&quot;</span>) &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/129935091-fdd41b9b-4cf0-4a8c-ac36-1ed186edcd4f.gif'></p><p>Remember helps us preserve the state across re-compositions. Otherwise, if we would just use mutableStateOf without remember, every time our HelloContent composable gets recomposed, the state gets reinitialized to an empty string.</p><p>We can use the remembered value as a parameter for other composables, or even as logic in statements to change what composable’s already displayed.</p><p>For example, we don’t want to display the greeting if the name is empty, so we can use the state in an if statement.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HelloContent</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(modifier = Modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">        <span class="keyword">var</span> name <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="string">&quot;&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name.isNotEmpty()) &#123; <span class="comment">// if문 추가</span></span><br><span class="line">            Text(</span><br><span class="line">                text = <span class="string">&quot;Hello, <span class="variable">$name</span>!&quot;</span>,</span><br><span class="line">                modifier = Modifier.padding(bottom = <span class="number">8.</span>dp),</span><br><span class="line">                style = MaterialTheme.typography.h5</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OutlinedTextField(</span><br><span class="line">            value = name,</span><br><span class="line">            onValueChange = &#123; name = it &#125;,</span><br><span class="line">            label = &#123; Text(text = <span class="string">&quot;Name&quot;</span>) &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>While remember helps us retain state across re-compositions, the state won’t be retained across configuration changes. For this, we’ll have to use rememberSaveable. RememberSavable will automatically save any value that can be saved in a bundle. But if that’s not the case, you can pass in a custom saver object.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HelloContent</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column(modifier = Modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">        <span class="keyword">var</span> name <span class="keyword">by</span> rememberSaveable &#123; mutableStateOf(<span class="string">&quot;&quot;</span>) &#125; <span class="comment">// remember -&gt; rememberSaveable</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name.isNotEmpty()) &#123;</span><br><span class="line">            Text(</span><br><span class="line">                text = <span class="string">&quot;Hello, <span class="variable">$name</span>!&quot;</span>,</span><br><span class="line">                modifier = Modifier.padding(bottom = <span class="number">8.</span>dp),</span><br><span class="line">                style = MaterialTheme.typography.h5</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OutlinedTextField(</span><br><span class="line">            value = name,</span><br><span class="line">            onValueChange = &#123; name = it &#125;,</span><br><span class="line">            label = &#123; Text(text = <span class="string">&quot;Name&quot;</span>) &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Right now, our composable holds its own state. This makes the composable hard to reuse, hard to test, and keeps the composable tightly coupled to how the state is stored.</p><p>So we should name this a stateless composable: a composable that doesn’t hold any state.</p><p>To do this, we can use state hoisting.</p><p>State hoisting is a programming pattern where you move the state to the caller of a composable.</p><p>A simple way to do it is by replacing the state with a parameter and use functions to represent events.</p><p>The parameter is the current value to be displayed, and the event is a lambda function that gets triggered whenever the state needs to be updated.</p><p>In our case, we extract the name and the onValueChange out of HelloContent and move them higher to a HelloScreen composable that calls HelloContent. HelloContent has access to the state as an immutable string parameter as well as a lambda onNameChange that it can call when it wants to request the state change.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HelloScreen</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">by</span> rememberSaveable &#123; mutableStateOf(<span class="string">&quot;&quot;</span>) &#125;</span><br><span class="line">    HelloContent(name = name, onNameChange = &#123; name = it &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HelloContent</span><span class="params">(name: <span class="type">String</span>, onNameChange: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Column(modifier = Modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name.isNotEmpty()) &#123;</span><br><span class="line">            Text(</span><br><span class="line">                text = <span class="string">&quot;Hello, <span class="variable">$name</span>!&quot;</span>,</span><br><span class="line">                modifier = Modifier.padding(bottom = <span class="number">8.</span>dp),</span><br><span class="line">                style = MaterialTheme.typography.h5</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OutlinedTextField(</span><br><span class="line">            value = name,</span><br><span class="line">            onValueChange = onNameChange,</span><br><span class="line">            label = &#123; Text(text = <span class="string">&quot;Name&quot;</span>) &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambdas are the most common way to describe events on a composable.</p><p>Here, we’re defining an event called onNameChange using a lambda that takes a string using Kotlin’s function type syntax. We’re using onNameChange, present tense, as the event doesn’t mean that the state has already changed, but that the composable is requesting that the event handler change it.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HelloScreen</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="string">&quot;&quot;</span>) &#125;</span><br><span class="line">    HelloContent(name = name, onNameChange = &#123; name = it &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HelloContent</span><span class="params">(name: <span class="type">String</span>, onNameChange: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Column(modifier = Modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">        Text(</span><br><span class="line">            text = <span class="string">&quot;Hello, <span class="variable">$name</span>!&quot;</span>,</span><br><span class="line">            modifier = Modifier.padding(bottom = <span class="number">8.</span>dp),</span><br><span class="line">            style = MaterialTheme.typography.h5</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        OutlinedTextField(</span><br><span class="line">            value = name,</span><br><span class="line">            onValueChange = onNameChange,</span><br><span class="line">            label = &#123; Text(text = <span class="string">&quot;Name&quot;</span>) &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Like this, the state goes down from HelloScreen to HelloContent, and events go up from HelloContent to HelloScreen, making HelloContent more reusable and testable than before.</p><p>But what if we want to use the name in other layers of our app?</p><p>Maybe we want to save it in a database. The best way to do this is to use a view model that will store the state in an observable holder and handle events.</p><p>So we can create a HelloViewModel that extends the ViewModel class.</p><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/129942318-16e83154-3698-48da-82c6-0bbcd9c24660.png'></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &quot;androidx.compose.runtime:runtime-livedata:$compose_version&quot;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _name = MutableLiveData(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> name: LiveData&lt;String&gt; = _name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HelloScreen</span><span class="params">(helloViewModel: <span class="type">HelloViewModel</span> = viewModel()</span></span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> name <span class="keyword">by</span> helloViewModel.name.observeAsState(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    HelloContent(name = name, onNameChange = &#123; name = it &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The view model holds and exposes the name in a LiveData, which then can be observed as state and passed to a composable.</p><p>Like this, every time the value in LiveData changes, it will automatically trigger a re-composition of HelloContent.</p><p>As the view model survives configuration changes, we don’t need to do anything else to persist the UI state.</p><p>Under the hood, <code>observeAsState</code> will also remember the state for it so it can survive re-composition.</p><blockquote><p>event handing 호이스팅</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _name = MutableLiveData(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> name: LiveData&lt;String&gt; = _name</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hoist the event handling to the view model.</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onNameChange</span><span class="params">(newName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        _name.value = newName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HelloScreen</span><span class="params">(helloViewModel: <span class="type">HelloViewModel</span> = viewModel()</span></span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> name <span class="keyword">by</span> helloViewModel.name.observeAsState(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    HelloContent(name = name, onNameChange = &#123; helloViewModel.onNameChange(it) &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then, we also hoist the event handling to the view model.</p><p>Like this, the view model is the one that updates the state every time an event happens.</p><p>As the UI state can be changed from other layers of the app, like based on the response of a network call, the view model allows us to better encapsulate the state and create a single source of truth for the UI, which makes it less likely to create inconsistent states.</p><blockquote><p>최종 코드</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _name = MutableLiveData(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> name: LiveData&lt;String&gt; = _name</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hoist the event handling to the view model.</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onNameChange</span><span class="params">(newName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        _name.value = newName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HelloScreen</span><span class="params">(helloViewModel: <span class="type">HelloViewModel</span> = viewModel()</span></span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> name <span class="keyword">by</span> helloViewModel.name.observeAsState(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    HelloContent(name = name, onNameChange = &#123; helloViewModel.onNameChange(it) &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HelloContent</span><span class="params">(name: <span class="type">String</span>, onNameChange: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Column(modifier = Modifier.padding(<span class="number">16.</span>dp)) &#123;</span><br><span class="line">        Text(</span><br><span class="line">            text = <span class="string">&quot;Hello, <span class="variable">$name</span>!&quot;</span>,</span><br><span class="line">            modifier = Modifier.padding(bottom = <span class="number">8.</span>dp),</span><br><span class="line">            style = MaterialTheme.typography.h5</span><br><span class="line">        )</span><br><span class="line">        OutlinedTextField(</span><br><span class="line">            value = name,</span><br><span class="line">            onValueChange = onNameChange,</span><br><span class="line">            label = &#123; Text(text = <span class="string">&quot;Name&quot;</span>) &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="요약"><a class="markdownIt-Anchor" href="#요약"></a> 요약</h2><ul><li>Persist state across re-composition: <code>remember</code></li><li>Persist state across configuration changes: <code>rememberSaveable</code></li><li><em>Hoist the state</em> for re-usability and testability</li><li>Use ViewModel with LiveData and <code>observeAsState</code></li></ul><p>If your state is internal to a composable, make sure you use <code>remember</code> to persist the state across re-composition.</p><p>Use <code>rememberSaveable</code> to persist the state across configuration changes.</p><p>Where possible, try to hoist the state to make the composable more reusable and testable.</p><p>Finally, use the “ViewModel” to hold an exposed state in an observable state holder like LiveData and to handle events.</p><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li>Android developers - <a href="https://www.youtube.com/watch?v=mymWGMy9pYI">Jetpack Compose: State</a></li><li>Android developers Youtube - <a href="https://developer.android.com/jetpack/compose/state">State and Jetpack Compose</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Compose/">Compose</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Jetpack/">Jetpack</category>
      
      <category domain="http://june0122.github.io/tags/Compose/">Compose</category>
      
      
      <comments>http://june0122.github.io/2021/08/23/android-compose-managing-state/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[디자인 패턴] 싱글턴 패턴(Singleton Pattern)</title>
      <link>http://june0122.github.io/2021/08/22/design-pattern-singleton/</link>
      <guid>http://june0122.github.io/2021/08/22/design-pattern-singleton/</guid>
      <pubDate>Sun, 22 Aug 2021 11:18:12 GMT</pubDate>
      
      <description>소프트웨어 디자인 패턴에서 &lt;b&gt;싱글턴 패턴&lt;small&gt;(Singleton pattern)&lt;/small&gt;&lt;/b&gt;을 따르는 클래스는, 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다.</description>
      
      
      
      <content:encoded><![CDATA[<p>객체가 있으면 해당 객체의 인스턴스들을 원하는만큼 생성할 수 있다.</p><p><code>Cat</code> 클래스가 있다고 가정해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span></span><br></pre></td></tr></table></figure><p>프로그래머는 다음과 같이 원하는 만큼 인스터스를 생성할 수 있으며, 아무런 문제가 없다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> firstCat = Cat()</span><br><span class="line"><span class="keyword">val</span> secondCat = Cat()</span><br><span class="line"><span class="keyword">val</span> yetAnohterCat = Cat()</span><br></pre></td></tr></table></figure><p>이러한 행동을 허용하지 않으려면 어떻게 해야할까?</p><p>분명히, 처음에 어떤 방식으로든 객체를 생성해야 한다. 하지만 두 번째부터는 <strong>이 객체가 이미 한 번 초기화되었으며, 대신 인스턴스를 반환한다는 것을 인식</strong>해야 한다. 이것이 싱글턴이 되는 주요 아이디어다.</p><p>자바와 다른 언어에서는 이 작업이 상당히 복잡하다.</p><ul><li>생성자를 <code>private</code>로 만들고 <strong>객체가 이미 한 번 이상 초기화되었음을 기억</strong>하는 것만으로는 충분하지 않다.</li><li>두 개의 개별 스레드가 동시에 초기화를 시도하는 <strong>경쟁 상태<small>(race condition)</small>를 방지</strong>하는 작업도 필요하다.<ul><li>경쟁 상태를 허용해버리면 두 개의 스레드가 동일한 객체의 두 인스턴스에 대한 참조를 가지므로 싱글턴의 전체 개념을 깨뜨릴 것이다.</li></ul></li></ul><p>자바에서 이러한 문제를 해결하려면 다음 중 하나를 수행해야 한다.</p><ul><li>싱글턴이 처음 액세스할 때가 아니라 애플리케이션이 시작될 때 빠르게 초기화된다는 점을 수락한다.</li><li>경쟁 조건을 방지하고 성능을 유지하기 위해 특정 코드를 작성한다.</li><li>이러한 문제들을 이미 해결한 프레임워크를 사용한다.</li></ul><p>코틀린은 이를 위해 <code>object</code> 예약어를 도입했다. 다음 객체를 보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 중괄호는 필요하지 않지만, 시각적 일관성을 위해 추가하였다.</span></span><br><span class="line"><span class="keyword">object</span> MySingleton &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>object</code>는 하나의 키워드에 선언과 초기화를 결합한 것이다. 이제부터 코드의 어디에서든 <code>MySingleton</code>에 접근할 수 있으며, 정확히 하나의 인스턴스만 존재할 것이다.</p><p>아직 객체가 아무런 작업을 수행하지 않으므로 호출 횟수를 계산하도록 코드를 추가해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> CounterSingleton &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> counter = AtomicInteger(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">increment</span><span class="params">()</span></span> = counter.incrementAndGet()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스레드 안정성<small>(thread safety)</small>은 테스트하지 않고, 일단 싱글턴을 호출하는 방법을 확인하기 위해 테스트해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">    println(CounterSingleton.increment())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드는 1에서 10까지의 숫자를 출력한다. 보다시피, <code>getInstance()</code> 메서드가 필요하지 않다.</p><blockquote><p><code>object</code>는 싱글턴을 생성하는 것 이상의 용도로 사용되는 키워드다.</p></blockquote><p>객체는 생성자를 가질 수 없다.</p><p>처음으로 데이터베이스에서 데이터를 로드하거나 네트워크를 통해 데이터를 로드하는 것과 같이 싱글턴에 대한 일종의 초기화 로직을 원하는 경우 <code>init</code> 블록을 대신 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> CounterSingleton &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;I was accessed for the first time&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 추가 코드는 여기서부터</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>또한 Kotlin의 싱글턴은 느리게 초기화된다<small>(<a href="https://kotlinlang.org/docs/object-declarations.html#semantic-difference-between-object-expressions-and-declarations">참고</a> : Object declarations are initialized lazily, when accessed for the first time)</small>. 일반 클래스와 마찬가지로 객체는 다른 클래스를 확장하고 인터페이스를 구현할 수 있다.</p><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li>Hands-on Design Patterns with Kotlin</li><li>Kotlin Docs : <a href="https://kotlinlang.org/docs/object-declarations.html">Object expressions and declarations</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Design-Pattern/">Design Pattern</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Design-Pattern/">Design Pattern</category>
      
      
      <comments>http://june0122.github.io/2021/08/22/design-pattern-singleton/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[디자인 패턴] 위임 패턴(Delegate Pattern)</title>
      <link>http://june0122.github.io/2021/08/21/design-pattern-delegate/</link>
      <guid>http://june0122.github.io/2021/08/21/design-pattern-delegate/</guid>
      <pubDate>Sat, 21 Aug 2021 09:06:35 GMT</pubDate>
      
      <description>소프트웨어 엔지니어링에서 &lt;b&gt;Delegate pattern&lt;small&gt;(위임 패턴)&lt;/small&gt;&lt;/b&gt;은 객체 합성이 상속과 동일하게 코드 재사용을 할 수 있도록 하는 객체 지향 디자인 패턴이다.</description>
      
      
      
      <content:encoded><![CDATA[<p>소프트웨어 엔지니어링에서 <b>delegate pattern<small>(위임 패턴)</small></b>은 객체 합성이 상속과 동일하게 코드 재사용을 할 수 있도록 하는 객체 지향 디자인 패턴이다.</p><h2 id="상속smallinheritancesmall-vs-합성smallcompositionsmall"><a class="markdownIt-Anchor" href="#상속smallinheritancesmall-vs-합성smallcompositionsmall"></a> 상속<small>(inheritance)</small> vs 합성<small>(composition)</small></h2><blockquote><p>객체지향 시스템에서 기능의 재사용을 위해 구사하는 가장 대표적인 기법은 클래스 상속, 그리고 객체 합성<small>(object composition)</small>이다.</p></blockquote><h3 id="클래스-상속"><a class="markdownIt-Anchor" href="#클래스-상속"></a> 클래스 상속</h3><ul><li>서브클래싱, 즉 다른 부모 클래스에서 상속받아 한 클래스의 구현을 정의하는 것.</li><li>서브클래싱에 의한 재사용을 화이트박스 재사용<small>(white-box reuse)</small>이라고 한다.<ul><li>'화이트박스’는 내부를 볼 수 있다는 의미에서 나온 말로, 상속을 받으면 부모 클래스의 내부가 서브클래스에 공개되기 때문에 화이트박스인 셈이다.</li></ul></li></ul><h3 id="객체-합성"><a class="markdownIt-Anchor" href="#객체-합성"></a> 객체 합성</h3><ul><li>클래스 상속에 대한 대안으로 다른 객체를 여러 개 붙여서 새로운 기능 혹은 객체를 구성하는 것이다.<ul><li>즉, 객체 또는 데이터 유형을 더 복잡한 유형으로 결합하는 방법</li></ul></li><li>객체를 합성하려면, 합성에 들어가는 객체들의 인터페이스를 명확하게 정의해 두어야 한다.</li><li>이런 스타일의 재사용을 블랙박스 재사용<small>(black-box reuse)</small>이라고 한다.<ul><li>객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문.</li></ul></li></ul><p>상속과 합성은 서로 장단점을 가지고 있다.</p><h4 id="클래스-상속의-장단점"><a class="markdownIt-Anchor" href="#클래스-상속의-장단점"></a> 클래스 상속의 장단점</h4><p>장점</p><ul><li>컴파일 시점에 정적으로 정의되고 프로그래밍 언어가 직접 지원하므로 그대로 사용하면 된다.</li><li>클래스 상속으로 부모 클래스의 구현을 쉽게 수정할 수도 있는데, 서브클래스는 모든 연산이 아닌 일부만 재정의할 수도 있다.</li></ul><p>단점</p><ul><li>런타임에 상속받은 부모 클래스의 구현을 변경할 수 없다.<ul><li>상속은 컴파일 시점에 결정되는 사항이기 때문.</li></ul></li><li>부모 클래스는 서브클래스의 물리적 표현의 최소 부분만을 정의하기 때문에 서브클래스는 부모 클래스가 정의한 물리적 표현들을 전부 또는 일부 상속받는다는 점.<ul><li>상속은 부모 클래스의 구현이 서브클래스에 다 드러나는 것이기 때문에 상속은 캡슐화를 파괴한다고 보는 시각도 있다.</li><li>서브클래스는 부모 클래스의 구현에 종속될 수밖에 없으므로, 부모 클래스 구현에 변경이 생기면 서브클래스도 변경해야 한다.</li></ul></li></ul><p>이 구현의 종속성이 걸림돌로 작용하면서, 서브클래스를 재사용하려고 할 때 문제가 발생한다. 상속한 구현이 새로운 문제에 맞지 않을 때, 부모 클래스를 재작성해야 하거나 다른 것으로 대체하는 일이 생기게 된다. 이런 종속성은 유연성과 재사용성을 떨어뜨린다.</p><ul><li>이를 해결하는 방법 한 가지는 추상 클래스에서만 상속 받는 것이다. 추상 클래스에는 구현이 거의 없거나 아예 없기 때문이다. 이미 추상 클래스를 상속했다는 것은 구현이 아닌 인터페이스를 상속한 것이므로 구현 자체는 서브클래스가 정의한다. 구현이 변경되면 서브클래스만 변경하면 되고 상위 추상 클래스는 고려할 필요가 없다.</li></ul><h4 id="객체-합성-2"><a class="markdownIt-Anchor" href="#객체-합성-2"></a> 객체 합성</h4><p>객체 합성은 한 객체가 다른 객체에 대한 참조자를 얻는 방식으로 런타임에 동적으로 정의된다. 합성은 객체가 다른 객체의 인터페이스만을 바라보게 하기 때문에, 인터페이스 정의에 더 많은 주의를 기울여야 한다. 객체는 인터페이스에서만 접근하므로 캡슐화를 유지할 수 있다. 동일한 타입을 갖는다면 다른 객체로 런타임에 대체가 가능하다. 객체는 인터페이스에 맞춰 구현되므로 구현 사이의 종속성은 확실히 줄어든다.</p><p>객체 합성은 시스템 설계에 또 다른 영향을 끼친다. 클래스 상속보다 객체 합성을 더 선호하는 이유는 각 클래스의 캡슐화를 유지할 수 있고, 각 클래스의 한 가지 작업에 집중할 수 있기 때문이다. 객체 합성으로 설계되면 클래스의 수는 적어지고 객체의 수는 좀더 많아질 수 있지만, 시스템의 행동은 클래스에 정의된 정적인 내용보다는 런타임에 드러나는 객체 합성에 의한 상호 관련성에 따라 달라질 수 있다.</p><blockquote><h3 id="클래스-상속보다는-객체-합성을-선호하라smallfavor-object-composition-over-class-inheritancesmall"><a class="markdownIt-Anchor" href="#클래스-상속보다는-객체-합성을-선호하라smallfavor-object-composition-over-class-inheritancesmall"></a> 클래스 상속보다는 객체 합성을 선호하라<small>(Favor object composition over class inheritance.)</small>.</h3></blockquote><p>결론적으로 재상용을 위해서 새로운 구성요소를 생성할 필요 없이 필요한 기존의 구성요소를 조립해서 모든 새로운 기능을 얻어올 수 있다. 그러나 가능한 구성요소의 집합이 실제로 사용할 수 있을 만큼 충분하지 않기 때문에, 기존 구성요소의 조합을 통한 재사용만으로 목적을 달성할 수 있는 경우는 드물다. 상속에 의한 재사용은 기존 클래스들을 조합해서 새로운 구성요소를 쉽게 만들 수 있도록 해 준다. 그러므로 상속과 객체 합성은 적절히 조합되어야만 완벽히 재사용이 가능하다.</p><h2 id="위임smalldelegationsmall"><a class="markdownIt-Anchor" href="#위임smalldelegationsmall"></a> 위임<small>(delegation)</small></h2><p>위임은 합성을 상속만큼 강력하게 만드는 방법이다.</p><p>위임에서는 두 객체가 하나의 요청을 처리한다. 수신 객체가 연산의 처리를 <b>위임자<small>(delegate)</small></b>에게 보낸다. 이는 서브클래스가 부모 클래스에게 요청을 전달하는 것과 유사한 방식이다.</p><p>위임과 동일한 효과를 얻으려면 수신 객체는 대리자에게 자신을 매개변수로 전달해서 위임된 연산이 수신자를 참조하게 한다.</p><blockquote><p>Window 클래스가 <code>area()</code> 호출을 내부 Rectangle 객체<small>(위임자, delegate)</small>에 위임</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>(<span class="keyword">val</span> width: <span class="built_in">Int</span>, <span class="keyword">val</span> height: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span> = width * height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span></span>(<span class="keyword">val</span> bounds: Rectangle) &#123;</span><br><span class="line">    <span class="comment">// Delegation</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span> = bounds.area()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Window 클래스를 Rectangle 클래스의 서브클래스로 만드는 대신, Window 클래스는 Rectangle 클래스를 자신의 인스턴스 변수로 만들고 Rectangle 클래스에 정의된 행동이 필요할 때는 Rectangle 클래스에 위임함으로써 Rectangle의 행동을 재사용할 수 있다.</p><p>다시 말해, 상속에 의해 Window 인스턴스를 Rectangle 인스턴스로 간주하는 방식이 아닌 Window 인스턴스가 Rectangle 인스턴스를 포함하도록 하고, Window 인스턴스는 자신이 받은 요청을 Rectangle 인스턴스로 전달하는 것이다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/130242401-6f1987cc-4d37-453d-8601-a9ffd5ff269d.png'></p><p>Window 클래스는 <code>area()</code> 연산을 Rectangle 인스턴스에 전달한다.</p><p>실선 화살표는 한 클래스가 다른 클래스의 인스턴스에 대한 참조자를 갖고 있음을 보여준다. 참조는 이름을 선택적으로 정의할 수 있는데, 다이어그램에선 <code>rectangle</code>로 정의한다.</p><p>위임의 가장 중요한 장점은 런타임에 행동의 복합을 가능하게 하고, 복합하는 방식도 변경해준다는 것이다.</p><ul><li>Window 객체가 런타임에 Rectangle 인스턴스를 Circle 인스턴스로 대체하면 원형의 윈도우가 될 것이다.</li><li>물론 이를 위해서는 Rectangle 클래스와 Circle 클래스가 동일한 타입이라는 가정이 필요하다.</li></ul><p>위임이 갖는 단점은 객체 합성을 통해 소프트웨어 설계의 유연성을 보장하는 방법과 동일하게 동적인데다가 고도로 매개변수화된 소프트웨어는 정적인 소프트웨어 구조보다 이해하기가 더 어렵다는 점이다.</p><ul><li>그 이유는 클래스에 상호작용이 다 정의되어 있는 것이 아니라 런타임 객체에 따라서 그 결과가 다르기 때문이다. 또한 런타임에 비효율적일 수 있다.</li><li>이런 위임이 만들어 내는 복잡함보다 단순화의 효과를 더 크게 할 수 있다면 그 설계는 사용하기 좋은 설계이다. 그러나 이러한 유용성은 상황에 따라 다르고 얼마나 많은 경험을 갖고 있는가에 좌우되므로 위임은 고도로 표준화된 패턴에서 사용하는 것이 최상이다.</li></ul><h3 id="위임을-부분적으로-사용하는-디자인-패턴"><a class="markdownIt-Anchor" href="#위임을-부분적으로-사용하는-디자인-패턴"></a> 위임을 부분적으로 사용하는 디자인 패턴</h3><ul><li>상태<small>(State)</small> 패턴</li><li>전략<small>(Strategy)</small> 패턴</li><li>방문자<small>(Visitor)</small> 패턴</li></ul><p>상태 패턴에서 객체는 현재 상태를 표현하는 상태 객체에 요청의 처리를 위임한다. 전략 패턴에서 객체는 요청을 수행하는 추상화한 전략 객체에게 특정 요청을 위임한다.</p><ul><li>이 두 패턴의 목적은 처리를 전달하는 객체를 변경하지 않고 객체의 행동을 변경할 수 있게 하자는 것이다.</li></ul><p>방문자 패턴에서, 객체 구조의 각 요소에 수행하는 연산은 언제나 방문자 객체에게 위임된 연산이다.</p><h3 id="위임에-전적으로-의존하는-디자인-패턴"><a class="markdownIt-Anchor" href="#위임에-전적으로-의존하는-디자인-패턴"></a> 위임에 전적으로 의존하는 디자인 패턴</h3><ul><li>중재자<small>(Mediator)</small> 패턴</li><li>책임 연쇄<small>(Chain of Responsibility)</small> 패턴</li><li>가교<small>(Bridge)</small> 패턴</li></ul><p>중재자 패턴은 객체 간의 교류를 중재하는 객체를 도입하여 중재자 객체가 다른 객체로 연산을 전달하도록 구현한다. 이때, 연산에 자신에 대한 참조자를 함께 보내고 위임받은 객체가 다시 자신에게 메시지를 보내서 자신이 정의한 데이터를 얻어가게 함으로써 진정한 위임을 구현한다.</p><p>책임 연쇄 패턴은 한 객체에서 다른 객체로 고리를 따라서 요청의 처리를 계속 위임한다. 이 요청에는 요청을 처음 받은 원본 객체에 대한 참조자를 포함한다.</p><p>가교 패턴은 구현과 추상적 개념을 분리하는 패턴이다. 추상화와 특정 구현을 대응시키고 추상화는 단순히 자신의 연산을 구현에 전달한다.</p><p>위임은 객체 합성의 극단적인 예로서, 코드 재사용을 위한 매커니즘으로 상속을 객체 합성으로 대체할 수 있다.</p><h2 id="코틀린의-위임"><a class="markdownIt-Anchor" href="#코틀린의-위임"></a> 코틀린의 위임</h2><p>코틀린은 기본적으로 보일러 플레이트가 필요 없이 위임 패턴을 지원한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClosedShape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>(<span class="keyword">val</span> width: <span class="built_in">Int</span>, <span class="keyword">val</span> height: <span class="built_in">Int</span>) : ClosedShape &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span> = width * height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> bounds: ClosedShape) : ClosedShape <span class="keyword">by</span> bounds</span><br></pre></td></tr></table></figure><p><code>Window</code>의 supertype 목록에 있는 <code>by</code> 절은 <code>bounds</code>가 <code>Window</code>의 객체 내부에 저장되고, 컴파일러가 <code>bounds</code>로 전달하는 <code>ClosedShape</code>의 모든 메서드를 생성함을 의미한다.</p><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li>&lt;Gof의 디자인 패턴&gt; 한국어판 : 상속 대 합성<small>(49p)</small>, 위임<small>(51p)</small></li><li>Kotlin Docs : <a href="https://kotlinlang.org/docs/delegation.html">Delegation</a></li><li>wikipedia : <a href="https://en.wikipedia.org/wiki/Delegation_pattern">Delegation pattern</a></li><li><a href="https://architecture101.blog/2009/02/18/misconception_of_gof_dp/">잘못 알려진 디자인 패턴의 두번째 원칙</a></li><li><a href="http://occamsrazr.net/tt/entry/favor-object-composition-over-class-inheritance%EC%9D%98-%EB%91%90-%EA%B0%80%EC%A7%80-%ED%95%B4%EC%84%9D">favor object composition over class inheritance의 두 가지 해석</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Design-Pattern/">Design Pattern</category>
      
      
      <category domain="http://june0122.github.io/tags/Design-Pattern/">Design Pattern</category>
      
      
      <comments>http://june0122.github.io/2021/08/21/design-pattern-delegate/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Jetpack Compose 개요 - Google I/O 2021</title>
      <link>http://june0122.github.io/2021/08/09/android-compose-google-io-2021/</link>
      <guid>http://june0122.github.io/2021/08/09/android-compose-google-io-2021/</guid>
      <pubDate>Mon, 09 Aug 2021 07:10:10 GMT</pubDate>
      
      <description>Google I/O 2021에서 발표한 Jetpack Compose에 대한 개요를 확인하고 선언적 UI 툴킷이 무엇인지, Compose를 사용하여 아름다운 UI를 구축하는 방법을 알아본다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="jetpack-compose의-등장-배경"><a class="markdownIt-Anchor" href="#jetpack-compose의-등장-배경"></a> Jetpack Compose의 등장 배경</h2><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128816157-8c2f051a-b69a-482c-a6a7-03aa66eb8aa7.png'></p><p>새로운 UI 툴킷이 필요한 이유는 무엇일까?</p><ul><li>뷰 기반의 기존 툴킷은 벌써 10년 넘게 사용해왔다. 그 당시와는 기술이 달라졌다.</li><li>기기 성능은 향상됐고 사용자들은 앱에 대한 더 높은 기대를 가지고 있다.</li><li>UI는 훨씬 동적이고 표현이 풍부해졌다.</li></ul><p>Views로도 멋진 앱을 개발할 수 있지만 최신 아키텍처를 기반으로 하고 Kotlin을 활용하는 현대적 툴킷을 원한다는 의견이 많았다.</p><ul><li>구글에서도 기능과 개선 사항을 더욱 빠르게 적용하고 싶어했다.</li><li>그래서 Jetpack Compose라는 선언형 독립형 툴킷<small>(declarative unbundled toolkit)</small>을 3년 전부터 개발하기 시작했다.</li><li>API Surface가 안정화되어 2021년 2월에 첫 베타를 출시하였다.</li><li>2021년 7월 28일, Jetpack Compose 1.0이 안정화 버전이 출시되었다. <small><a href="https://developer.android.com/jetpack/androidx/versions/all-channel#july_28_2021">릴리즈 노트</a></small></li></ul><h2 id="선언적-ui-툴킷smalldeclarative-ui-toolkitsmall"><a class="markdownIt-Anchor" href="#선언적-ui-툴킷smalldeclarative-ui-toolkitsmall"></a> 선언적 UI 툴킷<small>(Declarative UI Toolkit)</small></h2><h2 id="1-선언적smalldeclarativesmall"><a class="markdownIt-Anchor" href="#1-선언적smalldeclarativesmall"></a> 1. 선언적<small>(Declarative)</small></h2><p>최근 앱들은 데이터가 동적이고 실시간으로 업데이트 됨.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128815112-3838bc87-5064-439d-8fc2-28311c32df03.png'></p><p>원래 Android Views를 사용하면 XML에 UI를 선언해야 하며, 데이터가 바뀌면 UI도 업데이트해야 하고 변형도 필요하다.</p><ul><li>이를 위해서는 View를 조회하고 속성을 설정해야 한다.</li><li>애플리케이션 상태가 바뀔 때마다<small>(데이터베이스나 네트워크 호출이 로드되거나, 사용자 상호작용이 끝나면)</small> 이 새로운 정보로 UI를 업데이트해서 데이터를 동기화해야 하는데, View마다 상태가 다르고 각각 업데이트해야 하므로 그 과정이 복잡함 -&gt; 버그가 엄청나게 발생 가능, 개발자가 책임지고 모든 걸 업데이트해야 함</li></ul><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128525224-cc8efb66-832b-44b8-b803-fafd1a75e614.gif'></p><p>Compose와 같은 선언적 UI는 상태를 UI로 변환하는 다른 방식을 사용한다.</p><ul><li>UI는 변경 할 수 없고 한 번 생성하면 업데이트가 불가능함</li><li>앱 상태가 바뀌면 새로운 상태를 새로운 표현으로 변환함 -&gt; 동기화 문제가 완전히 해결됨</li><li>즉, UI 전체를 다시 생성하는 것</li></ul><p>Compose는 매우 지능적이고 효율적이어서 변경되지 않은 요소에 대한 작업은 건너 뛴다.</p><ul><li>개념적으로는 특정 상태에 맞추어 UI를 새로 생성하는 것과 같다.</li><li>코드는 특정 상태에 대한 UI 형태를 설명할 뿐, 생성 방법을 지정하지 않는다.</li></ul><h3 id="상태를-ui로-어떻게-변환할까"><a class="markdownIt-Anchor" href="#상태를-ui로-어떻게-변환할까"></a> 상태를 UI로 어떻게 변환할까?</h3><blockquote><p>문자열 리스트를 표시하는 간단한 구성 요소<small>(component)</small></p></blockquote><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128526641-503403a2-36c4-48fa-9201-a413f368aa00.png'></p><p>Compose에서 UI 구성 요소는 <code>@Composable</code> 애노테이션이 달린 함수일 뿐이다.</p><ul><li>이는 UI 구성 요소를 빠르고 쉽게 생성할 수 있게 해주며,</li><li>재사용 가능한 요소로 구성된 라이브러리로 UI를 나누는 것을 장려한다.</li></ul><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128626022-3561ec1a-4e40-4267-b40a-b1ed8167a67b.png'></p><p>컴포저블 함수는 값을 반환하는 대신 UI를 전달<small>(emit)</small>한다.</p><ul><li>예시 코드는 Compose 라이브러리의 <code>Column</code>과 <code>Text</code> 컴포저블을 사용하는 컴포저블 함수</li><li>텍스트를 수직으로 배열하고 간단한 텍스트 레이블을 표시</li></ul><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128626267-09db2334-13b4-4e7b-826c-2145b38393c0.png'></p><p>완전한 Kotlin 구문과 제어 플로우로 UI를 생성하기</p><ul><li>기존의 메시지를 반복 실행하는 코드에서 조건에 따라 요소를 표시하는 코드로 변경</li></ul><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128626399-9b0fae89-10cf-41c9-8bf6-46728c2769bb.png'></p><p><strong>컴포저블은 매개변수를 받을 수 있고 받아야만 한다.</strong></p><ul><li>데이터를 UI로 변환한다는 것이 그런 뜻이다.</li><li>컴포저블은 데이터를 함수 매개변수로 받아서 UI를 전달한다.</li><li>이렇게 함으로써, UI가 동기화 상태<small>(sync)</small>에서 벗어나지 않는다.<ul><li>메시지가 존재하는데도 “No message” 텍스트를 제거하지 않는 실수를 하지 않을 수 있다.</li></ul></li></ul><p>상태가 바뀌거나 메시지 리스트가 바뀌었을 때, 컴포저블 함수를 실행하면 새 UI가 생성된다 -&gt; <b>재생성<small>(re-composing)</small></b></p><p>메시지 목록은 어떻게 바뀔까?</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128627037-b4f2db7d-2640-44ea-a07b-c3800f424cfa.png'></p><p>콜 스택을 처리하는 동안 ViewModel이 메시지의 LiveData를 노출한다.</p><ul><li>이 데이터를 관찰할 수 있고, messages 필드를 읽는 컴포저블은 새 데이터가 입력될 때마다 재생성된다.</li><li>직접 observer를 설정할 필요가 없다.</li><li>Compose 컴파일러는 어느 컴포저블이 상태를 읽는지 추적하고, 상태가 바뀌면 자동으로 다시 실행한다.</li><li>컴파일러가 지능적이어서 입력이 변경된 컴포저블만 다시 실행하고 나머지는 건너뛰기에 매우 효율적이다.</li></ul><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128627179-ad4f61a2-3f52-4d37-8393-7a13a61c5a52.png'></p><p>각 컴포저블은 변경할 수 없다.</p><ul><li>컴포저블을 참조하거나 나중에 쿼리하거나 내용을 업데이트할 수 없다.</li><li>정보를 입력할 때는 모두 매개변수로 컴포저블에 전달해야 한다.<ul><li>하지만 이것이 컴포저블이 동적일 수 없다는 것을 의미하진 않는다.</li><li>모든 메시지를 선택하는 Checkbox를 더해 자세히 알아보자.</li></ul></li></ul><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128627253-8c7ef68b-d74c-4b54-82b5-1346cdd5c100.png'></p><p>Checkbox는 선택되지 않은 상태가 기본이다.</p><ul><li>View에서와 달리 확인란을 클릭하더라도 시각적인 변화는 없다.<ul><li>상태를 나타내는 상수로 전달했기 때문이다.</li><li>상태를 바꾸고 싶다면 코드에 적용해야 한다.</li></ul></li></ul><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128627316-71f0ad1d-5b32-4462-93e0-389bb6424cae.png'></p><p>Checkbox 선택 여부를 결정하는 로컬 변수를 넣어보자.</p><ul><li>Checkbox를 클릭하면 <code>onCheckChange</code> 이벤트를 제공한다. 이 콜백에서 로컬 상태를 업데이트할 수 있다.<ul><li>이렇게 하면 상태를 읽을 때 <code>checkbox</code>를 다시 받는다.</li><li>이 콜백에서 상태를 바꾸지 않으면 Checkbox에 시각적 변화는 없다는 걸 이해하는 것이 중요하다.</li></ul></li><li>처음에는 코드를 작성해야 Checkbox를 눌렀을 때 선택된다는게 직관적이지 못하다고 생각할 수 있지만 이것이 선언적 UI의 핵심 개념이다.</li><li>요소는 전달되는 매개변수가 완전히 통제한다. 이렇게 <b>단일 진실 공급원<small>(single source of truth)</small></b>을 생성하는 것이다.<ul><li>동기화해야 할 상태를 없애는 것!</li></ul></li><li>Checkbox를 누르는 사용자에게 어떻게 반응할지는 개발자에게 달려 있다.</li><li>검증을 실행해서 유효할 때만 디스플레이를 업데이트하고 싶은 경우, 코드로 완전히 통제하기 때문에 검증이 실패한 시점에 다시 돌아와서 변경을 취소할 필요가 없다.</li></ul><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128627697-b1f37a27-6c10-453f-b2ab-951439161b9b.png'></p><p>Compose는 입력 데이터가 바뀌면 컴포저블 함수를 다시 실행한다고 하였다. 하지만 다시 실행하거나 재생성을 호출하더라도 유지하고 싶은 변수가 있을 것이다.</p><ul><li>컴포저블 함수는 <code>remember</code> 함수를 사용하면 이전 실행에서 얻은 값을 기억할 수 있다.</li><li>그러면 값을 다시 사용해 재할당을 방지하거나 상태에 고정할 수 있다.</li></ul><p>위 예시에서는 이벤트 핸들링을 인라인으로 구현했지만, 다음 예시와 같이 대신에 state와 update lambda를 컴포저블의 매개변수로 전달하고 <b>단일 진실 공급원<small>(single source of truth)</small></b>으로 로직을 올릴 수 있다.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128627828-312166bc-e7e5-4b65-b7df-bcaec67eedc4.png'></p><p>선언적 UI의 핵심은 특정 상태에서 UI의 형태를 완전히 <b>설명하고</b> 상태가 바뀌면 프레임워크에서 UI <b>업데이트를 처리</b>하는 것이다.</p><ul><li>You completely <b>describe</b> your UI for a given state.</li><li>The framework <b>updates</b> your UI when the state changes.</li></ul><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128628063-ee977792-00b0-40db-9fc9-913e023961a0.png'></p><p>Compose는 여러 가지 애플리케이션 아키텍처와 호환되지만 단방향 데이터 플로우를 따르는 아키텍처와 잘 맞는다.</p><ul><li>ViewModel이 화면 상태의 단일 스트림을 노출하면 Compose UI에서 관찰하고, 각 구성 요소의 매개변수로 전달한다.</li><li>각 구성 요소는 필요한 상태만 수신하므로 데이터를 바꿀 때만 업데이트하면 된다.</li><li>ViewState 객체의 단일 스트림을 생성하면 상태 변경을 한 곳에서 처리하는 데 도움이 된다.</li><li>전체적 화면 상태를 추론하고 오류를 낮추기 쉽다.</li><li>이 패턴을 사용하면 간단하게 컴포저블을 테스트할 수 있다. 입력에 따라 완전히 제어되기 때문이다.</li></ul><h2 id="2-ui-툴킷smalltoolkitsmall"><a class="markdownIt-Anchor" href="#2-ui-툴킷smalltoolkitsmall"></a> 2. UI 툴킷<small>(Toolkit)</small></h2><p>선언적 패러다임을 사용하면 UI를 쉽게 사용할 수 있는 이유를 알아보자.</p><p>위에서 설명한 원칙에 따라 개발된 Compose는 풍부한 UI 구성 요소 툴킷을 제공한다.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128806100-da1987b0-b6c4-4cde-8243-be8f80580252.gif'></p><p>Jetpack Compose는 머티리얼 디자인 구성 요소와 테마 시스템을 구현한다.</p><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/128806251-852b8cd0-37cc-4ad6-9fcb-a4603693ae81.png'></p><p>애플리케이션을 조립하는 데 필요한 구성 요소도 제공한다.</p><ul><li><code>Button</code>, <code>Card</code>, <code>FAB</code>, <code>AppBar</code> 등</li></ul><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/128806465-0897fe3c-1dc0-4a6a-8825-d50ed64f7fc8.png'></p><p>모든 구성 요소는 기본적으로 머티리얼 스타일링을 따른다.</p><ul><li>머티리얼 테마를 구현하기 때문에 모든 구성 요소를 자신의 브랜드에 맞게 체계적으로 커스터마이즈할 수 있다.</li><li>원하는 색, 도형, 서체 스타일을 지정 가능</li></ul><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128806739-08dc3efc-ddb4-4a92-9b3d-cf95c8caf4c7.png'></p><p>Compose는 간단하지만 강력한 새로운 레이아웃 시스템을 제공한다.</p><ul><li>행<small>(row)</small>과 열<small>(column)</small>을 기반으로 하며 horizontal, vertical linear layout과 비슷하다고 볼 수 있다.</li><li>하지만 View 시스템과 달리, Compose 레이아웃 모델은 여러 척도<small>(measure)</small>를 전달할 수 없어서 중첩된<small>(nested)</small> 레이아웃에 적합하다.</li></ul><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/128807597-2feee562-a11d-4925-8e68-90a15688e603.png'></p><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/128807554-0a3c6242-fbf8-4533-8536-e6d8e4894dce.png'></p><p>새로운 Compose DSL<small>(Domain-specific language, 도메인 특화 언어)</small>을 적용한 ConstraintLayout을 사용하면 더욱 복잡한 레이아웃을 표현할 수 있지만 맞춤형 레이아웃도 훨씬 간단하게 구현이 된다.</p><ul><li>척도와 배치를 직접 설정해서 적절한 레이아웃을 만들고 싶다면 함수를 구현하기만 하면 된다.</li></ul><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/128807928-6c04f4d3-7a06-4a1c-b574-5a4994730128.png'></p><p>가장 기대가 큰 개선 사항은 새로운 애니메이션 시스템이다.</p><ul><li>훨씬 간단하게 사용 가능</li><li>보다 효과적이고 간단하게 UI에 모션을 적용할 수 있다.</li><li>Compose에 <a href="https://developer.android.com/training/constraint-layout/motionlayout">MotionLayout</a>을 가져오는 작업도 진행 중이다.</li></ul><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128808428-3d25ee12-72fe-4d8c-a365-7132e8fb6f07.png'></p><p>Compose에서는 테스트와 접근성이 1급 객체<small>(first-class citizens)</small>이다.</p><ul><li>UI에 병렬 트리를 생성하는 시맨틱<small>(semantic)</small> 시스템을 기반으로 한다.</li><li>접근성 서비스에 더 많은 정보를 제공하거나, UI 요소를 매칭해서 어설션<small>(assertion)</small>하는 데 도움이 된다.</li></ul><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128808455-3d85430b-47e5-4a65-98ff-4fbf65d62668.png'></p><p>Compose는 테스트 기능을 극대화하는 전용 테스트 아티팩트를 제공하고 독립적으로 컴포저블을 테스트하는 간편한 API를 제공한다.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128812945-ddc462a9-5592-413b-b952-b6097fea578a.png'></p><p>Compose는 Kotlin으로만 개발됐고 우수한 언어 기능을 활용하여 강력하고 간결하면서도 직관적인 API를 구축하였다.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128813059-334d2320-cb46-441e-8614-ead691c30b60.png'></p><p>코루틴을 사용하면 간단한 비동기식 API를 작성할 수 있다.</p><ul><li>제스처, 애니메이션, 스크롤링 등을 설명<ul><li>제스처를 애니메이션으로 핸드오프하는 것처럼 비동기식 이벤트를 결합한 코드를 간단하게 작성할 수 있다.</li></ul></li><li>구조적 동시성<small>(structured concurrency)</small>을 통해 이런 취소와 정리를 제공한다.</li></ul><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128813448-1c52c9b0-3c3d-4464-be48-a179940a5add.png'></p><p>Kotlin은 툴링<small>(tooling)</small>으로 구성된 강력한 에코시스템이 있다.</p><ul><li>UI 구성 요소를 새로운 함수로 추출해서 간단하게 재사용할 수 있다.</li></ul><h2 id="3-built-for-interop"><a class="markdownIt-Anchor" href="#3-built-for-interop"></a> 3. Built for interop</h2><blockquote><p>interoperability : 상호 운용성</p></blockquote><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128814913-a4cb5f4e-490a-417b-87cc-8456cae208e0.png'></p><p>Jetpack Compose는 기존 View 시스템과 호환된다.</p><ul><li>Compose는 필요에 따라 점진적으로 도입할 수 있다.<ul><li>화면의 작은 요소부터 시작해서 UI의 큰 부분이나 화면 전체를 교체하면 된다.</li></ul></li></ul><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128814927-385840ad-8d1e-427d-9f9c-9a245f75efc6.png'></p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128814933-5ee2c524-6124-4b7b-a26b-217c136ca506.png'></p><p>Compose는 필요한 단계를 진행할 수 있도록 도와준다.</p><ul><li>Views에 Compose를 포함할 수 있고, 반대로 Compose에서 Views를 호스팅할 수도 있다.</li><li>MapView의 광고처럼 아직 Compose로 구축하지 않은 콘텐츠를 표시할 때 유용하다.</li><li>Compose로 점차 migrate하면서 원하는 속도대로 도입할 수 있다.</li></ul><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128814954-0e0f0c4a-9504-4e87-ac78-e5534903b75f.png'></p><p>View와 상호 운용성 이외에도 다른 주요 라이브러리와의 통합을 제공한다.</p><ul><li>Compose는 기존 애플리케이션 아키텍처와도 호환돼서 처음부터 시작할 필요가 없다.<ul><li>공통 이미지 로딩 라이브러리에는 래퍼를 제공하고 머티리얼 또는 AppCompat XML 테마를 Compose로 변환할 때는 어댑터를 제공한다.</li></ul></li></ul><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li><a href="https://www.youtube.com/watch?v=7Mf2175h3RQ">What’s new in Jetpack Compose | Session</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Compose/">Compose</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Jetpack/">Jetpack</category>
      
      <category domain="http://june0122.github.io/tags/Compose/">Compose</category>
      
      <category domain="http://june0122.github.io/tags/Google-I-O-2021/">Google I/O 2021</category>
      
      
      <comments>http://june0122.github.io/2021/08/09/android-compose-google-io-2021/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Jetpack Compose 기초 - Compose 이해하기</title>
      <link>http://june0122.github.io/2021/08/05/android-compose-thinking-in-compose/</link>
      <guid>http://june0122.github.io/2021/08/05/android-compose-thinking-in-compose/</guid>
      <pubDate>Wed, 04 Aug 2021 23:24:52 GMT</pubDate>
      
      <description>Jetpack Compose는 Android를 위한 현대적인 선언형 UI 도구 키트로 프론트엔드 뷰를 명령형으로 변형하지 않고도 앱 UI를 렌더링할 수 있게 하는 &lt;b&gt;선언형 API&lt;small&gt;(declarative API)&lt;/small&gt;&lt;/b&gt;를 제공한다. 이를 통해 앱 UI를 더 쉽게 작성하고 유지관리할 수 있도록 지원한다.</description>
      
      
      
      <content:encoded><![CDATA[<p>Jetpack Compose</p><ul><li>Android를 위한 현대적인 선언형 UI 도구 키트</li><li>Compose는 프론트엔드 뷰를 명령형으로 변형하지 않고도 앱 UI를 렌더링할 수 있게 하는 <b>선언형 API<small>(declarative API)</small></b>를 제공 -&gt; 앱 UI를 더 쉽게 작성하고 유지관리할 수 있도록 지원</li></ul><h2 id="선언형-프로그래밍-패러다임"><a class="markdownIt-Anchor" href="#선언형-프로그래밍-패러다임"></a> 선언형 프로그래밍 패러다임</h2><p>지금까지 Android 뷰 계층 구조는 UI 위젯의 트리로 표시해옴. 사용자 상호작용 등의 이유로 인해 앱의 상태가 변경되면, 현재 데이터를 표시하기 위해 UI 계층 구조를 업데이트해야 함</p><ul><li>UI를 업데이트하는 가장 일반적인 방법 : <code>findViewById()</code>와 같은 함수를 사용하여 트리를 탐색하고 <code>button.setText(String)</code>, <code>container.addChild(View)</code> 또는 <code>img.setImageBitmap(Bitmap)</code>과 같은 메서드를 호출하여 노드를 변경. 이러한 메서드는 위젯의 내부 상태를 변경한다.</li></ul><p>뷰를 수동으로 조작하면 오류 발생 가능성이 커진다. 일반적으로 업데이트에 필요한 뷰의 수가 많을수록 유지보수 복잡성이 증가한다.</p><ul><li>데이터를 여러 위치에서 렌더링하면 데이터를 표시하는 뷰 중 하나의 업데이트를 누락할 수도 있음</li><li>두 업데이트가 충돌하여 잘못된 상태를 야기할 수도 있음</li></ul><p>Compose는 <strong>선언형 UI 프레임워크</strong>로, 지난 몇 년 간 업계 전반으로 선언형 UI 모델로 전환하기 시작 -&gt; 사용자 인터페이스 빌드 및 업데이트와 관련된 엔지니어링이 크게 간소화됨.</p><ul><li>이 기법은 처음부터 <strong>화면 전체를 개념적으로 재생성</strong>한 후 <strong>필요한 변경사항만 적용</strong>하는 방식으로 작동</li><li>이러한 접근 방식은 상태를 가진<small>(Stateful)</small> 뷰 계층 구조를 수동으로 업데이트할 때의 복잡성을 방지할 수 있음</li></ul><p>선언형 UI 모델에서 <strong>화면 전체를 재생성</strong>하는 데 있어 한 가지 문제는 시간, 컴퓨팅 성능 및 배터리 사용량 측면에서 잠재적으로 <strong>비용이 많이 든다</strong>는 것</p><ul><li>이 비용을 줄이기 위해, Compose는 특정 시점에 UI의 어떤 부분을 다시 그려야 하는지를 지능적으로 선택함</li><li>이는 재구성<small>(Recomposition)</small>에 설명된 대로 UI 구성요소를 디자인하는 방식에 몇 가지 영향을 미친다.</li></ul><h2 id="간단한-컴포저블-함수"><a class="markdownIt-Anchor" href="#간단한-컴포저블-함수"></a> 간단한 컴포저블 함수</h2><p>Compose를 사용하면, 데이터를 받아서 UI 요소를 내보내는 컴포저블 함수들을 정의해서 사용자 인터페이스를 빌드할 수 있다.</p><blockquote><p><code>String</code>을 받아서 인사말 메시지를 표시하는 <code>Text</code> 위젯을 내보내는 <code>Greeting</code> 컴포저블 함수</p></blockquote><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128242024-9ca855c3-f6f3-420b-9493-c65908c15522.png'></p><p><code>Greeting</code> 함수에 관해 주목할 만한 참고 사항들</p><ul><li>이 함수는 <code>@Composable</code> 애노테이션으로 애노테이션이 지정된다. 모든 컴포저블 함수에는 이 애노테이션이 있어야 한다. 이 애노테이션은 이 함수가 <strong>데이터를 UI로 변환하기 위한 함수라는 것을 Compose 컴파일러에 알린다.</strong></li><li>이 함수는 데이터를 받는다. 컴포저블 함수는 매개변수를 받을 수 있으며 이 매개변수를 통해 앱 로직이 UI를 형성<small>(describe)</small>할 수 있다.</li><li>이 함수는 UI에 텍스트를 표시한다. 이를 위해 실제로 텍스트 UI 요소를 생성하는 <code>Text()</code> 컴포저블 함수를 호출한다. 컴포저블 함수는 다른 컴포저블 함수를 호출하여 UI 계층 구조를 내보낸다<small>(emit)</small>.</li><li>이 함수는 아무것도 반환하지 않는다. UI를 내보내는 Compose 함수는 UI 위젯을 구성하는 대신 원하는 화면 상태를 설명하므로 아무것도 반환할 필요가 없다.</li><li>이 함수는 빠르고, <a href="https://june0122.github.io/2021/08/05/term-idempotent/">멱등성<small>(idempotent)</small></a>이며 부수효과<small>(side-effect)</small>가 없다.<ul><li>이 함수는 동일한 인수로 여러 번 호출될 때 동일한 방식으로 작동하며, 전역 변수 또는 <code>random()</code> 호출과 같은 다른 값을 사용하지 않는다.</li><li>이 함수는 속성 또는 전역 변수 수정과 같은 부수효과 없이 UI를 형성한다.</li></ul></li></ul><p>일반적으로 모든 컴포저블 함수는 재구성에서 설명한 이유로 인해 이러한 속성을 사용하여 작성해야 한다.</p><h2 id="선언형-패러다임-전환"><a class="markdownIt-Anchor" href="#선언형-패러다임-전환"></a> 선언형 패러다임 전환</h2><p>많은 명령형 객체 지향<small>(imperative object-oriented)</small> UI 툴킷을 사용하여 위젯의 트리를 인스턴스화함으로써 UI를 초기화 한다.</p><ul><li>흔히 XML 레이아웃 파일을 인플레이팅해서 이 작업을 한다.</li><li>각 위젯은 자체의 내부 상태를 유지하고 앱 로직이 위젯과 상호작용할 수 있도록 하는 getter와 setter 메서드를 노출한다.</li></ul><p>Compose의 선언형 접근 방식에서 위젯은 비교적 상태를 가지고 있지 않으며<small>(stateless)</small> setter 또는 getter 함수를 노출하지 않는다. 사실상 <strong>위젯은 객체로 노출되지 않는다. 동일한 컴포저블 함수를 다른 인수로 호출하여 UI를 업데이트한다.</strong> 이렇게 하면 <a href="https://developer.android.com/jetpack/guide">앱 아키텍처 가이드</a>에 설명된 대로 <code>ViewModel</code>과 같은 아키텍처 패턴에 상태를 쉽게 제공할 수 있다. 그런 다음 컴포저블은 observable data가 업데이트될 때마다 현재 애플리케이션 상태를 UI로 변환한다.</p><blockquote><p>앱 로직은 최상위의 컴포저블 함수에 데이터를 제공한다. 그러면 함수는 데이터를 사용하여 다른 컴포저블을 호출함으로써 UI를 형성하고 적절한 데이터를 해당 컴포저블 및 계층 구조 아래로 전달한다.</p></blockquote><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128247989-65872489-411e-4834-be98-4c56bcaf9f2d.png'></p><p>사용자가 UI와 상호작용할 때, UI는 <code>onClick</code>과 같은 이벤트를 발생시킨다. 이러한 이벤트를 앱 로직에 알려서 앱의 상태를 변경해야 한다. 상태가 변경되면 컴포저블 함수는 새 데이터와 함께 다시 호출된다. 이렇게 하면 UI 요소가 다시 그려진다. 이 프로세스를 <b>재구성<small>(recomposition)</small></b>이라 한다.</p><blockquote><p>사용자가 UI 요소와 상호작용하며 이에 따라 이벤트가 트리거된다. 앱 로직이 이벤트에 응답하면, 컴포저블 함수가 필요한 경우 새 매개변수를 사용하여 자동으로 다시 호출된다.</p></blockquote><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/128248004-686b8128-c05d-4ad7-aad3-16d71068a137.png'></p><h2 id="동적-콘텐츠"><a class="markdownIt-Anchor" href="#동적-콘텐츠"></a> 동적 콘텐츠</h2><p>composable 함수는 XML이 아닌 Kotlin으로 작성되기 때문에, 다른 Kotlin 코드와 마찬가지로 동적일 수 있다.</p><p>예를 들어 사용자 목록으로 환영하는 UI를 빌드한다고 가정해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">(names: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (name <span class="keyword">in</span> names) &#123;</span><br><span class="line">        Text(<span class="string">&quot;Hello <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 함수는 이름 목록을 받아서 각 사용자에 대한 인사말을 생성한다. 컴포저블 함수는 상당히 정교할 수 있다<small>(sophisticated)</small>. <code>if</code> 문을 사용하여 특정 UI 요소를 표시할지 여부를 결정할 수 있고, 루프를 사용할 수도, 헬퍼 함수를 호출할 수도, 기본 언어의 유연성을 완전히 활용할 수도 있다. <strong>이러한 성능과 유연성은 Jetpack Compose의 주요 이점 중 하나이다.</strong></p><h2 id="재구성smallrecompositionsmall"><a class="markdownIt-Anchor" href="#재구성smallrecompositionsmall"></a> 재구성<small>(Recomposition)</small></h2><p>명령형 UI 모델에서 위젯을 변경하려면 위젯에서 setter를 호출하여 내부의 상태를 변경한다. Compose에서는 새 데이터를 사용하여 컴포저블 함수를 다시 호출한다. 이렇게 하면 함수가 <em>재구성</em>되며, 필요한 경우 함수에서 내보낸 위젯이 새 데이터로 다시 그려진다. Compose 프레임워크는 변경된 구성요소만 지능적으로 재구성할 수 있다.</p><p>예를 들어 다음과 같이 버튼을 표시하는 컴포저블 함수를 고려해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ClickCounter</span><span class="params">(clicks: <span class="type">Int</span>, onClick: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Button(onClick = onClick) &#123;</span><br><span class="line">        Text(<span class="string">&quot;I&#x27;ve been clicked <span class="variable">$clicks</span> times&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>버튼이 클릭될 때마다 호출자는 <code>clicks</code> 값을 업데이트한다. Compose는 <code>Text</code> 함수를 사용해 람다를 다시 호출하여 새 값을 표시한다. 이 프로세스를 <em>재구성</em>이라 한다. <strong>값에 종속되지 않은 다른 함수들은 재구성되지 않는다.</strong></p><p>앞서 논의했듯이 전체 UI 트리를 재구성하는 하는 작업은 컴퓨팅 성능 및 배터리 수명을 사용한다는 측면에서 컴퓨팅 비용이 많이 들 수 있다. Compose는 <em>지능적 재구성</em>을 통해 이 문제를 해결한다.</p><p>재구성은 입력이 변경될 때 컴포저블 함수를 다시 호출하는 프로세스다. 이는 함수의 입력이 변경될 때 발생한다. Compose는 새 입력을 기반으로 재구성할 때, 변경되었을 수 있는 함수 또는 람다만 호출하고 나머지는 건너뛴다. 매개변수가 변경되지 않는 함수 또는 람다를 모두 건너뜀으로써 Compose는 재구성을 효율적으로할 수 있다.</p><p>함수의 재구성을 건너뛸 수 있으므로 컴포저블 함수 실행의 부수효과에 의존해서는 안된다. 그렇게 하면 사용자가 앱에서 이상하고 예측 불가능한 동작을 경험할 수 있다. 부수효과는 앱의 나머지 부분에 표시되는 변경사항이다. 예를 들어 다음 작업은 모두 위험한 부수효과이다.</p><ul><li>공유 객체의 속성에 쓰기</li><li><code>ViewModel</code>에서 observable을 업데이트</li><li>Shared preferences 업데이트</li></ul><p>컴포저블 함수는 애니메이션이 렌더링될 때와 같이 모든 프레임에서 같은 빈도로 재실행될 수 있다. 애니메이션 도중 버벅거림을 방지하려면 컴포저블 함수가 빨라야 한다. Shared preferences에서 읽기와 같이 비용이 많이 드는 작업을 실행해야 하는 경우 백그라운드 코루틴에서 작업을 실행하고 값 결과를 컴포저블 함수의 매개변수로 전달해야한다.</p><p>예를 들어 다음 코드는 컴포저블을 생성하여 <code>SharedPreferences</code>의 값을 업데이트한다. 대신 이 코드는 백그라운드 코루틴의 <code>ViewModel</code>로 읽기 및 쓰기를 이동한다. 앱 로직은 콜백과 함께 현재 값을 전달하여 업데이트를 트리거한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SharedPrefsToggle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    text: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    value: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onValueChanged: (<span class="type">Boolean</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Row &#123;</span><br><span class="line">        Text(text)</span><br><span class="line">        Checkbox(checked = value, onCheckedChange = onValueChanged)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 문서에서는 Compose에서 프로그래밍할 때 알아야 할 여러 가지 사항을 설명한다.</p><ul><li>컴포저블 함수는 순서와 관계없이 실행할 수 있다.</li><li>컴포저블 함수는 동시에<small>(parallel)</small> 실행할 수 있다.</li><li>재구성은 최대한 많은 수의 컴포저블 함수 및 람다를 건너뛴다.</li><li>재구성은 낙관적이며 취소될 수 있다.</li><li>컴포저블 함수는 애니메이션의 모든 프레임에서와 같은 빈도로 매우 자주 실행될 수 있다.</li></ul><p>다음 섹션에서는 컴포저블 함수를 빌드하여 재구성을 지원하는 방법을 설명한다. 어떤 경우든 컴포저블 함수를 빠르고, 멱등성이며, 부수효과가 없는 상태로 유지하는 것이 좋다.</p><h3 id="컴포저블-함수는-순서와-관계없이-실행할-수-있음"><a class="markdownIt-Anchor" href="#컴포저블-함수는-순서와-관계없이-실행할-수-있음"></a> 컴포저블 함수는 순서와 관계없이 실행할 수 있음</h3><p>컴포저블 함수의 코드를 살펴보면 코드가 표시된 순서대로 실행된다고 가정할 수도 있다. 하지만 <strong>코드가 반드시 표시된 순서대로 실행되는 것은 아니다.</strong> 컴포저블 함수에 다른 컴포저블 함수 호출이 포함되어 있다면 그 함수는 순서와 관계없이 실행될 수 있다. Compose에는 일부 UI 요소가 다른 UI 요소보다 우선순위가 높다는 것을 인식하고 그 요소를 먼저 그리는 옵션이 있다.</p><p>예를 들어 탭 레이아웃에 세 개의 화면을 그리는 다음과 같은 코드가 있다고 가정해 보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ButtonRow</span><span class="params">()</span></span> &#123;</span><br><span class="line">    MyFancyNavigation &#123;</span><br><span class="line">        StartScreen()</span><br><span class="line">        MiddleScreen()</span><br><span class="line">        EndScreen()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StartScreen</code>, <code>MiddleScreen</code> 및 <code>EndScreen</code> 호출은 순서와 관계없이 발생할 수 있다. 즉, 예를 들어 <code>StartScreen()</code>이 일부 전역 변수(부수효과)를 설정하고 <code>MiddleScreen()</code>이 이러한 변경사항을 활용하도록 할 수 없음을 의미한다. 대신 이러한 각 함수는 독립적이어야 한다.</p><h3 id="컴포저블-함수는-동시에smallparallelsmall-실행할-수-있음"><a class="markdownIt-Anchor" href="#컴포저블-함수는-동시에smallparallelsmall-실행할-수-있음"></a> 컴포저블 함수는 동시에<small>(parallel)</small> 실행할 수 있음</h3><p>Compose는 컴포저블 함수들을 동시에 실행하여 <strong>재구성을 최적화</strong>할 수 있다. 이를 통해 Compose가 다중 코어를 활용하고, 화면에 없는 컴포저블 함수를 낮은 우선순위로 실행할 수 있다.</p><p>이 최적화는 컴포저블 함수가 백그라운드 스레드 풀 내에서 실행될 수 있음을 의미한다. 컴포저블 함수가 <code>ViewModel</code>에서 함수를 호출하면, Compose는 동시에 여러 스레드에서 이 함수를 호출할 수 있다.</p><p>애플리케이션이 올바르게 작동하도록 하려면 모든 컴포저블 함수에 부수효과가 없어야 한다. 대신 UI 스레드에서 항상 실행되는 <code>onClick</code>과 같은 콜백에서 부수효과를 트리거한다.</p><p>컴포저블 함수가 호출될 때, 호출자<small>(caller)</small>와 다른 스레드에서 호출<small>(invocation)</small>이 발생할 수 있다. 즉, 컴포저블 람다의 변수를 수정하는 코드는 피해야 한다. 이러한 코드는 thread-safe하지 않을 뿐만 아니라 컴포저블 람다의 허용되지 않는 부수효과이기 때문이다.</p><p>다음은 목록과 개수를 표시하는 컴포저블을 보여주는 예시다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ListComposable</span><span class="params">(myList: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    Row(horizontalArrangement = Arrangement.SpaceBetween) &#123;</span><br><span class="line">        Column &#123;</span><br><span class="line">            <span class="keyword">for</span> (item <span class="keyword">in</span> myList) &#123;</span><br><span class="line">                Text(<span class="string">&quot;Item: <span class="variable">$item</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Text(<span class="string">&quot;Count: <span class="subst">$&#123;myList.size&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드는 부수효과가 없으며, 입력 목록을 UI로 변환한다. 이 코드는 작은 목록을 표시할 때 유용한 코드다. 그러나 함수가 로컬 변수에 쓰는 경우, 이 코드는 thread-safe 하지 않거나 적절하지 않다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="meta">@Deprecated(<span class="meta-string">&quot;Example with bug&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ListWithBug</span><span class="params">(myList: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> items = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    Row(horizontalArrangement = Arrangement.SpaceBetween) &#123;</span><br><span class="line">        Column &#123;</span><br><span class="line">            <span class="keyword">for</span> (item <span class="keyword">in</span> myList) &#123;</span><br><span class="line">                Text(<span class="string">&quot;Item: <span class="variable">$item</span>&quot;</span>)</span><br><span class="line">                items++ <span class="comment">// column의 재구성으로 인한 부수효과 때문에 이러한 코드는 피해야 한다.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Text(<span class="string">&quot;Count: <span class="variable">$items</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예에서 items는 모든 재구성을 통해 수정된다. 수정은 애니메이션의 모든 프레임에서 또는 목록이 업데이트될 때 실행될 수 있다. 어느 쪽이든 UI에 잘못된 개수가 표시된다. 이 때문에 이와 같은 쓰기는 Compose에서 지원되지 않는다. 이러한 쓰기를 금지함으로써 프레임워크가 컴포저블 람다를 실행하도록 스레드를 변경할 수 있다.</p><h3 id="재구성은-가능한-많이-건너뜀"><a class="markdownIt-Anchor" href="#재구성은-가능한-많이-건너뜀"></a> 재구성은 가능한 많이 건너뜀</h3><p>UI의 일부가 잘못된 경우, Compose는 업데이트해야 하는 부분만 재구성하기 위해 최선을 다한다. 즉, UI 트리에서 위 또는 아래에 있는 컴포저블을 실행하지 않고 단일 버튼의 컴포저블을 다시 실행하도록 건너뛸 수 있다.</p><p>모든 컴포저블 함수 및 람다는 자체적으로 재구성할 수 있다.</p><p>다음은 목록을 렌더링할 때 재구성이 일부 요소를 건너뛸 수 있는 방법을 보여주는 예이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 헤더와 함께 사용자가 클릭할 수 있는 이름 목록 표시 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">NamePicker</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    header: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    names: <span class="type">List</span>&lt;<span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    onNameClicked: (<span class="type">String</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        <span class="comment">// 이 코드는 [header]가 변경될 때 재구성될 것이다. 하지만 [names]가 변경될 땐 재구성되지 않는다.</span></span><br><span class="line">        Text(header, style = MaterialTheme.typography.h5)</span><br><span class="line">        Divider()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LazyColumn은 RecyclerView의 Compose 버전이다.</span></span><br><span class="line">        <span class="comment">// items()에 전달된 람다는 RecyclerView.ViewHolder와 유사하다.</span></span><br><span class="line">        LazyColumn &#123;</span><br><span class="line">            items(names) &#123; name -&gt;</span><br><span class="line">                <span class="comment">// item의 [name]이 업데이트될 때, 해당 item의 adapter가 재구성된다.</span></span><br><span class="line">                <span class="comment">// adapter는 [header]가 변경된다고 재구성되지 않는다.</span></span><br><span class="line">                NamePickerItem(name, onNameClicked)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Display a single name the user can click.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">NamePickerItem</span><span class="params">(name: <span class="type">String</span>, onClicked: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Text(name, Modifier.clickable(onClick = &#123; onClicked(name) &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러한 각 범위는 재구성 도중에 실행할 유일한 사항일 수 있다. Compose는 <code>header</code>가 변경될 때 상위 요소 중 어느 것도 실행하지 않고 <code>Column</code> 람다로 건너뛸 수 있다. 그리고 <code>Column</code>을 실행할 때 Compose는 <code>names</code>가 변경되지 않았다면 <code>LazyColumnItems</code>를 건너뛰도록 선택할 수 있다.</p><p>다시 말하지만, 모든 컴포저블 함수 또는 람다를 실행하는 작업에는 부수효과가 없어야 한다. 부수효과를 실행해야 할 때는 콜백에서 부수효과를 트리거해야 한다.</p><h3 id="재구성은-낙관적임"><a class="markdownIt-Anchor" href="#재구성은-낙관적임"></a> 재구성은 낙관적임</h3><p>재구성은 Compose가 컴포저블의 매개변수가 변경되었을 수 있다고 생각할 때마다 시작된다. 재구성은 <em>낙관적</em>이다. 즉, Compose는 매개변수가 다시 변경되기 전에 재구성을 완료할 것으로 예상한다. 재구성이 완료되기 전에 매개변수가 변경되면 Compose는 재구성을 취소하고 새 매개변수를 사용하여 재구성을 다시 시작할 수 있다.</p><p>재구성이 취소되면 Compose는 재구성에서 UI 트리를 삭제한다. 표시되는 UI에 종속되는 부수효과가 있다면 구성이 취소된 경우에도 부수효과가 적용된다. 이로 인해 일관되지 않은 앱 상태가 발생할 수 있다.</p><p>낙관적 재구성을 처리할 수 있도록 모든 컴포저블 함수 및 람다가 멱등성이고 부수효과가 없는지 확인해야 한다.</p><h3 id="컴포저블-함수는-매우-자주-실행될-수-있음"><a class="markdownIt-Anchor" href="#컴포저블-함수는-매우-자주-실행될-수-있음"></a> 컴포저블 함수는 매우 자주 실행될 수 있음</h3><p>경우에 따라, 컴포저블 함수는 UI 애니메이션의 모든 프레임에서 실행될 수 있다. 함수가 기기 저장소에서 읽기와 같이 비용이 많이 드는 작업을 실행하면 이 함수로 인해 UI 버벅임<small>(jank)</small>이 발생할 수 있다.</p><p>예를 들어 위젯이 기기 설정을 읽으려고 하면 잠재적으로 이 설정을 초당 수백 번 읽을 수 있으며 이는 앱 성능에 치명적인 영향을 줄 수 있다.</p><p>컴포저블 함수에 데이터가 필요하다면 데이터의 매개변수를 정의해야 한다. 그런 다음, 비용이 많이 드는 작업을 구성<small>(composition)</small> 외부의 다른 스레드로 이동하고, <code>mutableStateOf</code> 또는 <code>LiveData</code>를 사용하여 Compose에 직접 데이터를 전달할 수 있다.</p><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li>Android Developers : <a href="https://developer.android.com/jetpack/compose/mental-model">Jetpack Compose Foundation - Thinking in Compose</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Compose/">Compose</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Jetpack/">Jetpack</category>
      
      <category domain="http://june0122.github.io/tags/Compose/">Compose</category>
      
      
      <comments>http://june0122.github.io/2021/08/05/android-compose-thinking-in-compose/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래밍 용어] 멱등성(idempotent)이란?</title>
      <link>http://june0122.github.io/2021/08/05/term-idempotent/</link>
      <guid>http://june0122.github.io/2021/08/05/term-idempotent/</guid>
      <pubDate>Wed, 04 Aug 2021 22:19:57 GMT</pubDate>
      
      <description>멱등성&lt;small&gt;(idempotent)&lt;/small&gt;에 대한 개념</description>
      
      
      
      <content:encoded><![CDATA[<p>전산학이나 수학에서 사용하는 용어로 <b>연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질</b>, <b>연산을 여러 번 반복하여도 한 번만 수행된 것과 같은 성질</b>을 의미한다. 함수 <code>f(x)</code>를 예를 들면 다음과 같은 등식이 성립된다. 즉 메서드가 여러 번 실행되어도, 결과는 같으므로 <b>안전하게 사용</b>할 수 있는 성질이기도 하다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(f(x)) = f(x)</span><br></pre></td></tr></table></figure><p>등식으로만 처음 보면 감이 오지 않을 수 있는데 절대값을 구하기 위해 사용하는 <code>abs()</code> 함수가 바로 멱등성을 가지고 있다. 모든 <code>x</code>에 대해 <code>abs(abs(x)) = abs(x)</code>이기 대문이다.</p><p>수학적 정의에서 <code>x</code>가 객체의 상태를 나타내고, <code>f</code>가 해당 객체를 변경할 수 있는 연산이라는 점을 고려해보자. 예를 들어, <a href="https://docs.python.org/2/library/stdtypes.html#set">파이썬의 set</a>이 있고, 이것의 <code>discard</code> 메서드는 set에서 요소를 제거하고, 요소가 존재하지 않으면 아무 작업도 수행하지 않는다. 그러므로</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_set.discard(x)</span><br></pre></td></tr></table></figure><p>는 동일한 작업을 두 번 수행하는 것과 정확히 동일한 효과가 있다. <small>(참고로 <code>array.pop()</code>은 멱등적이지 않다)</small></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_set.discard(x)</span><br><span class="line">my_set.discard(x)</span><br></pre></td></tr></table></figure><p>멱등 연산은 작업 수행 요청이 최소 한 번 발생하도록 보장되지만 두 번 이상 발생할 수도 있는 <b>네트워크 프로토콜 설계에 자주 사용</b>된다. 작업이 멱등적이면 작업을 두 번 이상 수행해도 결과는 한 번만 수행된 것과 동일하기 때문에 문제가 없기 때문이다.</p><p>멱등은 <b>RESTful</b> 웹 서비스의 맥락에서 많이 언급된다. REST는 HTTP를 최대한 활용하여 프로그램에 웹 콘텐츠에 대한 액세스 권한을 부여하고, 일반적으로 HTTP 요청 및 응답 내에서 원격 프로시저 호출 스타일 서비스를 터널링하는 SOAP 기반 웹 서비스와 대조적으로 설정된다.</p><p>REST는 웹 애플리케이션을 <b>리소스</b><small>(예: Twitter 사용자 또는 Flickr 이미지)</small>로 구성한 다음 <code>POST</code>, <code>PUT</code>, <code>GET</code> 및 <code>DELETE</code>의 HTTP 메서드를 사용하여 해당 리소스를 생성, 업데이트, 읽기 및 삭제한다. 이중 <code>POST</code>를 제외한 나머지 HTTP 메서드를 사용하는 API<small>(<code>GET</code>, <code>PUT</code>, <code>DELETE</code>)</small>들이 멱등성이 유지되어야 한다.</p><p>멱등성은 REST에서 중요한 역할을 한다. REST 리소스 표현을 <code>GET</code>하고<small>(예: Flickr에서 jpeg 이미지 가져오기)</small> 작업이 실패하면 작업이 성공할 때까지 <code>GET</code>을 계속해서 반복할 수 있다. 웹 서비스의 경우 이미지를 몇 번 가져왔는지는 중요하지 않다. 마찬가지로 RESTful 웹 서비스를 사용하여 Twitter 계정 정보를 업데이트하는 경우 웹 서비스에서 확인을 받기 위해 필요한 만큼 새 정보를 <code>PUT</code> 할 수 있다. 천 번 <code>PUT</code> 하는 것은 한 번 <code>PUT</code> 하는 것과 같다. 마찬가지로 REST 리소스를 천 번 <code>DELETE</code>하는 것은 한 번 <code>DELETE</code>하는 것과 같다. 따라서 멱등성을 사용하면 통신 오류에 탄력적인 웹 서비스를 훨씬 쉽게 구성할 수 있다.</p><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li>Stackoverflow : <a href="https://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation">What is an idempotent operation?</a></li><li>NHN Cloud Meetup! : <a href="https://meetup.toast.com/posts/218">지속 가능한 소프트웨어를 위한 코딩 방법</a></li><li>Wikipedia : <a href="https://en.wikipedia.org/wiki/Idempotence">Idempotence</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Terminology/">Terminology</category>
      
      
      <category domain="http://june0122.github.io/tags/Terminology/">Terminology</category>
      
      <category domain="http://june0122.github.io/tags/Idempotent/">Idempotent</category>
      
      <category domain="http://june0122.github.io/tags/RESTful/">RESTful</category>
      
      
      <comments>http://june0122.github.io/2021/08/05/term-idempotent/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래밍 용어] 리터럴(literal)과 상수(constant)란?</title>
      <link>http://june0122.github.io/2021/08/04/term-literal/</link>
      <guid>http://june0122.github.io/2021/08/04/term-literal/</guid>
      <pubDate>Tue, 03 Aug 2021 19:40:58 GMT</pubDate>
      
      <description>리터럴&lt;small&gt;(literal)&lt;/small&gt;과 상수&lt;small&gt;(constant)&lt;/small&gt;에 대한 개념 비교</description>
      
      
      
      <content:encoded><![CDATA[<p>코틀린에서 &quot;<a href="https://kotlinlang.org/docs/lambdas.html#lambda-expressions-and-anonymous-functions">람다 표현식과 익명 함수</a>는 <b>함수 리터럴<small>(function literals)</small></b>이다&quot;라는 설명을 보면서 리터럴이 정확히 무엇인지 정확히 이해하고 있지 않은 것 같아 개념을 글로 정리하게 되었다.</p><p>위키백과에서 리터럴<small>(literal)</small>은 소스 코드의 <b>고정된 값</b>을 표현하는 용어라 설명한다.</p><blockquote><p>In computer science, a literal is a notation for representing a fixed value in source code.</p></blockquote><p><code>고정된 값</code>이라는 표현 때문에 우리가 흔히 사용하던 상수<small>(constant)</small>의 개념과 혼란이 왔는데, 실제로 구글에 <i>literal vs constant</i>에 대한 검색 결과가 많이 존재하는 것을 보아 이 용어들이 헷갈리는 건 나뿐만이 아니었나 보다. 위키백과에서 상수에 대해선 실행 중에 프로그램에 의해 <b>변경되어선 안되는 값</b>이라 설명한다.</p><blockquote><p>In computer programming, a constant is a value that should not be altered by the program during normal execution.</p></blockquote><p>리터럴은 고정된 값, 상수는 변경되어선 안되는 값이라니 위키백과의 설명만 봐서는 이 용어들에 대해 감을 잡기가 어려웠기에 스택오버플로우의 답변을 살펴보았다.</p><h2 id="설명-1"><a class="markdownIt-Anchor" href="#설명-1"></a> 설명 1</h2><h3 id="리터럴"><a class="markdownIt-Anchor" href="#리터럴"></a> 리터럴</h3><ul><li><code>&quot;hey&quot;</code> (a string)</li><li><code>false</code> (a boolean)</li><li><code>3.14</code> (a real number)</li><li><code>[1,2,3]</code> (a list of numbers)</li><li><code>(x) =&gt; x*x</code> (a function)</li><li><code>/^1?$|^(11+?)\1+$/</code> (a RegExp)</li></ul><h3 id="리터럴이-아닌-것"><a class="markdownIt-Anchor" href="#리터럴이-아닌-것"></a> 리터럴이 아닌 것</h3><ul><li><code>std::cout</code> (an identifier)</li><li><code>foo = 0;</code> (a statement)</li><li><code>1 + 2</code> (an expression)</li></ul><br><p>가장 많은 채택을 받은 답변이지만 뭔가 모호하다. 다른 답변들을 살펴보자.</p><h2 id="설명-2"><a class="markdownIt-Anchor" href="#설명-2"></a> 설명 2</h2><ul><li>기본적으로 상수는 값을 변경할 수 없는 변수이다.</li><li>리터럴은 고정값을 나타내는 표기법이다. 이 값은 문자열, 숫자 등이 될 수 있다.</li><li>리터럴은 변수에 할당될 수 있다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Simba&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><p><code>a</code>와 <code>name</code>은 변수이고, <code>pi</code>는 상수다. <code>10</code>, <code>&quot;Simba&quot;</code>, <code>3.14</code>는 리터럴이다.</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> y = <span class="number">2</span>; <span class="comment">// 2는 리터럴이지만, y는 아니다.</span></span><br><span class="line"><span class="keyword">int</span> z = y + <span class="number">4</span>; <span class="comment">// y랑 z는 리터럴이 아니지만 4는 리터럴이다.</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">2</span>; <span class="comment">// 1 + 2 는 리터럴이 아니지만 (표현식이다), 1과 2 각각은 리터럴이다.</span></span><br></pre></td></tr></table></figure><br><p>이제 리터럴이 무엇인지 감이 올 것 같지만 좀 더 보충해보자.</p><h2 id="설명-3"><a class="markdownIt-Anchor" href="#설명-3"></a> 설명 3</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DRINKING_AGE = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">const</span> VOTING_AGE = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>위의 코드에서 <code>18</code>과 <code>21</code>은 리터럴이다. 리터럴은 <code>if(age &gt; 18)</code> 또는 <code>if(age &lt; 21)</code>과 같이 프로그램의 모든 영역에서 사용될 수 있다. 하지만 상수를 이용하면 <code>if(age &gt; VOTING_AGE)</code>와 같이 코드를 더 이해하기 쉽게 만들 수 있다.</p><p>프로그래밍을 하면서 <i>매직 넘버를 사용하지 마라</i> 와 같은 말을 들어봤을 것이다. 상수를 사용하면 프로그래머가 각 리터럴이 무엇인지, 어떠한 의미를 지녔는지를 일일이 기억하고 유추할 필요가 없어진다. 비즈니스 요구 사항에 따라 상수를 변경해야 하는 경우<small>(예를 들어, 향후 음주 연령을 20세로 낮추는 경우)</small> 프로그램에 변경 사항을 적용하는 것이 훨씬 쉬워진다. 프로그램 전체에서 리터럴을 사용했다면 변경하기도 어렵고 일부 인스턴스는 수정이 누락될 위험도 있다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>스택오버플로우 등을 검색하여 리터럴과 상수의 차이점이 무엇인지 정리하였다. 이제 리터럴이 무엇인지 이해하였는데 코틀린 등의 언어에서 이야기하는 함수 리터럴의 정의는 무엇인지 알아볼 필요가 있다고 생각한다. 함수 리터럴에 대해선 아래의 글들을 참고하여 정리할 예정이다.</p><ul><li><a href="https://blog.kotlin-academy.com/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e">Kotlin Programmer Dictionary: Function Type vs Function literal vs Lambda expression vs Anonymous function</a></li><li><a href="https://medium.com/til-kotlin-ko/kotlin%EC%9D%98-extension%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80-part-3-587cc37e7337">Kotlin의 Extension은 어떻게 동작하는가 part 3</a></li></ul><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li>Wikipedia - <a href="https://en.wikipedia.org/wiki/Literal_(computer_programming)">Literal</a></li><li>MDN - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#literals">Literals</a></li><li>stackoverflow - <a href="https://stackoverflow.com/a/62239386">Confusion between constants and literals?</a></li><li>stackoverflow - <a href="https://stackoverflow.com/questions/485119/what-does-the-word-literal-mean">What does the word “literal” mean?</a></li><li>stackoverflow - <a href="https://stackoverflow.com/a/48411723">What is the difference between literals and non-literals …</a></li><li><a href="https://www.diffen.com/difference/Constant_vs_Literal">Constant vs. Literal</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Terminology/">Terminology</category>
      
      
      <category domain="http://june0122.github.io/tags/Terminology/">Terminology</category>
      
      
      <comments>http://june0122.github.io/2021/08/04/term-literal/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 1756번 : 피자 굽기</title>
      <link>http://june0122.github.io/2021/08/02/boj-1756/</link>
      <guid>http://june0122.github.io/2021/08/02/boj-1756/</guid>
      <pubDate>Mon, 02 Aug 2021 14:05:16 GMT</pubDate>
      
      <description>[이분탐색] 백준 알고리즘 1756번, 피자 굽기</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/1756">문제 보기</a></h2><h2 id="풀이"><a class="markdownIt-Anchor" href="#풀이"></a> 풀이</h2><p>이중 for문으로 문제를 접근하기엔 300,000<sup>2</sup>으로 시간 초과가 발생할 것을 예상할 수 있다. 이분탐색으로 문제를 해결하고 싶어도 주어진 배열은 정렬된 형태가 아니므로 입력값 그대로는 이분탐색을 사용할 수 없다. 이분탐색을 사용하기 위해 주어진 배열<small>(오븐의 지름값들)</small>을 내림차순으로 정렬되도록 값을 변경해준다.</p><table><thead><tr><th style="text-align:center">오븐 깊이</th><th style="text-align:center">오븐 지름</th><th style="text-align:center">통과할 수 있는 반죽의 최대 크기</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">6</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">3</td><td style="text-align:center">2</td></tr></tbody></table><p>위의 표와 같이 지름이 순서대로 <code>5 6 4 3 6 2 3</code>인 오븐을 예로 들면<small>(오븐의 최상단이 1, 최하단이 D이므로 깊이는 인덱스에 1을 더한다)</small>, 깊이 2에서 오븐의 지름이 6이라도 바로 위인 깊이 1의 오븐의 지름이 5이므로 통과할 수 있는 피자 반죽의 지름은 5보다 클 수가 없다. 오븐의 지름은 이전 깊이의 오븐의 지름보다 작거나 같아야하므로 아래와 같은 코드로 오븐의 지름을 변경한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> min = oven[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until depth) &#123;</span><br><span class="line">    min = min(min, oven[i])</span><br><span class="line">    oven[i] = min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 정렬된 배열이 있으니 이분탐색을 할 수 있다. 각 피자 반죽의 위치는 찾고자 하는 피자 반죽의 지름보다 작은 값이 처음으로 나타나는 위치에서 1을 뺀 값이다. 즉, 찾고자 하는 값보다 작은 값이 처음으로 나타나는 위치를 반환하는 upperBound 구현을 응용하여 피자 반죽의 위치를 알아낼 수 있다<small>(lowerBound는 내림차순 기준, 찾고자하는 값 이하가 처음으로 나타나는 위치)</small>.</p><p>탐색 구간의 끝점을 가장 최근 오븐에 들어간 피자 반죽의 위치로 설정하여 모든 반죽들의 위치를 탐색하면 마지막 반죽의 위치에 1을 더한 값<small>(1-based indexing이므로)</small>이 맨 위의 피자가 들어가 있는 깊이이다.</p><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"><span class="keyword">import</span> kotlin.math.min</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> en = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a: IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> b: IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    sortOvenDiameter(a)</span><br><span class="line">    println(lastIndex())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lastIndex</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    st = <span class="number">0</span></span><br><span class="line">    en = d</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        depthOfPizza(b[i])</span><br><span class="line">        <span class="keyword">if</span> (en &lt; <span class="number">0</span>) <span class="keyword">break</span></span><br><span class="line">        st = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> en + <span class="number">1</span> <span class="comment">// 1-based indexing : 오븐의 최상단이 1, 최하단이 D이므로</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">depthOfPizza</span><span class="params">(target: <span class="type">Int</span>)</span></span> &#123; <span class="comment">// 내림차순의 upperBound 사용</span></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    en--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sortOvenDiameter</span><span class="params">(a : <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> min = a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until d) &#123;</span><br><span class="line">        min = min(min, a[i])</span><br><span class="line">        a[i] = min</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    d = nextInt()</span><br><span class="line">    n = nextInt()</span><br><span class="line">    a = IntArray(d)</span><br><span class="line">    b = IntArray(n)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until d) a[i] = nextInt()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) b[i] = nextInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="정렬-순서에-따른-upperbound와-lowerbound-구현"><a class="markdownIt-Anchor" href="#정렬-순서에-따른-upperbound와-lowerbound-구현"></a> 정렬 순서에 따른 upperBound와 lowerBound 구현</h2><p><a href="https://www.acmicpc.net/problem/10816">BOJ 10816번, 숫자 카드 2</a> 기준으로 설명</p><blockquote><p>오름차순 정렬</p></blockquote><p>오름차순 정렬일 경우 <code>lowerBound</code>는 찾고자 하는 값 이상이 처음으로 나타나는 위치인 반면에, <code>upperBound</code>는 찾고자 하는 값보다 큰 값이 처음으로 나타나는 위치이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a : IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> b : IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    a.sort() <span class="comment">// 오름차순 정렬</span></span><br><span class="line">    b.forEach &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="subst">$&#123;upperBound(it) - lowerBound(it)&#125;</span> &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowerBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">upperBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    a = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        a[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">    m = nextInt()</span><br><span class="line">    b = IntArray(m)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">        b[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>내림차순 정렬</p></blockquote><p>내림차순 정렬일 경우 <code>lowerBound</code>는 찾고자 하는 값 이하가 처음으로 나타나는 위치인 반면에, <code>upperBound</code>는 찾고자 하는 값보다 작은 값이 처음으로 나타나는 위치이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a : IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> b : IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    a.sortDescending() <span class="comment">// 내림차순 정렬</span></span><br><span class="line">    b.forEach &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="subst">$&#123;upperBound(it) - lowerBound(it)&#125;</span> &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowerBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">upperBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    a = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        a[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">    m = nextInt()</span><br><span class="line">    b = IntArray(m)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">        b[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/">이분탐색</category>
      
      
      <comments>http://june0122.github.io/2021/08/02/boj-1756/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 1939번 : 중량제한</title>
      <link>http://june0122.github.io/2021/08/02/boj-1939/</link>
      <guid>http://june0122.github.io/2021/08/02/boj-1939/</guid>
      <pubDate>Mon, 02 Aug 2021 14:05:16 GMT</pubDate>
      
      <description>[이분탐색] 백준 알고리즘 1939번, 중량제한</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/1756">문제 보기</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> start = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> end = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> graph: Array&lt;ArrayList&lt;Info&gt;&gt;</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> visit: BooleanArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> factory: Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    binarySearch()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binarySearch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (start + end) / <span class="number">2</span></span><br><span class="line">        visit = BooleanArray(n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (dfs(factory.first, mid)) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">            result = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(cur: <span class="type">Int</span>, limit: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (visit[cur]) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    visit[cur] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (cur == factory.second) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (island <span class="keyword">in</span> graph[cur]) &#123;</span><br><span class="line">        <span class="keyword">val</span> (next, weight) = island.dest to island.weight</span><br><span class="line">        <span class="keyword">if</span> (weight &gt;= limit) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(next, limit))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> br = System.`<span class="keyword">in</span>`.bufferedReader()</span><br><span class="line">    <span class="keyword">val</span> firstLine = br.readLine().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    n = firstLine[<span class="number">0</span>].toInt()</span><br><span class="line">    m = firstLine[<span class="number">1</span>].toInt()</span><br><span class="line">    graph = Array(n + <span class="number">1</span>) &#123; ArrayList() &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">        <span class="keyword">val</span> (a, b, c) = br.readLine().split(<span class="string">&quot; &quot;</span>).map &#123; it.toInt()&#125;</span><br><span class="line">        graph[a].add(Info(b, c))</span><br><span class="line">        graph[b].add(Info(a, c))</span><br><span class="line">        end = max(end, c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> lastLine = br.readLine().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    factory = lastLine[<span class="number">0</span>].toInt() to lastLine[<span class="number">1</span>].toInt()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span></span>(<span class="keyword">val</span> dest: <span class="built_in">Int</span>, <span class="keyword">val</span> weight: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>BFS/DFS와 이분탐색을 함께 적용해서 풀어야하는 문제이다. 아직 BFS/DFS 문제에 익숙하지 않다보니 시간도 많이 소요되고 결국 다른 사람의 코드를 봐야했다. BFS/DFS 관련 문제를 많이 풀어보고 다시 이 문제를 풀어야겠다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/BFS/">BFS</category>
      
      <category domain="http://june0122.github.io/tags/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/">이분탐색</category>
      
      <category domain="http://june0122.github.io/tags/DFS/">DFS</category>
      
      <category domain="http://june0122.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/">그래프</category>
      
      
      <comments>http://june0122.github.io/2021/08/02/boj-1939/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 10815번 : 숫자 카드</title>
      <link>http://june0122.github.io/2021/08/02/boj-10815/</link>
      <guid>http://june0122.github.io/2021/08/02/boj-10815/</guid>
      <pubDate>Mon, 02 Aug 2021 14:03:32 GMT</pubDate>
      
      <description>[이분탐색] 백준 알고리즘 10815번, 숫자 카드</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/10815">문제 보기</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>이분 탐색 구현</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a: IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> b: IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    a.sort()</span><br><span class="line">    b.forEach &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="subst">$&#123;binarySearch(it)&#125;</span> &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binarySearch</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt;= en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            a[mid] &gt; target -&gt; en = mid - <span class="number">1</span></span><br><span class="line">            a[mid] &lt; target -&gt; st = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    a = IntArray(n)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        a[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">    m = nextInt()</span><br><span class="line">    b = IntArray(m)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">        b[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>kotlin.collections의 binarySearch 사용</p></blockquote><ul><li>JVM을 기반으로 하는 코틀린에서의 컬렉션은 자바에서 제공하는 클래스들을 그대로 사용한다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a: IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> b: IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">    a.sort()</span><br><span class="line">    b.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.binarySearch(it) &lt; <span class="number">0</span>) print(<span class="string">&quot;0 &quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> print(<span class="string">&quot;1 &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    a = IntArray(n)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        a[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">    m = nextInt()</span><br><span class="line">    b = IntArray(m)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">        b[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/">이분탐색</category>
      
      
      <comments>http://june0122.github.io/2021/08/02/boj-10815/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 이분 탐색 (Binary Search)</title>
      <link>http://june0122.github.io/2021/07/29/boj-binary-search/</link>
      <guid>http://june0122.github.io/2021/07/29/boj-binary-search/</guid>
      <pubDate>Thu, 29 Jul 2021 06:55:07 GMT</pubDate>
      
      <description>[바킹독의 실전 알고리즘] 0x13강 - 이분 탐색</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="설명"><a class="markdownIt-Anchor" href="#설명"></a> 설명</h2><p><b>정렬되어 있는 배열</b>에서 특정 데이터를 찾기 위해 모든 데이터를 순차적으로 확인하는 대신 <b>탐색 범위를 절반</b>으로 줄여가며 찾는 탐색 방법</p><ul><li>선형 탐색 : <i>O(N)</i></li><li>이분 탐색 : <i>O(logN)</i></li></ul><h2 id="구현"><a class="markdownIt-Anchor" href="#구현"></a> 구현</h2><h3 id="boj-1920-수-찾기"><a class="markdownIt-Anchor" href="#boj-1920-수-찾기"></a> <a href="https://www.acmicpc.net/problem/1920">BOJ 1920, 수 찾기</a></h3><ul><li>M개의 수에 대해 <strong>선형 탐색</strong>을 한다면 시간복잡도는 <i>O(NM)</i></li><li>미리 배열 A를 정렬해둔 다음 <strong>이분 탐색</strong>을 수행하면 시간복잡도는 <i>O(NlogN + MlogN)</i><ul><li><em>NlogN</em>은 정렬에 필요한 시간복잡도, <em>MlogN</em>은 이분탐색에 필요한 시간복잡도</li></ul></li></ul><blockquote><p>이분 탐색 직접 구현</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a: IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> b: IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    a.sort()</span><br><span class="line">    b.forEach &#123;</span><br><span class="line">        println(binarySearch(it))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binarySearch</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span> <span class="comment">// start</span></span><br><span class="line">    <span class="keyword">var</span> en = n - <span class="number">1</span> <span class="comment">// end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt;= en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            a[mid] &lt; target -&gt; st = mid + <span class="number">1</span></span><br><span class="line">            a[mid] &gt; target -&gt; en = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    a = IntArray(n)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        a[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">    m = nextInt()</span><br><span class="line">    b = IntArray(m)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">        b[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>kotlin.collections의 <code>binarySearch</code> 사용</p></blockquote><ul><li>JVM을 기반으로 하는 코틀린에서의 컬렉션은 자바에서 제공하는 클래스들을 그대로 사용한다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b.forEach &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.binarySearch(it) &gt;= <span class="number">0</span>) println(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span> println(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>contains</code> 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b.forEach &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.contains(it)) println(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span> println(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BOJ를 기준으로 <code>binarySearch</code>를 이용한 풀이는 <strong>2164ms</strong>, <code>contains</code>는 <strong>4940ms</strong> 시간이 소요되었다.</p><p>kotlin.collections의 <code>contains</code> 함수의 내부 구현은 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">contains</span><span class="params">(element: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(element) &gt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">indexOf</span><span class="params">(element: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element == <span class="keyword">this</span>[index]) &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>내부적으로 <code>indexOf</code> 함수를 사용하여 모든 인덱스를 순회하는 형태로 구현되어 있으며, <i>O(N)</i> 시간복잡도를 가진다.</p><p>그에 반해 <code>binarySearch</code>의 경우 <i>O(logN)</i>의 시간복잡도를 가지므로 더 좋은 성능을 보여준다.</p><p>다음 코드는 java.util.Arrays의 <code>binarySearch</code> 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">return</span> binarySearch0(a, fromIndex, toIndex, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch0</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = fromIndex;</span><br><span class="line">    <span class="keyword">int</span> high = toIndex - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + high &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> midVal = a[mid];</span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; key) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (midVal &lt;= key) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="boj-10816-숫자-카드2"><a class="markdownIt-Anchor" href="#boj-10816-숫자-카드2"></a> <a href="https://www.acmicpc.net/problem/10816">BOJ 10816, 숫자 카드2</a></h3><ul><li>삽입하는 수가 주어질 때, 오름차순 순서가 유지되는 제일 왼쪽 인덱스와 제일 오른쪽의 인덱스의 차이가 해당 배열에서 그 수의 등장 횟수가 되는 성질을 이용<ul><li><code>start</code> ~ <code>end</code>의 범위가 <code>0</code> ~ <code>a.size</code>인 것에 유의</li><li>while의 조건문이 <code>start &lt;= end</code>가 아니라 <code>start &lt; end</code></li></ul></li></ul><blockquote><p><code>Scanner</code>를 통한 입력 받기 (시간 초과)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a : IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> b : IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    a.sort()</span><br><span class="line">    b.forEach &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="subst">$&#123;upperBound(it) - lowerBound(it)&#125;</span> &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowerBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">upperBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    a = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        a[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">    m = nextInt()</span><br><span class="line">    b = IntArray(m)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">        b[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>readLine()</code>을 통한 입력 받기 (통과)</p></blockquote><ul><li>가독성이 좋아 Scanner를 통해 입력을 받는 방식을 BOJ에서 자주 사용하지만 다른 입력 방식들에 비해 느리기 때문에 시간 초과가 발생할 경우 <code>readLine()</code>을 이용하는 방법 등을 사용한다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a: IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    readLine()</span><br><span class="line">    a = readLine()!!.split(<span class="string">&quot; &quot;</span>).map &#123; it.toInt() &#125;.sorted().toIntArray()</span><br><span class="line">    readLine()</span><br><span class="line">    print(readLine()!!.split(<span class="string">&quot; &quot;</span>).map &#123; it.toInt() &#125;.map &#123; upperBound(it) - lowerBound(it) &#125;.joinToString(<span class="string">&quot; &quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowerBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">upperBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="주의사항"><a class="markdownIt-Anchor" href="#주의사항"></a> 주의사항</h3><ol><li>이분 탐색을 하고자 한다면 주어진 배열은 정렬되어 있어야 한다.</li><li>무한 루프에 빠지지 않게 mid 값을 정해야 한다.</li></ol><h2 id="연습-문제"><a class="markdownIt-Anchor" href="#연습-문제"></a> 연습 문제</h2><h3 id="boj-18870-좌표-압축"><a class="markdownIt-Anchor" href="#boj-18870-좌표-압축"></a> <a href="https://www.acmicpc.net/problem/18870">BOJ 18870, 좌표 압축</a></h3><ul><li>중복을 제외하고 자신보다 작은 수가 몇 개 있는지를 물어보는 문제</li></ul><blockquote><p>이분 탐색 - lowerBound 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> list: List&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">    <span class="keyword">val</span> sorted = list.distinct().sorted()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> list.indices) &#123;</span><br><span class="line">        sb.append(lowerBound(sorted, list[i])).append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowerBound</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = list.lastIndex</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (list[mid] &gt;= target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    readLine()</span><br><span class="line">    list = readLine()!!.split(<span class="string">&quot; &quot;</span>).map &#123; it.toInt() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>HashMap 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> list: List&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    <span class="keyword">val</span> sorted = list.sorted()</span><br><span class="line">    <span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">var</span> idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> sorted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(i)) map[i] = idx++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> list) &#123;</span><br><span class="line">        sb.append(map[i]).append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(sb)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    readLine()</span><br><span class="line">    list = readLine()!!.split(<span class="string">&quot; &quot;</span>).map &#123; it.toInt() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align = 'center'><img height = '350' src = 'https://user-images.githubusercontent.com/39554623/127417010-9ed6f9f1-ee89-4e7f-ba94-af8ef79df344.png'><img height = '350' src = 'https://user-images.githubusercontent.com/39554623/127417011-3364002f-9ba4-44db-88c0-1a901ad623d1.png'></p><ul><li>문제의 예제인 좌표 [2, 4, -10, 4, -9]을 위와 같은 알고리즘으로 압축하면 [2, 3, 0, 3, 1]이 되는데 위 그림 처럼 압축된 점들도 같은 동일선 상 안에 놓이게 된다.</li><li>이렇게 범위가 매우 넓은 좌표의 경우에 좌표를 인덱싱해서 처리 할 경우 손쉽게 처리 할 수 있게 된다.</li><li><a href="https://codingdog.tistory.com/entry/%EC%A2%8C%ED%91%9C-%EC%95%95%EC%B6%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B2%94%EC%9C%84%EA%B0%80-%ED%81%B4-%EB%95%8C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B3%B5%EA%B0%84%EC%9D%84-%EC%A4%84%EC%9D%BC%EA%B9%8C%EC%9A%94">좌표 압축 알고리즘에 대한 설명</a></li></ul><h3 id="boj-2295-세-수의-합"><a class="markdownIt-Anchor" href="#boj-2295-세-수의-합"></a> <a href="https://www.acmicpc.net/problem/2295">BOJ 2295, 세 수의 합</a></h3><p><code>a[i] + a[j] + a[k] = a[l]</code>을 만족하는 <code>a[l]</code> 중에서 최댓값을 구하기</p><ol><li><i>O(N<sup>4</sup>)</i> 풀이 :  i, j, k, l에 대한 4중 for문</li><li><i>O(N<sup>3</sup>logN)</i> 풀이 : i, j, k에 대한 3중 for문을 돌리고, 배열 a 안에 <code>a[i] + a[j] + a[k]</code>가 있는지 이분 탐색</li><li><i>O(N<sup>2</sup>logN)</i> 풀이<ul><li>미리 a에서 두 원소의 합을 다 묶어놓은 배열 two 생성</li><li><code>two[m] + a[k] = a[l]</code></li><li>k, l에 대한 2중 for문을 돌리고 <code>a[l] - a[k]</code>가 배열 two 안에 있는지 이분 탐색</li><li>two의 길이는 N<sup>2</sup>인데 log(N<sup>2</sup>)은 2logN 이어서 <i>O(N<sup>2</sup>log(N<sup>2</sup>))</i> = <i>O(N<sup>2</sup> * 2logN)</i> = <i>O(N<sup>2</sup>logN)</i></li></ul></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> list = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> two = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    </span><br><span class="line">    list.sort()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> i until n) &#123;</span><br><span class="line">            two.add(list[i] + list[j])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    two.sort()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (two.binarySearch(list[i] - list[j]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                println(list[i])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    repeat(n) &#123; list.add(nextInt()) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2개의 값을 묶은 후 어느 한쪽의 값을 이분탐색으로 찾아서 시간복잡도를 낮추는 아이디어</strong>는 이분탐색 관련 응용문제에서 핵심적으로 많이 나오므로 여러 문제들을 풀어보며 익숙해질 필요가 있다.</p><h2 id="parametric-search-small매개-변수-탐색small"><a class="markdownIt-Anchor" href="#parametric-search-small매개-변수-탐색small"></a> Parametric Search <small>(매개 변수 탐색)</small></h2><blockquote><p>조건을 만족하는 최소∙최대값을 구하는 문제<b>(최적화 문제)</b>를 <b>결정 문제</b>로 변환해 이분 탐색을 수행하는 방법</p></blockquote><p>parametric search는 꽤 어려운 난이도를 가지고 있다. 애초에 문제가 parametric search인 것을 눈치채기가 어렵고, DP나 그리디 등의 유형과 결합을 해서 나오는 경우도 빈번하다.</p><h3 id="boj-1654-세-수의-합"><a class="markdownIt-Anchor" href="#boj-1654-세-수의-합"></a> <a href="https://www.acmicpc.net/problem/1654">BOJ 1654, 세 수의 합</a></h3><ul><li>[최적화 문제] : N개를 만들 수 있는 랜선의 <strong>최대</strong> 길이</li><li>[결정 문제] : 랜선의 길이가 X일 때 랜선이 <strong>N개 이상인가 아닌가?</strong></li></ul><p>이 문제의 상황은 N개를 만들 수 있는 랜선의 최대 길이를 구하는 최적화 문제이다. 이걸 결정 문제로 바꾸면 반대로 우리가 구해야 하는 답이 인자로 들어가고, 조건의 참/거짓 여부를 판단하는 문제로 만들 수 있다.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/127440178-acf4a192-1ba7-4f08-99ab-f005e29decfc.png'></p><p>랜선의 길이가 줄어들수록 개수가 많아지므로 간단하게 그래프를 그려보면 랜선의 길이가 x축에 놓이고 개수가 y축에 놓인다. 그리고 그래프는 x가 커질수록 y가 감소하는 형태이다. 그래프에서 답은 표시한 지점으로, 개수가 N개 이상인 지점들 중에서 가장 길이가 긴 곳이다. 이 답을 기점으로 왼쪽은 개수가 N 이상이고 오른쪽은 N 미만이다. 랜선의 길이는 최소 1, 최대 2<sup>31</sup>-1인데, 우리는 여기서 이분탐색으로 답을 빠르게 찾아낼 수 있다.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/127440347-093188d8-a06c-405b-9305-322e8da02d3c.png'></p><p>이렇게 st, mid, en을 놓고 범위를 줄여가며 답을 찾는다. 최대 길이를 구해야하는 문제에서 랜선의 길이가 X일 때 조건을 만족하는지 확인하는 문제로 변환해서 풀이를 해낼 수 있다.</p><p>이 문제의 경우, 랜선의 길이를 X로 두고나면 조각의 개수를 구하는건 <i>O(N)</i>이고 랜선의 길이로 가능한 범위는 2<sup>31</sup>이어서 시간복잡도는 <i>O(log(2<sup>31</sup>N))</i> = <i>O(31N)</i></p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/127440224-353dd38a-022c-44fb-b3c4-00334f5eab30.png'></p><p>여기서 주의해야하는건, 지금처럼 이분탐색을 수행할 변수를 가지고 함수를 세웠을 때 그 함수가 감소함수거나 증가함수여야 한다. 만약 위의 그래프처럼 함수가 감소 혹은 증가함수 형태가 아니라 뒤죽박죽이면 이분탐색 자체가 불가능하다. 그래서 parametric search를 할 때에는 최적화 문제를 결정 문제로 바꿀 수 있는지 생각하고 그 결정 문제로 얻어낸 함수가 감소 혹은 증가함수인지를 따져봐야 한다. 문제에서 최소 혹은 최대 얘기가 있고 범위가 무지막지하게 크거나, 시간복잡도에서 값 하나를 로그로 어떻게 잘 떨구면 될 것 같을 때 parametric search 풀이가 가능하지는 않을까 고민을 해볼 필요가 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> arr: IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> st: <span class="built_in">Long</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> en = <span class="built_in">Int</span>.MAX_VALUE.toLong() <span class="comment">// 2^31 - 1</span></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (solve(mid)) st = mid</span><br><span class="line">        <span class="keyword">else</span> en = mid - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(st)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solve</span><span class="params">(x: <span class="type">Long</span>)</span></span>: <span class="built_in">Boolean</span> &#123; <span class="comment">// 결정 문제</span></span><br><span class="line">    <span class="keyword">var</span> cur = <span class="number">0L</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until k) cur += arr[i] / x</span><br><span class="line">    <span class="keyword">return</span> cur &gt;= n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    k = nextInt()</span><br><span class="line">    n = nextInt()</span><br><span class="line">    arr = IntArray(k)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until k) &#123;</span><br><span class="line">        arr[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mid = (st + en + 1) / 2</code>로 둬야 무한 루프에 빠지지 않는다. <code>mid = (st + en) / 2</code>로 두면 st와 en이 1 차이날 때 st가 계속 값이 똑같아버릴 수 있다.</p><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><ul><li><a href="https://youtu.be/3TkaOKHxHnI">[바킹독의 실전 알고리즘] 0x13강 - BFS</a></li><li><a href="https://jungguji.github.io/2020/12/15/%EB%B0%B1%EC%A4%80-18870%EB%B2%88-%EC%A2%8C%ED%91%9C-%EC%95%95%EC%B6%95/">https://jungguji.github.io/2020/12/15/백준-18870번-좌표-압축/</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%94%ED%82%B9%EB%8F%85/">바킹독</category>
      
      <category domain="http://june0122.github.io/tags/Binary-Search/">Binary Search</category>
      
      
      <comments>http://june0122.github.io/2021/07/29/boj-binary-search/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] View Binding (뷰 바인딩)</title>
      <link>http://june0122.github.io/2021/07/24/android-docs-view-binding/</link>
      <guid>http://june0122.github.io/2021/07/24/android-docs-view-binding/</guid>
      <pubDate>Fri, 23 Jul 2021 21:48:09 GMT</pubDate>
      
      <description>&lt;b&gt;뷰 바인딩&lt;small&gt;(View Binding)&lt;/small&gt;&lt;/b&gt; 기능은 뷰와 상호작용하는 코드를 쉽게 작성할 수 있게 해준다. 모듈에서 사용 설정&lt;small&gt;(enable)&lt;/small&gt;된 뷰 바인딩은 각 XML 레이아웃 파일의 &lt;b&gt;바인딩 클래스&lt;small&gt;(binding class)&lt;/small&gt;&lt;/b&gt;를 생성한다. 바인딩 클래스의 인스턴스는 상응하는 레이아웃에 ID가 있는 모든 뷰의 직접 참조가 포함된다.</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><b>뷰 바인딩<small>(View Binding)</small></b> 기능은 뷰와 상호작용하는 코드를 쉽게 작성할 수 있게 해준다.</li><li>모듈에서 사용 설정<small>(enable)</small>된 뷰 바인딩은 각 XML 레이아웃 파일의 <b>바인딩 클래스<small>(binding class)</small></b>를 생성한다.</li><li>바인딩 클래스의 인스턴스는 상응하는 레이아웃에 ID가 있는 모든 뷰의 직접 참조가 포함된다.</li><li>대부분의 경우, 뷰 바인딩이 <code>findViewById</code>를 대체한다.</li></ul><h2 id="설정-방법"><a class="markdownIt-Anchor" href="#설정-방법"></a> 설정 방법</h2><p>뷰 바인딩은 모듈 별로 사용 설정이 된다<small>(enabled on a module by module)</small>.</p><p>모듈에서 뷰 바인딩을 사용 설정<small>(enable)</small> 하려면, module 레벨의 <code>build.gradle</code> 파일에 <code>viewBinding</code> 빌드 옵션을 아래의 예시와 같이 <code>true</code>로 변경한다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">        ...</span><br><span class="line">        viewBinding &#123;</span><br><span class="line">            enabled = <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>바인딩 클래스를 생성하는 동안 레이아웃 파일을 무시하려면 <code>tools:viewBindingIgnore=&quot;true&quot;</code> 속성을 레이아웃 파일의 루트 뷰에 추가해야 한다.</p><h2 id="사용법"><a class="markdownIt-Anchor" href="#사용법"></a> 사용법</h2><p>모듈에 뷰 바인딩이 사용 설정되면, 모듈에 포함된 각 XML 레이아웃 파일의 바인딩 클래스가 생성된다.</p><p>각 바인딩 클래스에는 루트 뷰와 ID가 있는 모든 뷰에 대한 참조를 포함한다.</p><p>생성된 바인딩 클래스의 이름은 XML 파일의 이름을 카멜 표기법으로 변환하고 끝에 'Binding’이 추가된다.</p><blockquote><p><code>result_profile.xml</code> 이름을 가진 레이아웃 파일의 예시</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/name&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">android:cropToPadding</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@drawable/rounded_button&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>생성된 바인딩 클래스의 이름은 <code>ResultProfileBinding</code>이 된다. 이 클래스에는 <code>name</code>이라는 <code>TextView</code>와 <code>button</code>이라는 <code>Button</code> 등 두 개의 필드가 있다. 레이아웃의 <code>ImageView</code>에는 ID가 없으므로 바인딩 클래스에 참조가 없다.</p><p>모든 바인딩 클래스는 <code>getRoot()</code> 메서드를 포함하고 있는데, <strong>상응하는 레이아웃 파일의 루트 뷰에 대한 직접 참조를 제공</strong>한다.</p><p>위의 예시 코드에서는 <code>ResultProfileBinding</code> 클래스의 <code>getRoot()</code> 메서드가 <code>LinearLayout</code> 루트 뷰를 반환한다.</p><h3 id="액티비티에서의-뷰-바인딩-사용법"><a class="markdownIt-Anchor" href="#액티비티에서의-뷰-바인딩-사용법"></a> 액티비티에서의 뷰 바인딩 사용법</h3><p>액티비티에 사용할 바인딩 클래스 인스턴스를 설정하려면, 액티비티의 <code>onCreate()</code> 메서드에서 다음 두 단계를 따라야 한다.</p><ol><li>생성된 바인딩 클래스에 포함된 static <code>inflate()</code> 메서드를 호출한다. 이를 통해 액티비티에서 사용할 바인딩 클래스의 인스턴스를 생성한다.</li><li><code>getRoot()</code>메서드를 호출하거나 <a href="https://kotlinlang.org/docs/properties.html#declaring-properties">Kotlin property syntax</a>를 사용하여 루트 뷰의 참조를 가져온다.</li><li>루트 뷰를 <code>setContentView()</code>에 전달<small>(pass)</small>하여 화면 상의 활성 뷰로 만든다.</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ResultProfileBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    binding = ResultProfileBinding.inflate(layoutInflater)</span><br><span class="line">    <span class="keyword">val</span> view = binding.root</span><br><span class="line">    setContentView(view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 바인딩 클래스의 인스턴스를 사용하여 뷰를 참조할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binding.name.text = viewModel.name</span><br><span class="line">binding.button.setOnClickListener &#123; viewModel.userClicked() &#125;</span><br></pre></td></tr></table></figure><h3 id="프래그먼트에서의-뷰-바인딩-사용법"><a class="markdownIt-Anchor" href="#프래그먼트에서의-뷰-바인딩-사용법"></a> 프래그먼트에서의 뷰 바인딩 사용법</h3><p>프래그먼트에서 사용할 바인딩 클래스의 인스턴스를 설정하려면, 프래그먼트의 <code>onCreateView()</code> 메서드에서 다음 단계를 따라야 한다.</p><ol><li>생성된 바인딩 클래스에 포함된 static <code>inflate()</code> 메서드를 호출한다. 그러면 프래그먼트에서 사용할 바인딩 클래스의 인스턴스가 생성된다.</li><li><code>getRoot()</code>메서드를 호출하거나 <a href="https://kotlinlang.org/docs/properties.html#declaring-properties">Kotlin property syntax</a>를 사용하여 루트 뷰의 참조를 가져온다.</li><li><code>onCreateView()</code> 메서드에서 루트 뷰를 반환하여 화면 상의 활성 뷰를 만든다.</li></ol><blockquote><p>★ 참고 : inflate() 메서드를 사용하려면 layout inflator를 전달해야 한다. 레이아웃이 이미 inflate 되었다면, 바인딩 클래스의 static bind() 메서드를 호출하면 된다. 자세한 내용은 <a id = "a1"><a href="#f1">본문의 하단</a></a>이나 <a href="https://github.com/android/architecture-components-samples/blob/master/ViewBindingSample/app/src/main/java/com/android/example/viewbindingsample/BindFragment.kt#L36-L41">뷰 바인딩 깃허브 샘플의 예시</a>에서 볼 수 있다.</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _binding: ResultProfileBinding? = <span class="literal">null</span></span><br><span class="line"><span class="comment">// This property is only valid between onCreateView and</span></span><br><span class="line"><span class="comment">// onDestroyView.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> binding <span class="keyword">get</span>() = _binding!!</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: View? &#123;</span><br><span class="line">    _binding = ResultProfileBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">val</span> view = binding.root</span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">    _binding = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 바인딩 클래스의 인스턴스를 사용하여 뷰를 참조할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binding.name.text = viewModel.name</span><br><span class="line">binding.button.setOnClickListener &#123; viewModel.userClicked() &#125;</span><br></pre></td></tr></table></figure><blockquote><p>★ 참고 : 프래그먼트는 뷰보다 오래 지속된다<small>(Fragments outlive their views)</small>. 프래그먼트의 onDestroyView() 메서드에서 바인딩 클래스 인스턴스에 대한 참조를 정리해야 한다.</p></blockquote><h3 id="다른-구성smallconfigurationsmall에-대한-힌트"><a class="markdownIt-Anchor" href="#다른-구성smallconfigurationsmall에-대한-힌트"></a> 다른 구성<small>(configuration)</small>에 대한 힌트</h3><p>여러 구성<small>(configuration)</small>에서 뷰를 선언할 때, 특정 레이아웃에 따라 다른 뷰 타입을 사용하는 것이 더 합리적이다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># in res/layout/example.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/user_bio&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"># in res/layout-land/example.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">EditText</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/user_bio&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>이러한 경우, <code>TextView</code>가 공통된 기본 클래스<small>(common base class)</small>이기 때문에 생성된 클래스가 <code>TextView</code> 타입의 <code>userBio</code> 필드를 노출할 것으로 예상할 것이다. 하지만 기술적인 한계로 인해 뷰 바인딩 코드 생성기는 이러한 결정을 내릴 수 없으며, 대신에 단순히 <code>View</code> 필드를 생성한다. 이를 위해서는 나중에 <code>binding.userBio as TextView</code>를 사용하여 필드를 캐스팅해야 한다.</p><p>이 제한 사항을 해결하기 위해, 뷰 바인딩은 <code>tools:viewBindingType</code> 속성을 지원하여 생성된 코드에서 어떤 타입을 사용할 것인지 컴파일러에게 알릴 수 있다.</p><blockquote><p><code>tools:viewBindingType</code> 속성을 사용하여 컴파일러가 필드를 <code>TextView</code>로 생성하게 하기</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># in res/layout/example.xml (unchanged)</span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/user_bio&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"># in res/layout-land/example.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">EditText</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/user_bio&quot;</span> <span class="attr">tools:viewBindingType</span>=<span class="string">&quot;TextView&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>다른 예시로, 하나는 <code>BottomNavigationView</code>를 포함하고 다른 하나는 <code>NavigationRailView</code>를 포함하는 두 개의 레이아웃이 있다고 가정해보자. 두 클래스 모두 구현의 세부 정보가 포함된 <code>NavigationBarView</code>를 확장한다. 코드가 현재 레이아웃에 어떤 하위 클래스가 있는지 정확히 알 필요가 없는 경우, <code>tools:viewBindingType</code>를 사용하여 생성된 타입을 두 레이아웃 모두에서 <code>NavigationBarView</code>로 설정할 수 있다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># in res/layout/navigation_example.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">BottomNavigationView</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/navigation&quot;</span> <span class="attr">tools:viewBindingType</span>=<span class="string">&quot;NavigationBarView&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"># in res/layout-w720/navigation_example.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">NavigationRailView</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/navigation&quot;</span> <span class="attr">tools:viewBindingType</span>=<span class="string">&quot;NavigationBarView&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>참고로 뷰 바인딩은 코드를 생성할 때 속성 값의 유효성을 검사할 수 없다. 컴파일 타임과 런타임 오류를 방지하려면 값이 다음 조건들을 충족해야 한다.</p><ul><li>값은 <code>android.view.View</code>에서 상속되는 클래스여야 한다.</li><li>값은 해당 값이 배치된 태그의 슈퍼 클래스여야 한다. 예를 들어 다음 값들은 작동하지 않는다.<ul><li><code>&lt;TextView tools:viewBindingType=&quot;ImageView&quot; /&gt;</code> : ImageView는 TextView와 관련이 없다.</li><li><code>&lt;TextView tools:viewBindingType=&quot;Button&quot; /&gt;</code> : Button은 TextView의 슈퍼 클래스가 아니다.</li></ul></li><li>최종 타입은 모든 구성에서 일관되게 해결되어야 한다.</li></ul><h2 id="findviewbyid와의-차이점"><a class="markdownIt-Anchor" href="#findviewbyid와의-차이점"></a> findViewById와의 차이점</h2><p>뷰 바인딩은 <code>findViewById</code>를 사용하는 것에 비해 중요한 장점이 있다.</p><ul><li><strong>널 안정성</strong><ul><li>뷰 바인딩운 뷰에 대한 직접 참조를 생성하므로, 유효하지 않은 view ID로 인해 null pointer exception이 발생할 위험이 없다. 또한 레이아웃의 일부 구성에서만 뷰가 있는 경우, 바인딩 클래스에서 참조를 포함하는 필드가 <code>@Nullable</code>로 표시된다.</li></ul></li><li><strong>타입 안정성</strong><ul><li>각 바인딩 클래스에 있는 필드는 XML 파일에서 참조하는 뷰와 일치하는 타입을 가진다. 즉, 클래스 변환 예외<small>(class cast exception)</small>이 발생할 위험이 없다.</li></ul></li></ul><p>이러한 차이점은 레이아웃과 코드 사이의 비호환성으로 인해 <code>findViewById</code>가 런타임에 오류가 발생하는 반면, 뷰 바인딩은 런타임이 아닌 컴파일 타임에 빌드가 실패하게 된다는 것을 의미한다.</p><p>연산 속도 면에서도 <code>findViewById</code>는 레이아웃 태그를 순회하여 일치하는 뷰를 찾아가기 때문에 연산 속도에 영향을 미치고, 단순 바인딩 코드가 길어진다.</p><h2 id="데이터-바인딩과의-비교"><a class="markdownIt-Anchor" href="#데이터-바인딩과의-비교"></a> 데이터 바인딩과의 비교</h2><p>뷰 바인딩과 데이터 바인딩은 모두 뷰를 직접 참조하는 데 사용할 수 있는 바인딩 클래스를 생성한다. 하지만 뷰 바인딩은 보다 단순한 사용 사례를 처리하기 위한 것이며 데이터 결합에 비해 다음과 같은 이점을 제공한다.</p><ul><li>더 빠른 컴파일<ul><li>뷰 바인딩은 주석 처리<small>(annotation processing)</small>이 필요하지 않으므로 컴파일 시간이 더 짧다.</li></ul></li><li>사용 편의성<ul><li>뷰 바인딩은 특별히 태그된 XML 레이아웃 파일이 필요하지 않으므로 앱에서 더 신속하게 채택될 수 있다. 모듈에서 뷰 바인딩을 사용 설정하면 모듈의 모든 레이아웃에 뷰 바인딩이 자동으로 적용된다.</li></ul></li></ul><p>반대로 뷰 바인딩에는 데이터 바인딩과 비교해서 다음과 같은 제한 사항들이 있다.</p><ul><li>뷰 바인딩은 <a href="https://developer.android.com/topic/libraries/data-binding/expressions">레이아웃 변수 또는 레이아웃 표현식</a>을 지원하지 않으므로, XML 레이아웃 파일에서 직접 동적 UI 콘텐츠를 선언하는 데 사용할 수 없다.</li><li>뷰 바인딩은 <a href="https://developer.android.com/topic/libraries/data-binding/two-way">양방향 데이터 바인딩</a>을 지원하지 않는다.</li></ul><p>위 사항을 고려할 때, 일부 사례에서는 뷰 바인딩과 데이터 바인딩을 모두 사용하는 것이 가장 좋다. 고급 기능이 필요한 레이아웃에는 데이터 바인딩을, 고급 기능이 필요 없는 레이아웃에는 뷰 바인딩을 사용할 수 있다.</p><h3 id="b-id-f1레이아웃이-이미-인플레이트된-상황에서의-뷰-바인딩b"><a class="markdownIt-Anchor" href="#b-id-f1레이아웃이-이미-인플레이트된-상황에서의-뷰-바인딩b"></a> <b id = "f1">레이아웃이 이미 인플레이트된 상황에서의 뷰 바인딩</b>  <a href="#a1"> ↩</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * View Binding example with a fragment that uses the alternate constructor for inflation and</span></span><br><span class="line"><span class="comment"> * [onViewCreated] for binding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindFragment</span> : <span class="type">Fragment</span></span>(R.layout.fragment_blank) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scoped to the lifecycle of the fragment&#x27;s view (between onCreateView and onDestroyView)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> fragmentBlankBinding: FragmentBlankBinding? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> binding = FragmentBlankBinding.bind(view)</span><br><span class="line">        fragmentBlankBinding = binding</span><br><span class="line">        binding.textViewFragment.text = getString(string.hello_from_vb_bindfragment)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Consider not storing the binding instance in a field, if not needed.</span></span><br><span class="line">        fragmentBlankBinding = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위 코드는 인플레이션을 위해 <a href="https://developer.android.com/reference/androidx/fragment/app/Fragment#Fragment(int)">Alternate constructor</a>를 사용하고 <code>onViewCreated</code>를 바인딩에 사용하는 프래그먼트의 뷰 바인딩 예시이다. 레이아웃이 이미 인플레이트 되었기에 바로 바인딩 클래스의 static <code>bind()</code> 메서드를 호출하면 된다.</li></ul><h2 id="additional-resources"><a class="markdownIt-Anchor" href="#additional-resources"></a> Additional resources</h2><h3 id="samples"><a class="markdownIt-Anchor" href="#samples"></a> Samples</h3><ul><li><a href="https://github.com/android/architecture-components-samples/tree/main/ViewBindingSample">View binding sample</a></li></ul><h3 id="blogs"><a class="markdownIt-Anchor" href="#blogs"></a> Blogs</h3><ul><li><a href="https://medium.com/androiddevelopers/use-view-binding-to-replace-findviewbyid-c83942471fc">Use view binding to replace findViewById</a></li><li><a href="https://betterprogramming.pub/why-are-kotlin-synthetics-deprecated-and-what-are-the-alternatives-5c2b087dda1c">Why Are Kotlin Synthetics Deprecated and What Are the Alternatives?</a></li></ul><h3 id="videos"><a class="markdownIt-Anchor" href="#videos"></a> Videos</h3><ul><li><a href="https://www.youtube.com/watch?v=W7uujFrljW0">Android Jetpack: Replace findViewById with view binding</a></li></ul><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li>Android Docs - View Binding : <a href="https://developer.android.com/topic/libraries/view-binding">https://developer.android.com/topic/libraries/view-binding</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Documentation/">Documentation</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Data-Binding/">Data Binding</category>
      
      <category domain="http://june0122.github.io/tags/View-Binding/">View Binding</category>
      
      <category domain="http://june0122.github.io/tags/findViewById/">findViewById</category>
      
      
      <comments>http://june0122.github.io/2021/07/24/android-docs-view-binding/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 15649번 : N과 M</title>
      <link>http://june0122.github.io/2021/07/23/boj-15649/</link>
      <guid>http://june0122.github.io/2021/07/23/boj-15649/</guid>
      <pubDate>Fri, 23 Jul 2021 12:33:37 GMT</pubDate>
      
      <description>[백트래킹] 백준 알고리즘 15649번, N과 M</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/15649">문제 보기</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> arr = IntArray(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> isUsed = BooleanArray(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    m = nextInt()</span><br><span class="line">    backTrack(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(k : <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            print(<span class="string">&quot;<span class="subst">$&#123;arr[i]&#125;</span> &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> .. n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUsed[i].not()) &#123;</span><br><span class="line">            arr[k] = i</span><br><span class="line">            isUsed[i] = <span class="literal">true</span></span><br><span class="line">            backTrack(k+<span class="number">1</span>)</span><br><span class="line">            isUsed[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/">백트래킹</category>
      
      
      <comments>http://june0122.github.io/2021/07/23/boj-15649/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 2798번 : 블랙잭</title>
      <link>http://june0122.github.io/2021/07/23/boj-2798/</link>
      <guid>http://june0122.github.io/2021/07/23/boj-2798/</guid>
      <pubDate>Fri, 23 Jul 2021 12:33:37 GMT</pubDate>
      
      <description>[백트래킹] 백준 알고리즘 2798번, 블랙잭</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/2798">문제 보기</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> nums = IntArray(<span class="number">101</span>)</span><br><span class="line"><span class="keyword">val</span> visited = BooleanArray(<span class="number">101</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    m = nextInt()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        nums[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> arr = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    dfs(arr, <span class="number">0</span>)</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(arr: <span class="type">MutableList</span>&lt;<span class="type">Int</span>&gt;, count: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.sum() &lt;= m) result = max(result, arr.sum())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            visited[i] = <span class="literal">true</span></span><br><span class="line">            arr.add(nums[i])</span><br><span class="line">            dfs(arr, count + <span class="number">1</span>)</span><br><span class="line">            arr.removeAt(arr.size - <span class="number">1</span>)</span><br><span class="line">            visited[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>단순히 3중 for문을 이용하여 간단하게 해결할 수 있는 문제이지만 백트래킹에 익숙해지기 위해 위와 같이 풀이하였다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/">완전탐색</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/">백트래킹</category>
      
      
      <comments>http://june0122.github.io/2021/07/23/boj-2798/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 10819번 : 차이를 최대로</title>
      <link>http://june0122.github.io/2021/07/23/boj-10819/</link>
      <guid>http://june0122.github.io/2021/07/23/boj-10819/</guid>
      <pubDate>Fri, 23 Jul 2021 12:33:37 GMT</pubDate>
      
      <description>[백트래킹] 백준 알고리즘 10819번, 차이를 최대로</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/10819">문제 보기</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.abs</span><br><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> nums = IntArray(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> visited = BooleanArray(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        nums[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> arr = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    dfs(arr, <span class="number">0</span>)</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(arr: <span class="type">MutableList</span>&lt;<span class="type">Int</span>&gt;, count: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">        result = max(arr.value(), result)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            visited[i] = <span class="literal">true</span></span><br><span class="line">            arr.add(nums[i])</span><br><span class="line">            dfs(arr, count + <span class="number">1</span>)</span><br><span class="line">            arr.removeAt(arr.size - <span class="number">1</span>)</span><br><span class="line">            visited[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">value</span><span class="params">()</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span>) &#123;</span><br><span class="line">        sum += abs(<span class="keyword">this</span>[i] - <span class="keyword">this</span>[i + <span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/">백트래킹</category>
      
      
      <comments>http://june0122.github.io/2021/07/23/boj-10819/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 14889번 : 스타트와 링크</title>
      <link>http://june0122.github.io/2021/07/23/boj-14889/</link>
      <guid>http://june0122.github.io/2021/07/23/boj-14889/</guid>
      <pubDate>Fri, 23 Jul 2021 12:33:37 GMT</pubDate>
      
      <description>[백트래킹] 백준 알고리즘 14889번, 스타트와 링크</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/14889">문제 보기</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.abs</span><br><span class="line"><span class="keyword">import</span> kotlin.math.min</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> status: Array&lt;IntArray&gt;</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> visited: BooleanArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    status = Array(n) &#123; IntArray(n) &#125;</span><br><span class="line">    visited = BooleanArray(n)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            status[i][j] = nextInt()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(index: <span class="type">Int</span>, count: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == n / <span class="number">2</span>) &#123;</span><br><span class="line">        statusGap()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> index until n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            visited[i] = <span class="literal">true</span></span><br><span class="line">            dfs(i + <span class="number">1</span>, count + <span class="number">1</span>)</span><br><span class="line">            visited[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">statusGap</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> startSum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> linkSum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] &amp;&amp; visited[j]) &#123;</span><br><span class="line">                startSum += status[i][j] + status[j][i]</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!visited[i] &amp;&amp; !visited[j]) &#123;</span><br><span class="line">                linkSum += status[i][j] + status[j][i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = min(result, abs(startSum - linkSum))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스타트 팀과 링크 팀을 구분 짓는 자료구조를 따로 선언하지 않고 BooleanArray인 <em>visited</em>의 값을 통해 구분하므로 dfs 함수의 첫 번째 인자로 <em>index</em>를 사용하였다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/">백트래킹</category>
      
      
      <comments>http://june0122.github.io/2021/07/23/boj-14889/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 2661번 : 좋은수열</title>
      <link>http://june0122.github.io/2021/07/23/boj-2661/</link>
      <guid>http://june0122.github.io/2021/07/23/boj-2661/</guid>
      <pubDate>Fri, 23 Jul 2021 12:33:37 GMT</pubDate>
      
      <description>[백트래킹] 백준 알고리즘 2661번, 좋은수열</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/2661">문제 보기</a></h2><h2 id="풀이"><a class="markdownIt-Anchor" href="#풀이"></a> 풀이</h2><p>백트래킹 문제이며 좋은 수열인지 나쁜 수열인지 검사하는 코드를 구현하는 것이 핵심이다.</p><p>문자열에서 동일한 요소의 중복은 요소의 길이가 <code>1 ~ N/2</code>의 범위에 있을 때만 발생한다.</p><p>백트래킹을 통해 수열을 늘려나가는 식이므로 맨 뒷자리를 기준으로</p><p>맨 뒤 <code>1</code>자리의 수가 그 앞의 <code>1</code>자리 수와 동일한지</p><p>맨 뒤 <code>2</code>자리의 수가 그 앞의 <code>2</code>자리 수와 동일한지</p><p>맨 뒤 <code>3</code>자리의 수가 그 앞의 <code>3</code>자리 수와 동일한지</p><p>맨 뒤 <code>4</code>자리의 수가 그 앞의 <code>4</code>자리 수와 동일한지</p><p>…</p><p>맨 뒤 <code>N/2</code>자리의 수가 그 앞의 <code>N/2</code>자리 수와 동일한지 비교하는 식으로</p><p>한 번이라도 동일한 경우가 발생한다면 그 수열은 나쁜 수열로 판단할 수 있다.</p><p>가장 첫 번째로 나오는 백트래킹 알고리즘의 결과가 결과값들 중 가장 작은 수이기 때문에 기본적인 백트래킹 문제들과 같이 만들어진 결과값들끼리 최대나 최소를 비교할 필요가 없다. 그렇기 때문에 프로세스를 종료하는 코드 혹은 플래그를 이용하는 코드가 사용이 된다.</p><p>가장 작은 수를 나타내는 수열을 구하는 것이기 때문에 첫 번째 자리는 무조건 1이 나온다. 그러므로 dfs의 첫 탐색 정점 기준을 <code>&quot;1&quot;</code>로 잡고 시작하는 것이 더 효율적인 코드이지만 쉬운 이해를 위해 <code>dfs(&quot;&quot;)</code>을 사용하였다.</p><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"><span class="keyword">import</span> kotlin.system.exitProcess</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    dfs(<span class="string">&quot;&quot;</span>) <span class="comment">// dfs(&quot;1&quot;)이 더 효율적</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length == n) &#123;</span><br><span class="line">        println(s)</span><br><span class="line">        exitProcess(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s + i).isGood()) &#123;</span><br><span class="line">            dfs(s + i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">isGood</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> len = <span class="keyword">this</span>.length / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.substring(<span class="keyword">this</span>.length - i) == <span class="keyword">this</span>.substring(<span class="keyword">this</span>.length - i * <span class="number">2</span>, <span class="keyword">this</span>.length - i))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자바에서 프로세스를 강제 종료하는 <code>System.exit(0)</code>는 코틀린에선 <code>exitProcess(0)</code>를 사용한다. 하지만 <code>exitProcess(0)</code>를 사용하면 <em>kotlin.system</em> 패키지를 import 해줘야하는 번거로움이 있기에 시간이 제한되고 긴장되는 코딩 테스트 환경에서는 아래 코드와 같이 플래그 변수를 사용하거나 자바의 <code>System.exit(0)</code>를 사용하는 것이 나을 수도 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> exit = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    dfs(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (exit) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.length == n) &#123;</span><br><span class="line">        println(s)</span><br><span class="line">        exit = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s + i).isGood()) &#123;</span><br><span class="line">            dfs(s + i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">isGood</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> len = <span class="keyword">this</span>.length / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.substring(<span class="keyword">this</span>.length - i) == <span class="keyword">this</span>.substring(<span class="keyword">this</span>.length - i * <span class="number">2</span>, <span class="keyword">this</span>.length - i))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li><a href="https://bellog.tistory.com/43">https://bellog.tistory.com/43</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/">백트래킹</category>
      
      
      <comments>http://june0122.github.io/2021/07/23/boj-2661/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 14888번 : 연산자 끼워넣기</title>
      <link>http://june0122.github.io/2021/07/23/boj-14888/</link>
      <guid>http://june0122.github.io/2021/07/23/boj-14888/</guid>
      <pubDate>Fri, 23 Jul 2021 12:33:37 GMT</pubDate>
      
      <description>[백트래킹] 백준 알고리즘 14888번, 연산자 끼워넣기</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/14888">문제 보기</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"><span class="keyword">import</span> kotlin.math.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> min = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> nums: IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> visit: BooleanArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> opers: MutableList&lt;String&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    nums = IntArray(n)</span><br><span class="line">    visit = BooleanArray(n - <span class="number">1</span>)</span><br><span class="line">    opers = mutableListOf()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        nums[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repeat(nextInt()) &#123; opers.add(<span class="string">&quot;+&quot;</span>) &#125;</span><br><span class="line">    repeat(nextInt()) &#123; opers.add(<span class="string">&quot;-&quot;</span>) &#125;</span><br><span class="line">    repeat(nextInt()) &#123; opers.add(<span class="string">&quot;*&quot;</span>) &#125;</span><br><span class="line">    repeat(nextInt()) &#123; opers.add(<span class="string">&quot;/&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    println(max)</span><br><span class="line">    println(min)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(comb: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (comb.length == n - <span class="number">1</span>) &#123;</span><br><span class="line">        min = min(min, comb.result())</span><br><span class="line">        max = max(max, comb.result())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visit[i]) <span class="keyword">continue</span></span><br><span class="line">        visit[i] = <span class="literal">true</span></span><br><span class="line">        dfs(comb + opers[i])</span><br><span class="line">        comb.removeRange(comb.length - <span class="number">1</span>, comb.length - <span class="number">1</span>)</span><br><span class="line">        visit[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">result</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span>) &#123;</span><br><span class="line">        temp = calc(temp, nums[i+<span class="number">1</span>], <span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calc</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Char</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> (c) &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> -&gt; a + b</span><br><span class="line">        <span class="string">&#x27;-&#x27;</span> -&gt; a - b</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> -&gt; a * b</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span> -&gt; a / b</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">메모리</th><th style="text-align:center">시간</th></tr></thead><tbody><tr><td style="text-align:center">304432 KB</td><td style="text-align:center">1548 ms</td></tr></tbody></table><blockquote></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"><span class="keyword">import</span> kotlin.math.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> min = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line"><span class="keyword">val</span> opers = IntArray(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> nums: IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> visit: BooleanArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    nums = IntArray(n)</span><br><span class="line">    visit = BooleanArray(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        nums[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">        opers[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(nums[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    println(max)</span><br><span class="line">    println(min)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(acc: <span class="type">Int</span>, count: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">        min = min(min, acc)</span><br><span class="line">        max = max(max, acc)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opers[i] &lt;= <span class="number">0</span>) <span class="keyword">continue</span></span><br><span class="line">        opers[i]--</span><br><span class="line">        dfs(calc(acc, nums[count], i), count + <span class="number">1</span>)</span><br><span class="line">        opers[i]++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calc</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, oper: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> (oper) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; a + b</span><br><span class="line">        <span class="number">1</span> -&gt; a - b</span><br><span class="line">        <span class="number">2</span> -&gt; a * b</span><br><span class="line">        <span class="number">3</span> -&gt; a / b</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">메모리</th><th style="text-align:center">시간</th></tr></thead><tbody><tr><td style="text-align:center">13684 KB</td><td style="text-align:center">140 ms</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/">백트래킹</category>
      
      
      <comments>http://june0122.github.io/2021/07/23/boj-14888/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[코틀린 자료구조] 트리 (Tree)</title>
      <link>http://june0122.github.io/2021/07/19/data-structure-trees/</link>
      <guid>http://june0122.github.io/2021/07/19/data-structure-trees/</guid>
      <pubDate>Mon, 19 Jul 2021 14:36:42 GMT</pubDate>
      
      <description>&lt;b&gt;트리&lt;small&gt;(tree)&lt;/small&gt;&lt;/b&gt;는 매우 중요한 자료구조로 다음과 같이 소프트웨어 개발에서 반복되는 많은 문제를 해결하는 데 사용한다.&lt;br&gt;① 계층적 관계를 표현 ② 정렬된 데이터 관리 ③ 빠른 조회 작업을 용이하게 함</description>
      
      
      
      <content:encoded><![CDATA[<p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125863597-4066759b-d019-421a-bcd4-f0383febe0d0.png'></p><p><b>트리<small>(tree)</small></b>는 매우 중요한 자료구조로 다음과 같이 소프트웨어 개발에서 반복되는 많은 문제를 해결하는 데 사용한다.</p><ul><li>계층적 관계를 표현</li><li>정렬된 데이터 관리</li><li>빠른 조회 작업을 용이하게 함</li></ul><h2 id="트리와-관련된-용어들smallterminologysmall"><a class="markdownIt-Anchor" href="#트리와-관련된-용어들smallterminologysmall"></a> 트리와 관련된 용어들<small>(Terminology)</small></h2><h3 id="노드smallnodesmall"><a class="markdownIt-Anchor" href="#노드smallnodesmall"></a> 노드<small>(Node)</small></h3><p>연결 리스트와 마찬가지로 트리도 노드로 구성된다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125863852-f54f02f7-560f-4037-8e11-db6f9ba137b7.png'></p><p>각 노드는 일부 데이터를 캡슐화하고 자식을 추적한다.</p><h3 id="부모와-자식smallparent-and-childsmall"><a class="markdownIt-Anchor" href="#부모와-자식smallparent-and-childsmall"></a> 부모와 자식<small>(Parent and child)</small></h3><p>트리는 거꾸로 뒤집힌 실제 나무처럼 위에서 시작하여 아래쪽으로 가지를 뻗어 나간다.</p><p>첫 번째 노드를 제외한 모든 노드는 <strong>부모</strong> 노드라고 하는 위의 단일 노드에 연결된다. 바로 아래에 있고 부모 노드에 연결된 노드를 <strong>자식</strong> 노드라 한다. 트리에서 모든 자식은 정확히 한 명의 부모를 가진다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125863863-bf9c778e-92b9-4b93-b44a-edf19b0a64af.png'></p><h3 id="뿌리smallrootsmall"><a class="markdownIt-Anchor" href="#뿌리smallrootsmall"></a> 뿌리<small>(Root)</small></h3><p>트리의 최상위 노드를 트리의 뿌리<small>(루트, root)</small>라고 한다. 부모가 없는 유일한 노드이기도 하다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125863874-acebca4c-f298-4ab9-b24e-10376320c968.png'></p><h3 id="잎smallleafsmall"><a class="markdownIt-Anchor" href="#잎smallleafsmall"></a> 잎<small>(Leaf)</small></h3><p>자식이 없는 노드를 리프라고 한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125863886-cfebea5d-2c3d-497c-9848-a1c709baa36c.png'></p><h2 id="구현"><a class="markdownIt-Anchor" href="#구현"></a> 구현</h2><p>트리는 노드로 구성되어 있으므로 제일 처음해야 할 작업은 TreeNode 클래스를 생성하는 것이다.</p><blockquote><p>TreeNode.kt</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> value: T) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> children: MutableList&lt;TreeNode&lt;T&gt;&gt; = mutableListOf()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 노드는 값을 담당하고 MutableList를 사용하여 모든 자식에 대한 참조를 저장한다.</p><p>다음으로 TreeNode 내부에 아래의 메서드를 추가하자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(child: <span class="type">TreeNode</span>&lt;<span class="type">T</span>&gt;)</span></span> = children.add(child)</span><br></pre></td></tr></table></figure><p>이 메서드는 노드에 자식 노드를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> hot = TreeNode(<span class="string">&quot;Hot&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> cold = TreeNode(<span class="string">&quot;Cold&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> beverages = TreeNode(<span class="string">&quot;Beverages&quot;</span>).run &#123;</span><br><span class="line">        add(hot)</span><br><span class="line">        add(cold)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>계층 구조는 트리 구조의 자연스러운 형태 중 하나이다. 위의 코드는 아래와 같은 구조를 가지고 있다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125865331-9c19532f-d417-4f64-88f0-91cd4314520f.png'></p><h2 id="traversal-algorithms"><a class="markdownIt-Anchor" href="#traversal-algorithms"></a> Traversal algorithms</h2><p>배열이나 리스트와 같은 <strong>선형 컬렉션</strong>을 반복<small>(iterating)</small>하는 것은 간단하다. 선형 컬렉션에는 명확한 시작과 끝이 있다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125865349-410b60ee-2e18-41ea-b07c-05d8f3939925.png'></p><p>트리를 반복하는 것은 조금 더 복잡하다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125865353-3a4a0fec-6f60-42d7-8165-cdee3b7d6ddb.png'></p><p>왼쪽에 있는 노드가 우선 순위를 가져야 할까? 노드의 깊이는 우선 순위와 어떤 관련이 있을까? 순회 전략은 해결하려는 문제에 따라 다르게 가져가야 한다.</p><p>서로 다른 트리와 문제에 대해 여러 전략이 존재한다. 이 모든 방법은 노드를 <strong>방문</strong>하고 노드 내부의 정보를 사용할 수 있게 해준다.</p><blockquote><p>TreeNode 클래스의 외부에 정의 추가</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Visitor&lt;T&gt; = (TreeNode&lt;T&gt;) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> value: T) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="depth-first-traversalsmalldepth-first-search-dfs-깊이-우선-탐색small"><a class="markdownIt-Anchor" href="#depth-first-traversalsmalldepth-first-search-dfs-깊이-우선-탐색small"></a> Depth-first traversal<small>(Depth-first search, DFS, 깊이 우선 탐색)</small></h3><p>깊이 우선 탐색은 루트 노드에서 시작하여 리프에 도달한 다음 백트래킹하기 전에 각 분기를 따라 가능한 멀리 트리를 탐색한다.</p><p>TreeNode 내부에 다음을 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">forEachDepthFirst</span><span class="params">(visit: <span class="type">Visitor</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    visit(<span class="keyword">this</span>)</span><br><span class="line">    children.forEach &#123; </span><br><span class="line">        it.forEachDepthFirst(visit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 간단한 코드는 재귀를 사용하여 다음 노드를 처리한다.</p><p>재귀적인 구현을 사용하지 않으려면 스택을 사용할 수 있으나 재귀를 이용한 방법이 더 간단하다.</p><blockquote><p>재귀 깊이 우선 탐색 테스트</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">makeBeverageTree</span><span class="params">()</span></span>: TreeNode&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> tree = TreeNode(<span class="string">&quot;Beverages&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> hot = TreeNode(<span class="string">&quot;hot&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> cold = TreeNode(<span class="string">&quot;cold&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> tea = TreeNode(<span class="string">&quot;tea&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> coffee = TreeNode(<span class="string">&quot;coffee&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> chocolate = TreeNode(<span class="string">&quot;cocoa&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> blackTea = TreeNode(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> greenTea = TreeNode(<span class="string">&quot;green&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> chaiTea = TreeNode(<span class="string">&quot;chai&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> soda = TreeNode(<span class="string">&quot;soda&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> milk = TreeNode(<span class="string">&quot;milk&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> gingerAle = TreeNode(<span class="string">&quot;ginger ale&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> bitterLemon = TreeNode(<span class="string">&quot;bitter lemon&quot;</span>)</span><br><span class="line">    tree.add(hot)</span><br><span class="line">    tree.add(cold)</span><br><span class="line">    hot.add(tea)</span><br><span class="line">    hot.add(coffee)</span><br><span class="line">    hot.add(chocolate)</span><br><span class="line">    cold.add(soda)</span><br><span class="line">    cold.add(milk)</span><br><span class="line">    tea.add(blackTea)</span><br><span class="line">    tea.add(greenTea)</span><br><span class="line">    tea.add(chaiTea)</span><br><span class="line">    soda.add(gingerAle)</span><br><span class="line">    soda.add(bitterLemon)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>makeBeverageTree()</code>는 아래와 같은 트리를 생성한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125865366-20b030f5-3cee-472f-b095-2d50ba7e7151.png'></p><p>트리를 생성한 다음 <code>main()</code>에서 다음과 같은 코드를 실행한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tree = makeBeverageTree()</span><br><span class="line">    tree.forEachDepthFirst &#123; println(it.value) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드의 출력 결과는 깊이 우선 탐색이 각 노드를 방문하는 순서를 보여준다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Beverages</span><br><span class="line">hot</span><br><span class="line">tea</span><br><span class="line">black</span><br><span class="line">green</span><br><span class="line">chai</span><br><span class="line">coffee</span><br><span class="line">cocoa</span><br><span class="line">cold</span><br><span class="line">soda</span><br><span class="line">ginger ale</span><br><span class="line">bitter lemon</span><br><span class="line">milk</span><br></pre></td></tr></table></figure><h3 id="level-order-traversal"><a class="markdownIt-Anchor" href="#level-order-traversal"></a> Level-order traversal</h3><p>Level-order traversal은 노드의 깊이를 기반으로 트리의 각 노드를 방문하는 방법이다. 루트에서 시작하여 하위 레벨로 이동하기 전에 같은 레벨의 모든 노드를 방문한다.</p><p>TreeNode 내부에 다음을 추가한다.</p><blockquote><p><a href="https://github.com/june0122/DataStructureKotlin/tree/master/src/queue">직접 구현한 Queue</a>를 사용할 시</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">forEachLevelOrder</span><span class="params">(visit: <span class="type">Visitor</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    visit(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">val</span> queue = StackQueue&lt;TreeNode&lt;T&gt;&gt;()</span><br><span class="line">    children.forEach &#123; queue.enqueue(it) &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> node = queue.dequeue()</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        visit(node)</span><br><span class="line">        node.children.forEach &#123; queue.enqueue(it) &#125;</span><br><span class="line">        node = queue.dequeue()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>java.util 패키지 내부의 Queue 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">forEachLevelOrder</span><span class="params">(visit: <span class="type">Visitor</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    visit(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;TreeNode&lt;T&gt;&gt; = LinkedList()</span><br><span class="line">    children.forEach &#123; queue.offer(it) &#125;</span><br><span class="line">    <span class="keyword">var</span> node = queue.poll()</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        visit(node)</span><br><span class="line">        node.children.forEach &#123; queue.offer(it) &#125;</span><br><span class="line">        node = queue.poll()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>forEachLevelOrder()</code>는 각 노드를 레벨 순으로 방문한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125865372-a74a4353-1568-422f-ac6c-9abf96f4d858.png'></p><p>노드가 올바른 레벨 순서로 방문되도록 큐를 사용하는 방법에 유의한다. 현재 노드를 방문하여 모든 자식을 큐에 넣는다. 그런 다음 비어 있을 때까지 큐를 사용하기 시작한다. 노드를 방문할 때마다 노드의 모든 자식들도 큐에 넣는다. 이렇게 하면 같은 레벨의 모든 노드를 차례로 방문할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> tree = makeBeverageTree()</span><br><span class="line">  tree.forEachLevelOrder &#123; println(it.value) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">beverages</span><br><span class="line">hot</span><br><span class="line">cold</span><br><span class="line">tea</span><br><span class="line">coffee</span><br><span class="line">cocoa</span><br><span class="line">soda</span><br><span class="line">milk</span><br><span class="line">black</span><br><span class="line">green</span><br><span class="line">chai</span><br><span class="line">ginger ale</span><br><span class="line">bitter lemon</span><br></pre></td></tr></table></figure><h3 id="검색"><a class="markdownIt-Anchor" href="#검색"></a> 검색</h3><p>노드를 반복하는 메서드를 이미 구현했으므로 검색 알고리즘을 구현하는데 오래 걸리지 않는다.</p><p>TreeNode 내부에 아래의 코드를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">search</span><span class="params">(value: <span class="type">T</span>)</span></span>: TreeNode&lt;T&gt;? &#123;</span><br><span class="line">    <span class="keyword">var</span> result: TreeNode&lt;T&gt;? = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    forEachLevelOrder &#123; </span><br><span class="line">        <span class="keyword">if</span> (it.value == value) &#123;</span><br><span class="line">            result = it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드를 테스트하기 위해 <code>main()</code>에 아래의 코드를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tree = makeBeverageTree()</span><br><span class="line">    tree.search(<span class="string">&quot;ginger ale&quot;</span>)?.let &#123;</span><br><span class="line">        println(<span class="string">&quot;Found node: <span class="subst">$&#123;it.value&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tree.search(<span class="string">&quot;WKD Blue&quot;</span>)?.let &#123;</span><br><span class="line">        println(it.value)</span><br><span class="line">    &#125; ?: println(<span class="string">&quot;Couldn&#x27;t find WKD Blue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main()</code>을 실행하면 다음과 같은 출력 결과를 볼 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Found node: ginger ale</span><br><span class="line">Couldn&#x27;t find WKD Blue</span><br></pre></td></tr></table></figure><p>위에서 level-order traversal 알고리즘을 사용했는데, 모든 노드를 방문하기 때문에 일치하는 항목이 여러 개일 경우 마지막으로 일치하는 항목이 채택된다. 이것은 사용하는 순회 방법에 따라 다른 객체를 얻을 수 있음을 의미한다.</p><h2 id="챌린지"><a class="markdownIt-Anchor" href="#챌린지"></a> 챌린지</h2><p>아래 트리의 값을 레벨에 따라 순서대로 출력하시오. 같은 레벨에 속하는 노드는 같은 줄에 출력해야 합니다.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/126172924-394314ff-9136-4639-bd29-65e1615d6edb.png'></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">17</span> <span class="number">20</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">0</span> <span class="number">2</span> <span class="number">5</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><blockquote><p>예제 트리 생성 코드</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">makeSampleTree</span><span class="params">()</span></span>: TreeNode&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> tree = TreeNode(<span class="number">15</span>)</span><br><span class="line">    <span class="keyword">val</span> one = TreeNode(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> seventeen = TreeNode(<span class="number">17</span>)</span><br><span class="line">    <span class="keyword">val</span> twenty = TreeNode(<span class="number">20</span>)</span><br><span class="line">    tree.add(one)</span><br><span class="line">    tree.add(seventeen)</span><br><span class="line">    tree.add(twenty)</span><br><span class="line">    one.add(TreeNode(<span class="number">1</span>))</span><br><span class="line">    one.add(TreeNode(<span class="number">5</span>))</span><br><span class="line">    one.add(TreeNode(<span class="number">0</span>))</span><br><span class="line">    seventeen.add(TreeNode(<span class="number">2</span>))</span><br><span class="line">    twenty.add(TreeNode(<span class="number">5</span>))</span><br><span class="line">    twenty.add(TreeNode(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>레벨 별 노드 출력 코드 (java.util 패키지 내부의 Queue 사용)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printEachLevel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;TreeNode&lt;T&gt;&gt; = LinkedList()</span><br><span class="line">    <span class="keyword">var</span> nodesLeftInCurrentLevel = <span class="number">0</span></span><br><span class="line">    queue.offer(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        nodesLeftInCurrentLevel = queue.size</span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">while</span> (nodesLeftInCurrentLevel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.poll()</span><br><span class="line">            node?.let &#123;</span><br><span class="line">                print(<span class="string">&quot;<span class="subst">$&#123;node.value&#125;</span> &quot;</span>)</span><br><span class="line">                node.children.forEach &#123; queue.offer(it) &#125;</span><br><span class="line">                nodesLeftInCurrentLevel--</span><br><span class="line">            &#125; ?: <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>레벨 별 노드 출력 코드 (<a href="https://github.com/june0122/DataStructureKotlin/tree/master/src/queue">직접 구현한 Queue</a>를 사용)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printEachLevel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> queue = StackQueue&lt;TreeNode&lt;T&gt;&gt;()</span><br><span class="line">    <span class="keyword">var</span> nodesLeftInCurrentLevel = <span class="number">0</span></span><br><span class="line">    queue.enqueue(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty.not()) &#123;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        nodesLeftInCurrentLevel = queue.count</span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">while</span> (nodesLeftInCurrentLevel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.dequeue()</span><br><span class="line">            node?.let &#123;</span><br><span class="line">                print(<span class="string">&quot;<span class="subst">$&#123;node.value&#125;</span> &quot;</span>)</span><br><span class="line">                node.children.forEach &#123; queue.enqueue(it) &#125;</span><br><span class="line">                nodesLeftInCurrentLevel--</span><br><span class="line">            &#125; ?: <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>레벨 순서 순회를 용이하게 하기 위해 큐를 초기화하는 것으로 시작한다. 또한 새 줄을 출력하기 전에 작업해야하는 노드의 수를 추적하기 위해 <em>nodesLeftInCurrentLevel</em>을 만든다.</li><li>레벨 순서 순회는 큐가 빌 때까지 계속된다.</li><li>첫 번째 while 루프 내에서 <em>nodesLeftInCurrentLevel</em>을 큐의 현재 요소로 설정하여 시작한다.</li><li>다른 while 루프를 사용하여 <em>nodesLeftInCurrentLevel</em>의 수만큼 큐에서 요소를 빼낸다. 큐에서 빼는 모든 요소는 다음 줄로 넘어가지 않고 출력되며, 노드의 모든 자식을 큐에 넣는다.</li><li>이 시점에서 <code>println()</code>을 사용하여 새 줄을 생성한다. 다음 반복에서 <em>nodesLeftInCurrentLevel</em>은 이전 반복의 자식 수를 나타내는 <em>queue.count</em>로 업데이트된다.</li></ol><h2 id="요약"><a class="markdownIt-Anchor" href="#요약"></a> 요약</h2><ul><li>트리는 연결 리스트와 몇 가지 유사점을 공유한다. 그러나 트리의 노드는 무한히 많은 노드에 연결할 수 있는 반면 연결 리스트의 노드는 하나의 다른 노드에만 연결할 수 있다.</li><li>깊이 우선 및 레벨 순서 순회는 일반적인 유형의 트리에만 국한되지 않는다. 트리 구조에 따라 구현이 약간 다르지만 다른 유형의 트리에서도 작동할 수 있다.</li></ul><br><div style="text-align: right"> <a href="https://github.com/june0122/DataStructureKotlin/tree/master/src/tree"><b><i>Github에서 본문의 코드 확인하기 </div><br><div style="text-align: right"> <a href="https://www.raywenderlich.com/books/data-structures-algorithms-in-kotlin/v1.0"><b><i>Data Structures & Algorithms in Kotlin</i></b></a> 서적을 참고하여 작성했습니다. </div>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Data-Structure/">Data Structure</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Data-Structure/">Data Structure</category>
      
      <category domain="http://june0122.github.io/tags/Tree/">Tree</category>
      
      
      <comments>http://june0122.github.io/2021/07/19/data-structure-trees/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
