<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>카미유 테크 블로그</title>
    <link>http://june0122.github.io/</link>
    
    <atom:link href="http://june0122.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 24 May 2021 06:16:41 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[Codility] OddOccurrencesInArray</title>
      <link>http://june0122.github.io/2021/05/24/codility-odd-occurrences/</link>
      <guid>http://june0122.github.io/2021/05/24/codility-odd-occurrences/</guid>
      <pubDate>Mon, 24 May 2021 06:14:27 GMT</pubDate>
      
      <description>Lesson 2 - Arrays : OddOccurrencesInArray</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="lesson-2-arrays-oddoccurrencesinarray"><a class="markdownIt-Anchor" href="#lesson-2-arrays-oddoccurrencesinarray"></a> Lesson 2 - Arrays : <a href="https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/">OddOccurrencesInArray</a></h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>첫 시도</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(A: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> A.groupBy &#123; it &#125;.filter &#123; it.value.size % <span class="number">2</span> == <span class="number">1</span> &#125;.map &#123; it.key &#125;.first()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>날먹 시도 실패 😩</p><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/119300036-07198d80-bc9b-11eb-8fe0-3c9c837ef015.png'></p><blockquote><p>두 번째 시도 : HashMap 이용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(A: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> hashMap = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    A.forEach &#123;</span><br><span class="line">        hashMap[it] = hashMap.getOrDefault(it, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hashMap.keys.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashMap.getValue(it) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> it</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/119299593-27951800-bc9a-11eb-92a9-150c587edccc.png'></p><blockquote><p>번외 : <code>step</code>을 이용한 비교</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(A: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size == <span class="number">1</span>) <span class="keyword">return</span> A[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    A.sort()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> A.indices step <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> == A.size) <span class="keyword">return</span> A[i]</span><br><span class="line">        <span class="keyword">if</span> (A[i] != A[i + <span class="number">1</span>]) <span class="keyword">return</span> A[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/119301003-b5720280-bc9c-11eb-824c-637478b6acfe.png'></p><blockquote><p><code>xor</code> 연산 이용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(A: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    A.forEach &#123;</span><br><span class="line">        result = result xor it</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여러 방법으로 시도해도 효율성 테스트의 마지막 케이스가 실패했기에 검색을 해보니 비트 연산자를 활용하는 방법이 있었다!</p><p><code>xor</code> 연산은 숫자가 같으면 0, 숫자가 다르면 1을 반환하기 때문에 중복되지 않은 요소를 찾아내는데 유용하다.</p><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/119304589-6cbd4800-bca2-11eb-9764-563b75397646.png'></p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Codility/">Codility</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Codility/">Codility</category>
      
      
      <comments>http://june0122.github.io/2021/05/24/codility-odd-occurrences/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] 데이터베이스와 Room 라이브러리</title>
      <link>http://june0122.github.io/2021/05/24/android-bnr-11/</link>
      <guid>http://june0122.github.io/2021/05/24/android-bnr-11/</guid>
      <pubDate>Sun, 23 May 2021 23:14:22 GMT</pubDate>
      
      <description>&lt;b&gt;Room&lt;/b&gt;은 Jetpack의 아키텍처 컴포넌트 라이브러리로, 데이터베이스 설정과 사용을 쉽게 해준다. Room을 사용하면 애노테이션이 지정된 코틀린 클래스로 데이터베이스 구조와 쿼리를 정의할 수 있다.</description>
      
      
      
      <content:encoded><![CDATA[<p>거의 모든 애플리케이션은 장시간 동안 데이터를 저장할 곳이 필요하다. 본문에서는 <strong>Room 라이브러리</strong>를 사용해서 앱의 데이터베이스를 쿼리할 수 있는 코드를 구현하고, 데이터베이스로부터 데이터를 가져와서 리스트에 보여주도록 한다.</p><p><a href="https://june0122.github.io/2021/05/13/android-bnr-04/">ViewModel과 SIS</a>에서 장치 회전 및 프로세스 종료 시에 ViewModel과 SIS <sup>Saved Instance Status</sup>를 사용해서 일시적인 UI 상태 데이터를 지속하는 방법을 기술했다. ViewModel과 SIS는 UI와 관련된 적은 수의 데이터에는 아주 좋지만 UI와 결부되지 않는 데이터의 저장에는 사용할 수 없다. 또한, 액티비티나 프래그먼트 인스턴스에 연관되지 않으면서 UI 상태와 무관하게 영구적으로 지속할 필요가 있는 데이터의 저장에도 사용할 수 없다.</p><p>따라서 이런 앱 데이터는 ViewModel이나 SIS 대신 로컬 파일 시스템이나 로컬 데이터베이스 또는 웹 서버에 저장해야 한다.</p><h2 id="room-아키텍처-컴포넌트-라이브러리"><a class="markdownIt-Anchor" href="#room-아키텍처-컴포넌트-라이브러리"></a> Room 아키텍처 컴포넌트 라이브러리</h2><p>Room은 Jetpack의 아키텍처 컴포넌트 라이브러리로, 데이터베이스 설정과 사용을 쉽게 해준다. Room을 사용하면 애노테이션이 지정된 코틀린 클래스로 데이터베이스 구조와 쿼리를 정의할 수 있다.</p><p>Room은 <strong>API, 애노테이션 <sup>annotation</sup>, 컴파일러로 구성</strong>되어 있다.</p><ul><li>데이터베이스를 정의하고 인스턴스를 생성하기 위해 상속받는 클래스들이 <strong>API</strong>에 포함되어 있다.</li><li>데이터베이스에 저장할 필요가 있는 클래스, 데이터베이스를 나타내는 클래스, 데이터베이스 테이블을 사용하는 함수들을 정의하는 클래스 등을 나타내기 위해 <strong>애노테이션</strong>을 사용한다.</li><li><strong>컴파일러</strong>는 지정한 애노테이션을 컴파일해서 데이터베이스 구현체 <sub>(클래스나 인터페이스 등)</sub>를 생성한다.</li></ul><blockquote><p>Room을 사용하는데 필요한 의존성 추가</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin annotation processor tool 추가</span></span><br><span class="line">    id <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation <span class="string">&#x27;androidx.core:core-ktx:1.3.2&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// room-runtime과 room-compiler 추가</span></span><br><span class="line">    implementation <span class="string">&#x27;androidx.room:room-runtime:2.3.0&#x27;</span></span><br><span class="line">    kapt <span class="string">&#x27;androidx.room:room-compiler:2.3.0&#x27;</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>먼저 안드로이드 스튜디오의 <strong>플러그인 <sup>plug-in</sup></strong> 으로 <strong>kotlin-kapt</strong>를 추가한다. 플러그인은 안드로이드 스튜디오 같은 IDE에 기능을 추가하는 방법이다.</p><p>kotlin-kapt는 코틀린 애노테이션 처리 도구 <sup>Kotlin annotation processor tool</sup>다. 라이브러리에서 생성한 클래스를 코드에서 직접 사용하고자 할 때가 있다. 그런데 기본적으로 라이브러리가 생성한 클래스들은 안드로이드 스튜디오에서 알 수 가 없어 이런 클래스들을 import해서 사용하려고 하면 에러가 발생한다. kotlin-kapt 플러그인을 추가하면 라이브러리가 생성한 클래스들을 안드로이드 스튜디오에서 알 수 있으므로 import해서 사용할 수 있다.</p><p>위에서 추가한 첫 번째 의존성인 <em>room-runtime</em>은 데이터베이스를 정의하는 데 필요한 모든 클래스와 애노테이션을 포함하는 Room API다.</p><p>두 번째 의존성인 <em>room-compiler</em>는 지정한 애노테이션을 컴파일해서 데이터베이스 구현채를 생성한다. room-compiler 의존성을 지정할 때는 <code>implementation</code> 대신 <code>kapt</code> 키워드를 사용해 Room 컴파일러가 생성한 클래스들을 안드로이드 스튜디오가 알 수 있게 한다.</p><h2 id="데이터베이스-생성하기"><a class="markdownIt-Anchor" href="#데이터베이스-생성하기"></a> 데이터베이스 생성하기</h2><p>Room으로 데이터베이스를 생성할 때는 다음 세 단계로 한다.</p><ol><li>모델 클래스에 애노테이션을 지정해 데이터베이스 <strong>엔터티 <sup>entity</sup></strong> 로 만든다.</li><li>데이터베이스 자체를 나타내는 클래스를 생성한다.</li><li>데이터베이스가 모델 데이터를 처리할 수 있게 타입 변환기 <sup>type converter</sup>를 생성한다.</li></ol><p>Room은 이 단계가 수월하게 이루어지도록 해준다.</p><h3 id="entity-정의하기"><a class="markdownIt-Anchor" href="#entity-정의하기"></a> Entity 정의하기</h3><p>Room은 우리가 정의한 <strong>엔터티</strong>를 기반으로 앱의 데이터베이스 테이블 구조를 만든다. 엔터티는 우리가 생성하는 모델 클래스로, <code>@Entity</code> 애노테이션으로 지정한다. 그러면 이 애노테이션으로 Room이 해당하는 클래스의 데이터베이스 테이블을 생성한다.</p><p>본문의 예시로는 Crime 객체를 데이터베이스에 저장할 것이므로 Crime 클래스를 엔터티로 변경한다.</p><blockquote><p>Crime을 엔터티로 만들기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Crime</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: UUID = UUID.randomUUID(),</span><br><span class="line">    <span class="keyword">var</span> title: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">var</span> date: Date = Date(),</span><br><span class="line">    <span class="keyword">var</span> isSolved: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>@Entity</code> 애노테이션은 클래스 수준에 적용된다. 이 엔터티 애노테이션은 Crime 클래스가 데이터베이스 테이블의 구조를 정의함을 나타낸다. 따라서 테이블의 <strong>각 행 <sup>row</sup>이 하나의 Crime 객체를 나타내며, 클래스에 정의된 각 속성은 테이블의 열 <sup>column</sup>이므로 속성 이름은 열의 이름</strong>이 된다. 따라서 Crime 객체 데이터를 저장하는 테이블은 id, title, date, isSolved 열을 갖는다.</p><p>id 속성에는 <code>@PrimaryKey</code> 애노테이션이 추가되었다. 이 애노테이션은 <strong>기본 키 <sup>primary key</sup></strong> 열을 지정한다. 기본 키는 테이블의 모든 행에 고유한 데이터를 갖는 열이므로 각 행을 검색하는데 사용할 수 있다. 여기서는 id 속성값이 모든 Crime 객체에 고유하다. 따라서 id 속성에 <code>@PrimaryKey</code>를 지정하면 이 속성을 사용해 특정 Crime 객체 데이터를 쿼리할 수 있다.</p><h3 id="데이터베이스-클래스-생성하기"><a class="markdownIt-Anchor" href="#데이터베이스-클래스-생성하기"></a> 데이터베이스 클래스 생성하기</h3><p>엔터티 클래스는 데이터베이스 테이블의 구조를 정의한다. 앱에 여러 개의 데이터베이스가 있을 때는 특정 엔터티 클래스는 여러 데이터베이스에서 사용될 수 있다. 이런 경우가 흔하지는 않지만 가능하다. 이런 이유로 엔터티 클래스를 데이터베이스와 연관시켜 주어야 Room이 테이블을 생성하는데 사용할 수 있다.</p><p>우선 데이터베이스에 특정한 코드를 모아둘 패키지인 database를 생성하여 데이터베이스 클래스를 생성한다.</p><blockquote><p>초기의 CrimeDatabase 클래스 (database/CrimeDatabase.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(entities = [Crime::class], version = 1)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Database</code> 애노테이션은 이 클래스가 앱의 데이터베이스를 나태난다고 Room에게 알려준다. 이 애노테이션에는 두 개의 매개변수를 지정해야 한다.</p><ol><li>첫 번째 매개변수에는 이 데이터베이스의 테이블들을 생성하고 관리하는 데 사용할 엔터티 클래스들을 지정한다<ul><li>여기서는 앱에서 유일한 엔터티 클래스인 Crime 클래스만 지정하였다.</li></ul></li><li>두 번째 매개변수에는 데이터베이스의 버전을 지정한다.<ul><li>데이터베이스를 처음 생성했을 때는 버전이 <code>1</code>이다.</li><li>앱을 계속 개발하는 동안 새로운 엔터티를 추가하거나 기존 엔터티에 새로운 속성을 추가할 수 있다. 추가할 대는 <code>@Database</code> 애노테이션의 엔터티를을 변경하거나 데이터벵스 버전 번호를 증가시켜야 한다.</li></ul></li></ol><p>데이터베이스 클래스인 CrimeDatabase는 <strong>RoomDatabase</strong>의 서브 클래스다. 현재는 아무것도 갖고 있지 않으며, <code>abstract</code>로 지정되어서 이 클래스의 인스턴스를 생성할 수 없다. Room을 사용해서 데이터베이스 인스턴스를 얻는 방법은 이번 장 뒤에서 기술한다.</p><h3 id="타입-변환기-생성하기"><a class="markdownIt-Anchor" href="#타입-변환기-생성하기"></a> 타입 변환기 생성하기</h3><p>Room은 내부적으로 SQLite를 사용한다. SQLite는 MySQL이나 PostgreSQL 같은 오픈 소스 관계형 데이터베이스다 <sub>(SQL은 Structured Query Language의 약어이며 표준 데이터베이스 언어다)</sub>. 다른 데이터베이스와 달리 SQLite는 라이브러리를 사용해서 데이터를 읽거나 데이터를 쓸 수 있는 파일에 저장한다. 안드로이드는 추가 도우미 클래스들과 함께 SQLite 라이브러리를 표준 라이브러리에 포함하고 있다.</p><p>Room은 코틀린 객체와 데이터베이스 사이에서 객체-관계 매핑 <sup>ORM, Object-Relational Mapping</sup>계층의 역할을 하면서 SQLite 사용을 쉽게 해준다. Room을 사용하면 대부분의 경우에 SQLite를 자세히 알 필요 없다.</p><p>Room은 기본 데이터 타입을 SQLite 데이터베이스 테이블에 쉽게 저장할 수 있지만, 이외의 다른 타입은 문제가 생길 수 있다. Crime 클래스에는 Room이 저장 방법을 모르는 Date와 UUID 타임 속성이 있다. 따라서 이런 타입의 데이터를 데이터베이스 테이블에 저장하거나 가져오는 방법을 Room에게 알려줘야 한다.</p><p>데이터 타입을 변환하는 방법을 Room에게 알려주려면 <strong>타입 변환기</strong>를 지정하면 된다. 타입 변환기는 Room에게 특정 타입을 데이터베이스에 저장되는 타입으로 변환하는 방법을 알려준다. 이때 각 타입에 대해서 <strong><code>@TypeConverter</code> 애노테이션이 지정된 두 개의 함수가 필요</strong>하다.</p><ol><li>데이터베이스에 데이터를 저장하기 위해 타입을 변환하는 함수</li><li>데이터베이스로부터 읽은 데이터를 우리가 원하는 타입으로 변환하는 함수</li></ol><blockquote><p>타입 변환 클래스와 함수 추가하기 (database/CrimeTypeConverters.kt)</p></blockquote><p>Date, UUID 타입에 대해 변환을 처리하는 두 개의 함수를 각각 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeTypeConverters</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fromDate</span><span class="params">(date: <span class="type">Date</span>?)</span></span>: <span class="built_in">Long</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> date?.time</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toDate</span><span class="params">(millisSinceEpoch: <span class="type">Long</span>?)</span></span>: Date? &#123;</span><br><span class="line">        <span class="keyword">return</span> millisSinceEpoch?.let &#123; </span><br><span class="line">            Date(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toUUID</span><span class="params">(uuid: <span class="type">String</span>?)</span></span>: UUID? &#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.fromString(uuid)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fromUUID</span><span class="params">(uuid: <span class="type">UUID</span>?)</span></span>: String? &#123;</span><br><span class="line">        <span class="keyword">return</span> uuid?.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>타입 변환기 활성화하기 (database/CrimeDatabase.kt)</p></blockquote><p>변환기 클래스를 데이터베이스 클래스에 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(entities = [Crime::class], version = 1)</span></span><br><span class="line"><span class="meta">@TypeConverters(CrimeTypeConverters::class)</span> <span class="comment">// 변환기 클래스 추가</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이처럼 <code>@TypeConverters</code> 애노테이션을 추가하면서 CrimeTypeConverters 클래스를 전달하면, Room은 타입을 변환할 때 해당 클래스의 함수들을 사용한다.</p><p>이것으로 데이터베이스와 테이블 정의는 완료되었다.</p><h2 id="dao-정의하기"><a class="markdownIt-Anchor" href="#dao-정의하기"></a> DAO 정의하기</h2><p>데이터베이스 테이블의 데이터를 액세스하려면 DAO <sup>Data Access Object</sup>를 생성해야 한다. DAO는 데이터베이스 작업을 수행하는 함수들을 포함하는 인터페이스다.</p><p>본문에서의 예시의 DAO에는 두 개의 쿼리 함수가 필요하다. 바로 데이터베이스의 모든 범죄 데이터를 반환하는 함수와 지정된 UUID를 갖는 하나의 범죄 데이터를 반환하는 함수다.</p><blockquote><p>DAO 인터페이스 (database/CrimeDao.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CrimeDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이처럼 <code>@Dao</code> 애노테이션을 지정하면 CrimeDao가 DAO 중 하나임을 Room이 알게 된다. 그리고 데이터베이스 클래스에 CrimeDao를 등록하면 이 인터페이스에 추가된 함수들의 실행 코드를 Room이 생성한다.</p><blockquote><p>DAO에 두 개의 쿼리 함수 추가하기 (database/CrimeDao.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CrimeDao</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">&quot;SELECT * FROM crime&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrimes</span><span class="params">()</span></span>: List&lt;Crime&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">&quot;SELECT * FROM crime WHERE id=(:id)&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrime</span><span class="params">(id: <span class="type">UUID</span>)</span></span>: Crime?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Query</code> 애노테이션은 <code>getCrimes()</code>와 <code>getCrime(UUID)</code> 함수가 데이터베이스의 데이터를 읽는다는 것을 나타낸다(추가, 변경, 삭제가 아님). 이 DAO에 정의된 각 쿼리 함수의 반환 타입은 쿼리가 반환하는 결과의 타입을 반영한다.</p><p><code>@Query</code> 애노테이션은 문자열로 된 SQL 명령을 받는다. 대부분의 경우에는 간단한 SQL만 알면 되지만, SQL에 관한 더 자세한 내용은 <a href="https://www.sqlite.org">https://www.sqlite.org</a> 사이트의 <a href="https://www.sqlite.org/lang.html">SQL Syntax</a>에서 참고할 수 있다.</p><p><code>SELECT * FROM crime</code>은 crime 데이터베이스 테이블에 저장된 모든 행의 모든 열을 가져오며, <code>SELECT * FROM crime WHERE id=(:id)</code>는 id 값이 일치하는 행의 모든 열만 가져온다.</p><p>기존 데이터를 변경하는 함수를 인터페이스에 추가하는 것은 <a href="">링크 추가 예정</a>에서, 새로운 데이터를 추가하는 함수의 추가는 <a href="">링크 추가 예정</a>에서 다룬다.</p><p>다음으로 CrimeDao 인터페이스를 데이터베이스 클래스에 등록해야 한다. CrimeDao는 인터페이스이므로 이것을 구현하는 클래스를 Room이 생성한다. 하지만 이렇게 되려면 CrimeDao의 인스턴스를 생성하게 데이터베이스 클래스에 알려주어야 한다.</p><p>아래와 같이 CrimeDao를 반환 타입으로 갖는 추상 함수를 CrimeDatabase.kt에 추가한다.</p><blockquote><p>데이터베이스에 CrimeDao 등록하기 (database/CrimeDatabase.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(entities = [Crime::class], version = 1)</span></span><br><span class="line"><span class="meta">@TypeConverters(CrimeTypeConverters::class)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CrimeDao 등록</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">crimeDao</span><span class="params">()</span></span>: CrimeDao</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제는 데이터베이스가 생성되면 우리가 사용할 수 있는 CrimeDao 구현 클래스를 Room이 생성한다. 따라서 CrimeDao의 참조를 가지면 CrimeDao에 정의된 함수들을 호출해서 데이터베이스를 사용할 수 있다.</p><h2 id="리포지터리-패턴으로-데이터베이스-액세스하기"><a class="markdownIt-Anchor" href="#리포지터리-패턴으로-데이터베이스-액세스하기"></a> 리포지터리 패턴으로 데이터베이스 액세스하기</h2><blockquote><p>리포지터리 패턴 다이어그램</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119275355-7e293480-bc4f-11eb-9c51-a4b6cb604d21.png'></p><p>데이터베이스 액세스를 위해 본문에서는 <a href="https://developer.android.com/jetpack/guide">구글의 앱 아키텍처 지침</a>에서 권장하는 <strong>리포지터리 패턴 <sup>repository pattern</sup></strong> 을 사용한다.</p><p><strong>리포지터리</strong> 클래스는 리포지터리 <sup>데이터 저장소</sup>를 구현한다. 또한 단일 또는 여러 소스로부터 데이터를 액세스하는 로직을 캡슐화하고, 로컬 데이터베이스나 원격 서버로부터 특정 데이터 셋을 가져오거나 저장하는 방법을 결정한다. 그리고 UI 코드에서는 리포지터리에 모든 데이터를 요청한다. UI는 어떻게 데이터를 저장하거나 가져오는지에 관여하지 않으므로 이런 일은 리포지터리에서 구현한다.</p><blockquote><p><b id = "f1">리포지터리 구현하기</b>  <a href="#a1"> ↩</a> (CrimeRepository.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeRepository</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(context: Context)&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> INSTANCE: CrimeRepository? = <span class="literal">null</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">initialize</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                INSTANCE = CrimeRepository(context)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: CrimeRepository &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;CrimeRepository must be initialized&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CrimeRepository는 <strong>싱글톤 <sup>singleton</sup></strong> 이다. 즉, 앱이 실행되는 동안 하나의 인스턴스만 생성된다는 의미다.</p><p>싱글톤은 앱이 메모리에 있는 한 계속 존재하므로, 싱글톤이 갖는 속성은 액티비티나 프래그먼트의 생명주기 상태가 변경되어도 계속 유지될 수 있다. 그러나 안드로이드 운영체제가 메모리에서 앱을 제거하면 싱글톤도 같이 소멸한다. 따라서 CrimeRepository 싱글톤은 데이터를 장기간 저장하기 위한 해결책이 될 수 없지만, 대신에 CriminalIntent 앱에서 범죄 데이터를 갖고 있으면서 컨트롤러 클래스 간의 데이터를 쉽게 전달하는 방법을 제공한다.</p><p>CrimeRepository를 싱글톤으로 만들고자 여기서는 두 개의 함수를 동반 객체에 추가하였다. 하나는 CrimeRepository의 인스턴스를 생성하는 함수이고, 다른 하나는 기존에 생성된 CrimeRepository 인스턴스를 반환하는 함수다. 그리고 CrimeRepository의 생성자를 <code>private</code>로 지정해서 외부에서 <code>CrimeRepository.initialize(Context)</code>를 호출해야만 CrimeRepository 인스턴스를 생성할 수 있게 했다.</p><p>게터 함수인 <code>get()</code>에서는 CrimeRepository 인스턴스가 생성되지 않으면 IllegalStateException을 발생시킨다. 따라서 앱이 시작될 대 리포지터리인 CrimeRepository 인스턴스를 생성해야 한다.</p><p>이렇게 하려면 <strong>Application</strong>의 서브 클래스를 생성하면 된다.</p><blockquote><p>Application 서브 클래스 생성하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CriminalIntentApplication</span>: <span class="type">Application</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        CrimeRepository.initialize(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Activity.onCreate(...)</code>와 유사하게 <code>Application.onCreate(...)</code>는 앱이 최초로 메모리에 로드될 때 안드로이드 시스템이 자동 호출한다. 따라서 한번만 초기화되는 작업을 수행하는 데 적합하다.</p><p>액티비티나 프래그먼트와는 달리 Application 인스턴스 즉, CriminalIntentApplication 인스턴스는 CriminalIntent 앱이 최초 실행될 때 생성되거나 앱 프로세스 소멸로 인해 CriminalIntentApplication 인스턴스가 소멸된 후 CriminalIntent 앱이 다시 실행될 때 재생성된다.</p><p>CriminalIntentApplication 인스턴스를 안드로이드 시스템에서 사용하려면 매니페스트에 등록해야 한다. AndroidManifest.xml에 <code>android:name</code> 속성을 추가해서 앱을 설정하면 이후부터는 CriminalIntentApplication 인스턴스가 앱의 Context 객체로 사용된다.</p><blockquote><p>CriminalIntentApplication을 등록하기</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.june0122.criminalintent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.CriminalIntentApplication&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이제는 CriminalIntent 앱이 실행될 때 안드로이드 운영체제가 CriminalIntentApplication 인스턴스를 생성하고 이 인스턴스의 <code>onCreate()</code>를 호출한다. 따라서 CrimeRepository 인스턴스가 생성되어 사용할 수 있다.</p><p>다음으로 데이터베이스 객체와 DAO 객체의 참조를 저장하는 두 개의 속성을 CrimeRepository에 추가한다.</p><blockquote><p>리포지터리 속성 설정하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DATABASE_NAME = <span class="string">&quot;crime-database&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeRepository</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(context: Context)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> database: CrimeDatabase = Room.databaseBuilder(</span><br><span class="line">        context.applicationContext,</span><br><span class="line">        CrimeDatabase::<span class="keyword">class</span>.java,</span><br><span class="line">        DATABASE_NAME</span><br><span class="line">    ).build()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeDao = database.crimeDao()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Room.databaseBuilder()</code>는 세 개의 매개변수를 사용해서 CrimeDatabase의 실체 클래스를 생성한다.</p><ol><li>데이터베이스가 안드로이드 장치의 파일 시스템을 액세스하므로 첫 번째 매개변수는 데이터베이스의 컨텍스트로, 주로 앱의 Context <sub>(여기서는 CriminalIntentApplication)</sub> 객체를 전달한다.</li><li>두 번째 매개변수는 Room으로 생성하고자 하는 데이터베이스 클래스 <sub>(여기서는 CrimeDatabase)</sub></li><li>세 번째 매개변수는 Room으로 생성하고자 하는 데이터베이스 파일 이름이다.</li></ol><p>다른 컴포넌트에서는 CrimeDatabase를 액세스할 필요가 없으므로 여기서는 <code>private</code> 문자열로 지정하였다 <sub>(SQLite에서는 한 데이터베이스가 하나의 파일로 생성된다)</sub>.</p><p>다음으로 DAO의 데이터베이스 액세스 함수들을 CrimeRepository에서 사용하기 위한 함수를 추가한다.</p><blockquote><p>리포지터리 함수 추가하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeRepository</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(context: Context)&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeDao = database.crimeDao()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrimes</span><span class="params">()</span></span>: List&lt;Crime&gt; = crimeDao.getCrimes()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrime</span><span class="params">(id: <span class="type">UUID</span>)</span></span>: Crime? = crimeDao.getCrime(id)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Room은 DAO에 쿼리를 구현하므로 리포지터리에 DAO의 함수를 호출하는 함수가 필요하다. 이렇게 하면 리포지터리에서 DAO <sub>(여기서는 CrimeDao)</sub>의 함수를 호출만 하면 되므로 코드가 간단해지고 이해하기 쉬워진다.</p><h2 id="쿼리-테스트하기"><a class="markdownIt-Anchor" href="#쿼리-테스트하기"></a> 쿼리 테스트하기</h2><p>리포지터리가 준비되었지만 쿼리 함수를 테스트하기 전에 할 일이 하나 더 있다. 현재 데이터베이스에는 범죄 데이터가 하나도 없다. 코드에서 모의 데이터를 생성해 데이터베이스에 추가할 수 있찌만, 데이터를 추가하는 DAO 함수를 아직 구현하지 않았기 때문에 <a href="https://github.com/Jpub/AndroidBNR4/tree/main/Ch11/databases">데이터베이스 파일</a>을 이용한다. 안드로이드 스튜디오의 장치 파일 탐색기(Device File Explorer)를 사용해서 에뮬레이터에 파일을 업로드하면 된다.</p><p>참고로 에뮬레이터는 루트 권한으로 사용할 수 있어서 데이터베이스 파일의 업로드 및 앱에서의 사용이 가능하지만, 실제 장치에서는 데이터베이스 파일을 복사하지 못하거나 복사가 되더라도 권한이 없어서 앱에서 사용하지 못할 수 있기 때문에 데이터베이스 파일을 사용할 경우 에뮬레이터에서 테스트한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119275895-a23a4500-bc52-11eb-91af-6688896e4fd8.png'></p><p>리포지터리를 사용해서 퀴리할 수 있는 데이터가 준비되었으니 CrimeListViewModel에서 기존의 모의 데이터 코드를 삭제하고 CrimeRepository의 <code>getCrimes()</code> 함수를 호출하는 코드로 교체한다.</p><blockquote><p>CrimeListViewModel에서 리포지터리 액세스하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListViewModel</span>: <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    val crimes = mutableListOf&lt;Crime&gt;()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    init &#123;</span></span><br><span class="line"><span class="comment">//        for (i in 0 until 100) &#123;</span></span><br><span class="line"><span class="comment">//            val crime = Crime()</span></span><br><span class="line"><span class="comment">//            crime.title = &quot;Crime #$i&quot;</span></span><br><span class="line"><span class="comment">//            crime.isSolved = i % 2 == 0</span></span><br><span class="line"><span class="comment">//            crimes += crime</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeRepository = CrimeRepository.<span class="keyword">get</span>()</span><br><span class="line">    <span class="keyword">val</span> crimes = crimeRepository.getCrimes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>변경 후 앱을 실행하면 앱이 중단이 된다…!</p><p>LogCat의 에러 메시지를 보면 아래와 같다.</p><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/119277726-3fe64200-bc5c-11eb-81d6-055d961f8e93.png'></p><p>이 에러는 Room 라이브러리에서 발생된 것으로, 긴 시간 동안 UI를 차단하는 데이터베이스 액세스를 main 스레드에서 하려고 했기 때문이다. 따라서 데이터베이스 액세스와 같이 시간이 걸리는 작업은 백그라운드에서 수행해야 한다.</p><h2 id="애플리케이션의-스레드"><a class="markdownIt-Anchor" href="#애플리케이션의-스레드"></a> 애플리케이션의 스레드</h2><p>데이터베이스로부터 데이터를 가져오는 것은 즉시 처리되지 않고 오래 걸릴 수 있다. Room은 메인 스레드에서의 데이터베이스 액세스를 허용하지 않으며, 액세스하려고 하면 IllegalStateException을 발생시킨다.</p><p>이것을 이해하려면 스레드가 무엇인지, 그리고 메인 스레드는 무엇이고 무슨 일을 하는지 알아야 한다.</p><p>스레드는 단일의 실행 시퀀스다. 스레드 내부의 코드는 한 단계씩 실행된다. 모든 안드로이드 앱은 <strong>main 스레드</strong>로 시작된다. 그러나 main 스레드는 미리 정해진 순서로 실행되지 않는다. 대신에 무한 루프에 머물면서 사용자나 시스템이 유발한 이벤트를 기다린다. 그리고 이벤트가 발생하면 응답하는 코드를 실행한다.</p><blockquote><p>일반 스레드 vs main 스레드</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/119277908-36110e80-bc5d-11eb-8a3e-d58264bd7fa5.jpeg'></p><p>main 스레드는 UI를 변경하는 모든 코드들을 실행하며, 액티비티 시작, 버튼 클릭 등 서로 다른 UI 관련 이벤트들에 대한 응답으로 실행되는 코드들도 포함된다. 이벤트들은 어떤 형태로든 모두 UI와 관련이 있어서 main 스레드를 <strong>UI 스레드</strong>라고도 한다.</p><p>이벤트 루프에서는 UI 코드를 순서대로 유지한다. 따라서 시기 적절하게 코드가 실행되면서도 상호 충돌이 생기지 않는다. 지금까지 작성했던 모든 코드는 main 스레드에서 실행되었다.</p><h3 id="백그라운드-스레드"><a class="markdownIt-Anchor" href="#백그라운드-스레드"></a> 백그라운드 스레드</h3><p>데이터베이스 액세스는 다른 일보다 시간이 많이 걸린다. 따라서 이 시간 동안 UI는 완전히 응답 불가능이 될 것이고, 결국은 <strong>애플리케이션이 응답하지 않는(ANR, Application Not Responding)</strong> 결과를 초래하게 된다.</p><p>main 스레드가 중요한 이벤트에 대한 응답에 실패했다고 안드로이드의 와치독 <sup>watchdog</sup>이 판단하면 ANR이 발생하며, 애플리케이션이 중단된다 <sub>(10초 이내에 UI 응답이 없으면 사용자가 불편하지 않도록 안드로이드 시스템에서 ANR을 발생시킨다)</sub>.</p><p>이를 해결하기 위해 <strong>백그라운드 스레드</strong>를 생성해서 데이터베이스를 액세스해야 한다. 백그라운드 스레드를 앱에 추가할 때 중요한 규칙이 두 가지 있다.</p><ol><li><p><strong>장시간 실행되는 모든 작업은 백그라운드 스레드로 실행되어야 한다.</strong></p><ul><li>이렇게 하면 main 스레드가 UI 관련 작업을 자유롭게 처리할 수 있어서 사용자를 위한 UI 응답을 지속적으로 처리할 수 있다.</li></ul></li><li><p><strong>UI는 main 스레드에서만 변경할 수 있다.</strong></p><ul><li>백그라운드 스레드에서 UI를 변경하려고 하면 에러가 발생한다. 따라서 백그라운드 스레드에서 생성되는 모든 데이터는 main 스레드에 전달해서 UI를 변경하게 해야 한다.</li></ul></li></ol><p>안드로이드에서 백그라운드 스레드로 작업을 실행하는 방법에는 여러 가지가 있다. 비동기 네트워크를 요청하는 방법은 <a href="">링크 추가 예정</a>에서, 핸들러 <sup>Handler</sup>를 사용해서 많은 소규모 백그라운드 작업을 수행하는 방법은 <a href="">링크 추가 예정</a>에서, <strong>WorkManager</strong>를 사용해서 주기적인 백그라운드 작업을 수행하는 방법은 <a href="">링크 추가 예정</a>에서 알아본다.</p><p>백그라운드에서 데이터베이스 작업을 실행하기 위해 두 가지 방법을 사용하는데, 본문에서는 쿼리 데이터를 포함하는 <strong>LiveData</strong>를 사용하고, 후에 <strong>Executor</strong>를 사용해서 데이터를 추가 및 변경한다.</p><h2 id="livedata-사용하기"><a class="markdownIt-Anchor" href="#livedata-사용하기"></a> LiveData 사용하기</h2><p><strong>LiveData</strong>는 Jetpack의 <em>lifecycle-extensions</em> 라이브러리에 있는 데이터 홀더 클래스이며, Room에서 LiveData를 사용한다.</p><p>LiveData의 목적은 <strong>앱의 서로 다른 부분 간에 데이터 전달을 쉽게 만드는 것</strong>이다.</p><ul><li>범죄 데이터를 보여줘야하는 프래그먼트로 CrimeRepository에서 데이터를 전달할 수 있으며</li><li>스레드 간에도 데이터를 전달할 수 있어서 백그라운드 스레드에서 main 스레드로 데이터를 전달할 수 있다.</li></ul><p>Room DAO의 쿼리에서 LiveData를 반환하도록 구성하면, Room이 백그라운드 스레드에서 쿼리 작업을 자동 실행한 후 그 결과를 LiveData 객체로 반환한다. 따라서 액티비티나 프래그먼트에서는 LiveData 객체를 관찰하도록 설정만 하면 된다. 그리고 LiveData 객체가 준비되면 main 스레드의 액티비티나 프래그먼트에 통보되므로 이때 LiveData를 사용해서 데이터를 처리하면 된다.</p><blockquote><p>DAO에서 LiveData 반환하기</p></blockquote><p>원래의 반환 타입을 포함하는 LiveData 객체를 반환하도록 쿼리 함수들의 반환 타입을 변경한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CrimeDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">&quot;SELECT * FROM crime&quot;</span>)</span></span><br><span class="line"><span class="comment">//    fun getCrimes(): List&lt;Crime&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrimes</span><span class="params">()</span></span>: LiveData&lt;List&lt;Crime&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">&quot;SELECT * FROM crime WHERE id=(:id)&quot;</span>)</span></span><br><span class="line"><span class="comment">//    fun getCrime(id: UUID): Crime?</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrime</span><span class="params">(id: <span class="type">UUID</span>)</span></span>: LiveData&lt;Crime?&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CrimeDao를 구현한 자동 생성된 클래스에서 LiveData의 인스턴스를 반환하므로 Room은 백그라운드 스레드에서 쿼리를 실행한다. 그리고 쿼리가 완료되면 범죄 데이터가 main 스레드로 전달되고 LiveData 객체를 관찰하는 옵저버 <sup>observer</sup>에 통보된다. (본문에서는 CrimeListFragment가 옵저버)</p><p>다음으로 CrimeRepository의 쿼리 함수들이 LiveData를 반환하도록 변경한다.</p><blockquote><p>리포지터리에서 LiveData 반환하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeRepository</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(context: Context)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeDao = database.crimeDao()</span><br><span class="line"></span><br><span class="line"><span class="comment">//    fun getCrimes(): List&lt;Crime&gt; = crimeDao.getCrimes()</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrimes</span><span class="params">()</span></span>: LiveData&lt;List&lt;Crime&gt;&gt; = crimeDao.getCrimes()</span><br><span class="line"></span><br><span class="line"><span class="comment">//    fun getCrime(id: UUID): Crime? = crimeDao.getCrime(id)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrime</span><span class="params">(id: <span class="type">UUID</span>)</span></span>: LiveData&lt;Crime?&gt; = crimeDao.getCrime(id)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="livedata-관찰하기"><a class="markdownIt-Anchor" href="#livedata-관찰하기"></a> LiveData 관찰하기</h2><p>데이터베이스의 범죄 데이터를 범죄 리스트 화면에 보고자 <code>CrimeRepository.getCrimes()</code>로부터 반환되는 LiveData 객체를 관찰하도록 CrimeListFragment를 변경한다.</p><blockquote><p>속성에서 무슨 데이터를 저장하는지 알기 쉽게 하기 위해 이름 변경</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListViewModel</span>: <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeRepository = CrimeRepository.<span class="keyword">get</span>()</span><br><span class="line"><span class="comment">//    val crimes = crimeRepository.getCrimes()</span></span><br><span class="line">    <span class="keyword">val</span> crimeListLiveData = crimeRepository.getCrimes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LivaData는 데이터베이스로부터 반환되는 범죄 데이터들을 포함한다. 그리고 CrimeListFragment는 데이터베이스로부터 결과가 반환되는 것을 기다렸다가 LiveData가 반환되면 RecyclerView를 범죄 데이터로 채울 수 있다. 따라서 RecyclerView 어댑터를 비어 있는 List로 초기화해야 한다. 그리고 새로운 범죄 데이터가 LiveData로 반환될 때 RecyclerView 어댑터가 새로운 범죄 List를 갖도록 설정한다.</p><blockquote><p>LiveData 옵저버와 RecyclerView 어댑터 설정하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crimeRecyclerView: RecyclerView</span><br><span class="line"><span class="comment">//    private var adapter: CrimeAdapter? = null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> adapter: CrimeAdapter? = CrimeAdapter(emptyList())</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ...</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line">        ...</span><br><span class="line">        crimeRecyclerView.layoutManager = LinearLayoutManager(context)</span><br><span class="line">        crimeRecyclerView.adapter = adapter</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        crimeListViewModel.crimeListLiveData.observe(</span><br><span class="line">            viewLifecycleOwner,</span><br><span class="line">            Observer &#123; crimes -&gt;</span><br><span class="line">                crimes.let &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;Got crimes <span class="subst">$&#123;crimes.size&#125;</span>&quot;</span>)</span><br><span class="line">                    updateUI(crimes)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">(crimes: <span class="type">List</span>&lt;<span class="type">Crime</span>&gt;)</span></span> &#123;</span><br><span class="line">        adapter = CrimeAdapter(crimes)</span><br><span class="line">        crimeRecyclerView.adapter = adapter</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>LiveData.observe(LifecycleOwner, Observer)</code> 함수는 LiveData 인스턴스에 옵저버를 등록하기 위해 사용된다.</p><p><code>observe(...)</code> 함수의 첫 번째 인자로 지정된 viewLifeCycleOwner는 코틀린의 속성이며, <em>androidx.fragment.app.fragment</em>의 <code>getViewLifeCycleOwner()</code> 함수를 호출하는 것과 같다. viewLifeCycleOwner는 프래그먼트 뷰의 생명주기를 나타내는 LifecycleOwner 구현 객체를 반환한다. 따라서 여기서는 CrimeListFragment의 생명주기가 아닌 CrimeListFragment의 <strong>뷰의 생명주기</strong>에 맞춰 옵저버가 LiveData 인스턴스의 변경을 관찰하고 변경이 생기면 실행된다는 의미다.</p><p><code>observe(...)</code> 함수의 두 번째 인자는 Observer 인터페이스를 구현하는 객체, 즉 옵저버이며 여기서는 람다식으로 구현되었다. 옵저버는 LiveData의 새로운 데이터를 처리하며, 여기서는 LiveData의 범죄 데이터 리스트가 변경될 때마다 실행된다. 즉, LiveData의 범죄 List를 받아서 로그 메시지를 출력하고 <code>updateUI()</code> 함수를 호출한다.</p><p>만일 LiveData의 변경이 생길 때마다 옵저버가 실행되면 프래그먼트의 뷰가 유효한 상태가 아닐 때(예로, 화면에 보이지 않을 때)도 <code>updateUI(crimes)</code> 함수에서 프래그먼트의 뷰를 변경하려 할 것이고 결국 앱이 중단될 것이다.</p><p>그러므로 <code>LiveData.observe(...)</code> 함수의 첫 번째 인자로 LifecycleOwner 객체를 지정하는 것이다. 이렇게 하면 옵저버의 생명주기는 지정한 LifecycleOwner 객체가 나타내는 안드로이드 컴포넌트의 생명주기에 한정된다.</p><p>따라서 프래그먼트의 뷰가 유효한 상태일 때만 LiveData 객체가 옵저버에게 변경 <sub>(새로운 데이터를 받았음)</sub>을 통보해 UI를 변경할 수 있다. 이처럼 LiveData는 프래그먼트 뷰의 생명주기에 따라 반응해서 이런 컴포넌트를 <strong>생명주기-인식 컴포넌트 <sup>lifecycle-aware component</sup></strong> 라고 한다. 이 내용은 <a href="">링크 추가 예정</a>에서 자세히 다룬다.</p><p>LifecycleOwner 인터페이스를 구현하는 객체는 Lifecycle 객체를 포함한다. Lifecycle은 안드로이드 생명주기의 현재 상태를 유지 관리하는 객체다 <sub>(액티비티, 프래그먼트, 뷰, 심지어 앱 자체도 자신의 생명주기를 갖는다)</sub>. '생성’이나 '실행 재개’와 같은 생명주기 상태는 <code>Lifecycle.State</code> 열거형 <sup>enum</sup>에 정의되어 있으며, <code>Lifecycle.getCurrentState()</code>를 사용하면 Lifecycle 객체의 상태를 알 수 있다.</p><p>AndroidX의 <strong>Fragment</strong> 클래스는 <strong>LifecycleOwner</strong> 인터페이스를 구현하며, 프래그먼트 인스턴스의 생명주기 상태를 나타내는 <strong>Lifecycle</strong> 객체를 갖고 있다.</p><p>프래그먼트 뷰의 생명주기는 <strong>FragmentViewLifecycleOwner</strong>가 별개로 유지 및 관리한다. 각 프래그먼트는 자신의 뷰의 생명주기를 유지 및 관리하는 <strong>FragmentViewLifecycleOwner</strong> 인스턴스를 갖는다.</p><p>위의 코드에서는 <code>observe(...)</code> 함수의 첫 번째 인자로 viewLifecycleOwner를 전달하므로 옵저버의 실행이 프래그먼트 자신이 아닌 프래그먼트 뷰의 생명주기와 연동된다. 프래그먼트 뷰의 생명주기는 프래그먼트 인스턴스의 생명주기와 별개지만 프래그먼트의 생명주기를 반영한다. 그런데 프래그먼트의 <strong>유보 <sup>retaining</sup></strong> 로 이를 변경할 수 있다. 뷰의 생명주기와 프래그먼트 유보는 <a href="">링크 추가 예정</a>에서 더 자세히 다룬다.</p><p><code>Fragment.onViewCreated(...)</code>는 <code>Fragment.OnCreateView(...)</code>가 실행된 후 호출되므로 프래그먼트 뷰의 계층 구조에 맞춰 모든 뷰들이 형성된 후 실행된다. 따라서 <code>onCreated(...)</code>에서 LiveData 변경을 관찰하면 프래그먼트 뷰가 범죄 데이터를 보여줄 준비가 되었음을 확신할 수 있다. <code>observe()</code> 함수의 첫 번째 인자로 프래그먼트 자신이 아닌 viewLifecycleOwner를 전달하는 것도 이 때문이다. 여기서 원하는 것은 프래그먼트의 뷰가 좋은 상태일 때 LiveData로부터 범죄 리스트를 받는 것이다. 따라서 프래그먼트 뷰의 LifecycleOwner 객체를 사용하면 뷰가 화면에 보이지 않을 때는 LiveData 변경 데이터를 받지 않는다.</p><blockquote><p>데이터베이스의 범죄 데이터 보여주기</p></blockquote><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/119278756-4f688980-bc62-11eb-9810-ef978bfa885b.png'></p><h2 id="싱글톤"><a class="markdownIt-Anchor" href="#싱글톤"></a> 싱글톤</h2><p><a id = "a1"><a href="#f1">CrimeRepository에서 사용</a></a>된 것처럼 싱글톤 패턴은 안드로이드에서 매우 자주 사용된다. 그런데 싱글톤이 앱의 유지 보수를 어렵게 만들 수도 있다.</p><p>싱글톤은 프래그먼트나 액티비티보다 더 오래 존재한다. 또한, 싱글톤은 장치를 회전시키더라도 여전히 존재하며 앱의 액티비티와 프래그먼트를 오갈 때도 계속 남는다.</p><p>싱글톤을 사용하면 모델 객체를 소유하는 클래스를 편리하게 만들 수 있다. 범죄 데이터(Crime 객체)를 변경하는 많은 액티비티와 프래그먼트를 갖고 있는 더 복잡한 앱을 생각해보자. 한 컨트롤러가 범죄 데이터를 변경할 때 변경된 데이터를 어떻게 다른 컨트롤러에 전달할 수 있을까?</p><p>이때 만일 CrimeRepository가 범죄 데이터의 소유 클래스이면서 모든 변경 데이터가 CrimeRepository에 전달된다면 변경 데이터의 전달을 훨씬 쉽게 할 수 있다. 즉, 컨트롤러 사이를 이동하는 동안 특정 범죄의 식별자로 범죄 ID를 전달할 수 있으며, 각 컨트롤러는 이 ID를 사용해서 CrimeRepository로부터 해당 범죄 객체의 모든 데이터를 가져올 수 있다.</p><p>그러나 싱글톤은 몇 가지 단점을 가지고 있다.</p><ol><li><p>싱글톤은 컨트롤러보다 더 오랜 생애 동안 데이터를 저장하게 해주지만 <strong>싱글톤 자신도 생애가 있다.</strong> 즉, 앱이 종료된 후 어떤 시점에서 안드로이드 운영체제가 메모리를 회수하면 싱글톤은 자신의 인스턴스 변수와 함께 소멸된다. 따라서 싱글톤은 장기간에 걸쳐 데이터를 저장할 수 있는 방법은 아니며, 데이터를 디스크에 쓰거나 웹 서버로 전송하는 것만이 해결책이다.</p></li><li><p><strong>싱글톤은 코드의 단위 테스트를 어렵게 만들 수 있다.</strong> 안드로이드 개발자들은 주로 <strong>의존성 주입 <sup>dependency injection</sup></strong> 으로 이 문제를 해결한다. 이렇게 하면 객체들을 싱글톤을 공유할 수 있다.</p></li><li><p><strong>싱글톤은 잘못 사용될 수 있다.</strong> 편리하다고 아무 생각 없이 모든 것에 싱글톤을 사용하려고 할 수 있다. 왜냐하면 싱글톤은 코드 어디서나 사용할 수 있으며, 나중에 사용할 데이터가 어떤 것이든 싱글톤에 저장할 수 있기 때문이다. 그러나 '이 데이터는 어디에 사용되는가? 이 기능이 중요한 곳은 어디인가?'라는 매우 중요한 질문을 스스로에게 해야 한다.</p></li></ol><p>싱글톤은 잘 구성된 안드로이드 앱의 핵심 컴포넌트다. 단, 올바르게 사용될 때만 그렇다!</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Database/">Database</category>
      
      <category domain="http://june0122.github.io/tags/Room/">Room</category>
      
      
      <comments>http://june0122.github.io/2021/05/24/android-bnr-11/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] RecyclerView</title>
      <link>http://june0122.github.io/2021/05/23/android-bnr-09/</link>
      <guid>http://june0122.github.io/2021/05/23/android-bnr-09/</guid>
      <pubDate>Sat, 22 May 2021 20:29:02 GMT</pubDate>
      
      <description>ListView는 getView()를 호출하여 list를 뿌리게 되는데 화면 스크롤시 getView()함수가 계속해서 호출되게 되어 inflate를 통해서 view가 생성되며 동시에 findByViewId가 계속해서 호출되게 된다. 그러면 리스트를 생성하는데 있어 메모리의 비효율성이 발생하게 된다. 하지만 RecyclerView는 ViewHolder(findByViewId를 한 번만 호출) 패턴을 강제하여 사용자의 화면을 구성하고 있는데 &lt;b&gt;충분한 수의 ViewHolder가 생성되면 RecyclerView는 기존의 ViewHolder를 재활용해 시간과 메모리를 절약한다.&lt;/b&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>본문에서 예시로 설명할 앱 CriminalIntent의 객체 다이어그램</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119100962-713ff180-ba53-11eb-8175-b7cdc878cea9.jpeg'></p><h2 id="새로운-프래그먼트-및-viewmodel-추가하기"><a class="markdownIt-Anchor" href="#새로운-프래그먼트-및-viewmodel-추가하기"></a> 새로운 프래그먼트 및 ViewModel 추가하기</h2><blockquote><p>CrimeListViewModel</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListViewModel</span>: <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> crimes = mutableListOf&lt;Crime&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 모의 데이터 채우기</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> crime = Crime()</span><br><span class="line">            crime.title = <span class="string">&quot;Crime #<span class="variable">$i</span>&quot;</span></span><br><span class="line">            crime.isSolved = i % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">            crimes += crime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CrimeListFragment 생성 및 구현</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;CrimeListFragment&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span>: <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeListViewModel: CrimeListViewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(CrimeListViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Total crimes: <span class="subst">$&#123;crimeListViewModel.crimes.size&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newInstance</span><span class="params">()</span></span> : CrimeListFragment &#123;</span><br><span class="line">            <span class="keyword">return</span> CrimeListFragment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>동반 객체에서 정의된 <code>newInstance()</code> 함수에서는 CrimeListFragment 인스턴스를 생성하고 반환한다.</p><ul><li>이때 <code>newInstance()</code> 함수는 CrimeListFragment 클래스의 인스턴스를 생성하지 않고 호출할 수 있다.  자바의 static 메서드와 유사</li><li>따라서 액티비티에서 CrimeListFragment 인스턴스를 생성하려면 <code>newInstance()</code> 함수를 호출하면 된다.</li></ul><h3 id="프래그먼트에-사용되는-viewmodel-생명주기"><a class="markdownIt-Anchor" href="#프래그먼트에-사용되는-viewmodel-생명주기"></a> 프래그먼트에 사용되는 ViewModel 생명주기</h3><p><a href="https://june0122.github.io/2021/05/13/android-bnr-04/">[Android] ViewModel과 SIS</a>에서 액티비티와 함께 사용되는 ViewModel의 생명주기를 알아보았다. 그런데 ViewModel이 프래그먼트와 같이 사용되면 생명주기가 약간 달라진다. 이때도 두 개의 상태 <sub>('생성됨’또는 ‘소멸되어 존재하지 않음’)</sub>만 갖는 것은 동일하나, 액티비티 대신 프래그먼트의 생명주기와 결합된다.</p><p>다시 말해, 프래그먼트의 뷰가 화면에 나타나 있는 한 ViewModel은 활성화된 상태를 유지하며, 장치 회전 시에도 유지되어 새로 생성된 프래그먼트 인스턴스가 이어서 사용할 수 있다.</p><p>ViewModel은 프래그먼트가 소멸할 때 같이 소멸한다. 예를 들어, 사용자가 백 버튼을 누르거나 호스팅 액티비티가 프래그먼트를 다른 것으로 교체할 때 해당 액티비티가 화면에 나타나 있더라도 프래그먼트 및 이것과 연관된 ViewModel은 더 이상 필요 없으므로 소멸한다.</p><p>한 가지 특별한 경우는 <em>프래그먼트 트랜잭션을 백 스택에 추가</em>할 때다. 만일 액티비티가 현재 프래그먼트를 다른 것으로 교체할 때 트랜잭션이 백 스택에 추가된다면 해당 프래그먼트 인스턴스와 이것의 ViewModel은 소멸되지 않는다. 따라서 사용자가 백 버튼을 누르면 프래그먼트 트랜잭션이 역으로 수행되어 교체되기 전의 프래그먼트 인스턴스가 다시 화면에 나타나고 ViewModel의 모든 데이터는 보존된다.</p><blockquote><p>프래그먼트 트랜잭션을 사용해서 CrimeListFragment 추가하기</p></blockquote><p>CrimeFragment 대신 CrimeListFragment의 인스턴스를 호스팅하도록 변경</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> currentFragment =</span><br><span class="line">            supportFragmentManager.findFragmentById(R.id.fragment_container)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentFragment == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//          val fragment = CrimeFragment()</span></span><br><span class="line">            <span class="keyword">val</span> fragment = CrimeListFragment.newInstance()</span><br><span class="line">            supportFragmentManager</span><br><span class="line">                .beginTransaction()</span><br><span class="line">                .add(R.id.fragment_container, fragment)</span><br><span class="line">                .commit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>현재는 MainActivity가 항상 CrimeListFragment를 보여주도록 하드코딩되어 있지만, 후에는 사용자가 앱 화면을 이동하는 것에 따라 MainActivity가 CrimeListFragment와 CrimeFragment를 상호 교체하도록 변경할 것이다.</p><h2 id="recyclerview-추가하기"><a class="markdownIt-Anchor" href="#recyclerview-추가하기"></a> RecyclerView 추가하기</h2><p>RecyclerView 클래스는 다른 Jetpack 라이브러리에 있어서 사용하려면 우선 RecyclerView 라이브러리 의존성을 app/build.gradle 파일에 추가해야 한다.</p><blockquote><p>RecyclerView 의존성 추가하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation <span class="string">&#x27;androidx.lifecycle:lifecycle-extensions:2.2.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;androidx.recyclerview:recyclerview:1.2.0&#x27;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RecyclerView를 레이아웃 파일에 추가하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;androidx.recyclerview.widget.RecyclerView xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:id=<span class="string">&quot;@+id/crime_recycler_view&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>CrimeListFragment의 뷰가 준비되었으니 이 뷰를 프래그먼트와 연결한다.</p><blockquote><p>CrimeListFragment의 뷰 설정하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span>: <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crimeRecyclerView: RecyclerView</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeListViewModel: CrimeListViewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(CrimeListViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Total crimes: <span class="subst">$&#123;crimeListViewModel.crimes.size&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">val</span> view = inflater.inflate(R.layout.fragment_crime_list, container, <span class="literal">false</span>)</span><br><span class="line">        </span><br><span class="line">        crimeRecyclerView = view.findViewById(R.id.crime_recycler_view) <span class="keyword">as</span> RecyclerView</span><br><span class="line">        crimeRecyclerView.layoutManager = LinearLayoutManager(context)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RecyclerView가 생성된 후에는 곧바로 LayoutManager를 설정해야 하며, 여기서는 LinearLayoutManager를 설정했다. 만일 설정하지 않으면 RecyclerView가 작동하지 않는다.</p><p>RecyclerView는 항목들을 화면에 위치시키는 일을 직접하지 않고 LayoutManager에게 위임한다. 그러면 LayoutManager는 모든 항목들의 화면 위치를 처리하고 스크롤 동작도 정의한다. 따라서 LayoutManager가 설정되지 않으면 RecyclerView의 작동이 바로 중단된다.</p><p>LayoutManager는 안드로이드 프레임워크에 내장된 것 중 하나를 선택할 수 있으며, 서드파티 라이브러리의 것도 사용할 수 있다. 여기서는 LinearLayoutManager를 사용했는데, 이것은 리스트의 항목들을 수직 방향으로 배치한다. 이 책 후반부에서는 GridLayoutManager를 사용해서 격자 형태로 항목들을 배치할 것이다.</p><h2 id="항목-뷰-레이아웃-생성하기"><a class="markdownIt-Anchor" href="#항목-뷰-레이아웃-생성하기"></a> 항목 뷰 레이아웃 생성하기</h2><p>RecyclerView는 ViewGroup의 서브 클래스이며, <strong>항목 뷰(item view)</strong> 라고 하는 자식 View 객체들의 리스트를 보여준다. 각 itemView는 RecyclerView의 행으로 나타나며 데이터 저장소에서 가져온 하나의 객체를 나타낸다. 객체가 갖는 데이터 중에서 어떤 것들을 화면에 보여주는가에 따라 항목 View가 복잡해질 수도 있고 간단할 수도 있다.</p><blockquote><p>자식 뷰를 갖는 RecyclerView</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119100956-70a75b00-ba53-11eb-9c88-ef18ada6bb37.jpeg'></p><p>한 행으로 보이는 RecyclerView의 각 항목은 자신의 뷰 계층 구조를 가질 수 있다. 여기서는 각 항목의 View 객체가 두 개의 TextView를 포함하는 LinearLayout이 된다.</p><blockquote><p>리스트 항목 레이아웃 변경하기 (layout/list_item_crime.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;8dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/crime_title&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Crime Title&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/crime_date&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Crime Date&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="viewholder-구현하기"><a class="markdownIt-Anchor" href="#viewholder-구현하기"></a> ViewHolder 구현하기</h2><p>RecyclerView는 항목 View가 ViewHolder 인스턴스에 포함되어 있다고 간주한다. ViewHolder는 항목 View의 참조를 갖는다.</p><p>RecyclerView.ViewHolder의 서브 클래스인 CrimeHolder를 CrimeListFragment의 내부 클래스로 정의하자.</p><blockquote><p>초기 버전의 CrimeHolder (CrimeListFragment)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span>: <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ViewHolder와 이것의 itemView 속성</p></blockquote><p align = 'center'><img width = '150' src = 'https://user-images.githubusercontent.com/39554623/119100959-713ff180-ba53-11eb-8aef-6381a025e70d.jpeg'></p><p>CrimeHolder의 생성자는 항목 View를 인자로 받으며, CrimeHolder 인스턴스가 생성될 대 이 View는 슈퍼 클래스인 RecyclerView.ViewHolder의 생성자 인자로 전달된다. 그리고 RecyclerView.ViewHolder 슈퍼 클래스로부터 상속받은 itemView 속성이 생성자로 전달된 항목 View의 참조를 갖는다.</p><p>RecyclerView는 자체적으로 View를 생성하지 않으며, 항상 항목 View를 참조하는 ViewHolder를 생성한다.</p><blockquote><h4 id="b-id-f1viewholderb"><a class="markdownIt-Anchor" href="#b-id-f1viewholderb"></a> <b id = "f1">ViewHolder</b></h4></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119100937-6e450100-ba53-11eb-9320-522a7522d30d.jpeg'></p><p>itemView가 참조하는 항목 View가 간단할 때는 ViewHolder가 할 일이 적다. 그러나 복잡해지면 ViewHolder가 항목 View의 서로 다른 부분(자식 View)을 Crime 객체에 더 쉽고 효율적으로 연결해준다.</p><p>ViewHolder의 인스턴스가 처음 생성될 때 항목 View에 포함된 TextView의 참조를 알아내어 속성에 저장하도록 CrimeHolder를 변경한다.</p><blockquote><p>항목 View의 TextView 참조를 속성에 저장하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">    <span class="keyword">val</span> titleTextView: TextView = itemView.findViewById(R.id.crime_title)</span><br><span class="line">    <span class="keyword">val</span> dateTextView: TextView = itemView.findViewById(R.id.crime_date)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/119100951-700ec480-ba53-11eb-80e0-e6056c6293d2.jpeg'></p><p>여기서 CrimeHolder의 기본 생성자에 정의된 인자 겸 속성인 <code>view</code>는 <code>itemView</code> 속성과 동일한 항목 View의 참조 값을 갖는다. 따라서 새로 추가한 코드에서 <code>itemView</code> 대신 <code>view</code>를 사용해도 된다.</p><p>이제는 변경된 CrimeHolder가 항목 View의 TextView들에 대한 참조를 보존할 수 있으므로 이 TextView들의 값을 쉽게 보여줄 수 있게 되었다.</p><p>그런데 CrimeHolder의 인스턴스는 누가 또는 어디서 생성하는 것일까?</p><h2 id="어댑터를-구현해-recyclerview에-데이터-채우기"><a class="markdownIt-Anchor" href="#어댑터를-구현해-recyclerview에-데이터-채우기"></a> 어댑터를 구현해 RecyclerView에 데이터 채우기</h2><p><a id = "a1"><a href="#f1">ViewHolder 이미지</a></a>에 간단하게 나타나 있지만, RecyclerView는 자신이 ViewHolder를 생성하지 않는다. 대신에 이 일을 <strong>어댑터(adapter)</strong> 에 요청한다. 어댑터는 컨트롤러 객체로, RecyclerView와 RecyclerView가 보여줄 데이터 사이에 위치한다.</p><p><strong>Adapter</strong>는 다음의 일을 처리한다.</p><ul><li>필요한 ViewHolder 인스턴스들을 생성한다.</li><li>모델 계층의 데이터를 ViewHolder들과 바인딩한다.</li></ul><p>그리고 <strong>RecyclerView</strong>는 다음의 일을 처리한다.</p><ul><li>새로운 ViewHolder 인스턴스의 생성을 어댑터에게 요청한다.</li><li>지정된 위치의 데이터 항목에 ViewHolder를 바인딩하도록 어댑터에게 요청한다.</li></ul><p>이제는 어댑터를 생성할 때가 되었다. 아래의 코드와 같이 CrimeAdapter라는 이름의 내부 클래스를 CrimeListFragment에 추가하고 RecyclerView.Adapter의 서브 클래스로 지정한다. 그리고 Crime 객체가 저장된 List를 인자로 받아 crimes 속성에 저장하는 기본 생성자도 추가한다.</p><blockquote><p>CrimeAdapter 생성하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span>: <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeAdapter</span></span>(<span class="keyword">var</span> crimes: List&lt;Crime&gt;) : RecyclerView.Adapter&lt;CrimeHolder&gt;() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: CrimeHolder &#123;</span><br><span class="line">            <span class="keyword">val</span> view = layoutInflater.inflate(R.layout.list_item_crime, parent, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> CrimeHolder(view)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = crimes.size</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">CrimeHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> crime = crimes[position]</span><br><span class="line">            holder.apply &#123; </span><br><span class="line">                titleTextView.text = crime.title</span><br><span class="line">                dateTextView.text = crime.date.toString()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Adapter.onCreateViewHolder(...)</code>는 보여줄 뷰 <sub>(여기서는 list_item_view.xml)</sub>를 인플레이트한 후 이 뷰를 처리하는 ViewHolder <sub>(여기서는 CrimeHolder)</sub> 인스턴스를 생성하고 반환한다. <code>onCreateViewHolder(...)</code>의 매개변수는 <strong>서로 다른 타입의 뷰를 보여줄 때 필요</strong>한데, 아래 <a id = "a2"><a href="#f2">RecyclerView의 ViewType</a></a>에서 볼 수 있다.</p><p><code>Adapter.onBindViewHolder(holder: CrimeHolder, position: Int)</code>는 인자로 전달된 위치에 있는 Crime 객체의 범좌 제목과 발생일자를 CrimeHolder 인스턴스가 참조하는 TextView의 text 속성에 지정한다. 여기서는 Crime 객체가 List에 저장되어 있으므로 인자로 전달된 위치가 List 인덱스로 사용된다.</p><p>데이터가 저장된 데이터 셋에 몇 개의 데이터가 있는지 RecyclerView가 알아야 할 때 <code>Adapter.getItemCount()</code>를 호출해 어댑터에게 요청한다. 여기서는 <code>getItemCount()</code>가 List에 저장된 Crime 객체의 수를 반환한다.</p><p>화면에 보여줄 Crime 객체 또는 이 객체가 저장된 List를 RecyclerView는 모르며, CrimeAdapter가 안다.</p><blockquote><p>CrimeAdapter는 RecyclerView와 List&lt;Crime&gt; 사이에 위치</p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/119100927-6b4a1080-ba53-11eb-8a4f-a3201333d84e.jpeg'></p><p>RecyclerView는 화면에 보여줄 뷰 객체가 필요하면 자신과 연관된 Adapter에게 요청한다.</p><blockquote><p>RecyclerView와 CrimeAdapter 간의 소통 과정</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119100930-6d13d400-ba53-11eb-9f47-f066719fea09.jpeg'></p><p>RecyclerView는 CrimeAdapter의 <code>onCreateViewHolder(ViewGroup, Int)</code> 함수를 호출해 CrimeHolder 인스턴스를 생성한다. 이때 화면에 보여줄 항목 View를 생성자 인자로 전달한다. 그러나 CrimeAdapter가 생성해 RecyclerView에게 반환하는 CrimeHolder <sub>(그리고 이것의 itemView 속성)</sub>는 아직 데이터가 바인딩되지 않았다.</p><p>그런 다음에 RecyclerView는 CrimeAdapter의 <code>onBindViewHolder(ViewHolder, Int)</code> 함수를 호출한다. 이때 CrimeHolder의 데이터 셋 내부의 Crime 객체 위치를 인자로 전달한다. 그리고 CrimeAdapter는 이 함수에서 해당 위치의 모델 데이터인 Crime 객체를 찾아 이것을 CrimeHolder의 항목 View와 <strong>바인딩(binding)</strong> 즉, Crime 객체의 데이터를 항목 View에 채운다.</p><h2 id="recyclerview의-어댑터-설정하기"><a class="markdownIt-Anchor" href="#recyclerview의-어댑터-설정하기"></a> RecyclerView의 어댑터 설정하기</h2><p>이제는 어댑터가 준비되었으니 RecyclerView에 연결해야 한다. CrimeListFragment의 UI를 설정하는 <code>updateUI</code> 함수를 구현할 것인데, 지금은 이 함수에서 CrimeAdapter를 생성해 RecyclerView에 설정한다.</p><blockquote><p>어댑터 설정하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span>: <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crimeRecyclerView: RecyclerView</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> adapter: CrimeAdapter? = <span class="literal">null</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">val</span> view = inflater.inflate(R.layout.fragment_crime_list, container, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">        crimeRecyclerView = view.findViewById(R.id.crime_recycler_view) <span class="keyword">as</span> RecyclerView</span><br><span class="line">        crimeRecyclerView.layoutManager = LinearLayoutManager(context)</span><br><span class="line"></span><br><span class="line">        updateUI()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> crimes = crimeListViewModel.crimes</span><br><span class="line">        adapter = CrimeAdapter(crimes)</span><br><span class="line">        crimeRecyclerView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>맨 끝에 추가한 <code>crimeRecyclerView.adapter</code>에서 adapter는 RecyclerView의 속성이다. 코틀린에서는 속성의 값을 보존하는 필드를 내부적으로 유지하는데, 이것을 후원 필드 <sup>backing field</sup>라고 한다. 또한, 필드의 값을 반환하는 게터와 값을 변경하는 세터가 자동 생성되고 자동 호출된다.(자바와는 다르다) 즉, 속성의 값을 참조할 때는 게터가 자동으로 호출되며, 이 코드처럼 속성의 값을 지정/변경할 때는 세터가 자동 호출된다. 그러므로 게터 <sub><code>getAdapter()</code></sub>나 세터 <sub><code>setAdapter(RecyclerView.Adapter)</code></sub>를 호출할 필요가 없다. <code>crimeRecyclerView.adapter = adapter</code> 대신 <code>crimeRecyclerView.setAdapter(adapter)</code>로 해도 결과는 같다. 두 가지 모두 adapter 속성의 세터를 호출하는 것이기 때문이다. 그러나 코틀린 속성의 특성을 잘 활용하는 코드는 <code>crimeRecyclerView.adapter = adapter</code>이다.</p><blockquote><p>더미 데이터로 채워진 RecyclerView</p></blockquote><p><code>onBindViewHolder(...)</code> 함수가 최소한의 꼭 필요한 일만 수행하도록 작고 효율적으로 만들었기 때문에 상하 스크롤 시 매우 부드럽게 움직일 것이다.</p><p align = 'center'><img width = '200' src = 'https://user-images.githubusercontent.com/39554623/119213129-f11f9780-baf7-11eb-8815-2f2875105d36.jpeg'></p><h2 id="뷰의-재활용-recyclerview"><a class="markdownIt-Anchor" href="#뷰의-재활용-recyclerview"></a> 뷰의 재활용: RecyclerView</h2><p>위의 이미지에서는 한 화면에 14개의 View를 보여준다. 그리고 화면을 스크롤하면 100개의 View를 볼 수 있다. 그렇다면 메모리에 100개의 View를 모두 갖고 있는 것일까? 그렇지 않다. 이게 다 RecyclerView 덕분이다.</p><p>List에 저장된 모든 Crime 객체에 대해 하나씩 항목 View를 생성한다면 앱이 제대로 실행되지 않는다. List가 100개보다 훨씬 많은 데이터를 가질 수 있지만, 화면에서는 하나의 Crime이 하나의 항목 View만 필요하므로 한꺼번에 100개의 항목 View를 미리 생성하고 기다릴 필요가 없다. 그러므로 필요할 때만 항목 View 객체를 생성하는 것이 좋다.</p><p>RecyclerView가 바로 이런 일을 수행한다. 100개의 항목 View를 생성하는 대신에 한 화면을 채우는데 충분한 개수만 생성해, <strong>화면이 스크롤되면서 항목 View가 화면을 벗어날 때 RecyclerView는 해당 항목 View를 버리지 않고 재활용</strong>한다. 이름 그대로 RecyclerView는 끊임없이 항목 View를 재활용한다.</p><p>이런 이유로 <code>onCreateViewHolder(ViewGroup, Int)</code> 함수는 <code>onBindViewHolder(ViewHolder, Int)</code>보다 덜 호출된다. <strong>일단 충분한 수의 ViewHolder가 생성되면 RecyclerView는 <code>onCreateViewHolder(...)</code>의 호출을 중단하고 기존의 ViewHolder를 재활용해 <code>onBindViewHolder(ViewHolder, Int)</code>에 전달함으로써 시간과 메모리를 절약한다.</strong></p><h2 id="리스트-항목의-바인딩-개선하기"><a class="markdownIt-Anchor" href="#리스트-항목의-바인딩-개선하기"></a> 리스트 항목의 바인딩 개선하기</h2><p>현재는 CrimeAdapter가 <code>Adapter.onBindViewHolder(...)</code> 함수에서 Crime 객체의 데이터를 CrimeHolder가 참조하는 TextView로 직접 바인딩한다. 이렇게 해도 앱은 잘 실행된다. 그렇지만 CrimeHolder와 CrimeAdapter 간의 기능 분담을 명쾌하게 하는 것이 좋다. CrimeAdapter는 CrimeHolder가 내부적으로 하는 일을 모르는 것이 좋기 때문이다.</p><p>데이터 바인딩 작업을 수행하는 모든 코드는 CrimeHolder 내부에 두는 것이 좋다. 이렇게 하려면 우선 바인딩되는 Crime 객체의 참조를 보존하는 속성을 추가하면 된다. 그리고 내친 김에 기존의 TextView 참조 속성들을 <code>private</code>으로 변경하고 <code>bind(Crime)</code> 함수를 CrimeHolder에 추가한다. 이 함수에서는 바인딩되는 Crime 객체의 참조를 새로 추가하는 속성에 보존하며, TextView의 text 속성값을 현재 참조되는 Crime 객체의 속성값으로 설정한다.</p><blockquote><p><code>bind(Crime)</code> 함수 작성하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crime: Crime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> titleTextView: TextView = itemView.findViewById(R.id.crime_title)</span><br><span class="line">    <span class="keyword">val</span> dateTextView: TextView = itemView.findViewById(R.id.crime_date)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(crime: <span class="type">Crime</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.crime = crime</span><br><span class="line">        titleTextView.text = <span class="keyword">this</span>.crime.title</span><br><span class="line">        dateTextView.text = <span class="keyword">this</span>.crime.date.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제는 바인딩할 Crime 객체가 전달되면 CrimeHolder가 이 객체의 데이터를 반영해 제목 TextView와 발생일자 TextView의 text 속성값을 변경한다.</p><p>다음으로 RecyclerView가 요청할 때마다 <code>bind(Crime)</code> 함수를 호출하도록 변경해서 지정된 CrimeHolder를 특정 Crime 객체와 바인딩하자.</p><blockquote><p><code>bind(Crime)</code> 함수 호출하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeAdapter</span></span>(<span class="keyword">var</span> crimes: List&lt;Crime&gt;) : RecyclerView.Adapter&lt;CrimeHolder&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: CrimeHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> view = layoutInflater.inflate(R.layout.list_item_crime, parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> CrimeHolder(view)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = crimes.size</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">CrimeHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> crime = crimes[position]</span><br><span class="line"></span><br><span class="line"><span class="comment">//        holder.apply &#123;</span></span><br><span class="line"><span class="comment">//            titleTextView.text = crime.title</span></span><br><span class="line"><span class="comment">//            dateTextView.text = crime.date.toString()</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        holder.bind(crime)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="리스트-항목-선택에-응답하기"><a class="markdownIt-Anchor" href="#리스트-항목-선택에-응답하기"></a> 리스트 항목 선택에 응답하기</h2><p>사용자가 RecyclerView의 리스트 항목을 누르면 앱이 응답하도록 간단하게 Toast 메시지를 보여주자.</p><p>RecyclerView는 강력하고 기능도 좋지만 실질적인 책임은 거의 없다. 여기서도 그렇다. 터치 이벤트를 처리하는 것은 우리의 몫이다.</p><p>따라서 <strong>OnClickListener</strong>를 설정해 터치 이벤트를 처리하면 된다. 이때 각 항목 View는 자신과 연관된 CrimeHolder를 갖고 있으므로 CrimeHolder에서 항목 View의 <strong>OnClickListener</strong>를 구현하면 된다.</p><p>리스트 항목의 모든 View에 클릭 이벤트를 처리하도록 CrimeHolder를 변경한다.</p><blockquote><p>CrimeHolder에서 클릭 이벤트 처리하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view), View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crime: Crime</span><br><span class="line">    <span class="keyword">val</span> titleTextView: TextView = itemView.findViewById(R.id.crime_title)</span><br><span class="line">    <span class="keyword">val</span> dateTextView: TextView = itemView.findViewById(R.id.crime_date)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        itemView.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(crime: <span class="type">Crime</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.crime = crime</span><br><span class="line">        titleTextView.text = <span class="keyword">this</span>.crime.title</span><br><span class="line">        dateTextView.text = <span class="keyword">this</span>.crime.date.toString()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;<span class="subst">$&#123;crime.title&#125;</span> pressed!&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CrimeHolder 자신이 <strong>OnClickListener</strong> 인터페이스를 구현하고 있다. 그리고 리스트 행의 항목 View <sub>(itemView 속성이 참조함)</sub>에 발생하는 클릭 이벤트를 CrimeHolder가 받도록 설정되어 있다.</p><h2 id="listview와-gridview"><a class="markdownIt-Anchor" href="#listview와-gridview"></a> ListView와 GridView</h2><p>안드로이드 운영체제에는 ListView, GridView, Adapter 클래스가 포함되어 있다. 안드로이드 5.0까지는 이 클래스들을 사용해서 리스트나 그리드 형태로 항목들을 생성했다.</p><p>이 컴포넌트들의 API는 RecyclerView의 것과 매우 유사하다. ListView나 GridView 클래스는 리스트의 항목들을 스크롤하지만 각 항목에 관해서는 잘 알지 못한다. 그리고 리스트의 각 항목 View를 생성하는 일은 Adapter가 수행하지만, ListView나 GridView에서는 ViewHolder 패턴을 사용하도록 강제하지 않는다 <sub>(하지만 사용하는 것이 좋다)</sub>.</p><p>이런 기존 컴포넌트들은 RecyclerView로 대체되었다. ListView나 GridView의 작동 방식을 변경하려면 복잡하기 때문이다.</p><p>예를 들어, 수평 방향으로 스크롤 가능한 ListView를 생성하는 기능은 ListView API에 포함되어 있지 않아 많은 작업이 필요하다. 커스텀 레이아웃을 갖고 스크롤 가능한 RecyclerView를 생성하는 것도 여전히 많은 작업이 필요하다. 그러나 RecyclerView는 기능 확장이 되도록 설계되었으므로 나쁘지 않다.</p><p>RecyclerView의 또 다른 주요 기능은 리스트 항목의 애니메이션이다. ListView나 GridView의 경우 항목을 추가하거나 삭제할 때 생동감 있게 보이도록 하려면 구현이 복잡하고 에러가 생기기 쉽ㄴ다. 그러나 RecyclerView는 몇 가지 애니메이션 기능이 내장되어 있어서 훨씬 쉬우며, 이런 애니메이션 기능을 쉽게 커스터마이징 할 수 있다.</p><h2 id="b-id-f2recyclerview의-viewtypeb"><a class="markdownIt-Anchor" href="#b-id-f2recyclerview의-viewtypeb"></a> <b id = "f2">RecyclerView의 ViewType</b>  <a href="#a2"> ↩</a></h2><p>RecyclerView에 평범한 범죄를 보여주는 행과 심각한 범죄를 보여주는 행, 두 가지 타입 행을 생성한다.</p><p align = 'center'><img width = '150' src = 'https://user-images.githubusercontent.com/39554623/119218988-027b9a80-bb1e-11eb-8e9e-042f8542e9eb.jpeg'></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Crime</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: UUID = UUID.randomUUID(),</span><br><span class="line">    <span class="keyword">var</span> title: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">var</span> date: Date = Date(),</span><br><span class="line">    <span class="keyword">var</span> isSolved: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">var</span> requirePolice: <span class="built_in">Int</span> = VIEW_TYPE_NORMAL</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> VIEW_TYPE_NORMAL = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> VIEW_TYPE_SERIOUS = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crimeRecyclerView: RecyclerView</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> adapter: CrimeAdapter? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeListViewModel: CrimeListViewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(CrimeListViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Total crimes: <span class="subst">$&#123;crimeListViewModel.crimes.size&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">val</span> view = inflater.inflate(R.layout.fragment_crime_list, container, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">        crimeRecyclerView = view.findViewById(R.id.crime_recycler_view) <span class="keyword">as</span> RecyclerView</span><br><span class="line">        crimeRecyclerView.layoutManager = LinearLayoutManager(context)</span><br><span class="line"></span><br><span class="line">        updateUI()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> crimes = crimeListViewModel.crimes</span><br><span class="line">        adapter = CrimeAdapter(crimes)</span><br><span class="line">        crimeRecyclerView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view), View.OnClickListener &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crime: Crime</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> titleTextView: TextView = itemView.findViewById(R.id.crime_title)</span><br><span class="line">        <span class="keyword">val</span> dateTextView: TextView = itemView.findViewById(R.id.crime_date)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            itemView.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(crime: <span class="type">Crime</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.crime = crime</span><br><span class="line">            titleTextView.text = <span class="keyword">this</span>.crime.title</span><br><span class="line">            dateTextView.text = <span class="keyword">this</span>.crime.date.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">            Toast.makeText(context, <span class="string">&quot;<span class="subst">$&#123;crime.title&#125;</span> pressed!&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SeriousCrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view), View.OnClickListener &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crime: Crime</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> titleTextView: TextView = itemView.findViewById(R.id.crime_title)</span><br><span class="line">        <span class="keyword">val</span> dateTextView: TextView = itemView.findViewById(R.id.crime_date)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            itemView.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(crime: <span class="type">Crime</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.crime = crime</span><br><span class="line">            titleTextView.text = <span class="keyword">this</span>.crime.title</span><br><span class="line">            dateTextView.text = <span class="keyword">this</span>.crime.date.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">            Toast.makeText(context, <span class="string">&quot;<span class="subst">$&#123;crime.title&#125;</span> pressed!&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeAdapter</span></span>(<span class="keyword">var</span> crimes: List&lt;Crime&gt;) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemViewType</span><span class="params">(position: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> crime = crimes[position]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">when</span> (crime.requirePolice) &#123;</span><br><span class="line">                <span class="number">0</span> -&gt; Crime.VIEW_TYPE_NORMAL</span><br><span class="line">                <span class="number">1</span> -&gt; Crime.VIEW_TYPE_SERIOUS</span><br><span class="line">                <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Unknown View Type Error&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: RecyclerView.ViewHolder &#123;</span><br><span class="line">            <span class="keyword">val</span> view: View?</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">when</span>(viewType) &#123;</span><br><span class="line">                Crime.VIEW_TYPE_NORMAL -&gt; &#123;</span><br><span class="line">                    view = layoutInflater.inflate(R.layout.list_item_crime, parent, <span class="literal">false</span>)</span><br><span class="line">                    CrimeHolder(view)</span><br><span class="line">                &#125;</span><br><span class="line">                Crime.VIEW_TYPE_SERIOUS -&gt; &#123;</span><br><span class="line">                    view = layoutInflater.inflate(R.layout.list_item_serious_crime, parent, <span class="literal">false</span>)</span><br><span class="line">                    SeriousCrimeHolder(view)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Unknown View Type Error&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = crimes.size</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> crime = crimes[position]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">when</span> (crime.requirePolice) &#123;</span><br><span class="line">                Crime.VIEW_TYPE_NORMAL -&gt; &#123;</span><br><span class="line">                    (holder <span class="keyword">as</span> CrimeHolder).bind(crime)</span><br><span class="line">                &#125;</span><br><span class="line">                Crime.VIEW_TYPE_SERIOUS -&gt; &#123;</span><br><span class="line">                    (holder <span class="keyword">as</span> SeriousCrimeHolder).bind(crime)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newInstance</span><span class="params">()</span></span>: CrimeListFragment &#123;</span><br><span class="line">            <span class="keyword">return</span> CrimeListFragment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="참고하면-좋은-recyclerview-관련-글들"><a class="markdownIt-Anchor" href="#참고하면-좋은-recyclerview-관련-글들"></a> 참고하면 좋은 RecyclerView 관련 글들</h2><ul><li><a href="https://developer.android.com/guide/topics/ui/layout/recyclerview?hl=ko">https://developer.android.com/guide/topics/ui/layout/recyclerview?hl=ko</a></li><li><a href="https://medium.com/hongbeomi-dev/%EB%B2%88%EC%97%AD-recyclerview%EC%9D%98-%EB%82%B4%EB%B6%80-%EB%8F%99%EC%9E%91-941a2827fa5a">https://medium.com/hongbeomi-dev/번역-recyclerview의-내부-동작-941a2827fa5a</a></li><li><a href="https://woovictory.github.io/2019/01/03/Android-Diff-of-ListView-and-RecyclerView/">https://woovictory.github.io/2019/01/03/Android-Diff-of-ListView-and-RecyclerView/</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/RecyclerView/">RecyclerView</category>
      
      
      <comments>http://june0122.github.io/2021/05/23/android-bnr-09/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Codility] CyclicRotation</title>
      <link>http://june0122.github.io/2021/05/21/codility-cyclic-rotation/</link>
      <guid>http://june0122.github.io/2021/05/21/codility-cyclic-rotation/</guid>
      <pubDate>Fri, 21 May 2021 07:03:11 GMT</pubDate>
      
      <description>Lesson 2 - Arrays : CyclicRotation</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="lesson-2-arrays-cyclicrotation"><a class="markdownIt-Anchor" href="#lesson-2-arrays-cyclicrotation"></a> Lesson 2 - Arrays : <a href="https://app.codility.com/programmers/lessons/2-arrays/cyclic_rotation/">CyclicRotation</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>배열 인덱스 활용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(A: <span class="type">IntArray</span>, K: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">val</span> rotatedArray = IntArray(A.size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> A.indices) &#123;</span><br><span class="line">        <span class="keyword">val</span> index = (i + K) % A.size</span><br><span class="line">        rotatedArray[index] = A[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rotatedArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Dequeue <sup>덱</sup> 활용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(A: <span class="type">IntArray</span>, K: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">val</span> dequeue = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> rotation = <span class="keyword">when</span>(A.size) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; K % A.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dequeue.addAll(A.toList())</span><br><span class="line">    repeat(rotation) &#123; dequeue.addFirst(dequeue.removeLast()) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dequeue.toIntArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IntArray A의 크기가 0인 경우 <code>java.lang.ArithmeticException: / by zero</code>이 발생하므로 A가 0인 경우 회전하지 않도록 값을 0으로 설정해줘야 한다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Codility/">Codility</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Codility/">Codility</category>
      
      
      <comments>http://june0122.github.io/2021/05/21/codility-cyclic-rotation/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Fragment와 FragmentManager</title>
      <link>http://june0122.github.io/2021/05/21/android-bnr-08/</link>
      <guid>http://june0122.github.io/2021/05/21/android-bnr-08/</guid>
      <pubDate>Fri, 21 May 2021 06:58:59 GMT</pubDate>
      
      <description>하나 이상의 &lt;b&gt;프래그먼트(fragment)&lt;/b&gt; 로 앱의 UI를 관리하면 유연성이 좋아진다. 프래그먼트는 액티비티의 작업 수행을 대행할 수 있는 컨트롤러 객체다. 여기서 작업이란 UI 관리를 말하며, UI는 화면 전체 또는 일부분이 될 수 있다. 그런데 액티비티는 이런 유연성을 제공하도록 설계되지 않았다. 액티비티의 뷰들은 런타임 시에 변경되며, 이 뷰들을 제어하는 코드는 액티비티 내부에 있어야 한다. 따라서 &lt;b&gt;액티비티는 사용하는 특정 화면과 강하게 결합&lt;/b&gt;되어 있다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="ui-유연성의-필요"><a class="markdownIt-Anchor" href="#ui-유연성의-필요"></a> UI 유연성의 필요</h2><p>UI 유연성이라하면 사용자나 장치가 요구하는 것에 따라 런타임 시에 액티비티의 뷰를 구성하거나 변경할 수 있는 능력이다. 그런데 액티비티는 이런 유연성을 제공하도록 설계되지 않았다. 액티비티의 뷰들은 런타임 시에 변경되며, 이 뷰들을 제어하는 코드는 액티비티 내부에 있어야 한다. 따라서 <strong>액티비티는 사용하는 특정 화면과 강하게 결합</strong>되어 있다.</p><h2 id="프래그먼트-개요"><a class="markdownIt-Anchor" href="#프래그먼트-개요"></a> 프래그먼트 개요</h2><p>하나 이상의 <strong>프래그먼트(fragment)</strong> 로 앱의 UI를 관리하면 유연성이 좋아진다. 프래그먼트는 액티비티의 작업 수행을 대행할 수 있는 컨트롤러 객체다. 여기서 작업이란 UI 관리를 말하며, UI는 화면 전체 또는 일부분이 될 수 있다.</p><p>UI를 관리하는 프래그먼트를 <strong>UI 프래그먼트</strong>라 한다. UI 프래그먼트는 레이아웃 파일로부터 인플레이트 <sup>inflate</sup>되는 자신의 뷰를 하나 갖는다. 프래그먼트 뷰는 사용자가 보면서 상호 작용하기를 원하는 UI 요소들을 포함한다.</p><p>액티비티의 뷰는 자신의 UI를 갖는 대신 프래그먼트를 넣을 컨테이너를 가지며, 이 컨테이너에는 인플레이트된 프래그먼트의 뷰가 추가된다. 이 장에서는 액티비티가 하나의 프래그먼트만 포함하지만, 액티비티는 여러 개의 다른 프래그먼트 뷰를 수용하는 다수의 컨테이너를 가질 수 있다.</p><p>UI 프래그먼트를 사용하면 앱의 UI를 조립 가능한 요소로 분리할 수 있어서 유용하며, 탭 인터페이스를 비롯한 여러 가지를 쉽게 만들 수 있다.</p><p>새로운 안드로이드 Jetpack API 중에서도 내비게이션 컨트롤러와 같이 프래그먼트를 잘 활용하는 API가 있다. 따라서 프래그먼트를 사용하면 Jetpack API를 같이 사용할 때도 유용하다.</p><h2 id="프래그먼트를-이용한-앱-개발-시작"><a class="markdownIt-Anchor" href="#프래그먼트를-이용한-앱-개발-시작"></a> 프래그먼트를 이용한 앱 개발 시작</h2><p>예시로 사용되는 앱의 화면은 CrimeFragment라는 UI 프래그먼트가 관리하며, CrimeFragment의 인스턴스는 MainActivity라는 액티비티가 <strong>호스팅</strong>한다.</p><p>액티비티는 자신의 뷰 계층 구조에 프래그먼트와 그 뷰를 포함하는 곳을 제공하는데, 이것을 호스팅이라고 생각하면 된다. 프래그먼트는 화면에 보이는 뷰를 자체적으로 가질 수 없으며, 액티비티의 뷰 계층에 추가될 때만 화면에 자신의 뷰가 보인다.</p><blockquote><p>CrimeFragment를 호스팅하는 MainActivity</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119095167-e78d2580-ba4c-11eb-9438-c63f1c3689c5.jpeg'></p><p>액티비티로만 이루어진 앱에서 액티비티들이 했던, UI를 생성하고 관리하며 모델 객체들과 상호 작용하는 일을 CrimeFragment가 한다는 것을 아래의 다이어그램에서 알 수 있다.</p><blockquote><p>프래그먼트를 사용하는 앱의 객체 다이어그램</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119095164-e65bf880-ba4c-11eb-9f1e-45fc7801f301.jpeg'></p><h2 id="fragmentmanager에-ui-프래그먼트-추가하기"><a class="markdownIt-Anchor" href="#fragmentmanager에-ui-프래그먼트-추가하기"></a> FragmentManager에 UI 프래그먼트 추가하기</h2><p>Fragment 클래스가 허니콤 <sup>honeycomb</sup> 버전에 추가되면서 FragmentManager를 호출하는 코드를 포함하도록 Activity 클래스가 변경되었다. FragmentManager는 프래그먼트 리스트와 프래그먼트 트랜잭션의 백 스택 <sup>back stack</sup>을 처리한다. FragmentManager는 프래그먼트의 뷰를 액티비티의 뷰 계층에 추가하고 프래그먼트의 생명주기를 주도하는 책임을 갖는다.</p><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/119078193-ae46bc80-ba30-11eb-97a3-d88eb24fdf2a.jpeg'></p><h3 id="프래그먼트-트랜잭션"><a class="markdownIt-Anchor" href="#프래그먼트-트랜잭션"></a> 프래그먼트 트랜잭션</h3><p>FragmentManager에 프래그먼트를 관리하도록 넘겨주는 코드를 MainActivity.kt에 추가한다.</p><blockquote><p>CrimeFragment 추가하기<sup id = "a1"> <a href="#f1">코드 1</a></sup> (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> currentFragment =</span><br><span class="line">            supportFragmentManager.findFragmentById(R.id.fragment_container)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentFragment == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> fragment = CrimeFragment()</span><br><span class="line">            supportFragmentManager</span><br><span class="line">                .beginTransaction()</span><br><span class="line">                .add(R.id.fragment_container, fragment)</span><br><span class="line">                .commit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>액티비티에 프래그먼트를 추가하기 위해 액티비티의 FragmentManager를 호출했다. 이때 Jetpack 라이브러리와 AppCompatActivity 클래스를 사용하고 있으므로 supportFragmentMananger 속성을 사용해서 액티비티의 프래그먼트 매니저를 참조할 수 있다.</p><p>supportFragmentMananger의 이름 앞 'support’는 v4 지원 라이브러리로부터 유래된 것이다. 그러나 지금은 v4 지원 라이브러리가 Jetpack 내부에 androidx 라이브러리로 포함되었다.</p><blockquote><p><strong>프래그먼트 트랜잭션 <sup>fragment transaction</sup></strong> 을 생성하고 커밋</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">supportFragmentManager</span><br><span class="line">    .beginTransaction()</span><br><span class="line">    .add(R.id.fragment_container, fragment)</span><br><span class="line">    .commit()</span><br></pre></td></tr></table></figure><p>프래그먼트 트랜잭션은 프래그먼트 리스트에 프래그먼트를 추가 <sup>add</sup>, 삭제 <sup>remove</sup>, 첨부 <sup>attach</sup>, 분리 <sup>detach</sup>, 변경 <sup>replace</sup>하는데 사용된다. 프래그먼트 트랜잭션을 사용하면 여러 개의 오퍼레이션 <sub>(트랜잭션으로 실행되는 각 함수 코드)</sub>을 묶어서 수행할 수 있다. 예를 들어, 다수의 프래그먼트를 동시에 서로 다른 컨테이너에 추가하는 경우다. 프래그먼트로 런타임 시에 화면을 구성 또는 변경하는 방법의 핵심이 바로 프래그먼트 트랜잭션이다.</p><p>FragmentManager는 프래그먼트 트랜잭션의 백 스택을 유지 관리한다. 따라서 프래그먼트 트랜잭션이 다수의 오퍼레이션을 포함한다면 해당 트랜잭션이 백 스택에서 제거될 때 이 오퍼레이션들이 역으로 실행된다. 그러므로 다수의 프래그먼트 오퍼레이션들을 하나의 트랜잭션으로 묶으면 UI 상태를 더욱 잘 제어할 수 있다.</p><p><code>FragmentManager.beginTransaction</code> 함수는 FragmentTranscation의 인스턴스를 생성해 반환한다. FragmentTransaction 클래스는 플루언트 인터페이스 <sup>fluent interface</sup>를 사용한다. <sub>(플루언트 인터페이스는 코드를 이해하기 쉽게 해주는 객체지향 기법이며, 일반적으로 함수의 연쇄 호출 형태로 구현된다.)</sub> 즉, FragmentTransaction을 구성하는 함수들이 Unit 대신 FragmentTransaction 객체를 반환하기 때문에 이 함수들을 연쇄 호출할 수 있다 <sub>(코틀린의 Unit은 하나의 인스턴스만 생성되는 싱글톤 객체이며 자바의 void와 같이 함수의 반환 값이 없음을 나타내는 데 사용된다)</sub>. 따라서 위의 코드는 '새로운 프래그먼트 트랜잭션 인스턴스를 생성하고 이 인스턴스에 <code>add()</code> 오퍼레이션을 포함시킨 후 커밋해라’라는 의미다.</p><p><code>add(...)</code> 함수는 컨테이너 뷰 ID와 새로 생성된 CrimeFragment 인스턴스를 매개변수로 갖는다. 여기서 컨테이너 뷰 ID는 activity_main.xml에 정의했던 FrameLayout의 리소스 ID다.</p><p>컨테이너 뷰 ID는 다음 두 가지 목적으로 사용된다.</p><ol><li>액티비티 뷰의 어느 위치에 프래그먼트 뷰가 나타나야 하는지를 <strong>FragmentManager</strong>에 알려준다.</li><li><strong>FragmentManager</strong>의 리스트에서 프래그먼트를 고유하게 식별하는 데 사용된다.</li></ol><p>FragmentManager로부터 CrimeFragment를 가져오려면 다음의 코드 첫째 줄처럼 컨테이너 뷰 ID로 요청한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> currentFragment =</span><br><span class="line">    supportFragmentManager.findFragmentById(R.id.fragment_container)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentFragment == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> fragment = CrimeFragment()</span><br><span class="line">    supportFragmentManager</span><br><span class="line">        .beginTransaction()</span><br><span class="line">        .add(R.id.fragment_container, fragment)</span><br><span class="line">        .commit()</span><br></pre></td></tr></table></figure><p>FragmentManager가 FrameLayout의 리소스 ID를 사용해서 CrimeFragment를 식별한다는 것이 이상하게 보일지 모른다. 그러나 컨테이너 뷰의 리소스 ID로 UI 프래그먼트를 식별하는 것이 FragmentManager가 작동하는 방법이다. 만일 하나의 액티비티에 여러 개의 프래그먼트를 추가한다면, 각 프래그먼트에 대해 별도의 리소스 ID를 갖는 컨테이너 뷰를 생성하기 때문이다.</p><p>이제 <b id = "f1">코드 1</b> <a href="#a1"> ↩</a>이 어떻게 작동하는지 자세히 살펴보자.</p><p>우선 R.id.fragment_container의 컨테이너 뷰 ID와 연관된 프래그먼트를 FragmentManager에 요청한다. 만일 이 프래그먼트가 리스트에 이미 있다면, FragmentManager가 그것을 반환한다.</p><p>그런데 요청한 프래그먼트가 어째서 이미 프래그먼트 리스트에 있는 것일까? 여러 이유로 액티비티가 소멸되었다가 다시 생성될 때를 대비해서 리스트에 보존하기 대문이다. 즉, 장치가 회전되거나 안드로이드 운영체제의 메모리 회수로 MainActivity가 소멸되었다가 <strong>다시 생성</strong>되면 <code>MainActivity.onCreate(Bundle?)</code>이 다시 호출된다. 따라서 액티비티가 소멸될 때는 이 액티비티의 FragmentManager 인스턴스가 해당 액티비티의 프래그먼트 리스트를 보존한다. 그리고 해당 액티비티가 다시 생성되면 새로운 FragmentManager 인스턴스가 그 리스트를 가져와서 리스트에 있는 프래그먼트를 다시 생성해 이전 상태로 복원한다.</p><p>이와는 달리 지정된 컨테이너 뷰 ID의 프래그먼트가 리스트에 없다면, fragment 변수는 null이 된다. 이때는 새로운 CrimeFragment와 새로운 프래그먼트 트랜잭션(프래그먼트를 리스트에 추가하는)을 생성한다.</p><p>이렇게 MainActivity가 CrimeFragment를 호스팅하게 되었다.</p><h3 id="fragmentmanager와-프래그먼트-생명주기"><a class="markdownIt-Anchor" href="#fragmentmanager와-프래그먼트-생명주기"></a> FragmentManager와 프래그먼트 생명주기</h3><p>프래그먼트 생명주기는 액티비티 생명주기와 유사하다. 즉 중단 <sub>(stopped)</sub> 상태, 일시 중지 <sub>(paused)</sub> 상태, 실행 재개 <sub>(resumed)</sub> 상태를 가지며, 상태가 전환될 대 필요한 일을 처리하기 위해 오버라이드할 수 있는 함수들도 갖는다. 이 함수들은 액티비티 생명주기 함수들과 대응된다.</p><blockquote><p>프래그먼트 생명주기 다이어그램</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119095152-e3f99e80-ba4c-11eb-88d1-7fb7faeb2415.jpeg'></p><p>액티비티와 프래그먼트의 생명주기 함수가 대응된다는 점이 중요하다. 프래그먼트는 액티비티를 대신해 작동하므로 프래그먼트의 상태는 액티비티의 상태를 반영해야한다. 따라서 프래그먼트는 액티비티의 작업을 처리하기 위해 액티비티와 일치하는 생명주기 함수가 필요하다.</p><p>프래그먼트 생명주기와 액티비티 생명주기가 다른 점은 프래그먼트 생명주기 함수는 안드로이드 운영체제가 아닌 호스팅 액티비티의 FragmentManager가 호출한다는 점이다. 프래그먼트는 액티비티가 내부적으로 처리해서 안드로이드 운영체제는 액티비티가 사용하는 프래그먼트에 관해서는 아무것도 모른다.</p><p><code>onAttach(Context?)</code>, <code>onCreate(Bundle?)</code>, <code>onCreateView(...)</code>, <code>onViewCreated(...)</code> 함수들은 프래그먼트를 FragmentManager애 추가할 때 호출된다.</p><p><code>onActivityCreated(Bundle?)</code> 함수는 호스팅 액티비티의 <code>onCreate(Bundle?)</code> 함수가 실행된 후 호출된다. 앱에서는 <code>MainActivity.onCreate(Bundle?)</code>에서 CrimeFragment를 추가하는데, <code>onActivityCreated(Bundle?)</code> 함수는 프래그먼트가 추가된 후에 호출된다.</p><p>액티비티가 이미 실행 중일 때 프래그먼트를 추가하면 어떻게 될까? 이때 FragmentManager는 해당 프래그먼트가 호스팅 액티비티의 상태를 따라잡는데 필요한 프래그먼트 생명주기 함수를 몇 개이든 차례대로 즉시 호출한다. 예를 들어, 이미 실행 중인 액티비티에 프래그먼트가 추가되면 이 프래그먼트는 <code>onAttach(Context?)</code>, <code>onCreate(Bundle?)</code>, <code>onActivityCreated(Bundle?)</code>, <code>onStart()</code>, <code>onResume()</code>의 순서로 이 함수들의 호출을 연속해서 받게 된다.</p><p>일단 프래그먼트의 상태가 액티비티의 상태를 따라잡으면 이후부터는 호스팅 액티비티의 FragmentManager가 액티비티 상태와 동조된 프래그먼트 상태를 유지한다. 즉, 안드로이드 운영체제로부터 액티비티 생명주기 함수들이 호출되면 이것과 부합되는 프래그먼트 생명주기 함수들을 호출해준다.</p><h2 id="프래그먼트를-사용하는-애플리케이션-아키텍쳐"><a class="markdownIt-Anchor" href="#프래그먼트를-사용하는-애플리케이션-아키텍쳐"></a> 프래그먼트를 사용하는 애플리케이션 아키텍쳐</h2><p>프래그먼트는 주요 컴포넌트를 재사용하게끔 캡슐화한다. 여기서 주요 컴포넌트는 앱의 전체 화면에 나타난다. 만일 한번에 너무 많은 프래그먼트를 화면에 넣는다면, 프래그먼트 트랜잭션 때문에 코드가 지저분하게 된다. 따라서 작은 컴퍼넌트들을 재사용할 때는 프래그먼트 대신 커스텀 뷰 <sub>(View의 서브 클래스 또는 View의 서브 클래스의 서브 클래스)</sub>로 추출하는 것이 좋은 방법이다.</p><p>일반적으로 한 화면에는 최대 두 개 또는 세 개 정도의 프래그먼트를 사용하는 것이 좋다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      
      <comments>http://june0122.github.io/2021/05/21/android-bnr-08/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Codility] BinaryGap</title>
      <link>http://june0122.github.io/2021/05/19/codility-binary-gap/</link>
      <guid>http://june0122.github.io/2021/05/19/codility-binary-gap/</guid>
      <pubDate>Wed, 19 May 2021 00:41:13 GMT</pubDate>
      
      <description>Lesson 1 - Iterations : BinaryGap</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="lesson-1-iterations-binarygap"><a class="markdownIt-Anchor" href="#lesson-1-iterations-binarygap"></a> Lesson 1 - Iterations : <a href="https://app.codility.com/programmers/lessons/1-iterations/binary_gap/">BinaryGap</a></h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>이진수 변환 직접 구현</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(N: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> answer = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> temp = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> quotient = N</span><br><span class="line">    <span class="keyword">var</span> remainder: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (quotient &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        remainder = quotient % <span class="number">2</span></span><br><span class="line">        quotient /= <span class="number">2</span></span><br><span class="line">        temp += remainder.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> binary = temp.reversed()</span><br><span class="line">    <span class="keyword">val</span> oneIndexList = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    binary.forEachIndexed &#123; index, c -&gt;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            oneIndexList.add(index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> gap: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until oneIndexList.size - <span class="number">1</span>) &#123;</span><br><span class="line">        gap = oneIndexList[i+<span class="number">1</span>] - oneIndexList[i] - <span class="number">1</span></span><br><span class="line">        answer = max(gap, answer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>이진수 변환을 직접 구현</li><li>이진수 문자열에서 <code>1</code>이 위치한 인덱스들을 값으로 가지는 리스트 생성</li><li><code>1</code>이 위치한 인접한 인덱스끼리 빼고, 추가적으로 1을 더 빼면 gap의 크기가 나옴</li></ol><blockquote><p><code>Int.toString(radix: Int)</code> 사용하여 이진수 변환</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(N: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> binary = N.toString(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> zeroList = binary.split(<span class="string">&quot;1&quot;</span>).toMutableList()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binary.last() != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        zeroList.removeAt(zeroList.size - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> zeroList.map &#123; it.length &#125;.max() ?: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>Int.toString(radix: Int)</code> 사용하여 이진수 변환을 매우 간단하게 할 수 있다.</li><li><code>1</code>을 구분자 <sup>delimniter</sup>로 이진수 문자열을 <strong>split</strong> 하여 연결된 <code>0</code>들을 값으로 가진 리스트를 생성</li><li>만약 이진수의 끝자리가 <code>1</code>이 아닐 경우엔 마지막 연결된 <code>0</code>들은 gap으로 인정되지 않으므로 리스트에서 삭제한다.</li><li><code>Iterable&lt;T&gt;.map(transform: (T) -&gt; R)</code>을 통해 리스트 원소의 길이를 기준으로 리스트를 생성한 후 가장 큰 값을 <code>max()</code>를 이용해 리턴한다.</li></ol><p>대부분의 코딩 사이트는 <strong>kotlin 1.4</strong>를 지원하지 않는데 1.4 기준으로는 아래처럼 사용해야하거나 사용할 수 있다.</p><ul><li><code>removeAt(zeroList.size - 1)</code> -&gt; <code>zeroList.removeLast()</code></li><li><code>max()</code> -&gt; <code>maxOrNull()</code></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Codility/">Codility</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Codility/">Codility</category>
      
      
      <comments>http://june0122.github.io/2021/05/19/codility-binary-gap/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Do not concatenate text displayed with setText</title>
      <link>http://june0122.github.io/2021/05/18/android-memo-text-concatenatation/</link>
      <guid>http://june0122.github.io/2021/05/18/android-memo-text-concatenatation/</guid>
      <pubDate>Tue, 18 May 2021 02:27:19 GMT</pubDate>
      
      <description>TextView의 내용을 setText() 메서드를 이용해 설정할 때 Do not concatenate text displayed with setText. Use resource string with placeholders.라는 경고문을 자주 볼 수 있다. 대략 setText로 표시된 텍스트를 + 로 연결해서 사용하지 말고 리소스 문자열을 placeholder와 함께 사용하라는 내용인데, &lt;b&gt;문자열 서식 지정&lt;/b&gt;을 이용하여 &lt;b&gt;getString(int, Object...)&lt;/b&gt;의 값을 &lt;b&gt;setText()&lt;/b&gt;에 넣어주면 된다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-개요"><a class="markdownIt-Anchor" href="#문제-개요"></a> 문제 개요</h2><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/118576969-83f0c700-b7c4-11eb-956c-cebca0709b8d.png'></p><p>TextView의 내용을 <code>setText()</code> 메서드를 이용해 설정할 때 <strong>Do not concatenate text displayed with setText. Use resource string with placeholders.</strong> 라는 경고문을 자주 볼 수 있다.</p><p>대략 setText로 표시된 텍스트를 <code>+</code>로 연결해서 사용하지 말고 리소스 문자열을 placeholder와 함께 사용하라는 내용인데 어떻게 해결할 수 있을까?</p><h2 id="해결"><a class="markdownIt-Anchor" href="#해결"></a> 해결</h2><p>답은 <a href="https://developer.android.com/guide/topics/resources/string-resource?hl=ko#%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%84%9C%EC%8B%9D-%EC%A7%80%EC%A0%95"><strong>문자열 서식 지정</strong></a>에 있다. 아래의 코드와 같이 문자열 리소스에서 원하는 자리에 들어갈 값을 서식 인수 <sup>format argument</sup>를 추가하여 지정하는 것이다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;welcome_messages&quot;</span>&gt;</span>Hello, %1$s! You have %2$d new messages.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><p>위의 예시는 문자열에 두 개의 서식 인수가 존재하는데 <code>%1$s</code>에는 문자열이, <code>%2$d</code>에는 10진수 값이 들어간다. 여기서 주의해야 할 부분은 서식 인수의 syntax인데 아래와 같은 형태이다.</p><blockquote><p>%[<code>인자의 인덱스</code>$]<code>서식 지정자</code></p></blockquote><ul><li>인자의 인덱스 <sup>argument index</sup>는 문자열 리소스에서 서식 <strong>인수의 인덱스</strong>를 선택할 수 있게 해준다. 첫 번째 인자는 <code>1$</code>, 두 번째는 <code>2$</code>, 세 번째는 <code>3$</code>와 같은 식이다.</li><li>서식 지정자 <sup>format specifier</sup>는 <strong>데이터 타입</strong>을 지정하는 것인데, C언어 등에서 흔히 사용하는 <code>%d</code>, <code>%s</code>와 같은 서식 지정자와 동일한 개념이다.</li></ul><p>문자열 리소스에서 서식 인수를 지정했다면 <a href="https://developer.android.com/reference/android/content/Context?hl=ko#getString(int,%20java.lang.Object...)"><code>getString(int, Object...)</code></a>을 통해 아래의 코드와 같이 매개변수의 첫 번째 인자로 해당 문자열 리소스를 전달하고 차례로 서식 인수들에 들어갈 값을 전달하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = getString(R.string.welcome_messages, username, mailCount)</span><br></pre></td></tr></table></figure><p>결과적으로 <code>+</code>로 연결된 텍스트가 아닌 문자열 서식 지정을 이용하여 <code>getString(int, Object...)</code>의 값을 <code>setText()</code>에 넣어주면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testTextView.text = getString(R.string.welcome_messages, username, mailCount)</span><br></pre></td></tr></table></figure><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li><p>Android Developers 가이드 | <a href="https://developer.android.com/guide/topics/resources/string-resource?hl=ko#%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%84%9C%EC%8B%9D-%EC%A7%80%EC%A0%95">문자열 서식 지정</a></p></li><li><p>Android Developers 가이드 | <a href="https://developer.android.com/reference/android/content/Context?hl=ko#getString(int,%20java.lang.Object...)">getString</a></p></li><li><p>StackOverflow | <a href="https://stackoverflow.com/questions/33164886/android-textview-do-not-concatenate-text-displayed-with-settext">Android TextView : “Do not concatenate text displayed with setText”</a></p></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Memo/">Memo</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      
      <comments>http://june0122.github.io/2021/05/18/android-memo-text-concatenatation/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Intent: 액티비티 간 데이터 전달</title>
      <link>http://june0122.github.io/2021/05/17/android-bnr-06/</link>
      <guid>http://june0122.github.io/2021/05/17/android-bnr-06/</guid>
      <pubDate>Sun, 16 May 2021 23:18:07 GMT</pubDate>
      
      <description>&lt;b&gt;인텐트(intent)&lt;/b&gt;는 컴포넌트가 운영체제와 통신하는 데 사용할 수 있는 객체다. 지금까지 보았던 컴포넌트는 액티비티뿐이지만, 컴포넌트에는 서비스, 브로드캐스트 수신자, 콘텐츠 제공자도 있다. 인텐트는 다목적 통신 도구로, 이것을 추상화한 Intent 클래스는 인텐트의 용도에 따라 서로 다른 생성자들을 제공한다. 여기서는 시작시킬 액티비티를 ActivityManager에 알려주려고 인텐트를 사용한다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="액티비티-시작시키기"><a class="markdownIt-Anchor" href="#액티비티-시작시키기"></a> 액티비티 시작시키기</h2><p><code>startActivity(Intent)</code>는 시작시키고자 하는 액티비티에 대해 호출하는 <strong>static</strong> 함수라고 생각할지도 모르겠지만 그렇지 않다. 액티비티에서 <code>startActivity(Intent)</code>를 호출하면 이 호출은 안드로이드 운영체제에게 전달된다.</p><p>조금 더 구체적으로 말해서, <code>startActivity(Intent)</code> 호출은 <strong>ActivityManager</strong>라고 하는 안드로이드 운영체제의 컴포넌트로 전달된다. 그다음에 <strong>ActivityManager</strong>는 해당 액티비티의 인스턴스를 생성하고 이 인스턴스의 <code>onCreate(Bundle?)</code> 함수를 호출한다.</p><p>그렇다면 어떤 액티비티를 시작시킬지 <strong>ActivityManager</strong>가 어떻게 알 수 있을까? 이 정보는 <strong>Intent</strong> 매개변수에 있다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/118398907-991b0800-b695-11eb-917c-e8246d678c92.jpeg'></p><h3 id="인텐트로-통신하기"><a class="markdownIt-Anchor" href="#인텐트로-통신하기"></a> 인텐트로 통신하기</h3><p><strong>인텐트(intent)</strong> 는 <strong>컴포넌트</strong>가 운영체제와 통신하는 데 사용할 수 있는 객체다. 지금까지 보았던 컴포넌트는 액티비티뿐 <sup>activity</sup>이지만, 컴포넌트에는 서비스 <sup>service</sup>, 브로드캐스트 수신자 <sup>broadcast receiver</sup>, 콘텐츠 제공자 <sup>content provider</sup>도 있다.  <sub><a href="https://developer.android.com/guide/components/fundamentals?hl=ko">※ 안드로이드 4대 컴포넌트</a></sub></p><p>인텐트는 다목적 통신 도구로, 이것을 추상화한 <strong>Intent</strong> 클래스는 인텐트의 용도에 따라 서로 다른 생성자들을 제공한다. 여기서는 시작시킬 액티비티를 <strong>ActivityManager</strong>에 알려주려고 인텐트를 사용한다. 따라서 다음 생성자를 사용한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intent(packageContext: Context, <span class="class"><span class="keyword">class</span>: <span class="type">Class</span>&lt;<span class="type">?</span>&gt;)</span></span><br></pre></td></tr></table></figure><p>CheatActivity 클래스를 인자로 받는 Intent 객체를 생성하고 이 인텐트를 startActivity(Intent) 인자로 전달하는 코드를 cheatButton의 리스너 내부에 추가한다.</p><blockquote><p>MainActiviy에서 CheatActivity 시작시키기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cheatButton.setOnClickListener &#123;</span><br><span class="line">    <span class="comment">// CheatActivity를 시작시킨다</span></span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, CheatActivity::<span class="keyword">class</span>.java)</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Intent 생성자에게 전달하는 Class 인자에는 ActivityManager가 시작시켜야 하는 액티비티 클래스를 지정한다. 여기서 <strong>Context</strong> 인자는 이 액티비티 클래스가 있는 애플리케이션 패키지를 ActivityManager에게 알려준다.</p><p>액티비티를 시작시키기에 앞서, ActivityManager는 시작시킬 액티비티 클래스가 매니페스트의 activity 요소에 선언되어 있는지 확인한다. 만일 선언되어 있다면 해당 액티비티를 시작시키고, 선언되어 있지 않으면 ActivityNotFoundException이 발생되고 앱 실행이 중단된다. 모든 액티비티가 반드시 매니페스트에 선언되어야 하는 이유가 바로 이 때문이다.</p><h3 id="명시적-인텐트와-암시적-인텐트"><a class="markdownIt-Anchor" href="#명시적-인텐트와-암시적-인텐트"></a> 명시적 인텐트와 암시적 인텐트</h3><p>Context 객체와 Class 객체를 사용해서 생성하는 Intent는 <strong>명시적(explicit)</strong> 인텐트다. 명시적 인텐트는 앱 내부에 있는 액티비티를 시작시키기 위해 사용한다.</p><p>같은 앱 내부에 있는 두 개의 액티비티가 앱 외부의 ActivityManager를 통해서 통신하는 것이 이상하게 보일 수 있다. 그렇지만 이렇게 하면 한 애플리케이션의 액티비티가 다른 애플리케이션의 액티비티와 함께 동작하는 것이 쉬워진다.</p><p>한 애플리케이션의 액티비티에서 다른 애플리케이션의 액티비티를 시작시키려면 <strong>암시적(implicit)</strong> 인텐트를 생성한다.</p><h2 id="액티비티-간의-데이터-전달"><a class="markdownIt-Anchor" href="#액티비티-간의-데이터-전달"></a> 액티비티 간의 데이터 전달</h2><blockquote><p>MainActivity와 CheatActivity 간의 통신</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/118398906-98827180-b695-11eb-9180-85db7f39f5fd.jpeg'></p><h3 id="인텐트-엑스트라-사용하기"><a class="markdownIt-Anchor" href="#인텐트-엑스트라-사용하기"></a> 인텐트 엑스트라 사용하기</h3><p>엑스트라는 호출하는 액티비티가 인텐트에 포함시킬 수 있는 임의의 데이터로, 생성자 인자로 생각할 수 있다<sub>(액티비티 인스턴스는 안드로이드 운영체제에 의해 생성되고 그 생명주기가 관리된다)</sub>. 요청된 인텐트는 안드로이드 운영체제가 받아서 수신 액티비티에 전달한다. 그다음에 수신 액티비티는 해당 인텐트의 엑스트라로 전달된 데이터를 추출해 사용한다.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/118398904-96201780-b695-11eb-8d7c-df1b674f1718.jpeg'></p><p>엑스트라는 키와 값이 한 쌍으로 된 구조로, <code>MainActivity.onSaveInstanceState(Bundle)</code>에서 currentIndex의 값을 저장하기 위해 사용했던 <strong>Bundle</strong> 객체의 구조와 동일하다.</p><p>인텐트에 엑스트라를 추가할 때는 <code>Intent.putExtra(...)</code> 를 사용하며, 주로 <code>putExtra(name: String, value: Boolean)</code>을 호출한다.</p><p><code>Intent.putExtra(...)</code>는 여러 형태로 오버로딩되어 있지만 항상 두 개의 인자를 갖는다.</p><ol><li>첫 번째 인자는 항상 String 타입이며 엑스트라로 저장할 데이터 항목의 키를 나타낸다.</li><li>두 번째 인자는 이 키의 값을 나타내며, 다양한 타입으로 오버로딩되어 있다.</li></ol><blockquote><p>엑스트라 상수 추가하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> EXTRA_ANSWER_IS_TRUE = <span class="string">&quot;com.june0122.geoquiz.answer_is_true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheatActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>액티비티 코드는 여러 곳에서부터 시작될 수 있다. 따라서 엑스트라 키는 엑스트라의 데이터를 읽어서 사용하는 액티비티에 정의해야 한다.</p><ul><li>이때 위의 코드처럼 엑스트라의 키 값에 패키지 이름을 사용하면 다른 앱의 엑스트라와의 충돌 방지가 가능하다.</li></ul></li><li><p>다음으로 MainActivity로 돌아가서 인텐트에 엑스트라를 쓰는 코드를 추가해야 한다. 그런데 더 좋은 방법이 있다.</p><ul><li>MainActivity나 앱의 다른 코드에서는 CheatActivity가 인텐트의 엑스트라로 무엇을 받는지 알 필요가 없다.</li><li>따라서 CheatActivity의 실행의 위해 인텐트를 요청하는 코드를 별도의 함수로 캡슐화하면 좋다.</li></ul></li></ul><p>아래와 같이 CheatActivity에 <code>newIntent(...)</code> 함수를 동반 객체 <sup>companion object</sup> 내부에 둔다.</p><blockquote><p>CheatActivity의 <code>newIntent(...)</code> 함수 추가하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheatActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newIntent</span><span class="params">(packageContext: <span class="type">Context</span>, answerIsTrue: <span class="type">Boolean</span>)</span></span>: Intent &#123;</span><br><span class="line">            <span class="keyword">return</span> Intent(packageContext, CheatActivity::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line">                putExtra(EXTRA_ANSWER_IS_TRUE, answerIsTrue)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 함수에서는 CheatActivity가 필요로 하는 엑스트라 데이터를 갖는 인텐트를 생성한다. Boolean 타입의 answerIsTrue 인자는 EXTRA_ANSWER_IS_TRUE 상수 값을 키로 갖도록 엑스트라에 저장된다.</p><p>이처럼 동반 객체를 사용하면 클래스 인스턴스를 생성하지 않고 동반 객체의 함수를 사용할 수 있다. <sub>(java의 static 메서드와 유사)</sub> 따라서 아래에 나올 코드에서 <code>CheatActivity.newIntent(this@MainActivity, answerIsTrue)</code>처럼 동반 객체를 포함하는 클래스 이름을 사용해서 동반 객체의 함수를 호출할 수 있다. 또한, 동반 객체를 포함하는 클래스에서는 동반 객체를 자신의 멤버인 것처럼 인식하므로 편리하다.</p><blockquote><p>엑스트라를 갖는 인텐트로 CheatActivity 시작시키기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cheatButton.setOnClickListener &#123;</span><br><span class="line">    <span class="comment">// val intent = Intent(this, CheatActivity::class.java)</span></span><br><span class="line">    <span class="keyword">val</span> answerIsTrue = quizViewModel.currentQuestionAnswer</span><br><span class="line">    <span class="keyword">val</span> intent = CheatActivity.newIntent(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, answerIsTrue)</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 엑스트라 하나만 있으면 되지만, 필요하다면 <code>newIntent(...)</code> 함수에 더 많은 인자를 추가하여 Intent 하나에 여러 개의 엑스트라를 쓸 수 있다. 아래의 이미지와 같이 다양한 타입의 값을 엑스트라에 넣고 추출할 수 있다.</p><p align = 'center'><img height = '220' src = 'https://user-images.githubusercontent.com/39554623/118405239-d68d8e80-b6b1-11eb-958c-b7d24ec63aa9.png'><img height = '220' src = 'https://user-images.githubusercontent.com/39554623/118405411-c75b1080-b6b2-11eb-8ac5-33caf8e9a4e2.png'></p><p>다음으로 CheatActivity 클래스의 <code>onCreate(Bundle?)</code> 함수에 코드를 추가한다. 이 코드에서는 인텐트로 전달된 엑스트라의 값을 추출해 클래스 속성에 저장한다.</p><blockquote><p>엑스트라 사용하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheatActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> answerIsTrue = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_cheat)</span><br><span class="line">        </span><br><span class="line">        answerIsTrue = intent.getBooleanExtra(EXTRA_ANSWER_IS_TRUE, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Activity.intent</code>는 항상 액티비티를 시작시켰던 <strong>Intent</strong> 객체를 반환한다. 이 <strong>Intent</strong> 객체는 <code>startActivity(Intent)</code>를 호출할 때 인자로 전달되었던 객체다.</p><p>여기서 <strong>intent</strong> 대신 자바 스타일로 <code>getIntent()</code>를 사용해도 되지만 코틀린에서는 클래스 속성의 값을 가져올 떄 게터(getter)를 사용하지 않아도 된다. 속성을 참조할 때 자동으로 게터를 호출해주기 때문이다.</p><blockquote><p>엑스트라에서 추출한 값을 사용하도록 CheatActiviy에 코드 추가</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheatActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> answerTextView: TextView</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> showAnswerButton: Button</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> answerIsTrue = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        answerIsTrue = intent.getBooleanExtra(EXTRA_ANSWER_IS_TRUE, <span class="literal">false</span>)</span><br><span class="line">        answerTextView = findViewById(R.id.answer_text_view)</span><br><span class="line">        showAnswerButton = findViewById(R.id.show_answer_button)</span><br><span class="line">        showAnswerButton.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> answerText = <span class="keyword">when</span> &#123;</span><br><span class="line">                answerIsTrue -&gt; R.string.true_button</span><br><span class="line">                <span class="keyword">else</span> -&gt; R.string.false_button</span><br><span class="line">            &#125;</span><br><span class="line">            answerTextView.setText(answerText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="자식-액티비티로부터-결과-돌려받기"><a class="markdownIt-Anchor" href="#자식-액티비티로부터-결과-돌려받기"></a> 자식 액티비티로부터 결과 돌려받기</h3><p>자식 액티비티로부터 데이터를 돌려받고 싶다면 <code>Activity.startActivityForResult(Intent, Int)</code> 함수를 호출한다.</p><p>첫 번째 매개변수는 종전과 동일한 Intent 객체다. 두 번째 매개변수는 <strong>요청 코드(request code)</strong> 로 사용자가 정의한 정수다. 요청 코드는 자식 액티비티에 전달되었다가 부모 액티비티가 다시 돌려받으며 부모 액티비티가 여러 타입의 자식 액티비티들을 시작시킬 때 어떤 자식 액티비티가 결과글 돌려주는 것인지 알고자 할 때도 사용된다. 현재 MainActivity는 한 가지 타입의 자식 액티비티만 시작시키지만, 향후를 대비해서 요청 코드의 상수 값을 사용하는 것이 좋다.</p><blockquote><p>MainActivity에서 <code>startActivityForResult(Intent, Int)</code>를 호출하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> KEY_INDEX = <span class="string">&quot;index&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CODE_CHEAT = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        cheatButton.setOnClickListener &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// startActivity(intent)</span></span><br><span class="line">            startActivityForResult(intent, REQUEST_CODE_CHEAT)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        updateQuestion()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="결과-데이터-설정하기"><a class="markdownIt-Anchor" href="#결과-데이터-설정하기"></a> 결과 데이터 설정하기</h4><p>부모 액티비티에 데이터를 돌려주기 위해 자식 액티비티에서 호출하는 함수에는 다음 두 가지가 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setResult(resultCode: <span class="built_in">Int</span>)</span><br><span class="line">setResult(resultCode: <span class="built_in">Int</span>, <span class="keyword">data</span>: Intent)</span><br></pre></td></tr></table></figure><p>일반적으로 <strong>결과 코드(result code)</strong> 는 사전 정의된 두 개의 상수, 즉 Activity.RESULT_OK <sub>(정수 -1)</sub>, 또는 Activity.RESULT_CANCELED <sub>(정수 0)</sub> 중 하나다 <sub>(결과 코드를 정의할 때 RESULT_FIRST_USER(정수 1) 상수도 사용할 수 있다.)</sub>.</p><p>자식 액티비티가 어떻게 끝났는지에 따라 부모 액티비티에서 다른 액션을 취할 때 결과 코드를 사용하면 유용하다. 예를 들어, 자식 액티비티가 OK 버튼과 Cancel 버튼을 갖고 있고, 둘 중 어떤 버튼이 눌러졌는가에 따라 자식 액티비티가 결과 코드 값을 다르게 설정한다고 해보자. 그러면 부모 액티비티는 해당 결과 코드 값에 따라 다른 액션을 취할 수 있다.</p><p>자식 액티비티에서는 <code>setResult(...)</code>를 호출하지 않을 수도 있다. 부모 액티비티에서 어떤 결과 코드인지 구분할 필요가 없거나 인텐트의 데이터를 받을 필요가 없다면, 안드로이드 운영체제가 기본 결과 코드를 전달하게 할 수 있다. 자식 액티비티가 <code>startActivityForResult(...)</code>로 시작되었다면 결과 코드는 항상 부모 액티비티에 반환된다. 이때 자식 액티비티에서 <code>setResult(...)</code>를 호출하지 않은 상태에서 사용자가 장치의 백 버튼을 누르면 부모 액티비티는 결과 코드로 Activity.RESULT_CANCELED를 받게 된다.</p><h4 id="인텐트-돌려주기"><a class="markdownIt-Anchor" href="#인텐트-돌려주기"></a> 인텐트 돌려주기</h4><p>자식 액티비티가 부모 액티비티에 인텐트의 엑스트라를 돌려줄 수도 있다. 여기서는 엑스트라를 부모 액티비티인 MainActivity에 전달하는 것이 주 관심사다. 따라서 Intent를 생성하고 엑스트라를 저장한 후 <code>Activity.setResult(Int, Intent)</code>를 호출해 부모인 MainActivity에서 엑스트라 데이터를 받게 한다.</p><p>앞에서 CheatActivity가 받는 엑스트라 키의 상수를 CheatActivity에 정의했으니, 자식인 CheatActivity가 부모인 MainActivity에 전달할 새로운 엑스트라도 그것처럼 하면 된다.</p><blockquote><p>결과 설정하기</p></blockquote><ol><li>엑스트라의 키로 사용할 상수를 CheatActivity에 추가</li><li>인텐트를 생성해 거기에 엑스트라를 저장</li><li>결과 코드를 설정하는 private 함수 추가</li><li>‘정답 보기’ 버튼의 리스너에 이 함수의 호출 코드를 추가</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> EXTRA_ANSWER_SHOWN = <span class="string">&quot;com.june0122.geoquiz.answer_shown&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> EXTRA_ANSWER_IS_TRUE = <span class="string">&quot;com.june0122.geoquiz.answer_is_true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheatActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        showAnswerButton.setOnClickListener &#123;</span><br><span class="line">            ...</span><br><span class="line">            answerTextView.setText(answerText)</span><br><span class="line">            setAnswerShownResult(<span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setAnswerShownResult</span><span class="params">(isAnswerShown: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = Intent().apply &#123;</span><br><span class="line">            putExtra(EXTRA_ANSWER_SHOWN, isAnswerShown)</span><br><span class="line">        &#125;</span><br><span class="line">        setResult(Activity.RESULT_OK, <span class="keyword">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용자가 정답 보기 버튼(showAnswerButton)을 누르면 CheatActivity는 <code>setResult(Int, Intent)</code>를 호출하기 위해 인텐트를 생성하고 결과 코드를 추가한다.</p><p>그리고 사용자가 장치의 백 버튼을 눌러서 다시 MainActivity로 돌아가면 ActivityManager가 부모 액티비티인 MainActivity의 다음 함수를 호출한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onActivityResult(requestCode: <span class="built_in">Int</span>, resultCode: <span class="built_in">Int</span>, <span class="keyword">data</span>: Intent)</span><br></pre></td></tr></table></figure><p>여기서 첫 번째 매개변수는 MainActivity에서 전달했던 요청 코드다. 나머지 매개변수인 결과 코드와 인텐트는 자식 액티비티인 CheatActivity의 <code>setResult(Int, Intent)</code>로 전달되었던 것들이다.</p><p>아래는 이러한 상호작용을 보기 쉽게 시퀀스 다이어그램으로 정리한 이미지이다.</p><blockquote><p>GeoQuiz의 시퀀스 다이어그램</p></blockquote><p align = 'center'><img width = '650' src = 'https://user-images.githubusercontent.com/39554623/118407318-418f9300-b6bb-11eb-9af4-44cd6bc08290.jpeg'></p><p>이제는 CheatActivity에서 설정한 결과 데이터를 처리하기 위해 MainActivity에서 <code>onActivityResult(Int, Int, Intent)</code>를 오버라이딩하여 구현하는 것만 남았다.</p><h4 id="결과-데이터-처리하기"><a class="markdownIt-Anchor" href="#결과-데이터-처리하기"></a> 결과 데이터 처리하기</h4><p>CheatActivity가 돌려주는 값을 저장하는 새로운 속성을 QuizViewModel.kt에 추가한다.</p><p>사용자의 커닝 상태(커닝 여부를 나타내는 데이터)는 UI 상태의 일부다. 따라서 사용자의 커닝 상태는 MainActivity 대신 QuizViewModel에서 보존해야 한다. 이렇게 하면 액티비티 소멸이 아닌 구성 변경 시에 계속 보존되기 때문이다.</p><blockquote><p>QuizViewModel에 사용자 커닝 상태 보존하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuizViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> isCheater = <span class="literal">false</span> <span class="comment">// 사용자 커닝 상태를 보존할 변수 추가</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그다음에 CheatActivity가 돌려주는 결과 값을 가져오기 위해 MainActivity.kt에서 <code>onActivityResult(...)</code>를 오버라이드한다. 이때 요청 코드와 결과 코드가 기대한 값인지 확인한다.</p><ul><li>이렇게 하면 코드의 유지 보수가 쉬워진다. 특히, 인텐트로 시작시키는 자식 액티비티의 종류가 늘어났을 때 아주 유용하다.</li></ul><blockquote><p><code>onActivityResult(...)</code> 오버라이드하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (resultCode != Activity.RESULT_OK) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (requestCode == REQUEST_CODE_CHEAT) &#123;</span><br><span class="line">            quizViewModel.isCheater =</span><br><span class="line">                <span class="keyword">data</span>?.getBooleanExtra(EXTRA_ANSWER_SHOWN, <span class="literal">false</span>) ?: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 사용자가 정답을 커닝했는지 여부를 확인하고 그에 따른 적절한 응답을 주기 위해 MainActivity의 <code>checkAnswer(Boolean)</code> 함수를 수정한다.</p><blockquote><p>isCheater 값에 따라 토스트 메시지 변경하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkAnswer</span><span class="params">(userAnswer: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> correctAnswer = quizViewModel.currentQuestionAnswer</span><br><span class="line"></span><br><span class="line"><span class="comment">//        val messageResId = if (userAnswer == correctAnswer) &#123;</span></span><br><span class="line"><span class="comment">//            R.string.correct_toast</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            R.string.incorrect_toast</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> messageResId = <span class="keyword">when</span> &#123;</span><br><span class="line">            quizViewModel.isCheater -&gt; R.string.judgment_toast</span><br><span class="line">            userAnswer == correctAnswer -&gt; R.string.correct_toast</span><br><span class="line">            <span class="keyword">else</span> -&gt; R.string.incorrect_toast</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, messageResId, Toast.LENGTH_SHORT)</span><br><span class="line">                .show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="챌린지"><a class="markdownIt-Anchor" href="#챌린지"></a> 챌린지</h2><h3 id="장치-회전과-프로세스-종료-시-cheatactivity의-ui-상태-보존하기"><a class="markdownIt-Anchor" href="#장치-회전과-프로세스-종료-시-cheatactivity의-ui-상태-보존하기"></a> 장치 회전과 프로세스 종료 시 CheatActivity의 UI 상태 보존하기</h3><p>사용자가 정답을 커닝한 후에 CheatActivity 화면에서 장치를 회전해서 커닝 결과를 지울 수 있다. 그리고 MainActivity로 돌아오면 전혀 커닝하지 않은 것처럼 되는 문제를 해결해보자.</p><blockquote><p>CheatActivity.kt</p></blockquote><ol><li><code>by lazy</code> 키워드를 사용하여 quizViewModel을 선언한다.</li><li>Bundle 객체에 저장될 데이터의 키로 사용할 상수 KEY_CHEAT_STATUS를 추가한다.</li><li><code>onSaveInstanceState(Bundle)</code>을 오버라이드한다.<ul><li>isCheater 값을 Bundle 객체에 저장시킨다.</li><li>이때 키는 상수인 KEY_CHEAT_STATUS이며 키의 값은 quizViewModel.isCheater다.</li></ul></li><li><code>onCreate(Bundle?)</code>에서 Bundle 객체 값을 확인한다.<ul><li>Bundle 객체에 저장된 값을 확인해 값이 있으면 그 값을 quizViewModel.isCheater에 지정한다.</li><li>키가 Bundle 객체에 없거나 Bundle 객체 참조가 null이면 cisCheater의 값을 false으로 설정한다.</li></ul></li><li><code>updateAnswer()</code> 함수를 작성하여 <code>onCreate(Bundle?)</code> 함수와 정답 보기 버튼의 리스너 내부에서 호출한다.<ul><li><code>updateAnswer()</code>에선 커닝을 했을 경우 <sub>(<code>quizViewModel.isCheater == true</code>)</sub> QuizViewModel로부터 커닝에 대한 답을 가져오고, answerTextView에 보일 값을 설정한다.</li><li>그리고 부모 액티비티에 데이터를 돌려주기 위해 자식 액티비티에서 호출하는 함수 <code>setResult(...)</code>가 포함된 함수 <code>setAnswerShownResult</code>를 <code>updateAnswer()</code> 함수의 마지막에 호출한다.</li></ul></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> KEY_CHEAT_STATUS = <span class="string">&quot;cheat&quot;</span> <span class="comment">// ② Bundle 객체에 저장될 데이터의 키로 사용될 상수 선언</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheatActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> quizViewModel: QuizViewModel <span class="keyword">by</span> lazy &#123; <span class="comment">// ① quizViewModel을 선언</span></span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(QuizViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> answerIsTrue = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// ④ Bundle 객체 값 확인</span></span><br><span class="line">        <span class="keyword">val</span> isCheater = savedInstanceState?.getBoolean(KEY_CHEAT_STATUS, <span class="literal">false</span>) ?: <span class="literal">false</span></span><br><span class="line">        quizViewModel.isCheater = isCheater</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// ⑥ 정답 보기 버튼 클릭 시, quizViewModel의 isCheater 값을 true로 변경하고 updateAnswer() 호출</span></span><br><span class="line">        showAnswerButton.setOnClickListener &#123;</span><br><span class="line">            quizViewModel.isCheater = <span class="literal">true</span></span><br><span class="line">            updateAnswer()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ⑦ 액티비티 생성 시 updateAnswer() 호출</span></span><br><span class="line">        updateAnswer()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ③ `onSaveInstanceState(Bundle)`을 오버라이드</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSaveInstanceState</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(savedInstanceState)</span><br><span class="line">        savedInstanceState.putBoolean(KEY_CHEAT_STATUS, quizViewModel.isCheater)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⑤ updateAnswer() 함수를 작성</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateAnswer</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (quizViewModel.isCheater) &#123;</span><br><span class="line">            <span class="keyword">val</span> questionTextResId = <span class="keyword">when</span> &#123;</span><br><span class="line">                quizViewModel.currentQuestionAnswer -&gt; R.string.true_button</span><br><span class="line">                <span class="keyword">else</span> -&gt; R.string.false_button</span><br><span class="line">            &#125;</span><br><span class="line">            answerTextView.setText(questionTextResId)</span><br><span class="line">            setAnswerShownResult(<span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setAnswerShownResult</span><span class="params">(isAnswerShown: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = Intent().apply &#123;</span><br><span class="line">            putExtra(EXTRA_ANSWER_SHOWN, isAnswerShown)</span><br><span class="line">        &#125;</span><br><span class="line">        setResult(Activity.RESULT_OK, <span class="keyword">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="문제마다-커닝-여부-관리하기"><a class="markdownIt-Anchor" href="#문제마다-커닝-여부-관리하기"></a> 문제마다 커닝 여부 관리하기</h3><blockquote><p>QuizViewModel.kt</p></blockquote><ol><li>커닝 여부를 저장하는 MutableList인 cheatStatusList를 questionBank의 크기만큼 false로 초기화한다.</li><li>커스텀 접근자를 통해 cheatStatusList의 커닝 여부 값을 가져오고 저장할 수 있는 연산 프로퍼티 currentQuestionCheatStatus를 추가한다.</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuizViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> questionBank = listOf(</span><br><span class="line">        Question(R.string.question_australia, <span class="literal">true</span>),</span><br><span class="line">        Question(R.string.question_oceans, <span class="literal">true</span>),</span><br><span class="line">        Question(R.string.question_mideast, <span class="literal">false</span>),</span><br><span class="line">        Question(R.string.question_africa, <span class="literal">false</span>),</span><br><span class="line">        Question(R.string.question_americas, <span class="literal">true</span>),</span><br><span class="line">        Question(R.string.question_asia, <span class="literal">true</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> cheatStatusList = MutableList(questionBank.size) &#123; <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentQuestionCheatStatus: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = cheatStatusList[currentIndex]</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            cheatStatusList[currentIndex] = value</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MainActivity.kt</p></blockquote><ol start="3"><li>requestCode가 REQUEST_CODE_CHEAT일 때, <code>quizViewModel.isCheater</code> 대신 <code>quizViewModel.currentQuestionCheatStatus</code>의 값을 변경한다.</li><li>마찬가지로 checkAnswer 함수에서 <code>quizViewModel.isCheater</code> 대신 <code>quizViewModel.currentQuestionCheatStatus</code>, 즉 커닝 여부가 True일 때 경고성 토스트를 보여주도록 변경한다.</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (requestCode == REQUEST_CODE_CHEAT) &#123;</span><br><span class="line"><span class="comment">//            quizViewModel.isCheater = ... 을 아래의 코드로 변경</span></span><br><span class="line">            quizViewModel.currentQuestionCheatStatus =</span><br><span class="line">                <span class="keyword">data</span>?.getBooleanExtra(EXTRA_ANSWER_SHOWN, <span class="literal">false</span>) ?: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkAnswer</span><span class="params">(userAnswer: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> correctAnswer = quizViewModel.currentQuestionAnswer</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> messageResId = <span class="keyword">when</span> &#123;</span><br><span class="line"><span class="comment">//            quizViewModel.isCheater -&gt; R.string.judgment_toast</span></span><br><span class="line">            quizViewModel.currentQuestionCheatStatus -&gt; R.string.judgment_toast</span><br><span class="line">            userAnswer == correctAnswer -&gt; R.string.correct_toast</span><br><span class="line">            <span class="keyword">else</span> -&gt; R.string.incorrect_toast</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><p><a href="https://github.com/Jpub/AndroidBNR4/tree/main/Ch06/GeoQuiz">실무에 바로 적용하는 안드로이드 프로그래밍(제4판) : CHAPTER 6 코드</a></p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      
      <comments>http://june0122.github.io/2021/05/17/android-bnr-06/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Kotlin] Data Class</title>
      <link>http://june0122.github.io/2021/05/13/kotiln-data-class/</link>
      <guid>http://june0122.github.io/2021/05/13/kotiln-data-class/</guid>
      <pubDate>Thu, 13 May 2021 12:58:54 GMT</pubDate>
      
      <description>어떤 클래스가 데이터를 저장하는 역할만을 수행한다면 toString, equals, hashCode를 반드시 오버라이드해야 한다. IntelliJ 같은 IDE는 이러한 메소드들을 자동으로 정의해주고, 작성된 메소드의 정확성과 일관성을 검사해준다. 하지만 코틀린은 더 편리하다! 이제는 이런 메소드를 IDE를 통해 생성할 필요도 없이 data라는 변경자를 클래스 앞에 붙이면 필요한 메소드를 컴파일러가 자동으로 만들어준다. data 변경자가 붙은 클래스를 &lt;b&gt;데이터 클래스&lt;/b&gt;라고 부른다.</description>
      
      
      
      <content:encoded><![CDATA[<p>자바 플랫폼에서는 클래스가 <code>equals</code>, <code>hashCode</code>, <code>toString</code> 등의 메소드를 구현해야 한다. 다행히 자바 IDE들이 이런 메소드를 자동으로 생성해주긴 하지만 코드베이스가 번잡해지는건 변함이 없다.</p><p>코틀린 컴파일러는 한걸음 더 나가서 이런 메소드를 기계적으로 생성하는 작업을 보이지 않는 곳에서 해주기 때문에 필수 메소드로 인한 번잡함 없이 소스코드를 깔끔하게 유지 가능하다.</p><p>그런 코틀린의 원칙이 잘 드러나는 사례가 클래스 생성자나 프로퍼티 접근자를 컴파일러가 자동으로 만들어주는 것이다. 코틀린 컴파일러는 데이터 클래스에 유용한 메소드를 자동으로 만들어준다.</p><h2 id="1-모든-클래스가-정의해야-하는-메소드"><a class="markdownIt-Anchor" href="#1-모든-클래스가-정의해야-하는-메소드"></a> 1. 모든 클래스가 정의해야 하는 메소드</h2><p>자바와 마찬가지로 코틀린 클래스도 <code>toString</code>, <code>equals</code>, <code>hashCode</code> 등을 오버라이드할 수 있다. 각각이 어떤 메소드이고 어떻게 그런 메소드를 정의해야 하는지 살펴보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>이제 이 <strong>클래스의 인스턴스를 어떻게 문자열로 표현</strong>할지 생각해보자.</p><h3 id="1-1-문자열-표현-tostring"><a class="markdownIt-Anchor" href="#1-1-문자열-표현-tostring"></a> 1-1. 문자열 표현 : <code>toString()</code></h3><p>자바처럼 코틀린의 모든 클래스도 인스턴스의 문자열 표현을 얻을 방법을 제공한다. 주로 디버깅과 로깅 시 이 메소드를 사용한다.</p><blockquote><p>기본으로 제공되는 객체의 문자열 표현</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> client1 = Client(<span class="string">&quot;KAMIYU&quot;</span>, <span class="number">123456</span>)</span><br><span class="line">&gt;&gt;&gt; println(client1)</span><br><span class="line"></span><br><span class="line"><span class="symbol">Client@</span>61bbe9ba</span><br></pre></td></tr></table></figure><p>기본으로 제공되는 객체의 문자열 표현은 위와 같이 <code>Client@61bbe9ba</code> 같은 방식인데, 이 기본 구현을 바꾸려면 <code>toString</code> 메소드를 오버라이드해야 한다.</p><blockquote><p><code>Client</code>에 <code>toString()</code> 구현</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">&quot;Client(name=<span class="variable">$name</span>, postalCode=<span class="variable">$postalCode</span>)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> client1 = Client(<span class="string">&quot;KAMIYU&quot;</span>, <span class="number">123456</span>)</span><br><span class="line">&gt;&gt;&gt; println(client1)</span><br><span class="line"></span><br><span class="line">Client(name=KAMIYU, postalCode=<span class="number">123456</span>)</span><br></pre></td></tr></table></figure><p>이런 문자열 표현으로부터 기본 문자열 표현보다 더 많은 정보를 얻을 수 있다.</p><h3 id="1-2-객체의-동등성-equals"><a class="markdownIt-Anchor" href="#1-2-객체의-동등성-equals"></a> 1-2. 객체의 동등성 : <code>equals()</code></h3><p>Client 클래스를 사용하는 모든 계산은 클래스 밖에서 이뤄진다. Client는 단지 데이터를 저장할 뿐이며, 그에 따라 구조도 단순하고 내부 정보를 외부에 투명하게 노출하게 설계됐다. 그렇지만 클래스는 단순할지라도 동작에 대한 몇 가지 요구 사항이 있을 수 있다. 예를 들어 서로 다른 두 객체가 내부에 동일한 데이터를 포함하는 경우 그 둘을 동등한 객체로 간주해야 할 수도 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> client1 = Client(<span class="string">&quot;KAMIYU&quot;</span>, <span class="number">123456</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> client2 = Client(<span class="string">&quot;KAMIYU&quot;</span>, <span class="number">123456</span>)</span><br><span class="line">&gt;&gt;&gt; println(client1 == client2)</span><br><span class="line"></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>위 예제에서는 두 객체가 동일하지 않다. 이는 Client 클래스의 요구 사항을 만족시키고 싶다면 <code>equals</code>를 오버라이드 할 필요가 있다는 뜻이다.</p><ul><li>참고로 코틀린에서 <code>==</code> 연산자는 <strong>참조 동일성을 검사하지 않고 객체의 동등성을 검사</strong>한다. 따라서 <code>==</code> 연산은 <code>equals</code>를 호출하는 식으로 컴파일된다.<sup id = "a1"><a href="#f1">1</a></sup></li></ul><blockquote><p><code>Client</code>에 <code>equals()</code> 구현하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="literal">null</span> || other !<span class="keyword">is</span> Client) <span class="comment">// other가 Client인지 검사</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> name == other.name &amp;&amp; <span class="comment">// 두 객체의 프로퍼티 값 비교, 코틀린의 is 검사는 자바의 instanceof와 같다.</span></span><br><span class="line">                postalCode == other.postalCode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">&quot;Client(name=<span class="variable">$name</span>, postalCode=<span class="variable">$postalCode</span>)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>equals</code>를 오버라이드하고 나면 프로퍼티의 값이 모두 같은 두 Client 객체는 <strong>동등</strong>하리라 예상할 수 있다. 실제로 <code>client1 == client2</code>는 이제 true를 반환한다.</p><ul><li>하지만 Client 클래스로 더 복잡한 작업을 수행해보면 제대로 작동하지 않는 경우가 있다. 이와 관련해서 흔히 면접에서 질문하는 내용이 <strong>“Client가 제대로 작동하지 않는 경우를 말하고 문제가 무엇인지 설명하시오”</strong> 다. <code>hashCode</code> 정의를 빠뜨려서 그렇다고 답하는 개발자가 많을 것이다. 이 경우에는 실제 <strong><code>hashCode</code>가 없다는 점이 원인</strong>이다. 이제 왜 hashCode가 중요한지 알아보자.</li></ul><h3 id="1-3-해시-컨테이너-hashcode"><a class="markdownIt-Anchor" href="#1-3-해시-컨테이너-hashcode"></a> 1-3. 해시 컨테이너: <code>hashCode()</code></h3><p>자바에서는 <code>equals</code>를 오버라이드할 때 반드시 <code>hashCode</code>도 함께 오버라이드해야 한다. 이유는 다음과 같다.</p><p>원소가 'KAMIYU’라는 고객 하나뿐인 집합을 만들자. 그 후 새로 원래의 'KAMIYU’와 똑같은 프로퍼티를 포함하는 새로운 Client 인스턴스를 만들어서 그 인스턴스가 집합 안에 들어있는지 검사해보자. 프로퍼티가 모두 일치하므로 새 인스턴스와 집합에 있는 기존 인스턴스는 동등하다. 따라서 새 인스턴스가 집합에 속했는지 여부를 검사하면 true가 반환되리라 예상할 수 있다. <strong>하지만 실제로는 false가 나온다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> processed = hashSetOf(Client(<span class="string">&quot;KAMIYU&quot;</span>, <span class="number">123456</span>))</span><br><span class="line">&gt;&gt;&gt; println(processed.contains(Client(<span class="string">&quot;KAMIYU&quot;</span>, <span class="number">123456</span>)))</span><br><span class="line"></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>이는 Client 클래스가 <code>hashCode</code> 메소드를 정의하지 않았기 때문이다. JVM 언어에서는 <code>hashCode</code>가 지켜야 하는 <strong>“<code>equals()</code>가 true를 반환하는 두 객체는 반드시 같은 <code>hashCode()</code>를 반환해야 한다”</strong> 라는 제약이 있는데 이를 Client는 어기고 있기 때문이다.</p><p>processed 집합은 HashSet이다. HashSet은 원소를 비교할 때 비용을 줄이기 위해 먼저 객체의 해시 코드를 비교하고 해시 코드가 같은 경우에만 실제 값을 비교한다. 방금 본 예제의 두 Client 인스턴스는 해시 코드가 다르기 때문에 두 번째 인스턴스가 집합 안에 들어있지 않다고 판단한다. 해시 코드가 다를 때 <code>equals</code>가 반환하는 값은 판단 결과에 영향을 끼치지 못한다. 즉, 원소 객체들이 해시 코드에 대한 규칙을 지키지 않는 경우 HashSet은 제대로 작동할 수 없다. 이 문제를 고치려면 Client가 <code>hashCode</code>를 구현해야 한다.</p><blockquote><p>Client에 <code>hashCode()</code> 구현하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> = name.hashCode() * <span class="number">31</span> + postalCode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 이 클래스는 예상대로 작동한다. 하지만 지금까지 얼마나 많은 코드를 작성해야 했는지 생각해보라. 다행히 코틀린 컴파일러는 이 모든 메소드를 자동으로 생성해줄 수 있다. 어떻게 하면 코틀린이 이런 메소드를 생성하게 만들 수 있는지 살펴보자.</p><h2 id="2-데이터-클래스-모든-클래스가-정의해야-하는-메소드-자동-생성"><a class="markdownIt-Anchor" href="#2-데이터-클래스-모든-클래스가-정의해야-하는-메소드-자동-생성"></a> 2. 데이터 클래스: 모든 클래스가 정의해야 하는 메소드 자동 생성</h2><p>어떤 클래스가 데이터를 저장하는 역할만을 수행한다면 <code>toString</code>, <code>equals</code>, <code>hashCode</code>를 반드시 오버라이드해야 한다. IntelliJ 같은<br />IDE는 이러한 메소드들을 자동으로 정의해주고, 작성된 메소드의 정확성과 일관성을 검사해준다.</p><p>하지만 코틀린은 더 편리하다! 이제는 이런 메소드를 IDE를 통해 생성할 필요도 없이 <strong><code>data</code>라는 변경자를 클래스 앞에 붙이면 필요한 메소드를 컴파일러가 자동으로 만들어준다.</strong> <code>data</code> 변경자가 붙은 클래스를 <strong>데이터 클래스</strong>라고 부른다.</p><blockquote><p>Client를 데이터 클래스로 선언하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>이제 Client 클래스는 자바에서 요구하는 모든 메소드를 포함한다.</p><ul><li>인스턴스 간 비교를 위한 <code>equals</code></li><li>HashMap과 같은 해시 기반 컨테이너에서 키로 사용할 수 있는 <code>hashCode</code></li><li>클래스의 각 필드를 선언 순서대로 표시하는 문자열 표현을 만들어주는 <code>toString</code></li></ul><p><code>equals</code>와 <code>hashCode</code>는 주 생성자에 나열된 모든 프로퍼티를 고려해 만들어진다. 생성된 <code>equals</code> 메소드는 모든 프로퍼티 값의 동등성을 확인한다. <code>hashCode</code> 메소드는 모든 프로퍼티의 해시 값을 바탕으로 계산한 해시 값을 반환한다. 이때 주 생성자 밖에 정의된 프로퍼티는 <code>equals</code>나 <code>hashCode</code>를 계산할 때 고려의 대상이 아니라는 사실에 유의하라.</p><p>코틀린 컴파일러는 data 클래스에게 방금 말한 세 메소드뿐 아니라 몇 가지 유용한 메소드를 더 생성해준다.</p><h3 id="2-1-데이터-클래스와-불변성-copy-메소드"><a class="markdownIt-Anchor" href="#2-1-데이터-클래스와-불변성-copy-메소드"></a> 2-1. 데이터 클래스와 불변성: <code>copy()</code> 메소드</h3><p>데이터 클래스의 프로퍼티가 꼭 <code>val</code> 일 필요는 없다. 원한다면 <code>var</code> 프로퍼티를 써도 되지만 모든 프로퍼티를 읽기 전용으로 만들어서 데이터 클래스를 불변 <sup>immutable</sup> 클래스로 만들라고 권장한다. HashMap 등의 컨테이너에 데이터 클래스 객체를 담는 경우엔 불변성이 필수적이다. 데이터 클래스 객체를 키로 하는 값을 컨테이너애 담은 다음에 키로 쓰인 데이터 객체의 프로퍼티를 변경하면 컨테이너 상태가 잘못될 수 있다. 게다가 불변 객체를 사용하면 프로그램에 대해 훨씬 쉽게 추론할 수 있다. 특히 다중 스레드 프로그램의 경우 이런 성질은 더 중요하다. 불변 객체를 주로 사용하는 프로그램에서는 스레드가 사용 중인 데이터를 다른 스레드가 변경할 수 없으므로 스레드를 동기화해야 할 필요가 줄어든다.</p><p>데이터 클래스 인스턴스를 불변 객체로 더 쉽게 활용할 수 있게 코틀린 컴파일러는 <strong>객체를 복사하면서 일부 프로퍼티를 바꿀 수 있게 해주는 <code>copy</code> 메소드를 제공한다.</strong> 객체를 메모리상에서 직접 바꾸는 대신 복사본을 만드는 편이 더 낫다. 복사본은 원본과 다른 생명주기를 가지며, 복사를 하면서 일부 프로퍼티 값을 바꾸거나 복사본을 제거해도 프로그램에서 원본을 참조하는 다른 부분에 전혀 영향을 끼치지 않는다. Client의 <code>copy</code>를 직접 구현한다면 다음과 같을 것이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(name: <span class="type">String</span> = this.name, postalCode: <span class="type">Int</span> = this.postalCode)</span></span> = Client(name, postalCode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음은 <code>copy</code> 메소드를 사용하는 방법이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> kamiyu = Client(<span class="string">&quot;KAMIYU&quot;</span>, <span class="number">123456</span>)</span><br><span class="line">&gt;&gt;&gt; println(kamiyu.copy(postalCode = <span class="number">111000</span>))</span><br><span class="line"></span><br><span class="line">Client(name=KAMIYU, postalCode=<span class="number">111000</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-구조-분해-선언과-component-함수"><a class="markdownIt-Anchor" href="#2-2-구조-분해-선언과-component-함수"></a> 2-2. 구조 분해 선언과 component 함수</h3><p>구조 분해 선언 <sup>destructuring declaration</sup>이라는 개념에서 <strong>구조 분해를 사용하면 복합적인 값을 분해해서 여러 다른 변수를 한꺼번에 초기화 할 수 있다.</strong></p><blockquote><p>구조 분해 사용 방법</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> p = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> (x, y) = p</span><br><span class="line">&gt;&gt;&gt; println(x)</span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt;&gt;&gt; println(y)</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p><strong>구조 분해 선언</strong>은 일반 변수 선언과 비슷해 보인다. 다만 <strong><code>=</code>의 좌변에 여러 변수를 괄호로 묶었다</strong>는 점이 다르다.</p><p>내부에서 구조 분해 선언은 다시 관례를 사용한다. 구조 분해 선언의 각 변수를 초기화하기 위해 <code>componentN</code>이라는 함수를 호출한다. 여기서 <code>N</code>은 구조 분해 선언에 있는 변수 위치에 따라 붙는 번호다. 앞에서 살펴본 <code>val (x, y) = p</code>는 아래와 같이 컴파일된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (a,b) = p</span><br><span class="line">      ↓</span><br><span class="line"><span class="keyword">val</span> a = p.component1()</span><br><span class="line"><span class="keyword">val</span> b = p.component2()     </span><br></pre></td></tr></table></figure><p>data 클래스의 주 생성자에 들어있는 프로퍼티에 대해서는 컴파일러가 자동으로 <code>componentN</code> 함수를 만들어준다. 다음 예제는 데이터 타입이 아닌 클래스에서 이런 함수를 어떻게 구현하는지 보여준다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span> = x</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span> = y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// componentN 함수가 구현되어 있지 않다면 아래와 같은 오류를 보여준다.</span></span><br><span class="line"><span class="comment">// Destructuring declaration initializer of type Point must have a &#x27;component1()&#x27; function</span></span><br></pre></td></tr></table></figure><p>구조 분해 선언은 함수에서 여러 값을 반환할 때 유용하다. 여러 값을 한꺼번에 반환해야 하는 함수가 있다면 반환해야 하는 모든 값이 들어갈 데이터 클래스를 정의하고 함수의 반환 타입을 그 데이터 클래스로 바꾼다. 구조 분해 선언 구문을 사용하면 이런 함수가 반환하는 값을 쉽게 풀어서 여러 변수에 넣을 수 있다.</p><p>이런 동작을 보여주기 위해 파일 이름을 이름과 확장자로 나누는 함수를 작성해보자.</p><blockquote><p>구조 분해 선언을 사용해 여러 값 반환하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">NameComponents</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> extension: String) <span class="comment">// 값을 저장하기 위한 데이터 클래스를 선언</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">splitFileName</span><span class="params">(fullName: <span class="type">String</span>)</span></span> : NameComponents &#123;</span><br><span class="line">    <span class="keyword">val</span> result = fullName.split(<span class="string">&quot;.&quot;</span>, limit = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> NameComponents(result[<span class="number">0</span>], result[<span class="number">1</span>]) <span class="comment">// 함수에서 데이터 클래스의 인스턴스를 반환</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> (name, ext) = splitFileName(<span class="string">&quot;example.kt&quot;</span>) <span class="comment">// 구조 분해 선언 구문을 사용해 데이터 클래스를 푼다</span></span><br><span class="line">&gt;&gt;&gt; println(name)</span><br><span class="line">example</span><br><span class="line">&gt;&gt;&gt; println(ext)</span><br><span class="line">kt</span><br></pre></td></tr></table></figure><p>배열이나 컬렉션에도 <code>componentN</code> 함수가 있음을 안다면 위 예제를 더 개선할 수 있다. 크기가 정해진 컬렉션을 다루는 경우 구조 분해가 특히 더 유용하다. 예를 들어 여기서 split은 2개의 원소로 이뤄진 리스트를 반환한다.</p><blockquote><p>컬렉션에 대해 구조 분해 선언 사용하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">NameComponents</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> extension: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">splitFileName</span><span class="params">(fullName: <span class="type">String</span>)</span></span> : NameComponents &#123;</span><br><span class="line">    <span class="keyword">val</span> (name, ext) = fullName.split(<span class="string">&quot;.&quot;</span>, limit = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> NameComponents(name, ext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>물론 무한히 <code>componentN</code>을 선언할 수 없으므로 이런 구문을 무한정 사용할 수는 없다. 그럼에도 불구하고 여전히 컬렉션에 대한 구조 분해는 유용하다. 코틀린 표준 라이브러리에서는 맨 앞의 다섯 원소에 대한 <code>componentN</code>을 제공한다.</p><h4 id="구조-분해-선언과-루프"><a class="markdownIt-Anchor" href="#구조-분해-선언과-루프"></a> 구조 분해 선언과 루프</h4><p>함수 본문 내의 선언문뿐만 아니라 변수 선언이 들어갈 수 있는 장소라면 어디든 구조 분해 선언을 할 수 있다. 예를 들어 루프 안에서도 구조 분해 선언을 사용할 수 있다. 특히 Map의 원소에 대해 이터레이션할 때 구조 분해 선언이 유용하다.</p><blockquote><p>구조 분해 선언을 사용해 맵 이터레이션 하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printEntries</span><span class="params">(map: <span class="type">Map</span>&lt;<span class="type">String</span>, String&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ((key, value) <span class="keyword">in</span> map) &#123; <span class="comment">// 루프 변수에 구조 분해 선언 사용</span></span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$key</span> -&gt; <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">val</span> map = mapOf(<span class="string">&quot;Oracle&quot;</span> to <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;JetBrains&quot;</span> to <span class="string">&quot;Kotlin&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; printEntries(map)</span><br><span class="line">Oracle -&gt; Java</span><br><span class="line">JetBrains -&gt; Kotlin</span><br></pre></td></tr></table></figure><p>이 간단한 예제는 두 가지 코틀린 관례를 활용한다. 하나는 객체를 iteration하는 관례고, 다른 하나는 구조 분해 선언이다. 코틀린 표준 라이브러리에는 맵에 대한 확장 함수로 iterator가 들어있다. 그 iterator는 맵 원소에 대한 이터레이터를 반환한다. 따라서 자바와 달리 코틀린에서는 맵을 직접 이터레이션할 수 있다. 또한 코틀린 라이브러리는 Map.Entry에 대한 확장 함수로 <code>component1</code>과 <code>component2</code>를 제공한다. 위의 루프는 이런 확장 함수를 사용하는 아래의 코드와 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (entry <span class="keyword">in</span> map.entries) &#123;</span><br><span class="line">    <span class="keyword">val</span> key = entry.component1()</span><br><span class="line">    <span class="keyword">val</span> value = entry.component2()</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$key</span> -&gt; <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 예제는 코틀린 관례를 적용할 때 확장 함수가 얼마나 중요한 역할을 하는지 잘 보여준다.</p><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li><a href="http://www.acornpub.co.kr/book/kotlin-in-action#toc">Kotlin in Action</a> - 4.3절 <sup>171p</sup>, 7.4절 <sup>326p</sup></li><li><a href="https://kotlinlang.org/docs/data-classes.html#data-classes-and-destructuring-declarations">https://kotlinlang.org/docs/data-classes.html#data-classes-and-destructuring-declarations</a></li><li><a href="https://kotlinlang.org/docs/destructuring-declarations.html#example-returning-two-values-from-a-function">https://kotlinlang.org/docs/destructuring-declarations.html#example-returning-two-values-from-a-function</a></li></ul><hr /><p><b id = "f1"><sup> 1 </sup></b>  <a href="#a1"> 동등성 연산에 <code>==</code> 사용 ↩</a></p><blockquote><p><strong>동일하다</strong> : 두 객체가 완전히 같을 경우 / <strong>동등하다</strong> : 두 객체가 같은 정보를 같고 있을 경우</p></blockquote><p>자바에서는 <code>==</code>를 원시 타입과 참조 타입을 비교할 때 사용한다. 원시 타입의 경우 <code>==</code>는 두 피연사자의 값이 같은지 비교한다 <sup>동등성(equality)</sup>. 반면 참조 타입의 경우 <code>==</code>는 두 피연산자의 주소가 같은지를 비교한다 <sup>참조 비교(reference comparision)</sup>. 따라서 자바에서는 두 객체의 동등성을 알려면 <code>equals</code>를 호출해야 한다. 자바에서는 <code>equals</code> 대신 <code>==</code>를 호출하면 문제가 될 수 있다는 사실도 아주 잘 알려져 있다.</p><p>코틀린에서는 <code>==</code> 연산자가 두 객체를 비교하는 기본적인 방법이다. <code>==</code>는 내부적으로 <code>equals</code>를 호출해서 객체를 비교한다. 따라서 클래스가 <code>equals</code>를 오버라이드하면 <code>==</code>를 통해 안전하게 그 클래스의 인스턴스를 비교할 수 있다. 참조 비교를 위해서는 <code>===</code> 연산자를 사용할 수 있다. <code>===</code> 연산자는 자바에서 객체의 참조를 비교할 때 사용하는 <code>==</code> 연산자와 같다.</p><ul><li><code>==</code> 연산자는 자바와 코틀린에서 원시 타입의 비교에서는 동일하게 동작하지만, <strong>참조 타입의 비교에서는 다르게 동작한다.</strong><ul><li>자바의 참조 타입 비교 <code>==</code> : <strong>주소</strong>가 같은지를 비교</li><li>코틀린의 참조 타입 비교 <code>==</code> : 내부적으로 <code>equals</code>를 호출해서 주소 비교가 아닌 <strong>동등성</strong> 비교를 한다.</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Kotlin/">Kotlin</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      
      <comments>http://june0122.github.io/2021/05/13/kotiln-data-class/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] ViewModel과 SIS</title>
      <link>http://june0122.github.io/2021/05/13/android-bnr-04/</link>
      <guid>http://june0122.github.io/2021/05/13/android-bnr-04/</guid>
      <pubDate>Wed, 12 May 2021 17:30:08 GMT</pubDate>
      
      <description>&lt;b&gt;ViewModel&lt;/b&gt;은 특정 액티비티 화면과 연동되며, 해당 화면에 보여줄 데이터를 형식화하는 로직을 두기 좋은 곳이다. ViewModel은 모델 객체와 연동되어 모델을 &#39;장식한다&#39;. 즉, 모델 데이터를 화면에 보여주는 기능을 ViewModel이 수행한다. ViewModel을 사용하면 화면에서 필요한 모든 데이터를 한곳에서 종합하고 데이터를 형식화할 수 있다.</description>
      
      
      
      <content:encoded><![CDATA[<p>안드로이드는 적절한 시점에 대체 리소스를 제공하지만, 장치 회전에 따른 액티비티 소멸 및 재생성은 문제가 생길 수 있다. 회전 시 데이터가 초기화되는 결함을 해결하려면, 장치 회전 후에 재생성되는 MainActivity 인스턴스가 초기화 되는 데이터의 직전 값을 알아야 한다. 그러려면 장치 회전과 같은 런타임 구성 변경 시에 해당 데이터를 보존할 방법이 필요하다.</p><p><strong>ViewModel</strong>에 UI 데이터를 저장해 UI 상태가 유실되는 결함을 해결할 수 있다. 또한, 이보다는 덜 생기지만 여전히 문제가 많은 결함인 '프로세스 종료에 따른 UI 상태 유실’도 안드로이드의 인스턴스 상태 보존 메커니즘을 사용해 해결한다.</p><h2 id="viewmodel-의존성-추가하기"><a class="markdownIt-Anchor" href="#viewmodel-의존성-추가하기"></a> ViewModel 의존성 추가하기</h2><p>우선 <strong>ViewModel</strong> 클래스를 프로젝트에 추가한다. <strong>ViewModel</strong> 클래스는 안드로이드 Jetpack의 lifecycle-extensions(생명주기 확장) 라이브러리에 포함되어 제공되는데, 사용하려면 우선 프로젝트 <strong>의존성(dependencies)</strong> 에 lifecycle-extensions 라이브러리를 포함시켜야 한다.</p><p>프로젝트 의존성은 그래들(Gradle) 구성 파일인 build.gradle 파일에 지정한다(그래들은 안드로이드 앱의 빌드 도구다). 두 개의 build.gradle 파일 중 <em>build.gradle(Module: YourProject.app)</em>, 즉 app 모듈의 빌드 파일에 지정한다.</p><blockquote><p>build.gradle에 lifecycle-extensions 의존성 추가</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation <span class="string">&#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;androidx.lifecycle:lifecycle-extensions:2.2.0&#x27;</span> <span class="comment">// lifecycle-extensions library 포함시키기</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="viewmodel-추가하기"><a class="markdownIt-Anchor" href="#viewmodel-추가하기"></a> ViewModel 추가하기</h2><p><strong>ViewModel</strong>은 특정 액티비티 화면과 연동되며, 해당 화면에 보여줄 데이터를 형식화하는 로직을 두기 좋은 곳이다. ViewModel은 모델 객체와 연동되어 모델을 ‘장식한다’. 즉, 모델 데이터를 화면에 보여주는 기능을 ViewModel이 수행한다. ViewModel을 사용하면 화면에서 필요한 모든 데이터를 한곳에서 종합하고 데이터를 형식화할 수 있다.</p><p>android.lifecycle 패키지는 <strong>생명주기를 인식하는</strong> 컴포넌트를 비롯해서 생명주기 관련 API도 제공하며, ViewModel도 android.lifecycle 패키지의 일부다. 생명주기를 인식하는 컴포넌트는 액티비티와 같은 다른 컴포넌트의 생명주기를 관찰하고 상태를 고려해 작동한다.</p><p>구글에서는 액티비티 생명주기와 다른 컴포넌트 생명주기 처리를 쉽게 할 수 있도록 android.lifecycle 패키지와 이 패키지의 내용물(클래스나 인터페이스 등)을 만들었다. 이는 또다른 생명주기 인식 컴포넌트인 <strong>LiveData</strong> 및 <strong>백그라운드 스레드</strong> 내용과 연결된다.</p><blockquote><p>ViewModel 클래스 생성</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;QuizViewModel&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuizViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;ViewModel instance created&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewModel 인스턴스가 소멸되기 전에 호출됨</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCleared</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCleared()</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;ViewModel instance about to be destroyed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ViewModel 인스턴스 사용하기</p></blockquote><p>MainActivity.kt의 <code>onCreate(Bundle?)</code>에서 현재 액티비티를 QuizViewModel 인스턴스와 연결한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> provider: ViewModelProvider = ViewModelProvider(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> quizViewModel = provider.<span class="keyword">get</span>(QuizViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Got a QuizViewModel: <span class="variable">$quizViewModel</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        trueButton = findViewById(R.id.true_button)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ViewModelProvider</strong>는 ViewModel의 레지스트리처럼 작동한다. 즉, 액티비티(여기선 MainActivity) 인스턴스가 처음으로 QuizViewModel을 요청하면 ViewModelProvider가 새로운 QuizViewModel 인스턴스를 생성하고 반환한다. 그리고 장치 구성이 변경되어 새로 생성된 MainActivity 인스턴스가 QuizViewModel을 또 요청하면 QuizViewModel 인스턴스가 새로 생성되지 않고 최초 생성되었던 인스턴스가 반환된다. 또한, MainActivity 인스턴스가 종료되어(예를 들어, 사용자가 백 버튼을 눌러서) 소멸될 때는 QuizViewModel 인스턴스도 같이 메모리에서 제거된다.</p><h2 id="viewmodel-생명주기와-viewmodelprovider"><a class="markdownIt-Anchor" href="#viewmodel-생명주기와-viewmodelprovider"></a> ViewModel 생명주기와 ViewModelProvider</h2><p>사용자가 액티비티를 끝낸다는 것은 그 당시 UI 상태가 더 이상 필요 없음을 의미하므로 상태 데이터를 초기화하면 된다. 이와 달리 사용자가 장치를 회전해서 액티비티 화면의 방향이 바뀔 때는 회전 이전과 이후의 UI 상태는 같아야 한다. 사용자는 계속 같은 화면을 볼 수 있기를 기대하기 때문이다.</p><p>액티비티의 <code>isFinishing</code> 속성으로 이런 두 가지 시나리오 중 어느 것에 해당되는지 판단할 수 있다.</p><ol><li>만일 <code>isFinishing</code>이 <em>true</em>면 사용자가 액티비티를 끝냈음을 의미한다(예를 들어, 백 버튼을 누르거나 오버뷰 화면에서 해당 앱 카드를 없앴을 때).<ul><li>따라서 현재의 액티비티 인스턴스가 소멸되더라도 이 당시의 UI 상태는 보존할 필요가 없다.</li></ul></li><li>그렇지 않고 <code>isFinishing</code>이 <em>false</em>면 장치의 회전에 따른 구성 변경으로 인해 시스템이 현재의 액티비티 인스턴스를 소멸시킨다는 것을 의미한다.<ul><li>따라서 사용자가 계속 같은 화면을 볼 수 있도록 UI 상태가 보존되어야 한다.</li><li>이때 ViewModel을 사용하면 다른 방법을 사용하지 않아도 액티비티의 UI 상태 데이터를 메모리에 보존할 수 있다.</li></ul></li></ol><p>ViewModel의 생명주기는 사용자의 기대를 더 잘 반영하는데, 이는 장치의 구성 변경이 생겨도 계속 존재하다가 액티비티가 종료될 때만 소멸되기 때문이다.</p><p>위의 MainActivity 코드에서 했던 것처럼, ViewModel 인스턴스는 액티비티 생명주기와 <strong>연동</strong>된다. ViewModel 인스턴스는 액티비티 상태 변화와 무관하게 액티비티가 종료될 때까지 메모리에 남아 있다가 액티비티가 종료되면 소멸된다.</p><blockquote><p>MainActivity와 연동되는 QuizViewModel</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/117375186-79534980-af09-11eb-9d42-cffb5f598d8d.jpeg'></p><p>장치의 회전 등에 따른 구성 변경이 생길 때마다 현재의 액티비티 인스턴스는 소멸되고 다시 새 인스턴스가 생성되지만, 액티비티와 연관되는 ViewModel은 메모리에 남는다.</p><blockquote><p>장치 회전 시 MainActiviy와 QuizViewModel</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/117375538-2a59e400-af0a-11eb-91ee-c38bdeeefc99.jpeg'></p><h3 id="로그캣으로-확인해보기"><a class="markdownIt-Anchor" href="#로그캣으로-확인해보기"></a> 로그캣으로 확인해보기</h3><blockquote><p>QuizViewModel의 인스턴스가 생성됨</p></blockquote><p>앱 실행 시, MainActivity 인스턴스가 생성되고 <code>onCreate(Bundle?)</code>에서 최초로 ViewModel을 요청할 때 새로운 QuizViewModel 인스턴스가 생성됨을 알 수 있다.</p><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/117377004-3f844200-af0d-11eb-87cc-e6b8f4bf4a02.png'></p><blockquote><p>장치 회전 시, MainActivity 인스턴스는 소멸되지만 QuizViewModel 인스턴스는 남아있음</p></blockquote><p>장치 회전 시, MainActivity 인스턴스는 소멸되지만 QuizViewModel 인스턴스는 남아있음을 알 수 있다. 장치가 회전된 후 새로운 MainActivity 인스턴스가 생성될 대 QuizViewModel을 다시 요청한다. 그런데 이전에 생성된 QuizViewModel 인스턴스가 여전히 메모리에 남아있으므로 ViewModelProvide는 새 인스턴스를 생성하지 않고 기존 인스턴스를 반환한다. (<code>QuizViewModel@5a77eca</code>를 그대로 사용하는 것을 확인할 수 있다.)</p><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/117377521-698a3400-af0e-11eb-89e7-143ff01b4a43.png'></p><blockquote><p>MainActivity 인스턴스와 QuizViewModel 인스턴스가 모두 소멸됨</p></blockquote><p>백 버튼을 누르면 MainActivity 인스턴스가 소멸될 때 QuizViewModel 인스턴스도 같이 소멸됨을 알 수 있다. 이때 QuizViewModel의 <code>onCleared()</code>가 호출된다.</p><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/117377794-0d73df80-af0f-11eb-882e-4e2e9f4e9d04.png'></p><p>MainActivity와 QuizViewModel 간의 관계는 <strong>단방향</strong>이다. 즉, <strong>액티비티는 ViewModel을 참조하지만, ViewModel은 액티비티를 참조하지 않는다.</strong> ViewModel은 액티비티나 다른 뷰의 참조를 가지면 안 된다. <strong>메모리 유실(memory leak)</strong> 이 생길 수 있기 때문이다.</p><p>소멸되어야 하는 객체의 참조를 다른 객체가 가지면 메모리 유실이 생길 수 있다. 이때 참조되는 객체를 가비지 컬렉터가 메모리에서 제거할 수 없게 된다(이것을 강한 참조(strong reference)라고 한다). 구성 변경으로 인한 메모리 유실은 흔히 생기는 결함이다.</p><p>장치 회전 시에 액티비티 인스턴스는 소멸되지만, ViewModel 인스턴스는 메모리에 남는다. 그런데 ViewModel 인스턴스가 액티비티 인스턴스에 대해 강한 참조를 가지면 다음 두 가지 문제가 생길 수 있다.</p><ol><li>액티비티 인스턴스가 메모리에서 제거되지 않아 이 인스턴스가 사용하는 메모리가 유실된다.</li><li>ViewModel 인스턴스가 과거 액티비티의 뷰를 변경하려고 하면 IllegalStateException이 발생한다.</li></ol><h3 id="viewmodel에-데이터-추가하기"><a class="markdownIt-Anchor" href="#viewmodel에-데이터-추가하기"></a> ViewModel에 데이터 추가하기</h3><blockquote><p>QuizViewModel에 모델 데이터와 비즈니스 로직 추가하기</p></blockquote><ul><li><code>currentQuestionAnswer</code>와 <code>currentQuestionText</code>는 연산 프로퍼티 <sup>속성</sup>이다.<ul><li>이것은 다른 프로퍼티의 값을 사용해서 산출된 값을 자신의 값으로 반환하므로 이 프로퍼티의 값을 저장하는 필드 <sup>backing field</sup>가 클래스 인스턴스에 생기지 않는다.</li><li><code>get()</code>은 프로퍼티의 값을 반환하는 접근자 <sup>accessor</sup>이다.</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuizViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 모델 데이터  추가 ↓</span></span><br><span class="line">    <span class="keyword">var</span> currentIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> questionBank = listOf(</span><br><span class="line">        Question(R.string.question_australia, <span class="literal">true</span>),</span><br><span class="line">        Question(R.string.question_oceans, <span class="literal">true</span>),</span><br><span class="line">        Question(R.string.question_mideast, <span class="literal">false</span>),</span><br><span class="line">        Question(R.string.question_africa, <span class="literal">false</span>),</span><br><span class="line">        Question(R.string.question_americas, <span class="literal">true</span>),</span><br><span class="line">        Question(R.string.question_asia, <span class="literal">true</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 비즈니스 로직 추가 ↓</span></span><br><span class="line">    <span class="keyword">val</span> currentQuestionAnswer: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = questionBank[currentIndex].answer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> currentQuestionText: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = questionBank[currentIndex].textResId</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">moveToNext</span><span class="params">()</span></span> &#123;</span><br><span class="line">        currentIndex = (currentIndex + <span class="number">1</span>) % questionBank.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ViewModel은 사용하기 쉽도록 자신과 연관된 화면에서 필요한 모든 데이터를 저장하고 형식화한다. 따라서 프레젠테이션 로직 코드를 액티비티와 분리할 수 있어서 액티비티를 좀 더 간단하게 유지할 수 있다.<ul><li>가능한 한 액티비티를 간단히 유지하는 것이 좋은 이유는 액티비티에 추가되는 모든 코드는 뜻하지 않게 액티비티 생명주기의 영향을 받을 수 있기 때문이다.</li><li>간단하게 유지하면 액티비티는 화면에 나타나는 것을 처리하는 것만 집중하고, 보여줄 데이터를 결정하는 내부로직은 신경 쓰지 않아도 된다.</li></ul></li></ul><blockquote><p>늦게 초기화되는 QuizViewModel</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// by lazy 키워드 사용</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> quizViewModel: QuizViewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(QuizViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>by lazy</code> 키워드를 사용하면 quizViewModel을 var이 아닌 val 속성으로 선언할 수 있어 좋다.<ul><li>액티비티 인스턴스가 생성될 떼 QuizViewModel 인스턴스 참조를 quizViewModel에 한번만 저장하기 때문.</li></ul></li><li>또한, <code>by lazy</code> 키워드를 사용하면 최초로 quizViewModel이 사용될 때까지 초기화를 늦출 수 있다.<ul><li>MainActivity 인스턴스가 생성된 후 호출되는 <code>onCreate(Bundle?)</code>에서 quizViewModel이 사용되므로 이때 quizViewModel이 QuizViewModel 인스턴스 참조로 초기화되어 안전하게 사용할 수 있다.</li></ul></li></ul><blockquote><p>QuizViewModel로부터 문제, 정답 및 인덱스 가져오기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        nextButton.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">// currentIndex = (currentIndex + 1) % questionBank.size</span></span><br><span class="line">            quizViewModel.moveToNext()</span><br><span class="line">            updateQuestion()</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateQuestion</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// val questionTextResId = questionBank[currentIndex].textResId</span></span><br><span class="line">        <span class="keyword">val</span> questionTextResId = quizViewModel.currentQuestionText</span><br><span class="line">        questionTextView.setText(questionTextResId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkAnswer</span><span class="params">(userAnswer: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// val correctAnswer = questionBank[currentIndex].answer</span></span><br><span class="line">        <span class="keyword">val</span> correctAnswer = quizViewModel.currentQuestionAnswer</span><br><span class="line">        ...</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure><p>ViewModel을 사용함으로써 회전하기 직전에 보던 문제를 MainActivity가 기억해서 보여준다. 이로써 장치 회전으로 생긴 UI 상태 유실 결함은 해결되었다. 하지만 아직 눈에 띄지 않는 또 다른 결함이 있다.</p><h2 id="프로세스-종료-시에-데이터-보존하기"><a class="markdownIt-Anchor" href="#프로세스-종료-시에-데이터-보존하기"></a> 프로세스 종료 시에 데이터 보존하기</h2><p>안드로이드 운영체제가 앱의 프로세스를 소멸시킬 때는 메모리에 있는 앱의 모든 액티비티들과 ViewModel들이 제거되지만, 액티비티나 ViewModel의 그 어떤 생명주기 콜백 함수도 호출하지 않는다.</p><p>그렇다면 액티비티가 소멸될 때 UI 상태 데이터를 보존해 액티비티의 재구성에 사용할 수 있는 방법은 무엇일까? <strong>SIS(Saved Instance State, 저장된 인스턴스 상태)</strong> 에 데이터를 저장하는 것이 방법이 될 수 있다. SIS는 안드로이드 운영체제가 일시적으로 액티비티 외부에 저장하는 데이터이며, <code>Activity.onSaveInstanceState(Bundle)</code>을 오버라이드해 SIS에 데이터를 추가할 수 있다.</p><p>액티비티가 ‘중단’ 상태로 바뀔 때는 언제든지 안드로이드 운영체제가 <code>Activity.onSaveInstanceState(Bundle)</code>을 호출한다. 중단된 액티비티는 <strong>종료 대상</strong>이 되므로 이때 시점이 중요하다. 만일 우선순위가 낮은 백그라운드 앱이라서 앱의 프로세스가 종료된다면 <code>Activity.onSaveInstanceState(Bundle)</code>이 이미 호출되었다고 생각하면 된다.</p><p>액티비티의 슈퍼 클래스에 기본 구현된 <code>onSaveInstanceState(Bundle)</code>에서는 현재 액티비티의 모든 뷰가 자신들의 상태를 Bundle 객체의 데이터로 저장한다. Bundle은 문자열 키와 값을 쌍으로 갖는 구조체다. <code>onCreate(Bundle?)</code>의 인자로 전달되는 Bundle 객체를 앞에서 이미 보았다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 오버라이드한 <code>onCreate(Bundle?)</code>에서는 인자로 받은 Bundle 객체를 액티비티의 슈퍼 클래스에 정의된 <code>onCreate(Bundle?)</code>에 전달해 호출한다. 그러면 슈퍼 클래스의 <code>onCreate(Bundle?)</code>에서는 인자로 받은 Bundle 객체에 저장된 뷰들의 상태 데이터를 사용해서 액티비티의 뷰 계층을 다시 생성한다.</p><h3 id="onsaveinstancestatebundle-오버라이드하기"><a class="markdownIt-Anchor" href="#onsaveinstancestatebundle-오버라이드하기"></a> <code>onSaveInstanceState(Bundle)</code> 오버라이드하기</h3><ul><li>액티비티의 슈퍼 클래스에 기본 구현된 <code>onSaveInstanceState(Bundle)</code>에서는 현재 액티비티의 모든 뷰가 자신들의 상태를 <strong>Bundle</strong> 객체의 데이터로 저장</li><li>액티비티에서 <code>onSaveInstanceState(Bundle)</code>을 오버라이드하면 추가적으로 <strong>Bundle</strong> 객체에 데이터를 저장 가능하며 <code>onCreate(Bundle?)</code>에서 다시 받을 수 있다.</li></ul><blockquote><p>키로 이용할 상수 추가하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> KEY_INDEX = <span class="string">&quot;index&quot;</span>   <span class="comment">// Bundle 객체에 저장될 데이터의 키로 사용</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>onSaveInstanceState(Bundle)</code> 오버라이드하기</p></blockquote><ul><li>currentIndex의 값을 <strong>Bundle</strong> 객체에 저장<ul><li>이때 키는 상수인 KEY_INDEX이며 키의 값은 currentIndex다.</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSaveInstanceState</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onSaveInstanceState(savedInstanceState)</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;onSaveInstanceState&quot;</span>)</span><br><span class="line">    savedInstanceState.putInt(KEY_INDEX, quizViewModel.currentIndex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>onCreate(Bundle?)</code>에서 Bundle 객체 값 확인하기</p></blockquote><ul><li>마지막으로 <code>onCreate(Bundle?)</code>에서는 <strong>Bundle</strong> 객체에 저장된 값을 확인해 값이 있으면 그 값을 currentIndex에 지정하면 된다.<ul><li>키(“index”)가 <strong>Bundle</strong> 객체에 없거나 <strong>Bundle</strong> 객체 참조가 null이면 currentIndex의 값을 0으로 설정한다.</li></ul></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;onCreate(Bundle?) called&quot;</span>)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> currentIndex = savedInstanceState?.getInt(KEY_INDEX, <span class="number">0</span>) ?: <span class="number">0</span></span><br><span class="line">    quizViewModel.currentIndex = currentIndex</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>onCreate(Bundle?)</code>에서는 null이 될 수 있는 Bundle 객체 참조를 인자로 받는다.<ul><li>액티비티의 새로운 인스턴스가 최초로 생성될 때는 상태 데이터가 없으므로 Bundle 객체 참조가 null이 되기 때문.</li><li>하지만 장치 회전이나 프로세스 종료 후에 액티비티 인스턴스가 다시 생성될 때는 Budle 객체 참조가 null이 아니며, 이때는 <code>onSaveInstanceState(Bundle)</code>에서 추가한 키와 값의 쌍으로 된 데이터가 Bundle 객체에 포함된다.</li></ul></li><li>물론 Bundle 객체에는 프레임워크에서 추가한 정보 <sup>예로, EditText의 값이나 다른 기본 UI 위젯의 상태 데이터</sup>도 포함될 수 있다.</li></ul><h3 id="복원-테스트-해보기"><a class="markdownIt-Anchor" href="#복원-테스트-해보기"></a> 복원 테스트 해보기</h3><p><code>설정 → 개발자 옵션</code>에서 '앱’으로 표시된 항목의 ‘활동 유지 안함’ 옵션을 활성화하여 사용자가 종료하면 즉시 모든 작업을 삭제시킬 수 있다.</p><br><p align = 'center'><img width = '350' src = 'https://user-images.githubusercontent.com/39554623/118005347-4552ab00-b385-11eb-8498-0df8c37d2aa4.jpeg'></p><blockquote><p>‘활동 유지 안함’ 비활성화 상태에서 홈 버튼 클릭</p></blockquote><ul><li><code>onDestroy()</code> 호출이 되지 않아 액티비티가 소멸하지 않고 중단된 상태로 유지된다.</li></ul><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/118004486-767eab80-b384-11eb-8220-6654ccf5e54c.png'></p><blockquote><p>‘활동 유지 안함’ 활성화에서 홈 버튼 클릭</p></blockquote><ul><li><code>onDestroy()</code> 호출이 되어 중단 상태의 액티비티가 소멸되어 메모리에서 제거된다.</li><li>따라서 새로 생성된 액티비티 인스턴스의 <code>onCreate(Bundle?)</code>에서는 소멸된 인스턴스에서 <strong>Bundle</strong> 객체에 저장했던 문제의 인덱스를 사용해서 현재 액티비티 인스턴스의 문제 인덱스를 복원할 수 있다.</li></ul><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/118004652-9a41f180-b384-11eb-9d05-9db2e73897f1.png'></p><p><code>onSaveInstanceState(Bundle)</code>를 오버라이드하여 Bundle 객체에 저장하지 않았을 때는 홈 버튼 클릭 후 다시 앱을 실행시키면 홈 버튼을 누를 당시의 문제가 유지되지 않고 첫번째 문제 인덱스인 '캔버라는 호주의 수도이다’가 표시되지만, <code>onSaveInstanceState(Bundle)</code>를 오버라이드하여 Bundle 객체에 currentIndex 값을 저장시키면 홈 버튼 클릭 후 다시 앱을 실행시켜도 홈 버튼을 누를 당시의 문제가 그대로 보인다. 아래 이미지에서 ‘수에즈 운하는 홍해와 인도양을 연결한다’ 문제가 그대로 유지되고 있는 것을 확인할 수 있다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/118008961-944e0f80-b388-11eb-942a-8b0a3fa10b26.gif'></p><p>위의 테스트에서는 액티비티가 확실하게 메모리에서 제거되도록 하기 위해 임시로 ‘활동 유지 안함’ 옵션을 활성화했지만, 이 경우에는 성능 저하가 생길 수 있으므로 테스트가 끝나면 해당 옵션을 비활성화 하도록 한다. 홈 버튼 대신 백 버튼을 누르면 ‘활동 유지 안함’ 옵션과는 무관하게 항상 액티비티가 소멸된다는 사실을 알아두자.</p><h3 id="sis와-액티비티-레코드"><a class="markdownIt-Anchor" href="#sis와-액티비티-레코드"></a> SIS와 액티비티 레코드</h3><p>액티비티(프로세스)의 소멸에도 어떻게 <code>onSaveInstanceState(Bundle)</code>에 저장된 데이터가 존속할까? <code>onSaveInstanceState(Bundle)</code>이 호출될 때 데이터가 저장된 Bundle 객체는 안드로이드 운영체제에 의해 <strong>액티비티 레코드 <sup>activity record</sup></strong> 로 저장되기 때문이다.</p><p>아래는 액티비티 레코드가 무엇인지 알기 위해 액티비티 생명주기에 <strong>보존 <sup>stashed</sup></strong> 상태가 추가된 이미지이다.</p><blockquote><p>완전한 액티비티 생명주기</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/117900138-95892900-b303-11eb-84f7-236f8cce68a0.jpeg'></p><p>액티비티가 보존 상태이면 액티비티 인스턴스는 존재하지 않지만, 액티비티 레코드 객체는 안드로이드 운영체제에 살아있다. 따라서 안드로이드 운영체제는 해당 액티비티 레코드를 사용해서 액티비티를 되살릴 수 있다.</p><p>액티비티는 <code>onDestroy()</code>가 호출되지 않고 보존 상태가 될 수 있다. 그러므로 장치에 이상이 생기지 않는 한, <code>onStop()</code>과 <code>onSaveInstanceState(Bundle)</code>이 호출되는 거에 의존해서 코드를 작성하면 된다. 일반적으로는 현재 액티비티에 속하는 작고 일시적인 상태 데이터를 Bundle 객체에 보존하기 위해 <code>onSaveInstanceState(Bundle)</code>을 오버라이드 한다. 그리고 지속해서 저장할 데이터(예로, 사용자가 입력/수정한 것)는 <code>onStop()</code>을 오버라이드해서 처리한다. 이 함수가 실행된 후에는 언제든 해당 액티비티가 소멸될 수 있기 때문이다.</p><p>그런데 액티비티 레코드는 언제 없어질까? 액티비티가 종료되면 액티비티 레코드도 같이 소멸된다. 액티비티 레코드는 장치가 다시 부팅될 때도 폐기된다.</p><h2 id="viewmodel-vs-sis"><a class="markdownIt-Anchor" href="#viewmodel-vs-sis"></a> ViewModel vs SIS</h2><p>SIS에는 프로세스가 종료될 때는 물론이고, 장치의 구성 변경이 생길 때도 Bundle 객체를 사용해서 액티비티 레코드를 저장할 수 있다. 액티비티가 최초 실행될 때는 SIS의 Bundle 객체 참조가 null이다. 그리고 장치를 회전하면 안드로이드 운영체제가 현재 액티비티 인스턴스의 <code>onSaveInstanceState(Bundle)</code>을 호출하므로 보존할 상태 데이터를 이 함수에서 Bundle 객체에 저장할 수 있다. 그리고 이후에 새로운 액티비티 인스턴스가 생성되면 안드로이드 운영체제가 Bundle 객체에 저장된 상태 데이터를 <code>onCreate(Bundle?)</code>의 인자로 전달한다.</p><p>그렇다면 SIS만 사용해도 충분한데, GeoQuiz 앱에서는 굳이 ViewModel도 같이 사용할까? 사실 GeoQuiz 앱은 간단해서 SIS만 사용해도 된다.</p><p>그러나 대부분의 앱은 GeoQuiz처럼 작으면서 하드코딩된 데이터에 의존하지 않는다. 대신에 데이터베이스, 인터넷, 또는 둘 다로부터 동적인 데이터를 가져온다. 그리고 이런 작업은 비동기적이면서 느릴 수 있으며, 장치의 배터리나 네트워크 리소스를 많이 사용한다. 또한, 이런 작업을 액티비티 생명주기와 결속해서 처리하면 오류도 많이 생길 수 있다.</p><p>ViewModel의 진가는 액티비티의 동적 데이터를 처리할 때 발휘된다. ViewModel은 장치의 구성 변경이 생겨도 다운로드 작업을 계속할 수 있게 해준다. 그리고 이미 알고 있듯이, 사용자가 액티비티를 끝내면 ViewModel은 자동으로 클린업이 된다.</p><p>하지만 프로세스가 종료되면 ViewModel이 처리하지 못한다. 자신이 가진 모든 것이 프로세스와 함께 메모리에서 완전히 제거되기 때문이다. SIS가 주목받는 이유가 바로 이 때문이다. 그런데 SIS에는 제약이 있다. SIS는 직렬화되어 <sup>serialized</sup> 디스크에 저장되므로 크거나 복잡한 객체를 저장하는 것은 피해야 한다.</p><p>그런데 구글 안드로이드 팀의 적극적인 ViewModel 개선 작업으로 <code>lifecycle-viewmodel-savedstate</code> 라이브러리가 새로 배포되었는데, 이 라이브러리는 프로세스가 종료될 때 ViewModel이 자신의 상태 데이터를 보존할 수 있게 해준다. 따라서 액티비티의 SIS와 더불어 ViewModel 사용할 때의 어려움을 덜어줄 것이다.</p><p>이제는 ViewModel이나 SIS 중 어느 것이 더 좋은가는 문제되지 않으므로 두 가지를 절충해서 사용하면 된다.</p><ul><li>UI 상태를 다시 생성하기 위해 필요한 소량의 정보를 저장할 때 -&gt; <strong>SIS</strong></li><li>장치의 구성 변경이 생겨서 UI에 넣는데 필요한 많은 데이터에 빠르고 쉽게 접근하고자 메모리에 캐싱할 때 -&gt; <strong>ViewModel</strong></li></ul><p>프로세스가 종료된 후 액티비티 인스턴스가 다시 생성될 때는 SIS 데이터를 사용해서 ViewModel을 설정할 수 있다. 이렇게 하면 ViewModel과 액티비티가 절대 소멸되지 않는 것처럼 처리할 수 있다.</p><p>그런데 장치의 구성 변경 후에 SIS 데이터를 사용해서 ViewModel을 변경하면 앱에서 불필요한 작업을 하게 된다. 구성 변경 시에는 ViewModel이 메모리에 남아 있기 때문이다. 또한, ViewModel의 변경 작업으로 사용자가 기다리게 되거나 쓸데없이 리소스 <sup>배터라</sup>를 사용하게 된다.</p><p>이 문제를 해결하려면 ViewModel의 데이터를 변경하기 위해 더 많은 작업이 필요할 때는 ViewModel의 데이터 갱신이 필요한지 먼저 검사한 후에 데이터를 가져오는 작업을 수행하고 변경한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeFancyViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setCurrentIndex</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index != currentIndex) &#123;</span><br><span class="line">            currentIndex = index</span><br><span class="line">            <span class="comment">// 현재의 문제를 데이터베이스에서 로드한다.</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 문제의 인덱스 값을 현재의 인덱스 값과 비교해서 다를 때만 해당 인덱스의 문제를 데이터베이스 등에서 새로 가져온다. 같으면 이미 문제를 갖고 있는 것이기 때문이다. 따라서 필요할 때만 ViewModel 데이터의 변경 작업이 수행된다.</p><p>장기간 저장하는 데이터의 경우에는 ViewModel이나 SIS 모두 해결책이 아니다. 따라서 액티비티의 상태와 무관하게 앱이 장치에 설치되어 있는 동안 계속 남아 있어야 할 데이터를 저장해야 한다면 다른 영구 저장소를 사용해야한다. 이때 데이터베이스와 shared preference를 사용할 수 있다.</p><h2 id="섣부른-해결책-피하기"><a class="markdownIt-Anchor" href="#섣부른-해결책-피하기"></a> 섣부른 해결책 피하기</h2><p>장치의 구성 변경으로 인한 앱의 결함(UI 상태 유실)을 앱 회전을 비활성화해서 해결하려는 시도는 장치 회전에 따른 문제는 해결하겠지만, 앱의 다른 결함을 일으키기 쉽다. 개발이나 테스트할 때는 잘 나타나지 않지만, 사용자는 틀림없이 생명주기와 관련해서 다음 두 가지 결함에 직면할 여지를 남기기 때문이다.</p><ol><li>런타임 시에 생길 수 있는 구성 변경이 있다.<ul><li>창 크기 조정이나 야간 모드 변경 등의 구성 변경이 예시이다. 물론 이런 구성 변경도 별도로 잡아내어 무시하거나 처리할 수 있을 것이다. 하지만 런타임 구성 변경에 따라 올바른 리소스를 자동 선택해주는 시스템의 기능을 비활성화시키기 때문에 나쁜 방법이다.</li></ul></li><li>회전의 비활성화나 첫째 방법과 같은 구성 변경 처리는 프로세스 중단으로 인한 문제를 해결하지 못한다.<ul><li>따라서 앱에서 필요해서 가로나 세로 방향으로 고정시키고 싶다고 하더라도 구성 변경과 프로세스 중단에 대비하는 코드를 여전히 작성해야 한다. 이를 위해선 ViewModel과 SIS를 잘 알아야 한다.</li></ul></li></ol><h2 id="jetpack-androidx-그리고-아키텍처-컴포넌트"><a class="markdownIt-Anchor" href="#jetpack-androidx-그리고-아키텍처-컴포넌트"></a> Jetpack, AndroidX 그리고 아키텍처 컴포넌트</h2><p>ViewModel을 포함하는 <code>lifecycle-extensions</code>와 <code>lifecycle-viewmodel</code> 라이브러리는 안드로이드 Jetpack 컴포넌트의 일부다. 줄여서 Jetpack이라고 하는 안드로이드 Jetpack 컴포넌트는 안드로이드 앱 개발을 더욱더 쉽게 하고자 구글이 만든 라이브러리의 모음이며, <a href="https://developer.android.com/jetpack">developer.android.com/jetpack</a>에서 모든 Jetpack 라이브러리의 내역을 볼 수 있다. <strong>app</strong> 모듈의 build.gradle 파일에 해당 라이브러리의 의존성을 추가하면 어떤 Jetpack 라이브러리도 프로젝트에 포함시킬 수 있다.</p><p>각 Jetpack 라이브러리는 androidx 네임스페이스로 시작하는 패키지에 위치한다. 이러한 이유로 때로는 'AndroidX’와 'Jetpack’을 혼용하기도 한다.</p><p>Jetpack 라이브러리는 <strong>기반(foundation), 아키텍처(architecture), 행동(behavior), UI</strong>의 네 가지 범주로 분류된다. 이 중에서 아키텍처 범주의 라이브러리들을 <strong>아키텍처 컴포넌트 <sup>architecture components</sup></strong> 라고도 한다. ViewModel도 이런 아키텍처 컴포넌트 중 하나다. 다른 주요 아키텍처 컴포넌트는 <strong>Room</strong>, <strong>Data Binding</strong>, <strong>WorkManager</strong>가 있다.</p><p>일부 Jetpack 컴포넌트들은 완전히 새로운 것인 반면에, 다른 컴포넌트는 지원 라이브러리 <sup>support library</sup>로 불렸던 이전의 많은 라이브러리를 소수의 더 큰 라이브러리로 모아 놓은 것이다. 따라서 이제부터는 종전의 지원 라이브러리 대신 Jetpack(AndroidX) 버전을 사용한다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      
      <comments>http://june0122.github.io/2021/05/13/android-bnr-04/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] 액티비티 생명주기</title>
      <link>http://june0122.github.io/2021/05/08/android-bnr-03/</link>
      <guid>http://june0122.github.io/2021/05/08/android-bnr-03/</guid>
      <pubDate>Sat, 08 May 2021 00:53:46 GMT</pubDate>
      
      <description>Activity의 모든 인스턴스는 생명주기를 갖는다. 그리고 생명주기 동안에 액티비티는 네 가지 상태, 즉 실행 재개(resumed), 일시 중지(paused), 중단(stopped), 존재하지 않음(non-existent)으로 상호 전환된다. 또한, 각 전환이 발생할 때 액티비티에 상태 변경을 알려주는 Activity 함수들이 있으며, 이 함수들은 안드로이드가 자동 호출한다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="액티비티-상태와-생명주기-콜백"><a class="markdownIt-Anchor" href="#액티비티-상태와-생명주기-콜백"></a> 액티비티 상태와 생명주기 콜백</h2><p>Activity의 모든 인스턴스는 생명주기를 갖는다. 그리고 생명주기 동안에 액티비티는 네 가지 상태, 즉 실행 재개(resumed), 일시 중지(paused), 중단(stopped), 존재하지 않음(non-existent)으로 상호 전환된다. 또한, 각 전환이 발생할 때 액티비티에 상태 변경을 알려주는 Activity 함수들이 있으며, 이 함수들은 안드로이드가 자동 호출한다.</p><blockquote><p>액티비티 상태 다이어그램</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/117298233-18e4ed80-aeb2-11eb-9cc3-f4a0f93a3d0f.jpeg'></p><blockquote><p>액티비티 상태</p></blockquote><table><thead><tr><th style="text-align:center">상태</th><th style="text-align:center">메모리에 있음?</th><th style="text-align:center">사용자에게 보임?</th><th style="text-align:center">포그라운드에서 실행?</th></tr></thead><tbody><tr><td style="text-align:center">존재하지 않음</td><td style="text-align:center">아니오</td><td style="text-align:center">아니오</td><td style="text-align:center">아니오</td></tr><tr><td style="text-align:center">중단</td><td style="text-align:center">예</td><td style="text-align:center">아니오</td><td style="text-align:center">아니오</td></tr><tr><td style="text-align:center">일시 중지</td><td style="text-align:center">예</td><td style="text-align:center">예(부분적)<sup id = "a1"><a href="#f1">*</a></sup></td><td style="text-align:center">아니오</td></tr><tr><td style="text-align:center">실행 재개</td><td style="text-align:center">예</td><td style="text-align:center">예</td><td style="text-align:center">예</td></tr></tbody></table><p><b id = "f1"> * </b> 당시 상황에 따라 일시 중지된 액티비티의 전체 또는 일부가 사용자에게 보일 수 있다 <a href="#a1">↩</a></p><h3 id="존재하지-않음-상태"><a class="markdownIt-Anchor" href="#존재하지-않음-상태"></a> ‘존재하지 않음’ 상태</h3><ul><li>액티비티가 아직 론칭되지 않았거나 소멸되었음(예를 들어, 사용자가 백 버튼을 눌러서)을 나타낸다.</li><li>이 때문에 때로는 이 상태를 ‘소멸(destroyed)’ 상태라고도 한다. 이때 액티비티 인스턴스는 메모리에 존재하지 않으며, 사용자가 보거나 상호 작용하기 위한 뷰도 없다.</li></ul><h3 id="중단-상태"><a class="markdownIt-Anchor" href="#중단-상태"></a> ‘중단’ 상태</h3><ul><li>액티비티 인스턴스가 메모리에 있지만, 이것의 뷰는 화면에서 볼 수 없다는 것을 나타낸다.</li><li>액티비티가 처음 시작될 때 거쳐가는 상태이며, 액티비티 인스턴스의 뷰가 화면에서 완전히 가려졌을 때 언제든 다시 진입하는 상태다.<ul><li>예를 들어, 전체 화면을 사용하는 다른 액티비티를 사용자가 시작하거나 홈 버튼을 누를 때 등이다.</li></ul></li></ul><h3 id="일시-중지-상태"><a class="markdownIt-Anchor" href="#일시-중지-상태"></a> ‘일시 중지’ 상태</h3><ul><li>액티비티가 포그라운드(foreground)에서 작동하지는 않지만, 액티비티 인스턴스의 뷰 전체 또는 일부를 화면에서 볼 수 있음을 나타낸다.<ul><li>예를 들어, 이 액티비티 위에 새로운 대화상자나 투명 액티비티가 사용자에 의해 시작된다면 이 액티비티는 일부만 화면에 보이게 된다.</li><li>만일 사용자가 다중 창 모드(분활 화면 모드)로 두 개의 액티비티를 같이 보고 있다면 액티비티 전체가 화면에 보일 수 있지만, 포그라운드에 존재하지 않을 수도 있다.</li></ul></li></ul><h3 id="실행-재개-상태"><a class="markdownIt-Anchor" href="#실행-재개-상태"></a> ‘실행 재개’ 상태</h3><ul><li>액티비티가 메모리에 있으면서 화면에서 전체를 볼 수 있고 포그라운드에 있음을 나타낸다.</li><li>사용자가 현재 상호 작용하고 있는 액티비티가 바로 이 상태다.</li><li>‘실행 재개’ 상태는 장치의 전체 시스템에 걸쳐 하나의 액티비티만 될 수 있다.<ul><li>즉, 한 액티비티가 ‘실행 재개’ 상태가 되면 직전에 실행 중이던 액티비티는 다른 상태로 바뀐다는 의미다.</li></ul></li></ul><p>상단의 액티비티 상태 다이어그램 이미지에 있는 함수들을 사용해 액티비티 생명주기의 전환 시점에 필요한 일을 처리할 수 있다. 이 함수들을 <strong>생명주기 콜백(lifecycle callback)</strong> 이라고 한다.</p><p>이미 생명주기 콜백 함수 중 하나인 <code>onCreate(Bundle?)</code>을 알고 있을 것이다. 액티비티 인스턴스가 생성되고 화면에 나타나기 전에 안드로이드 운영체제가 이 함수를 호출한다.</p><p>UI를 준비하기 위해 액티비티에서는 다음과 같이 <code>onCreate(Bundle?)</code> 함수를 오버라이드(override)한다.</p><ul><li>위젯을 인플레이트해 뷰 객체로 생성한 후 화면에 보여준다. (<code>setContentView(Int)</code>를 호출)</li><li>인플레이트된 위젯의 객체 참조를 얻는다.</li><li>사용자와의 상호 작용을 처리하기 위해 위젯에 리스너를 설정한다.</li><li>외부의 모델 데이터를 연결한다.</li></ul><h2 id="액티비티-생명주기-로깅하기"><a class="markdownIt-Anchor" href="#액티비티-생명주기-로깅하기"></a> 액티비티 생명주기 로깅하기</h2><h3 id="로그-메세지-만들기"><a class="markdownIt-Anchor" href="#로그-메세지-만들기"></a> 로그 메세지 만들기</h3><ul><li>안드로이드에서 android.util.Log 클래스는 공유되는 시스템 수준의 로그에 로그 메시지를 전달한다.<ul><li>Log 클래스는 메시지를 로깅하기 위한 함수들을 갖고 있다.</li></ul></li><li>메시지의 내용은 물론, 메시지의 중요도를 나타내는 레벨(level)도 제어할 수 있다.<ul><li>안드로이드는 다섯 개의 로그 레벨을 지원</li></ul></li></ul><blockquote><p>로그 레벨과 함수</p></blockquote><table><thead><tr><th style="text-align:center">로그 레벨</th><th style="text-align:center">함수</th><th style="text-align:center">용도</th></tr></thead><tbody><tr><td style="text-align:center">ERROR</td><td style="text-align:center">Log.e(…)</td><td style="text-align:center">에러</td></tr><tr><td style="text-align:center">WARNING</td><td style="text-align:center">Log.w(…)</td><td style="text-align:center">경고</td></tr><tr><td style="text-align:center">INFO</td><td style="text-align:center">Log.i(…)</td><td style="text-align:center">정보성 메시지</td></tr><tr><td style="text-align:center">DEBUG</td><td style="text-align:center">Log.d(…)</td><td style="text-align:center">디버깅 출력이며 필터링할 수 있다.</td></tr><tr><td style="text-align:center">VERBOSE</td><td style="text-align:center">Log.v(…)</td><td style="text-align:center">개발 전용</td></tr></tbody></table><p>각 로깅 함수는 두 개의 시그니처(signature)를 갖는다.</p><ol><li>하나는 태그 문자열과 메시지 문자열로 된 두 개의 인자를 받고<ul><li>일반적으로 태그 문자열에는 클래스 이름을 값으로 갖는 TAG 상수를 지정한다. 이렇게 하면 메시지의 근원을 알기 쉽다.</li></ul></li><li>다른 하나는 이 두 인자에 <strong>Throwable</strong> 인스턴스를 추가로 받는다.<ul><li><strong>Throwable</strong> 인스턴스는 앱이 발생시킬 수 있는 특정 예외에 관한 정보를 쉽게 로깅할 수 있게 한다.</li></ul></li></ol><blockquote><p>TAG 상수 추가하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>참고로, 이처럼 .kt 파일 내부에서 클래스 바깥쪽에 선언한 변수를 코틀린에서는 <strong>최상위 수준 속성</strong>이라고 한다. 최상위 수준 속성은 다음 두 가지 상황에 사용할 수 있다.</p><ol><li>특정 클래스의 인스턴스를 생성하지 않고 바로 사용할 수 있으므로 애플리케이션이 실행되는 동안 속성값을 계속 보존해야 할 때다.</li><li>애플리케이션 전체에서 사용하는 상수를 정의할 때 유용하다.</li></ol><blockquote><p>안드로이드에서 로깅하는 방법</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DEBUG 로그 레벨로 메시지를 로깅한다</span></span><br><span class="line">Log.d(TAG, <span class="string">&quot;Current question index: <span class="variable">$currentIndex</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> question = questionBank[currentIndex]</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex: ArrayIndexOutOfBoundsException) &#123;</span><br><span class="line">    <span class="comment">// 스택에 저장된 예외의 기록과 함께 ERROR 로그 레벨로 메시지를 로깅한다</span></span><br><span class="line">    Log.e(TAG, <span class="string">&quot;Index was out of bounds&quot;</span>, ex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>생명주기 함수를 추가로 오버라이드하기(MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate(Bundle?) called&quot;</span>)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStart() called&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume()</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onResume() called&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onPause() called&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStop() called&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onDestroy() called&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Log.d(…)를 호출해 메시지를 로깅하기 전에 오버라이드되는 슈퍼 클래스 함수를 호출한다는 점에 유의하자. 오버라이드하는 각 콜백 함수에서는 오버라이드되는 슈퍼 클래스 함수를 호출하는 코드가 맨 앞에 있어야 한다. 각 함수에 override 키워드가 있는 이유는 오버라이드하는 함수가 슈퍼 클래스에 있는지 컴파일러에게 확인하라고 요청하기 위해서다.</p><h2 id="액티비티-생명주기가-사용자-액션에-어떻게-응답하는지-살펴보기"><a class="markdownIt-Anchor" href="#액티비티-생명주기가-사용자-액션에-어떻게-응답하는지-살펴보기"></a> 액티비티 생명주기가 사용자 액션에 어떻게 응답하는지 살펴보기</h2><p>GeoQuiz 앱이 설치 및 실행될 때는 생명주기 함수 <code>onCreate(Bundle?)</code>, <code>onStart()</code>, <code>onResume()</code>가 차례대로 호출되고 MainActivity 인스턴스가 생성된다. 즉, MainActivity 인스턴스가 ‘실행 재개’ 상태가 된다(메모리에 로드되고, 사용자에게 보이며, 포그라운드에서 작동함).</p><blockquote><p>앱 설치 및 실행 시, <code>onCreate(Bundle?)</code>, <code>onStart()</code>, <code>onResume()</code>가 차례대로 호출된다.</p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/117337853-da165e00-aed8-11eb-8895-b29343002bc3.png'></p><h3 id="일시적으로-액티비티-떠나기"><a class="markdownIt-Anchor" href="#일시적으로-액티비티-떠나기"></a> 일시적으로 액티비티 떠나기</h3><p>홈 버튼을 누르면 MainActivity는 <code>onPause()</code>, <code>onStop()</code> 호출을 받지만, <code>onDestroy()</code>는 호출되지 않는다. 그러면 MainActivity는 어떤 상태일까?</p><blockquote><p>홈 버튼을 누르면 <code>onPause()</code>, <code>onStop()</code>가 호출된다.</p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/117338319-64f75880-aed9-11eb-827c-40e26231b683.png'></p><p>장치의 홈 버튼을 누르면 안드로이드 운영체제에 '나는 다른 작업을 하려고 한다. 그런데 현재의 액티비티 화면에서 볼일이 다 끝나지 않았으므로 다시 돌아올 수 있다.'라고 알리는 셈이 된다. 따라서 안드로이드 운영체제는 현재 액티비티를 일시 중지했다가 중단시킨다. 즉, GeoQuiz 앱에서 홈 버튼을 누른 후에는 MainActivity의 인스턴스가 ‘중단’ 상태가 된다(메모리에는 있지만 사용자에게는 보이지 않으며, 포그라운드에서 실행되지 않는다). 그러나 사용자가 나중에 GeoQuiz 앱으로 돌아오면 안드로이드 운영체제는 재빨리 MainActivity 인스턴스를 다시 시작한다.</p><blockquote><p>다시 앱을 키면 <code>onStart()</code>, <code>onResume()</code>이 차례로 호출된다. (<code>onPause()</code>, <code>onStop()</code>는 홈 버튼 클릭 시 호출된 것)</p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/117338765-e9e27200-aed9-11eb-9ba3-ba5435cbeeff.png'></p><h4 id="오버뷰-화면overview-screen에서의-동작은"><a class="markdownIt-Anchor" href="#오버뷰-화면overview-screen에서의-동작은"></a> 오버뷰 화면(overview screen)에서의 동작은?</h4><p>아래의 이미지와 같이 오버뷰 화면의 각 카드는 이전에 사용자가 사용했던 앱을 나타낸다. 오버뷰 화면은 ‘최근 앱 화면’ 또는 '태스크 매니저’라고도 한다. 여기서는 개발자 문서에서 얘기하는 '오버뷰 화면’이라고 칭한다.</p><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/117339390-a3d9de00-aeda-11eb-8bda-6c192e189bcf.jpeg'></p><blockquote><p>오버뷰 화면에서 태스크 클릭 시에는 <code>onStart()</code>, <code>onResume()</code>이 호출</p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/117340539-f8ca2400-aedb-11eb-89aa-7017d0e14e6a.png'></p><p>오버뷰 화면에서 GeoQuiz 태스크를 클릭하면 MainActivity가 화면에 나타난다. 이때 로그캣 창의 메시지를 보면 <code>onStart()</code>, <code>onResume()</code>이 호출되었음을 알 수 있다. 하지만 <code>onCreate(...)</code>는 호출되지 않았는데 홈 버튼을 누른 후에 MainActivity는 ‘중단’ 상태가 되었기 때문이다. 따라서 MainActivity 인스턴스는 여전히 메모리에 있으므로 다시 생성될 필요가 없다. 그리고 오버뷰 화면에서 선택되면 액티비티만 다시 시작되어('일시 정지’이면서 화면에 볼 수 있는 상태) 실행이 재개된다(포그라운드로 '실행 재개’되는 상태).</p><p>액티비티는 ‘일시 중지’ 상태에 머물러 있을 수도 있는데, 이때는 일부만 화면에 보이거나(예를 들어, 투명한 백그라운드를 갖거나 더 작은 화면 크기를 갖는 다른 액티비티가 '일시 중지’된 액티비티 화면 위에 있을 때) 또는 전체 화면이 보일 수도 있다(다중 창 모드일 때).</p><h3 id="다중-창-모드multi-window-mode에서의-동작은"><a class="markdownIt-Anchor" href="#다중-창-모드multi-window-mode에서의-동작은"></a> 다중 창 모드(multi window mode)에서의 동작은?</h3><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/117344934-f1594980-aee0-11eb-9168-fd5a8f2c1e9c.jpeg'>&emsp;&emsp;&emsp;&emsp;<img width = '250' src = 'https://user-images.githubusercontent.com/39554623/117344937-f28a7680-aee0-11eb-98c1-12a1d8a55482.jpeg'></p><p>아래 창에 열린 다른 앱을 클릭하고 로그캣의 메시지를 보면 GeoQuiz의 MainActivity에서 <code>onPause()</code>가 호출되었음을 알 수 있다. 즉, MainActivity는 현재 ‘일시 중지’ 상태다.</p><p>그리고 위의 창에 열린 GeoQuiz를 클릭하면 MainActivity의 <code>onResume()</code>가 호출된다. 이제는 MainActivity가 ‘실행 재개’ 상태가 되었기 때문이다.</p><h3 id="액티비티-끝내기"><a class="markdownIt-Anchor" href="#액티비티-끝내기"></a> 액티비티 끝내기</h3><p>장치의 백 버튼을 누른 후 로그캣의 메시지를 확인해보자. MainActivity의 <code>onPause()</code>, <code>onStop()</code>, <code>onDestroy()</code>가 호출되었을 것이다. MainActivity의 인스턴스가 존재하지 않는 상태다(메모리에 없고 화면에도 보이지 않으며, 포그라운드에서도 동작하지 않음).</p><blockquote><p>백 버튼을 누르면 액티비티 인스턴스가 소멸되어 <code>onPause()</code>, <code>onStop()</code>, <code>onDestroy()</code>가 호출된다.</p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/117345504-94aa5e80-aee1-11eb-82dc-e8b98099fd2f.png'></p><p>장치의 백 버튼을 눌렀다는 것은 앱의 사용자가 해당 액티비티를 <strong>끝냈다</strong>는 의미다. 달리 말해, 안드로이드 운영체제에 '나는 이 액티비티를 다 사용했으므로 더 이상 필요 없다.'라고 알리는 셈이다. 그러면 안드로이드 운영체제는 해당 액티비티를 소멸시키고 메모리로부터 모든 흔적을 지운다. 이것이 바로 장치의 제한된 리소스를 절약하는 안드로이드의 방식이다.</p><p>또한, 오버뷰 화면에서 해당 앱의 카드를 옆으로 밀어내도 앱을 끝낼 수 있으며, 코드에서는 <code>Activity.finish()</code>를 호출해 액티비티를 끝낼 수 있다.</p><blockquote><p>오버뷰 화면에서 앱 종료 시, <code>onDestroy()</code> 호출</p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/117346453-b7894280-aee2-11eb-95b3-f8a4d1cd421b.png'></p><h3 id="액티비티-회전시키기"><a class="markdownIt-Anchor" href="#액티비티-회전시키기"></a> 액티비티 회전시키기</h3><p>장치를 회전하면 <code>onPause()</code>, <code>onStop()</code>, <code>onDestroy()</code>, <code>onCreate(...)</code>, <code>onStart()</code>, <code>onResume()</code>이 차례로 호출된다.</p><blockquote><p>장치 회전 시, MainActivity가 죽었다가 다시 살아난다!</p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/117346682-0800a000-aee3-11eb-87ea-66bf40070494.png'></p><p>위 메시지를 보면 알 수 있듯, 장치를 회전하면 보고 있던 MainActivity 인스턴스는 소멸되었다가 다시 새로운 인스턴스로 생성된다. 현재 인스턴스의 currentIndex에 저장된 값이 메모리에서 지워지므로, 장치를 회전하면 그 당시 사용자가 어떤 문제를 보고 있었는지 GeoQuiz가 모르게 된다는 의미다.</p><p>장치가 회전될 때 안드로이드는 완전히 새로운 MainActivity 인스턴스를 생성한다. 따라서 <code>onCreate(Bundle?)</code>에서 currentIndex이 값이 0으로 초기화되므로 사용자는 첫 번째 문제를 다시 보게 된다.</p><h2 id="장치-구성-변경과-액티비티-생명주기"><a class="markdownIt-Anchor" href="#장치-구성-변경과-액티비티-생명주기"></a> 장치 구성 변경과 액티비티 생명주기</h2><p>장치를 회전하면 <strong>장치 구성(device configuration)</strong> 이 변경된다. 장치 구성은 각 장치의 현재 상태를 나타내는 특성들의 집합이다. 장치 구성을 이루는 특성에는 화면 방향, 화면 밀도, 화면 크기, 키보드 타입, 도크(dock) 모드, 언어 등이 있다.</p><p>일반적으로 앱에서는 서로 다른 장치 구성에 맞추기 위해 대체 리소스를 제공한다. 장치마다 다른 화면 밀도를 고려해 여러 화살표 아이콘을 프로젝트에 추가했을 때 이미 이런 예를 보았다.</p><p><strong>런타임 구성 변경(runtime configuration change)</strong> 이 생길 때는 새로운 구성에 더 잘 맞는 리소스들이 있을 수 있다. 따라서 안드로이드는 현재의 액티비티 인스턴스를 소멸시키고 새로운 구성에 가장 적합한 리소스를 찾는다. 그리고 그런 리소스를 사용해서 해당 액티비티의 새 인스턴스를 다시 빌드한다. 예로 장치의 화면 방향이 가로 방향으로 변경될 때 안드로이드가 찾아 사용할 대체 리소스를 생성할 수 있다.</p><blockquote><p>가로 방향 레이아웃 <code>activity_main.xml (land)</code> 생성</p></blockquote><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/117349400-4e0b3300-aee6-11eb-8820-2c74137aa9bb.png'></p><blockquote><p>방향에 따른 레이아웃이 나온다</p></blockquote><br><p align = 'center'><img width = '200' src = 'https://user-images.githubusercontent.com/39554623/117349205-14d2c300-aee6-11eb-92b0-52e8d4ca63be.jpeg'>&emsp;&emsp;&emsp;&emsp;<img width = '300' src = 'https://user-images.githubusercontent.com/39554623/117349211-169c8680-aee6-11eb-92f5-cf73d17b70c0.jpeg'></p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      
      <comments>http://june0122.github.io/2021/05/08/android-bnr-03/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Model-View-Controller</title>
      <link>http://june0122.github.io/2021/05/08/android-bnr-02/</link>
      <guid>http://june0122.github.io/2021/05/08/android-bnr-02/</guid>
      <pubDate>Sat, 08 May 2021 00:51:19 GMT</pubDate>
      
      <description>안드로이드 API는 &lt;b&gt;모델-뷰-컨트롤러(MVC)&lt;/b&gt;라는 아키텍처에 맞추어 설계되었다. 애플리케이션의 어떤 객체든 &lt;b&gt;모델 객체&lt;/b&gt; 또는 &lt;b&gt;뷰 객체&lt;/b&gt; 또는 &lt;b&gt;컨트롤러 객체&lt;/b&gt;가 되어야 한다는 것이 MVC의 주요 관점이다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="데이터-클래스data-class"><a class="markdownIt-Anchor" href="#데이터-클래스data-class"></a> 데이터 클래스(data class)</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Question</span></span>(<span class="meta">@StringRes</span> <span class="keyword">val</span> texResId: <span class="built_in">Int</span>, <span class="keyword">val</span> answer: <span class="built_in">Boolean</span>)</span><br></pre></td></tr></table></figure><p><code>@StringRes</code> 애노테이션은 없어도 되지만, 다음 두 가지 이유로 지정하는 것이 좋다.</p><ol><li>생성자에서 유효한 문자열 리소스 ID를 제공하는지를 컴파일 시점에서 Lint(안드로이드 스튜디오에 내장된 코드 검사기)가 검사한다. 따라서 유효하지 않은 리소스 ID가 생성자에 사용되어 런타임 시에 앱이 중단되는 것을 방지해준다.</li><li>애노테이션을 지정함으로써 다른 개발자가 쉽게 코드를 알 수 있다.</li></ol><p>texResId의 타입이 String이 아니고 Int인 이유는 texResId 변수는 질문 문자열 리소스의 리소스 ID(항상 Int 타입)를 갖기 때문이다.</p><!-- more --><p>Question과 같은 클래스처럼 주로 데이터를 갖는 클래스가 많이 있으며, 그중에는 업무에 관련된 것도 있고 프로그램에서 필요해서 생성한 것도 있다. 이런 클래스들은 비즈니스 로직을 처리하는 함수보다는 주로 데이터를 저장하는 속성을 갖는다.</p><ol><li>따라서 클래스 인스턴스끼리 각 속성의 값을 비교하거나(<code>equals()</code> 함수)</li><li>인스턴스를 컬렉션(HashMap 등)에 저장할 때 사용할 키 값(해시 코드)을 생성하는(<code>hashCode()</code> 함수) 기능이나</li><li>속성값을 문자열로 쉽게 출력하는(<code>toString</code> 함수) 기능이 공통으로 필요하다.</li></ol><p>이런 이유로 코틀린에서는 <a href="https://github.com/june0122/TIL/blob/master/KOTLIN/LAB/Data%20Classes.md"><strong>데이터 클래스(data class)</strong></a>라는 개념을 추가하였다. 즉, 클래스를 정의할 때 data 키워드를 지정하면 이 클래스를 데이터 클래스로 간주하며, 방금 설명했던 기능들을 처리해주는 함수들을 해당 클레스에 맞게 코틀린 컴파일러가 자동으로 생성해준다.</p><blockquote><p>GeoQuiz의 객체 다이어그램</p></blockquote><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/117186172-8989fc80-ae15-11eb-860b-fcb4c8d573e2.jpeg'></p><h2 id="모델-뷰-컨트롤러와-안드로이드"><a class="markdownIt-Anchor" href="#모델-뷰-컨트롤러와-안드로이드"></a> 모델-뷰-컨트롤러와 안드로이드</h2><p>위 그림의 객체들은 세 부분, 즉 모델(Model), 컨트롤러(Controller), 뷰(View)로 분리됨에 주목하자. 안드로이드 API는 <strong>모델-뷰-컨트롤러</strong>(MVC)라는 아키텍처에 맞추어 설계되었다. 애플리케이션의 어떤 객체든 <strong>모델 객체</strong> 또는 <strong>뷰 객체</strong> 또는 <strong>컨트롤러 객체</strong>가 되어야 한다는 것이 MVC의 주요 관점이다.</p><h3 id="모델-객체-model-object"><a class="markdownIt-Anchor" href="#모델-객체-model-object"></a> 모델 객체 (Model Object)</h3><ul><li>모델 객체는 애플리케이션의 '데이터’와 '비즈니스 로직’을 갖는다.</li><li>모델 클래스는 앱과 관계가 있는 것들을 <strong>모델링</strong>한다.<ul><li>ex) 사용자, 상품, 서버에 저장된 사진 등</li></ul></li><li>모델 객체는 UI를 모른다. 데이터를 보존하고 관리하는 것이 유일한 목적이다.</li><li>애플리케이션의 모든 모델 객체들은 <strong>모델 계층(model layer)</strong> 을 구성한다.<ul><li>GeoQuiz의 모델 계층은 Question 클래스로 구성된다.</li></ul></li></ul><h3 id="뷰-객체-view-object"><a class="markdownIt-Anchor" href="#뷰-객체-view-object"></a> 뷰 객체 (View Object)</h3><ul><li>뷰 객체는 자신을 화면에 그리는 방법과 터치와 같은 사용자의 입력에 응답하는 방법이다.<ul><li>쉽게 말해, 화면에서 볼 수 있는 것이라면 그것은 뷰 객체다.</li></ul></li><li>안드로이드는 구성 가능한 뷰 클래스를 풍부하게 제공하지만, 직접 커스텀 클래스를 생성할 수도 있다.</li><li>애플리케이션의 뷰 객체들은 <strong>뷰 계층(view layer)</strong> 을 구성한다.<ul><li>GeoQuiz의 뷰 계층은 res/layout/activity_main.xml 요소들로부터 인플레이트되는 위젯들로 구성된다.</li></ul></li></ul><h3 id="컨트롤러-객체-controller-object"><a class="markdownIt-Anchor" href="#컨트롤러-객체-controller-object"></a> 컨트롤러 객체 (Controller Object)</h3><ul><li>컨트롤러 객체는 뷰와 모델 객체를 결속하여 '애플리케이션 로직’을 포함한다.</li><li>컨트롤러 객체는 뷰 객체에 의해 촉발되는 다양한 이벤트에 응답하고 모델 객체 및 뷰 계층과 주고받는 데이터의 흐름을 관리한다.</li><li>안드로이드에서 컨트롤러는 일반적으로 <strong>Activity</strong>나 <strong>Fragment</strong>의 서브 클래스이다.<ul><li>GeoQuiz의 컨트롤러 계층은 MainActivity만으로 구성되어 있다.</li></ul></li></ul><blockquote><p>사용자 입력의 MVC 처리 흐름</p></blockquote><p align = 'center'><img width = '700' src = 'https://user-images.githubusercontent.com/39554623/117189778-88f36500-ae19-11eb-9851-e7b834e0d185.png'></p><h2 id="mvc-사용하기"><a class="markdownIt-Anchor" href="#mvc-사용하기"></a> MVC 사용하기</h2><p>애플리케이션 기능이 많아지면 너무 복잡해져 이해하기 어려울 수 있다. 따라서 코드를 클래스로 분리하면 설계에 도움이 되고 전체를 이해하기도 쉬워진다. 개별적인 변수와 함수 대신 클래스 관점으로 생각할 수 있기 때문이다.</p><p>이와 유사하게 클래스들을 모델과 뷰 그리고 컨트롤러 계층으로 분리하면 애플리케이션을 설계하고 이해하는 데 도움이 된다. 개별적인 클래스 대신 계층의 관점으로 생각할 수 있기 때문이다.</p><p>MVC는 클래스를 재사용하기 쉽도록 해준다. 여러 일을 혼자서 처리하는 클래스보다는 제한된 책임을 갖는 클래스를 재사용하는 것이 더 쉽기 때문이다.</p><p>MVC는 큰 앱은 물론 작고 같단한 앱에도 잘 적용되지만, 더 크고 복잡한 앱에서는 컨트롤러 계층이 훨씬 커지거나 복잡해질 수 있다. 대게는 액티비티나 다른 컨트롤러들을 가볍게(thin) 유지하려고 한다. 가벼운 액티비티는 가능한 한 비즈니스 로직을 적게 포함하기 때문이다. 그리고 앱의 컨트롤러를 가볍게 만드는 데 MVC가 더 이상 적합하지 않을 때는 <strong>MVVM</strong>(모델-뷰-뷰모델) 아키텍처가 그 대안이 될 수 있다.</p><h2 id="tools-네임스페이스"><a class="markdownIt-Anchor" href="#tools-네임스페이스"></a> tools 네임스페이스</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span>  // 레이아웃의 루트 태그에 tools 네임스페이스 추가</span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/question_text_view&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">&quot;24dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:text</span>=<span class="string">&quot;@string/question_australia&quot;</span> /&gt;</span>  // tools 네임스페이스로 지정</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ul><li>이 네임스페이스를 사용하면 TextView 위젯의 속성을 오버라이드해 레이아웃 디자인에 해당 문자열 리소스를 보여줄 수 있다.<ul><li>TextView에 <code>tools:text</code> 속성을 추가하면, 안드로이드 스튜디오가 <code>tools:text</code> 속성을 알 수 있게 레이아웃의 루트 태그에 tools 네임스페이스를 추가해야 한다.</li></ul></li><li>tools 네임스페이스 속성들은 앱이 장치에서 실행되어 위젯들이 화면에 나타날 때는 무시된다.</li><li><code>android:text</code>로 지정된 값은 런타임 시에 나타나고, <code>tools:text</code>로 지정된 값은 디자인 시에 보기 위해 사용된다.</li></ul><h2 id="화면-픽셀-밀도"><a class="markdownIt-Anchor" href="#화면-픽셀-밀도"></a> 화면 픽셀 밀도</h2><p>안드로이드는 밀도에 독립적인 크기 단위를 제공한다. 따라서 서로 다른 화면 밀도에서 일정한 크기를 갖도록 그 단위를 사용하면 된다. 그리고 안드로이드가 그 단위를 런타임 시에 픽셀로 변환하므로 신경 쓸 필요도 없다.</p><br><p align = 'center'><img width = '700' src = 'https://user-images.githubusercontent.com/39554623/117203388-e8597100-ae29-11eb-8899-4e9280695556.jpeg'></p><br><ul><li>px: <strong>pixel(픽셀)</strong> 의 줄임말이다. 화면 밀도와는 무관하게 1픽셀은 화면의 1픽셀과 일치한다. 픽셀은 장치의 화면 밀도에 적합하게 조정되지 않으므로 사용을 권장하지 않는다,</li><li>dp: <strong>density-independent pixel(밀도 독립적 필셀)</strong> 의 줄임말이다. 마진과 패딩 등의 크기를 픽셀 값으로 지정하지 않을 때 사용한다. <strong>1dp</strong>는 항상 장치 화면의 1/160인치이며, 화면 밀도와 무관하게 일정한 크기를 갖는다. 따라서 장치의 화면이 고밀도일 때는 더 많은 수의 화면 픽셀을 채우기 위해 dp를 사용한다.</li><li>sp: <strong>scale-independent pixel(크기 독립적 픽셀)</strong> 의 줄임말이다. sp는 사용자의 폰트 크기 선택도 고려한 dp다. 주로 화면에 나타나는 텍스트의 크기를 설정하기 위해 사용한다.</li><li>pt, mm, in: 포인트(1/72인치), 밀리미터, 인치로 크기를 지정할 수 있는 크기 단위이다. 그런데 모든 장치에 잘 맞도록 구성되지 않아 사용을 권장하지 않는다.</li></ul><p>실무에서는 dp와 sp를 사용하며, 안드로이드는 이 값들을 런타임 시에 픽셀로 변환한다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      
      <comments>http://june0122.github.io/2021/05/08/android-bnr-02/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] View, Inflate, Listener</title>
      <link>http://june0122.github.io/2021/05/08/android-bnr-01/</link>
      <guid>http://june0122.github.io/2021/05/08/android-bnr-01/</guid>
      <pubDate>Fri, 07 May 2021 20:35:00 GMT</pubDate>
      
      <description>뷰(View)는 UI를 만드는데 사용되는 구성 요소로 장치 화면에 보이는 모든 것에 해당한다. 사용자가 화면을 보며 상호 작용하는 뷰는 위젯이며 안드로이드 SDK에는 많은 위젯이 포함되어 원하는 UI를 구성 할 수 있다. 모든 위젯은 View 클래스의 인스턴스이거나 View의 서브 클래스 중 하나의 인스턴스다. 뷰그룹(ViewGrop)은 View의 일종으로 다른 뷰를 포함하고 배치해 화면에 보여주지만 그 자신은 화면에 나타나지 않는다. 레이아웃도 뷰그룹이며 뷰그룹의 서브 클래스에는 ConstraintLayout이나 FrameLayout 등이 있다.</description>
      
      
      
      <content:encoded><![CDATA[<ul><li>안드로이드 지원 라이브러리에서 제트팩으로<ul><li>기존의 안드로이드 지원(support) 라이브러리들은 그 수가 많고 독립적인 개발 및 버전 관리 때문에 어려움이 많았다.</li><li>따라서 안드로이드 10부터는 모든 지원 라이브러리를 androidx라는 <strong>네임스페이스 <sup>namespace</sup></strong> 를 갖는, 몇 개의 더 큰 라이브러리로 통합하게 되었다.</li><li>그렇고 이렇게 통합된 라이브러리를 <strong>Jetpack</strong>이라고 한다.</li></ul></li></ul><h2 id="뷰-계층-구조view-hierarchy"><a class="markdownIt-Anchor" href="#뷰-계층-구조view-hierarchy"></a> 뷰 계층 구조(view hierarchy)</h2><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/117080997-e9cb6080-ad79-11eb-96d7-af95c94939ab.png'></p><ul><li><p>뷰(View)</p><ul><li>뷰는 UI를 만드는데 사용되는 구성 요소</li><li>장치 화면에 보이는 모든 것이 뷰</li><li>사용자가 화면을 보며 상호 작용하는 뷰 -&gt; 위젯 <sup>widget</sup></li></ul></li><li><p>위젯(Widget)</p><ul><li>안드로이드 SDK에는 많은 위젯이 포함되어 원하는 UI(화면에 보이는 모습과 앱과의 상호작용)을 구성 가능</li><li>모든 위젯은 View 클래스의 인스턴스이거나 View의 서브 클래스 <sup>TextView나 Button</sup> 중 하나의 인스턴스</li></ul></li><li><p>뷰그룹(ViewGrop)</p><ul><li>View의 일종</li><li>다른 뷰를 포함하고 배치해 화면에 보여주지만 그 자신은 화면에 나타나지 않음</li><li>레이아웃도 뷰그룹, 뷰그룹의 서브 클래스에는 ConstraintLayout이나 FrameLayout 등이 있음</li></ul></li></ul><blockquote><p>ConstraintLayout이 뷰그룹이며, 유일한 자식이 TextView 위젯인 레이아웃</p></blockquote><figure class="highlight xml"><figcaption><span>activity_main.xml</span><a href="https://www.w3.org/XML/">xml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="레이아웃-xml에서-뷰-객체로"><a class="markdownIt-Anchor" href="#레이아웃-xml에서-뷰-객체로"></a> 레이아웃 XML에서 뷰 객체로</h2><p>xml 파일 내에 정의된 XML 요소들이 어떻게 View 객체가 될까?</p><p>GeoQuiz 프로젝트를 생성하면 MainActivity라는 이름의 Activity 서브 클래스가 자동으로 생성된다. MainActivity 클래스 파일은 app/java 디렉터리의 com.june0122.geoquiz 패키지 아래에 있다.</p><p>안드로이드는 원래 자바 코드만 지원했기 때문에 현재 소스 코드 파일이 있는 디렉터리의 이름은 java다. 코틀린 소스 파일도 java 디렉터리에 저장된다. 물론 koltin이라는 이름의 새 디렉터리를 생성해 이 디렉터리에 코틀린 소스 파일들을 따로 저장할 수 있지만 해당 소스 파일들이 프로젝트에 포함되도록 kotlin 디렉터리에 있다는 것을 안드로이드 스튜디오에 알려줘야 한다. 하지만 사용 언어마다 소스 파일을 별개의 디렉터리에 두는 것은 그리 유용하지 않으므로 코틀린 소스 파일도 java 디렉터리에 두는 것이 좋다. (괜히 상호 호환성이 큰 장점이 아니다!)</p><h3 id="appcompatactivity-란"><a class="markdownIt-Anchor" href="#appcompatactivity-란"></a> AppCompatActivity 란?</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> trueButton: Button</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> falseButton: Button</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AppCompatActivity는 안드로이드 Activity 클래스의 서브 클래스</li><li>과거 안드로이드 버전과의 호환성을 지원하기 위해 제공</li><li>'AppCompat’은 'application compatibility’의 단축어</li><li>Jetpack의 AppCompat 라이브러리는 안드로이드 버전이 달라도 일관된 UI를 유지하는 데 핵심이 되는 클래스와 리소스들을 포함한다.</li></ul><blockquote><p>AppCompat의 각 하위 패키지들</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">androidx.appcompat.app</span><br><span class="line">androidx.appcompat.content.res</span><br><span class="line">androidx.appcompat.graphics.drawable</span><br><span class="line">androidx.appcompat.view</span><br><span class="line">androidx.appcompat.widget</span><br></pre></td></tr></table></figure><blockquote><p>app/build.gradle 파일에 추가되어있는 AppCompat 라이브러리 의존성</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation <span class="string">&#x27;androidx.appcompat:appcompat:1.2.0&#x27;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="activity-함수-oncreatebundle"><a class="markdownIt-Anchor" href="#activity-함수-oncreatebundle"></a> Activity 함수 <code>onCreate(Bundle?)</code></h3><ul><li>액티비티 서브 클래스의 인스턴스가 생성될 때 자동으로 호출됨</li><li>이때 이 함수에서는 액티비티가 UI를 화면에 보여주고 처리할 수 있도록 다음 함수를 호출함</li></ul><h3 id="activitysetcontentviewlayoutresid-int"><a class="markdownIt-Anchor" href="#activitysetcontentviewlayoutresid-int"></a> <code>Activity.setContentView(layoutResID: Int)</code></h3><ul><li>이 함수는 레이아웃을 <strong>인플레이트 <sup>inflate</sup></strong> 해 화면에 나타낸다.<ul><li>인플레이트 : 뷰 계층 구조를 따라 객체로 생성하는 것</li></ul></li><li>레이아웃이 인플레이트되면 레이아웃 파일에 있는 각 위젯이 자신의 속성에 정의된 대로 인스턴스로 생성됨</li><li>이 함수를 호출할 때는 인플레이트될 레이아웃의 리소스 ID(resource ID)를 인자로 전달</li></ul><h2 id="리소스와-리소스-id"><a class="markdownIt-Anchor" href="#리소스와-리소스-id"></a> 리소스와 리소스 ID</h2><p>레이아웃은 <strong>리소스(resource)</strong> 이다. 리소스는 애플리케이션의 일부이며, 코드가 아닌 이미지 파일이나 오디오 파일 및 XML 파일 같은 것들이다. 프로젝트의 리소스들은 app/res 디렉터리 아래의 서브 디렉터리에 존재한다.</p><p>코드에서는 리소스의 리소스 ID를 지정해야 사용 가능하며 모든 리소스 ID는 앱을 빌드할 때마다 안드로이드 빌드 도구가 <strong>R.class</strong>에 자동으로 생성한다(안드로이드 스튜디오 3.6 이전 버전에서는 소스 코드 파일인 R.java를 임시로 생성했지만, 3.7 이상 버전에서는 이 파일을 생성하지 않고 R.class만 생성).</p><p>레이아웃은 하나의 리소스 ID가 생성되고, 문자열은 각각에 대해 하나의 리소스 ID가 생성된다.하지만 레이아웃에 포함된 각 위젯에서는 코드에서 참조해 사용할 필요가 있는 것에만 리소스 ID가 필요하므로 직접 지정한 것만 생성된다. (GeoQuiz 레이아웃의 리소스 ID인 R.layout.activity_main에서 activity_main은 R 클래스의 내부 클래스인 layout 안에 정수형 상수로 정의되어 있다. 문자열도 리소스 ID를 가지며, R 클래스의 내부 클래스인 string 안에 정수형 상수로 정의되어 있다. 따라서 strings.xml 파일에 기본으로 정의도니 앱 이름의 문자열은 R.string.app_name으로 참조할 수 있다.)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/true_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginRight</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/true_button&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>XML 파일에서 버튼의 android:id 속성값에는 <code>+</code>가 있지만, android:text 속성값에는 없다는 것에 주목<ul><li>android:id 속성은 ID를 <strong>생성하고</strong>, android:text 속성은 문자열을 <strong>참조만 하기</strong> 때문이다.</li></ul></li></ul><h2 id="위젯을-코드와-연결하기"><a class="markdownIt-Anchor" href="#위젯을-코드와-연결하기"></a> 위젯을 코드와 연결하기</h2><ul><li>코트 연결의 두 단계<ul><li>인플레이트된 View 객체들의 참조를 얻는다.</li><li>이 객체들에 리스너를 설정해 사용자 액션에 응답한다.</li></ul></li></ul><h3 id="위젯의-참조-얻기"><a class="markdownIt-Anchor" href="#위젯의-참조-얻기"></a> 위젯의 참조 얻기</h3><p>버튼들이 리소스 ID를 가지면 MainActivity에서 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> trueButton: Button</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> falseButton: Button</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        trueButton = findViewById(R.id.true_button)</span><br><span class="line">        falseButton = findViewById(R.id.false_button)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드에 있듯이, 액티비티에서는 <code>Activity.findViewById(Int)</code>를 호출해 View 객체로 인플레이트된 위젯의 참조를 얻는다. 이 함수는 위젯의 리소스 ID를 인자로 받아서 해당 위젯(여기서는 Button)의 객체를 반환한다(이때 View 타입을 Button 타입으로 반환해준다).</p><h3 id="리스너-설정하기"><a class="markdownIt-Anchor" href="#리스너-설정하기"></a> 리스너 설정하기</h3><ul><li>안드로이드 애플리케이션은 <strong>이벤트 기반(event-driven)</strong> 으로 구동된다.</li><li>이벤트에 응답하기 위해 생성하는 객체를 <strong>리스너 <sup>listener</sup></strong> 라고 하며, 리스너는 해당 이벤트의 <strong>리스너 인터페이스 <sup>listener interface</sup></strong> 를 구현한다.</li><li>안드로이드 SDK에는 다양한 이벤트의 리스너 인터페이스가 존재하여 따로 만들 필요가 없다.</li></ul><p>버튼이 눌러졌는지에 대한 이벤트를 리스닝하기 위해서, 아래 예제 코드의 리스너는 <strong>View.OnClickListener</strong> 인터페이스를 구현한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line">    </span><br><span class="line">    trueButton = findViewById(R.id.true_button)</span><br><span class="line">    falseButton = findViewById(R.id.false_button)</span><br><span class="line">    </span><br><span class="line">    trueButton.setOnClickListener &#123; view: View -&gt;</span><br><span class="line">        <span class="comment">// 버튼 클릭의 응답을 여기서 처리</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>trueButton의 리스너는 <strong>OnClickListener</strong> 인터페이스를 구현하는 익명 클래스의 인스턴스이며 중괄호 <code>&#123;&#125;</code> 안에 정의한다. 그리고 <strong>setOnClickListener</strong> 함수로 등록한다.</p><p>안드로이드 프레임워크에는 <strong>onClick(View)</strong> 메서드만 갖는 인터페이스인 <strong>View.OnClickListener</strong>가 정의되어 있다. 이처럼 <strong>단일 추상 메서드 <sup>Single Abstract Method, SAM</sup></strong> 를 갖는 자바 인터페이스를 <strong>SAM</strong>이라고 하며, 주로 익명의 내부 클래스를 사용해서 구현한다.</p><p>코틀린에서는 자바와 호환성을 유지하기 위해 특별한 형태로 SAM을 지원한다. 즉, 함수 리터럴 또는 람다식으로 SAM을 작성하면 이것을 해당 인터페이스의 구현 객체로 변환한다(코틀린에선 함수 리터럴이나 람다식으로 익명 함수 정의 가능). 이와 같은 내부 처리를 <strong>SAM 변환 <sup>SAM conversion</sup></strong> 이라고 한다. 위의 예제는 람다식을 이용하여 <strong>OnClickListener</strong> 인터페이스를 구현한 것이다.</p><blockquote><p>View.OnClickListener 인터페이스 문서</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.view;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface definition for a callback to be invoked when a view is clicked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when a view has been clicked.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v The view that was clicked.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    void onClick(View v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trueButton.setOnClickListener(<span class="keyword">object</span> : View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>trueButton이라는 뷰 객체에 setOnClickListener라는 메소드가 있는데, 이 메소드는 View.OnClickListener 인터페이스 객체를 받는 메소드이다.</li><li>인터페이스를 객체로 넘길 때, 구현체 부분이 있어야 하므로 익명 객체의 구현체를 만들어서 같이 넘기게 된다.</li></ul><h2 id="안드로이드-앱-빌드-절차"><a class="markdownIt-Anchor" href="#안드로이드-앱-빌드-절차"></a> 안드로이드 앱 빌드 절차</h2><p>빌드를 하는 동안 안드로이드 도구가 리소스와 코드 그리고 AndroidManifest.xml 파일(애플리케이션에 관한 메타데이터를 포함)을 가지고 하나의 .apk 파일로 만든다. 그리고 이 파일은 실제 장치나 에뮬레이터에서 실행될 수 있게 디버그 키가 부여된다(.apk를 구글 플레이 스토어에서 배포하려면 구글에서 릴리즈 키를 받아 앱에 포함시켜야 한다).</p><p>안드로이드 스튜디오에서는 프로젝트의 빌드와 관리에 필요한 모든 것을 그래들(Gradle) 자동화 빌드 도구를 사용해 처리하므로 신경 쓰지 않아도 된다.</p><p>그런데 레이아웃 파일인 activity_main의 내용은 어떻게 애플리케이션의 View 객체로 변환될까? 빌드 절차의 일부로 aapt2 <sup>Android Asset Packaging Tool 2</sup>가 레이아웃 파일의 리소스들을 좀 더 압축된 형태로 컴파일한다. 그리고 이렇게 컴파일된 리소스들이 .apk 파일로 통합된다. 그 다음에 MainActivity의 onCreate(Bundle?) 메서드에서 setContentView(…) 메서드가 호출되면, MainActivity는 LayoutInflater 클래스를 사용해서 레이아웃 파일에 정의된 각 View의 인스턴스를 생성한다.</p><blockquote><p>activity_main.xml을 인플레이트(XML 요소를 뷰 객체로 생성)하기</p></blockquote><p align = 'center'><img width = '700' src = 'https://user-images.githubusercontent.com/39554623/117084396-1e431a80-ad82-11eb-8b8d-37ed77f36866.jpeg'></p><br><p>뷰 클래스를 XML로 정의하는 대신에 액티비티에서 코틀린이나 자바 코드로 생성할 수도 있다. 하지만 이것은 그리 좋은 방법이 아니다. <strong>뷰 클래스를 XML로 정의하면 프레젠테이션(사용자 인터페이스) 계층을 애플리케이션 로직과 분리할 수 있기 때문이다. <sup>MVC 패턴</sup></strong></p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      
      <comments>http://june0122.github.io/2021/05/08/android-bnr-01/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
