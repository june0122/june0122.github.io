<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>카미유 테크 블로그</title>
    <link>http://june0122.github.io/</link>
    
    <atom:link href="http://june0122.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 09 Jun 2021 08:56:49 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[Kotlin] Coroutine - 코루틴의 내부 구현</title>
      <link>http://june0122.github.io/2021/06/09/coroutines-under-the-hood/</link>
      <guid>http://june0122.github.io/2021/06/09/coroutines-under-the-hood/</guid>
      <pubDate>Wed, 09 Jun 2021 08:48:07 GMT</pubDate>
      
      <description>코루틴은 디컴파일되면 일반 코드일 뿐이다. &lt;b&gt;Continuation Passing Style&lt;small&gt;(CPS, 연속 전달 방식)&lt;/b&gt; 이라는 형태로 동작하며, 결과를 호출자에게 직접 반환하는 대신 &lt;b&gt;Continuation&lt;/b&gt;으로 결과를 전달한다. &lt;b&gt;Continuation&lt;/b&gt;이라는 객체가 있고, 매 번 함수를 호출할 때마다 &lt;b&gt;continuation&lt;/b&gt;을 넘겨준다. &lt;b&gt;continuation&lt;/b&gt;은 Callback 인터페이스 같은 것으로, 재개를 해주는 인터페이스를 가진 객체인 것이다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="코루틴은-jvm에서-내부적으로-어떻게-동작하는-것일까"><a class="markdownIt-Anchor" href="#코루틴은-jvm에서-내부적으로-어떻게-동작하는-것일까"></a> 코루틴은 JVM에서 내부적으로 어떻게 동작하는 것일까?</h2><p>아래의 내용은 <a href="https://www.youtube.com/watch?v=YrrUCSi72E8&amp;t=110s">KotlinConf 2017 - Deep Dive into Coroutines on JVM by Roman Elizarov</a> 영상의 내용들이다.</p><h4 id="there-is-no-magic"><a class="markdownIt-Anchor" href="#there-is-no-magic"></a> There is no magic</h4><p>코루틴은 디컴파일되면 일반 코드일 뿐이다. <strong>Continuation Passing Style<small>(CPS, 연속 전달 방식)</small></strong> 이라는 형태의 코드로 전환한다.</p><blockquote><h3 id="a-toy-problem"><a class="markdownIt-Anchor" href="#a-toy-problem"></a> A toy problem</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> token = requestToken()</span><br><span class="line">    <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">    processPost(post)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>서버에서 토큰을 가져와서 게시물을 포스트한 다음, 포스트 완료처리를 하는 세 가지 연산을 코루틴으로 만들면 JVM 혹은 바이트코드에서 내부적으로 어떤 형태로 동작하는 것일까?</p><p>이것이 Continuation Passing Style로 내부적으로 컴파일할 때 아래와 같이 바뀐다.</p><blockquote><h3 id="continuation-passing-style"><a class="markdownIt-Anchor" href="#continuation-passing-style"></a> Continuation Passing Style</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">    requestToken &#123; token -&gt;</span><br><span class="line">        <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">        processPost(post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Continuation Passing Style은 결과를 호출자에게 직접 반환하는 대신 <strong>Callback</strong>같은 것 <sup>continuation</sup>으로 결과를 전달하는 것을 의미한다.</p><blockquote><h3 id="kotlin-suspending-functions"><a class="markdownIt-Anchor" href="#kotlin-suspending-functions"></a> Kotlin suspending functions</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">createPost</span><span class="params">(token: <span class="type">Token</span>, item: <span class="type">Item</span>)</span></span>: Post &#123; … &#125;</span><br></pre></td></tr></table></figure><p><code>createPost(…)</code>라는 suspend 함수를 하나를 만들었을 때, 코루틴에서는 일시 중단이 되었다가 재개가 되는데 어떻게 이것이 가능한 것인지 알아보자.</p><blockquote><h3 id="kotlin-suspending-functions-2"><a class="markdownIt-Anchor" href="#kotlin-suspending-functions-2"></a> Kotlin suspending functions</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// suspend fun createPost(token: Token, item: Item): Post &#123; … &#125;</span></span><br><span class="line">     ↓</span><br><span class="line"><span class="comment">// Java/JVM </span></span><br><span class="line"><span class="function">Object <span class="title">createPost</span><span class="params">(Token token, Item item, Continuation&lt;Post&gt; cont)</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure><p>내부적으로는 JVM에 들어갈 때 바이트코드로 컴파일되면서 같은 <code>createPost(…)</code>인데 <strong>Continuation</strong>이 생성되어 Continuation Passing Style로 변환된다.</p><p>호출했던 함수의 끝에 매개변수가 하나 추가되서 <strong>Continuation</strong>이라는 객체를 넘겨주는 것으로 변환되는 것이다.</p><blockquote><h3 id="labels"><a class="markdownIt-Anchor" href="#labels"></a> Labels</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    suspen <span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// LABEL 0</span></span><br><span class="line">↛       <span class="keyword">val</span> token = requestToken()</span><br><span class="line">    <span class="comment">// LABEL 1</span></span><br><span class="line">↛       <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">    <span class="comment">// LABEL 2</span></span><br><span class="line">        processPost(post)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>먼저 Labael이라는 작업을 하게 되는데 코루틴에서 순차적으로 작성했던 코드들이 <code>suspend</code> 함수가 되면 컴파일할 때 Label이 찍히게 된다.</p><p>이 함수가 재개되어야 하는데, 재개될 때 필요한 <strong>Suspention Point</strong><small>(중단 지점과 재개 지점)</small>가 요구된다. 그래서 이 지점들을 Label로 찍어놓는 것이다. 이런 작업을 코틀린 컴파일러가 내부적으로 하게 된다.</p><p>대략적으로 아래와 같은 형태가 되는데, 작성했던 함수가 내부적으론 <code>switch-case</code>문처럼 바뀌어 case문이 3개가 생성되고 세 번을 실행하는 것을 알 수 있다. 함수를 실행할 때 0번이든, 1번이든, 2번이든 함수를 재개할 수 있는 지점이 생긴 것이다. 그리고 이 함수를 호출한 지점은 중단점이 될 수도 있는 것이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">    switch (label) &#123;</span><br><span class="line">        case <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">val</span> token = requestToken()</span><br><span class="line">        case <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">        case <span class="number">2</span>:</span><br><span class="line">            processPost(post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Label들이 다 완성되고 나면 Continuation Passing Style로 변환을 하게 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>, cont: <span class="type">Continuation</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sm = <span class="keyword">object</span> : CoroutineImpl &#123; … &#125;</span><br><span class="line">    switch (sm.label) &#123;</span><br><span class="line">        case <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">val</span> token = requestToken(sm)</span><br><span class="line">        case <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">val</span> post = createPost(token, item, sm)</span><br><span class="line">        case <span class="number">2</span>:</span><br><span class="line">            processPost(post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Continuation</strong>이라는 객체가 있고, 매 번 함수를 호출할 때마다 <strong>continuation</strong>을 넘겨준다. <strong>continuation</strong>은 Callback 인터페이스 같은 것으로, 재개를 해주는 인터페이스를 가진 객체인 것이다.</p><p>위의 코드에서 <code>sm</code>이라고 하는 것은 <strong>state machine</strong>을 의미하는데, 각각의 함수가 호출될 때 상태<small>(지금까지 했던 연산의 결과)</small>를 같이 넘겨줘야 한다. 이 <strong>state machine</strong>의 정체는 결국 <strong>Continuation</strong>이고, <strong>Continuation</strong>이 어떠한 정보값을 가진 형태로 Passing이 되면서 코루틴이 내부적으로 동작하게 되는 것이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>, cont: <span class="type">Continuation</span>)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> sm = cont <span class="keyword">as</span>? ThisSM ?: <span class="keyword">object</span> : ThisSM &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(…)</span></span> &#123;</span><br><span class="line">            postItem(<span class="literal">null</span>, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (sm.label) &#123;</span><br><span class="line">        case <span class="number">0</span>:</span><br><span class="line">            sm.item = item</span><br><span class="line">            sm.label = <span class="number">1</span></span><br><span class="line">            requestToken(sm)</span><br><span class="line">        case <span class="number">1</span>:</span><br><span class="line">            createPost(token, item, sm)</span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각각의 suspend function이 Continuation<small>(위 코드에선 <code>sm</code>)</small>을 마지막 매개변수로 가져가게 된다.</p><ul><li>만약 <code>requestToken(sm)</code>이 완료되었다면 <code>sm</code><small>(continuation)</small>에다가 <code>resume()</code>을 호출하게 된다.</li><li>다시 <code>createPost(token, item, sm)</code>가 호출되고 이것이 완료되었을 때도 <code>sm</code><small>(continuation)</small>에다가 <code>resume()</code>을 호출하는 형태가 반복되는 것이다.</li></ul><p>그렇다면 <code>resume()</code>은 정체가 무엇일까? 위의 코드에서 <code>resume()</code>은 결국 자기 자신을 불러주는 것이다. <small>(<code>postItem(…)</code> 내부에서 <code>postItem(…)</code>을 다시 호출하고 있음)</small></p><ul><li>예시로, suspend function인 <code>requestToken(sm)</code>의 연산이 끝났을 때 <code>resume()</code>을 통해 다시 <code>postItem(…)</code>이 호출되는데, 그때 Label 값을 하나 올려서 다른 케이스가 호출되도록 하는 것이다. 이렇게 되면 내부적으로는 마치 suspend function이 호출되고 다음 번 케이스, 그리고 또다시 다음 번 케이스로 넘어가는 형태가 되는 것이다.</li></ul><h2 id="decomplie된-코드-살펴보기"><a class="markdownIt-Anchor" href="#decomplie된-코드-살펴보기"></a> Decomplie된 코드 살펴보기</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> userData = fetchUserData()</span><br><span class="line">        <span class="keyword">val</span> userCache = cacheUserData(userData)</span><br><span class="line">        updateTextView(userCache)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchUserData</span><span class="params">()</span></span> = <span class="string">&quot;user_name&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">cacheUserData</span><span class="params">(user: <span class="type">String</span>)</span></span> = user</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">updateTextView</span><span class="params">(user: <span class="type">String</span>)</span></span> = user</span><br></pre></td></tr></table></figure><p>위의 코드를 코틀린의 바이트코드로 만든 다음, Decompile하여 Java 코드로 만들어보자.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/120593066-e3fc9400-c479-11eb-9f3d-3ad7738018d3.png'></p><blockquote><p>Decomplie된 코드</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Example_nomagic_01Kt</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">      BuildersKt.launch$default((CoroutineScope)GlobalScope.INSTANCE, (CoroutineContext)<span class="literal">null</span>, (CoroutineStart)<span class="literal">null</span>, (Function2)(new Function2((Continuation)<span class="literal">null</span>) &#123;</span><br><span class="line">         int label;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Nullable</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object $result) &#123;</span><br><span class="line">            Object var10000;</span><br><span class="line">            label17: &#123;</span><br><span class="line">               Object var4 = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">               switch(<span class="keyword">this</span>.label) &#123;</span><br><span class="line">               case <span class="number">0</span>:</span><br><span class="line">                  ResultKt.throwOnFailure($result);</span><br><span class="line">                  <span class="keyword">this</span>.label = <span class="number">1</span>;</span><br><span class="line">                  var10000 = Example_nomagic_01Kt.fetchUserData(<span class="keyword">this</span>);</span><br><span class="line">                  <span class="keyword">if</span> (var10000 == var4) &#123;</span><br><span class="line">                     <span class="keyword">return</span> var4;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">               case <span class="number">1</span>:</span><br><span class="line">                  ResultKt.throwOnFailure($result);</span><br><span class="line">                  var10000 = $result;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">               case <span class="number">2</span>:</span><br><span class="line">                  ResultKt.throwOnFailure($result);</span><br><span class="line">                  var10000 = $result;</span><br><span class="line">                  <span class="keyword">break</span> label17;</span><br><span class="line">               default:</span><br><span class="line">                  <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               String userData = (String)var10000;</span><br><span class="line">               <span class="keyword">this</span>.label = <span class="number">2</span>;</span><br><span class="line">               var10000 = Example_nomagic_01Kt.cacheUserData(userData, <span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">if</span> (var10000 == var4) &#123;</span><br><span class="line">                  <span class="keyword">return</span> var4;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String userCache = (String)var10000;</span><br><span class="line">            Example_nomagic_01Kt.updateTextView(userCache);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@NotNull</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> Continuation create(<span class="meta">@Nullable</span> Object value, <span class="meta">@NotNull</span> Continuation completion) &#123;</span><br><span class="line">            Intrinsics.checkNotNullParameter(completion, <span class="string">&quot;completion&quot;</span>);</span><br><span class="line">            Function2 var3 = new &lt;anonymous <span class="keyword">constructor</span>&gt;(completion);</span><br><span class="line">            <span class="keyword">return</span> var3;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> Object invoke(Object var1, Object var2) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((&lt;undefinedtype&gt;)<span class="keyword">this</span>.create(var1, (Continuation)var2)).invokeSuspend(<span class="built_in">Unit</span>.INSTANCE);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;), <span class="number">3</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> static void main(String[] var0) &#123;</span><br><span class="line">      main();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> Object fetchUserData(<span class="meta">@NotNull</span> Continuation $completion) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;user_name&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> Object cacheUserData(<span class="meta">@NotNull</span> String user, <span class="meta">@NotNull</span> Continuation $completion) &#123;</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> String updateTextView(<span class="meta">@NotNull</span> String user) &#123;</span><br><span class="line">      Intrinsics.checkNotNullParameter(user, <span class="string">&quot;user&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>코드의 <em>64번째 라인</em>을 보면 <code>fetchUserData(…)</code>와 <code>cacheUserData(…)</code>와 같이 suspend function이었던 함수들이 일반 함수로 변경되고 마지막 매개변수로 Continuation이 들어간 것을 확인할 수 있다.</p></li><li><p>일시 중단과 재개를 위해서 suspention point를 label로 표시해두는 <strong>Labeling</strong> 작업이 Decompile되어 <em>11번째 라인</em>과 같이 <code>switch-case</code>문이 생성된 것을 확인할 수 있다.</p><ul><li>케이스가 3개 생성되었는데 첫 번째 케이스에서 <code>fetchUserData(…)</code>를 호출하면서 <strong>Continuation</strong> 객체가 넘어가는 것을 확인할 수 있다.</li><li>위의 자료에서 설명했던 부분과는 다른 부분이 존재하지만, 요지는 <code>switch-case</code> 형태로 Decompile되면서 다시 재개될 수 있는 형태로 만들어지고 <strong>Continuation</strong> 객체가 전달되고 있는 것을 확인할 수 있다는 것이다.</li><li>아래 이미지처럼 <em>15번째 라인</em>과 <em>34번째 라인</em>에서 함수의 마지막 매개변수로 Continuation 객체가 <code>this</code>로 전달되고 있다.</li></ul></li></ol><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/120595224-004e0000-c47d-11eb-8e2c-3f965f4c09ed.png'></p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/120595278-10fe7600-c47d-11eb-8ffc-cbcb1437b475.png'></p><h2 id="cps-simulation-해보기"><a class="markdownIt-Anchor" href="#cps-simulation-해보기"></a> CPS simulation 해보기</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">↛       <span class="keyword">val</span> userData = fetchUserData()</span><br><span class="line">↛       <span class="keyword">val</span> userCache = cacheUserData(userData)</span><br><span class="line">        updateTextView(userCache)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;[in] main&quot;</span>)</span><br><span class="line">    myCoroutine(MyContinuation())</span><br><span class="line">    println(<span class="string">&quot;\n[out] main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myCoroutine</span><span class="params">(cont: <span class="type">MyContinuation</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span>(cont.label) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;\nmyCoroutine(), label: <span class="subst">$&#123;cont.label&#125;</span>&quot;</span>)</span><br><span class="line">            cont.label = <span class="number">1</span></span><br><span class="line">            fetchUserData(cont)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">1</span> -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;\nmyCoroutine(), label: <span class="subst">$&#123;cont.label&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> userData = cont.result</span><br><span class="line">            cont.label = <span class="number">2</span></span><br><span class="line">            cacheUserData(userData, cont)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">2</span> -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;\nmyCoroutine(), label: <span class="subst">$&#123;cont.label&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> userCache = cont.result</span><br><span class="line">            updateTextView(userCache)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fetchUserData</span><span class="params">(cont: <span class="type">MyContinuation</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;fetchUserData(), called&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result = <span class="string">&quot;[서버에서 받은 사용자 정보]&quot;</span></span><br><span class="line">    println(<span class="string">&quot;fetchUserData(), 작업완료: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    cont.resumeWith(Result.success(result))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cacheUserData</span><span class="params">(user: <span class="type">String</span>, cont: <span class="type">MyContinuation</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;cacheUserData(), called&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result = <span class="string">&quot;[캐쉬함 <span class="variable">$user</span>]&quot;</span></span><br><span class="line">    println(<span class="string">&quot;cacheUserData(), 작업완료: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    cont.resumeWith(Result.success(result))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">updateTextView</span><span class="params">(user: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;updateTextView(), called&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;updateTextView(), 작업완료: [텍스트 뷰에 출력 <span class="variable">$user</span>]&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContinuation</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = EmptyCoroutineContext)</span><br><span class="line">    : Continuation&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> label = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result.getOrThrow()</span><br><span class="line">        println(<span class="string">&quot;Continuation.resumeWith()&quot;</span>)</span><br><span class="line">        myCoroutine(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[in] main</span><br><span class="line"></span><br><span class="line">myCoroutine(), label: 0</span><br><span class="line">fetchUserData(), called</span><br><span class="line">fetchUserData(), 작업완료: [서버에서 받은 사용자 정보]</span><br><span class="line">Continuation.resumeWith()</span><br><span class="line"></span><br><span class="line">myCoroutine(), label: 1</span><br><span class="line">cacheUserData(), called</span><br><span class="line">cacheUserData(), 작업완료: [캐쉬함 [서버에서 받은 사용자 정보]]</span><br><span class="line">Continuation.resumeWith()</span><br><span class="line"></span><br><span class="line">myCoroutine(), label: 2</span><br><span class="line">updateTextView(), called</span><br><span class="line">updateTextView(), 작업완료: [텍스트 뷰에 출력 [캐쉬함 [서버에서 받은 사용자 정보]]]</span><br><span class="line"></span><br><span class="line">[out] main</span><br></pre></td></tr></table></figure><h2 id="정리"><a class="markdownIt-Anchor" href="#정리"></a> 정리</h2><ul><li>There is no magic<ul><li>CPS<small>Continuation Passing Style</small> == Callbacks</li><li>CPS Transformation</li></ul></li><li>Decompile<ul><li>Labels</li><li>Callback</li></ul></li><li>CPS simulation<ul><li>debugging</li></ul></li></ul><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li><a href="https://youtu.be/DOXyH1RtMC0">새차원, 코틀틴 코루틴</a></li><li><a href="https://www.youtube.com/watch?v=YrrUCSi72E8&amp;t=110s">KotlinConf 2017 - Deep Dive into Coroutines on JVM by Roman Elizarov</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/categories/Kotlin/Coroutine/">Coroutine</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Coroutine/">Coroutine</category>
      
      
      <comments>http://june0122.github.io/2021/06/09/coroutines-under-the-hood/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] CustomView &amp; Touch Event</title>
      <link>http://june0122.github.io/2021/06/07/android-bnr-30/</link>
      <guid>http://june0122.github.io/2021/06/07/android-bnr-30/</guid>
      <pubDate>Sun, 06 Jun 2021 17:09:18 GMT</pubDate>
      
      <description>안드로이드는 뛰어난 기능의 표준 뷰와 위젯을 많이 제공한다. 그러나 때로는 앱 특유의 비주얼을 보여주는 &lt;b&gt;커스텀&lt;small&gt;(custom)&lt;/small&gt; 뷰&lt;/b&gt;가 필요하다. 커스텀 뷰를 생성하려면 다음의 세 단계를 거친다.&lt;br&gt;&amp;emsp;➀ 슈퍼 클래스를 선택한다. 단순 커스텀 뷰에선 &lt;b&gt;View&lt;/b&gt;, 복합 커스텀 뷰에선 &lt;b&gt;FrameLayout&lt;/b&gt;과 같이 적합한 레이아웃 클래스를 선택한다.&lt;br&gt;&amp;emsp;➁ 1번에서 선택한 슈퍼 클래스의 서브 클래스를 만들고, 해당 슈퍼 클래스의 생성자를 오버라이드한다.&lt;br&gt;&amp;emsp;➂ 슈퍼 클래스의 주요 함수들을 오버라이드해 커스터마이징한다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="커스텀-뷰-생성하기"><a class="markdownIt-Anchor" href="#커스텀-뷰-생성하기"></a> 커스텀 뷰 생성하기</h2><p>안드로이드는 뛰어난 기능의 표준 뷰와 위젯을 많이 제공한다. 그러나 때로는 앱 특유의 비주얼을 보여주는 커스텀<small>(custom)</small> 뷰가 필요하다.</p><p>커스텀 뷰에는 여러 종류가 있지만 크게 두 가지 유형으로 분류할 수 있다.</p><ul><li><b>단순<small>(simple)</small></b> : 단순 뷰는 내부적으로 복잡할 수 있지만, 자식 뷰가 없어서 구조가 간단하다. 대부분 커스텀 렌더링을 수행한다.</li><li><b>복합<small>(composite)</small></b> : 복합 뷰는 서로 다른 뷰 객체들로 구성된다. 일반적으로 복합 뷰는 자식 뷰들을 관리하지만, 자신은 커스텀 렌더링을 하지 않는다. 대신에 렌더링은 각 자식 뷰에게 위임한다.</li></ul><p>커스텀 뷰를 생성하려면 다음의 세 단계를 거친다.</p><ol><li>슈퍼 클래스를 선택한다. 단순 커스텀 뷰에서 View는 비어 있는 캔버스와 같아서 가장 많이 사용된다. 복합 커스텀 뷰에서는 FrameLayout과 같이 적합한 레이아웃 클래스를 선택한다.</li><li>1번에서 선택한 슈퍼 클래스의 서브 클래스를 만들고, 해당 슈퍼 클래스의 생성자를 오버라이드한다.</li><li>슈퍼 클래스의 주요 함수들을 오버라이드해 커스터마이징한다.</li></ol><h3 id="boxdrawingview-생성하기"><a class="markdownIt-Anchor" href="#boxdrawingview-생성하기"></a> BoxDrawingView 생성하기</h3><p><strong>BoxDrawingView</strong>는 단순 뷰이면서 <b>View</b>의 직계 서브 클래스가 된다.</p><p>BoxDrawingView라는 이름의 새로운 클래스를 생성하고 <strong>View</strong>를 슈퍼 클래스로 지정한다. 그리고 BoxDrawingView.kt에서 아래 코드와 같이 생성사를 추가한다. 이 생성자는 Context 객체 및 null이 가능하면서 기본값이 null인 <strong>AttributeSet</strong> 객체를 인자로 받는다.</p><blockquote><p>BoxDrawingView의 초기 구현 (BoxDrawingView.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxDrawingView</span></span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>) : View(context, attrs) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이처럼 <strong>AttributeSet</strong>에 기본값을 지정하면, 실제로는 <strong>두 개의 생성자가 제공</strong>된다. 우리 뷰의 인스턴스가 <em>➀ 코드</em> 또는 <em>➁ 레이아웃 XML 파일</em>로부터 생성될 수 있어야 하기 때문이다. 레이아웃 파일로부터 인스턴스가 생성되어 초기화되는 뷰는 XML에 지정된 속성들을 포함하는 <strong>AttributeSet</strong>의 인스턴스를 인자로 받는다.</p><p>그다음으로 BoxDrawingView를 사용하도록 <em>res/layout/activity_drag_and_drawing.xml</em> 레이아웃 파일을 변경한다.</p><blockquote><p>BoxDrawingView를 레이아웃에 추가하기 (res/layout/activity_drag_and_drawing.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.june0122.draganddraw.BoxDrawingView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>여기서는 레이아웃 인플레이터가 찾을 수 있게 BoxDrawingView 클래스가 속한 패키지의 전체 경로를 지정해야 한다. 인플레이터는 View 인스턴스를 생성하는 데 필요한 레이아웃 파일을 찾는다. 이때 요소로 지정된 클래스 이름에 전체 패키지 경로가 지정되지 않으면 인플레이터가 android.view와 android.widget 패키지에서 해당 이름의 클래스를 찾는다. 따라서 해당 클래스가 다른 곳에 있다면 레이아웃 인플레이터는 그것을 찾지 못하고 앱은 실행이 중단된다. 그러므로 <strong>android.view와 android.widget 패키지 외부에 있는 커스텀 클래스나 이외의 다른 클래스들에서는 반드시 전체 패키지 경로가 포함된 클래스 이름을 지정해야 한다.</strong></p><h2 id="터치-이벤트-처리하기"><a class="markdownIt-Anchor" href="#터치-이벤트-처리하기"></a> 터치 이벤트 처리하기</h2><p>터치 이벤트를 리스닝할 때는 다음의 <strong>View</strong> 함수를 사용해서 터치 이벤트 리스너를 설정한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnTouchListener</span><span class="params">(l: <span class="type">View</span>.<span class="type">OnTouchListener</span>)</span></span></span><br></pre></td></tr></table></figure><p>이 함수는 <code>setOnClickListener(View.OnClickListener)</code>와 같은 방법으로 작동한다. 즉, 함수의 인자로 <code>View.OnClickListener</code>를 구현한 리스너 객체<small>(여기서는 View의 서브 클래스인 BoxDrawingView 인스턴스)</small>를 전달하면 터치 이벤트가 발생할 때마다 이 객체에 구현된 <code>onTouchEvent(…)</code> 함수가 호출된다.</p><p>따라서 BoxDrawingView에서는 다음 View 함수를 오버라이드하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(evenet: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure><p>이 함수는 <strong>MotionEvent</strong> 인스턴스를 인자로 받는다. <strong>MotionEvent</strong>는 터치 이벤트를 나타내는 클래스이며, 화면을 터치한 위치와 <b>액션<small>(action)</small></b>을 포함한다. 액션은 다음과 같이 이벤트 발생 단계를 나타낸다.</p><table><thead><tr><th style="text-align:center">액션 상수</th><th style="text-align:center">의미</th></tr></thead><tbody><tr><td style="text-align:center">ACTION_DOWN</td><td style="text-align:center">사용자가 화면을 손가락으로 터치함</td></tr><tr><td style="text-align:center">ACTION_MOVE</td><td style="text-align:center">사용자가 화면 위에서 손가락을 움직임</td></tr><tr><td style="text-align:center">ACTION_UP</td><td style="text-align:center">사용자가 화면에서 손가락을 뗌</td></tr><tr><td style="text-align:center">ACTION_CANCEL</td><td style="text-align:center">부모 뷰가 터치 이벤트를 가로챔</td></tr></tbody></table><p><code>onTouchEvent(MotionEvent)</code>의 구현 코드에서는 <strong>MotionEvent</strong> 객체의 다음 함수를 호출해 액션의 값을 확인할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAction</span><span class="params">()</span></span>: <span class="built_in">Int</span></span><br></pre></td></tr></table></figure><p>BoxDrawingView.kt에 아래 코드를 추가하자. 여기서는 이벤트가 제대로 처리되는지 로그캣에서 확인하기 위해 로그 태그 상수와 네 개의 각 액션에 대해 로그 메시지를 출력하는 <code>onTouchEvent(MotionEvent)</code>의 구현 코드도 추가한다.</p><blockquote><p>BoxDrawingView 구현하기 (BoxDrawingView.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;BoxDrawingView&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxDrawingView</span></span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>) : View(context, attrs) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> current = PointF(event.x, event.y)</span><br><span class="line">        <span class="keyword">var</span> action = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">when</span> (event.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_DOWN&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_MOVE&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_UP -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_UP&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_CANCEL -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_CANCEL&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;<span class="variable">$action</span> at x=<span class="subst">$&#123;current.x&#125;</span>, y=<span class="subst">$&#123;current.y&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 터치된 위치를 나타내는 X와 Y 좌표를 <strong>PointF</strong> 객체에 넣는다. 이 장의 나머지 코드에서 두 값을 같이 사용해야 하기 때문이다. <strong>PointF</strong>는 이런 역할을 하는 <strong>안드로이드의 컨테이너 클래스</strong>다.</p><p><em>Logcat</em> 창의 검색 상자에 <strong>I/BoxDrawingView</strong>를 입력하고 앱을 실행하여 화면을 터치하고 끌어보는 등 상호 작용을 하면 BoxDrawingView가 받는 모든 터치 액션의 X, Y 좌표가 로그에 실시간으로 출력된다.</p><blockquote><p>앱 화면과 상호 작용을 했을 때 로그에 나타나는 X, Y 좌표값들</p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/120932086-619cfa00-c72f-11eb-812b-f8d462797b5e.png'></p><h3 id="모션-이벤트-추적하기"><a class="markdownIt-Anchor" href="#모션-이벤트-추적하기"></a> 모션 이벤트 추적하기</h3><p>BoxDrawingView에서는 좌표만 로깅하는 게 아니라 화면에 박스들도 그릴 것이다. 이렇게 하려면 몇 가지 해결할 것이 있다.</p><p>우선 박스를 정의하기 위해 시작 지점<small>(손가락이 처음 놓인 곳)</small>과 현재 지점<small>(손가락이 현재 있는 곳)</small>이 반드시 필요하다.</p><p>그다음에 박스를 정의하려면 하나 이상의 MotionEvent로부터 발생하는 데이터를 추적해야하며, 이 데이터를 Box 객체에 저장해야 한다.</p><p>하나의 박스를 정의하는 데이터를 나타내는 <strong>Box</strong> 클래스를 생성해 아래의 코드를 추가한다.</p><blockquote><p>Box 클래스 추가하기 (Box.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span>(<span class="keyword">val</span> start: PointF) &#123;</span><br><span class="line">    <span class="keyword">var</span> end: PointF = start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> left: <span class="built_in">Float</span></span><br><span class="line">        <span class="keyword">get</span>() = min(start.x, end.x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> right: <span class="built_in">Float</span></span><br><span class="line">        <span class="keyword">get</span>() = max(start.x, end.x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> top: <span class="built_in">Float</span></span><br><span class="line">        <span class="keyword">get</span>() = min(start.y, end.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> bottom: <span class="built_in">Float</span></span><br><span class="line">        <span class="keyword">get</span>() = max(start.y, end.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용자가 BoxDrawingView를 터치하면 새로운 Box 객체가 생성되어 기존 박스 List에 추가되도록 하자.</p><p>사용자가 그리는 상태 정보를 추적하기 위해 BoxDrawingView 클래스에 새로운 Box 객체를 사용하는 코드를 추가한다.</p><blockquote><p>Box 객체를 사용하는 코드 추가하기 (BoxDrawingView.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxDrawingView</span></span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>) : View(context, attrs) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currentBox: Box? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> boxen = mutableListOf&lt;Box&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> current = PointF(event.x, event.y)</span><br><span class="line">        <span class="keyword">var</span> action = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">when</span> (event.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_DOWN&quot;</span></span><br><span class="line">                <span class="comment">// 그리기 상태를 재설정한다</span></span><br><span class="line">                currentBox = Box(current).also &#123; boxen.add(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_MOVE&quot;</span></span><br><span class="line">                updateCurrentBox(current)</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_UP -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_UP&quot;</span></span><br><span class="line">                updateCurrentBox(current)</span><br><span class="line">                currentBox = <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_CANCEL -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_CANCEL&quot;</span></span><br><span class="line">                currentBox = <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;<span class="variable">$action</span> at x=<span class="subst">$&#123;current.x&#125;</span>, y=<span class="subst">$&#123;current.y&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateCurrentBox</span><span class="params">(current: <span class="type">PointF</span>)</span></span> &#123;</span><br><span class="line">        currentBox?.let &#123;</span><br><span class="line">            it.end = current</span><br><span class="line">            invalidate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 <em>ACTION_DOWN</em> 모션 이벤트를 받을 때마다 <em>currentBox</em> 속성을 새로운 Box 객체로 설정한다. 이 객체는 이벤트가 발생한 위치를 시작 지점으로 가지며 박스 List에 저장된다<small>(본문의 뒤에서 그리기를 구현할 때 BoxDrawingView에서 이 박스 List에 저장된 모든 Box를 화면에 그린다)</small>.</p><p>사용자의 손가락이 화면을 이동하거나 화면에서 떨어지면 <em>currentBox.end</em>를 변경한다. 그리고 터치가 취소되거나 사용자의 손가락이 화면에서 떨어지면 그리기를 끝내기 위해 <em>currentBox</em>를 null로 변경한다. 즉, Box 객체는 List에 안전하게 저장되지만, 모션 이벤트에 관해서는 더 이상 변경이 생기지 않는다.</p><p><code>updateCurrentBox()</code> 함수에서 <code>invalidate()</code>를 호출한다. <code>invalidate()</code> 함수를 호출하면 뷰가 <b>무효<small>(invalid)</small></b>라는 것을 안드로이드에게 알려주므로 안드로이드 시스템이 해당 뷰의 변경 사항을 반영해서 다시 그려준다. 여기서는 사용자가 손가락을 움직여서 새로운 박스를 생성하거나 박스 크기를 조정할 때마다 <code>invalidate()</code> 함수를 호출해 BoxDrawingView를 다시 그리게 한다. 이렇게 하면 사용자가 손가락을 끌어서 박스를 생성하는 동안 어떤 모습인지 볼 수 있다.</p><p>참고로 앱이 시작되면 앱의 모든 뷰가 <strong>무효</strong> 상태가 되어 뷰들이 화면에 어떤 것도 그릴 수 없게 된다. 이런 상황을 해결하기 위해 안드로이드는 최상위 수준 <strong>View</strong>의 <code>draw()</code> 함수를 호출함으로써 부모 뷰가 자신을 그리게 되고, 이것의 자식 뷰들 또한 자신들을 그리게 된다. 뷰 계층을 따라 내려가면서 자식 뷰들의 또 다른 자식 뷰들도 자신들을 그리게 되는 식이다. 결국 뷰 계층의 모든 뷰가 자신을 그리게 되면 최상위 수준 <strong>View</strong>는 더 이상 무효 상태가 되지 않는다.</p><p>다음으로 박스를 화면에 그려보자.</p><h2 id="ondrawcanvas-내부에서-렌더링하기"><a class="markdownIt-Anchor" href="#ondrawcanvas-내부에서-렌더링하기"></a> <code>onDraw(Canvas)</code> 내부에서 렌더링하기</h2><p>뷰가 화면에 그려지게 하려면 다음 View 함수를 오버라이드해야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span></span><br></pre></td></tr></table></figure><p><code>onTouchEvent(MotionEvent)</code>의 <em>ACTION_MOVE</em>에 대한 응답에서 호출한 <code>invalidate()</code> 함수는 BoxDrawingView를 다시 무효 상태로 만든다. 그럼으로써 BoxDrawingView는 자신을 다시 그리게 되고 이때 <code>onDraw(Canvas)</code>가 다시 호출된다.</p><p>이제는 <strong>Canvas</strong> 매개변수에 대해 알아보자. <strong>Canvas</strong>와 <strong>Paint</strong> 모두 안드로이드의 주요 그리기 클래스다.</p><ul><li><strong>Canvas</strong> 클래스는 모든 그리기 함수를 갖고 있다. 우리가 호출하는 Canvas의 함수들은 그리는 위치와 선, 원, 단어, 사각형 등의 형태를 결정한다.</li><li><strong>Paint</strong> 클래스는 이런 함수들이 어떻게 수행되는지를 결정한다. 즉, 우리가 호출하는 Paint의 함수들은 도형이 채워져야 하는지, 어떤 폰트의 텍스트를 그리는지, 어떤 색의 선인지와 같은 특성을 지정한다.</li></ul><p>BoxDrawingView 인스턴스가 초기화될 때 두 개의 Paint 객체를 생성하도록 BoxDrawingView.kt를 변경한다.</p><blockquote><p>Paint 객체 생성하기 (BoxDrawingView.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxDrawingView</span></span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>) : View(context, attrs) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currentBox: Box? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> boxen = mutableListOf&lt;Box&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> boxPaint = Paint().apply &#123;</span><br><span class="line">        color = <span class="number">0x22ff0000</span>.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> backgroundPaint = Paint().apply &#123;</span><br><span class="line">        color = <span class="number">0xfff8efe0</span>.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제는 화면에 박스를 그릴 수 있다.</p><blockquote><p><code>onDraw(Canvas)</code> 오버라이드 하기 (BoxDrawingView.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxDrawingView</span></span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>) : View(context, attrs) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 배경을 채운다</span></span><br><span class="line">        canvas.drawPaint(backgroundPaint)</span><br><span class="line">        </span><br><span class="line">        boxen.forEach &#123; box -&gt; </span><br><span class="line">            canvas.drawRect(box.left, box.top, box.right, box.bottom, boxPaint)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>황백색 배경의 Paint를 사용해서 박스의 배경인 캔버스를 채운다. 그다음에 박스 List에 저장된 각 Box 객체에 대해 박스의 두 점을 조사해 직사각형의 왼쪽, 오른쪽, 위, 아래의 꼭지점 위치를 결정한다. 왼쪽과 위의 값은 X와 Y의 최솟값이, 아래쪽과 오른쪽은 최댓값이 된다.</p><p>이 값들을 산출한 후 <code>Canvas.drawRect(…)</code>를 호출해 화면에 빨간색의 사각형을 그린다.</p><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/120933267-48e31300-c734-11eb-909a-f00498e631cc.gif'></p><h2 id="궁금증-해소-️-gesturedetector"><a class="markdownIt-Anchor" href="#궁금증-해소-️-gesturedetector"></a> 궁금증 해소 💁🏻‍♂️ : GestureDetector</h2><p>터치 이벤트를 처리하는 또 다른 방법으로 <strong>GestureDetector</strong> 객체가 있다. GestureDetector는 특정 이벤트가 발생하면 알려주는 리스너를 갖고 있다. 예를 들어, <code>GestureDetector.OnGestureListener</code>는 화면을 길게 누르거나 밀거나 스크롤하는 등의 이벤트를 리스닝하는 함수들을 갖고 있다. 그리고 두 번 두드림 이벤트를 리스닝하는 <code>GestureDetector.OnDoubleTapListener</code>도 있다. 대부분은 View의 <code>onTouch(…)</code>나 <code>onTouchEvent(…)</code> 함수를 오버라이드해서 사용하는 다양한 이벤트 처리가 필요하지 않다. 따라서 이러한 함수 대신 GestureDetector를 사용하는 것도 아주 좋은 방법이다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/CustomView/">CustomView</category>
      
      <category domain="http://june0122.github.io/tags/TouchEvent/">TouchEvent</category>
      
      
      <comments>http://june0122.github.io/2021/06/07/android-bnr-30/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] 단위 테스트와 오디오 재생</title>
      <link>http://june0122.github.io/2021/06/06/android-bnr-20/</link>
      <guid>http://june0122.github.io/2021/06/06/android-bnr-20/</guid>
      <pubDate>Sun, 06 Jun 2021 05:28:37 GMT</pubDate>
      
      <description>&lt;b&gt;단위 테스트&lt;small&gt;(unit testing)&lt;/small&gt;&lt;/b&gt;는 하나의 컴포넌트&lt;small&gt;(주로 클래스)&lt;/small&gt; 자체를 테스트하는 것이므로 작성할 수 있는 가장 작은 종류의 테스트다. 그리고 테스트를 실행하고자 전체 앱이나 장치를 사용할 필요가 없으며, 테스트를 여러 번 실행해도 충분할 만큼 빠르게 실행된다. 따라서 하나의 컴포넌트르 테스트할 때 장치 테스트로 실행하는 경우는 거의 없다. 단위 테스트는 안드로이드 런타임이 아닌 &lt;b&gt;로컬 컴퓨터의 JVM&lt;small&gt;(Java Virtual Machine)&lt;/small&gt;에서 실행되므로 빠르게 이루어진다.&lt;/b&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>MVVM 아키텍처가 매력적인 이유 중 하나는 <b>단위 테스트<small>(unit testing)</small></b>가 쉽기 때문이다. 단위 테스트는 앱의 각 단위가 제대로 작동하는지 검사하는 작은 프로그램들을 작성하는 것이다.</p><p>본문에서는 단위 테스트 및 안드로이드 오디오 API를 쉽게 사용하도록 해주는 도구인 <strong>SoundPool</strong> 클래스를 사용한다. <strong>SoundPool</strong> 클래스는 많은 음원 파일을 메모리로 로드할 수 있으며, 재생하려는 음원의 최대 개수를 언제든 제어할 수 있다. 따라서 사용자가 앱의 모든 버튼을 동시에 마구잡이로 누르더라도 앱의 실행이나 장치에는 영향을 주지 않는다.</p><h2 id="soundpool-생성하기"><a class="markdownIt-Anchor" href="#soundpool-생성하기"></a> SoundPool 생성하기</h2><p>먼저 BeatBox 클래스 내부에 음원 재생 기능을 추가한다. 우선 SoundPool 객체를 생성하는 코드를 작성하자.</p><blockquote><p>SoundPool 생성하기 (BeatBox.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;BeatBox&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SOUNDS_FOLDER = <span class="string">&quot;sample_sounds&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> MAX_SOUNDS = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatBox</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> assets: AssetManager) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sounds: List&lt;Sound&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> soundPool = SoundPool.Builder()</span><br><span class="line">        .setMaxStreams(MAX_SOUNDS)</span><br><span class="line">        .build()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        sounds = loadSounds()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SoundPool 인스턴스를 생성할 때는 SoundPool.Builder 클래스의 <code>build()</code> 함수를 사용한다. 따라서 여기서는 <strong>SoundPool.Builder</strong> 인스턴스를 생성한 후 <code>build()</code>를 호출한다.</p><p><code>setMaxStreams(Int)</code> 함수에서는 현재 시점에 재생할 음원의 최대 개수를 인자로 전달하여 지정할 수 있다. 코드에서는 5를 전달하는데, 따라서 다섯 개의 음원이 재생 중일 때 여섯 번째 음원을 재생하려고 하면 SoundPool이 가장 오래된 음원의 재생을 중단한다.</p><p>또한, <code>setAudioAttributes(AudioAttributes)</code>를 사용하면 오디오 스티름의 다른 속성들을 지정할 수 있다. 자세한 내용은 <a href="https://developer.android.com/reference/android/media/AudioAttributes">안드로이드 문서</a>에서!</p><h2 id="에셋-사용하기"><a class="markdownIt-Anchor" href="#에셋-사용하기"></a> 에셋 사용하기</h2><p>현재 음원 파일들은 앱의 애셋으로 저장되어 잇는데, 이 파일들을 사용해서 오디오를 재생하기에 앞서 애셋의 작동 원리를 알아보자.</p><p>Sound 객체는 애셋 파일 경로를 갖고 있다. 그런데 애셋 파일 경로의 파일을 열 때는 File 클래스를 사용할 수 없고 반드시 <strong>AssetManager</strong>를 사용해야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> assetPath = sound.assetPath</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> assetManager = context.assets</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> soundData = assetManager.<span class="keyword">open</span>(assetPath)</span><br></pre></td></tr></table></figure><p>이렇게 하면 코틀린의 다른 <strong>InputStream</strong>을 사용할 때처럼 표준 <strong>InputStream</strong>이 반환된다.</p><p>경우에 따라서는 <strong>InputStream</strong> 대신 <strong>FileDescriptor</strong>가 필요할 수 있다. <strong>SoundPool</strong>을 사용할 때가 그렇다. 이때는 <code>AssetManager.openFd(String)</code>을 호출하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> assetPath = sound.assetPath</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> assetManager = context.assets</span><br><span class="line"></span><br><span class="line"><span class="comment">// AssetFileDescriptor는 FileDescriptor와 다르다</span></span><br><span class="line"><span class="keyword">val</span> assetFileDescriptor = assetManager.openFd(assetPath)</span><br><span class="line"></span><br><span class="line"><span class="comment">// … 그러나 필요하다면 다음과 같이 쉽게 보통의 FileDescriptor를 얻을 수 있다</span></span><br><span class="line"><span class="keyword">val</span> fileDescriptor = assetFileDescriptor.fileDescriptor</span><br></pre></td></tr></table></figure><h2 id="음원-로드하기"><a class="markdownIt-Anchor" href="#음원-로드하기"></a> 음원 로드하기</h2><p>SoundPool에 음원을 로드하는 것이 다음으로 할 일이다. 오디오를 재생하는 다른 방법과 달리 SoundPool을 사용하면 응답이 빠르다. 따라서 음원 재생을 요청하면 즉시 재생이 시작된다.</p><p>단, 재생에 앞서 SoundPool로 음원을 로드해야 한다. 이때 로드할 각 음원은 자신의 정수 ID를 갖는다. 이 ID를 유지하기 위한 <em>soundId</em> 속성을 Sound 클래스에 추가한다.</p><blockquote><p><em>soundId</em> 속성 추가하기 (Sound.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sound</span></span>(<span class="keyword">val</span> assetPath: String, <span class="keyword">var</span> soundId: <span class="built_in">Int</span>? = <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> name = assetPath.split(<span class="string">&quot;/&quot;</span>).last().removeSuffix(WAV)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 <em>soundId</em> 속성을 null이 가능한 Int? 타입으로 지정하였다. <em>soundId</em>에 null 값을 지정하여 Sound의 ID 값이 없음을 알려줄 수 있기 때문이다.</p><p>다음으로는 음원을 로드한다. SoundPool에 Sound 인스턴스를 로드하기 위해 BeatBox 클래스에 <code>load(Sound)</code> 함수를 추가한다.</p><blockquote><p>SoundPool에 음원 로드하기 (BeatBox.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatBox</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> assets: AssetManager) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadSounds</span><span class="params">()</span></span>: List&lt;Sound&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">(sound: <span class="type">Sound</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> afd: AssetFileDescriptor = assets.openFd(sound.assetPath)</span><br><span class="line">        <span class="keyword">val</span> soundId = soundPool.load(afd, <span class="number">1</span>)</span><br><span class="line">        sound.soundId = soundId</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 <code>soundPool.load(AssetFileDescriptor, Int)</code> 함수를 호출해 나중에 재생할 음원 파일을 SoundPool에 로드한다. 이 함수에서는 정수 ID를 반환하는데, 음원을 유지하고 다시 재생<small>(또는 언로드)</small>하기 위해서다. 그리고 이 값을 앞에서 정의했던 <em>soundId</em> 속성에 저장한다.</p><p><code>openFd(String)</code>에서는 IOException을 발생시킬 수 있으므로 <code>load(Sound)</code>도 IOException을 발생시킬 수 있다. 따라서 <code>load(Sound)</code>가 호출될 때는 항상 IOException을 처리해야 한다.</p><p>다음으로 <code>load(Sound)</code>를 호출해 모든 음원을 로드하는 코드를 <code>BeatBox.loadSounds()</code> 함수 내부에 추가한다.</p><blockquote><p>모든 음원을 로드하기 (BeatBox.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadSounds</span><span class="params">()</span></span>: List&lt;Sound&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">val</span> sounds = mutableListOf&lt;Sound&gt;()</span><br><span class="line">    soundNames.forEach &#123; fileName -&gt;</span><br><span class="line">        <span class="keyword">val</span> assetPath = <span class="string">&quot;<span class="variable">$SOUNDS_FOLDER</span>/<span class="variable">$fileName</span>&quot;</span></span><br><span class="line">        <span class="keyword">val</span> sound = Sound(assetPath)</span><br><span class="line">        <span class="comment">//  sounds.add(sound)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            load(sound)</span><br><span class="line">            sounds.add(sound)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ioe: IOException) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Could not load sound <span class="variable">$fileName</span>&quot;</span>, ioe)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sounds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeatBox 앱을 실행해 에러 없이 모든 음원이 로드되는지 확인해본다. 만일 정상적으로 로드되지 않으면 로그캣 창에 붉은색의 예외 메시지가 나타난다<small>(아직 음원은 재생되지 않으며 화면에도 아무 변화가 없다)</small>.</p><h2 id="음원-재생하기"><a class="markdownIt-Anchor" href="#음원-재생하기"></a> 음원 재생하기</h2><p>BeatBox 앱에서 음원 재생이 되어야 하니 음원을 재생하는 <code>play(Sound)</code> 함수를 BeatBox 클래스에 추가한다.</p><blockquote><p>음원 재생하기 (BeatBox.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatBox</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> assets: AssetManager) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        sounds = loadSounds()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">play</span><span class="params">(sound: <span class="type">Sound</span>)</span></span> &#123;</span><br><span class="line">        sound.soundId?.let &#123; </span><br><span class="line">            soundPool.play(it, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1.0f</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>play(Sound)</code> 함수는 음원을 재생하기 전에 해당 음원의 <em>soundId</em>가 null이 아닌지 확인한다. 만일 음원 로드에 실패하면 null이 될 수 있다.</p><p>일단 null 값이 아니라고 확인되면 <code>SoundPool.play(Int, Float, Float, Int, Int, Float)</code>를 호출해 음원을 재생한다. 매개 변수들의 내역은 다음과 같다. 음원 ID, 왼쪽 볼륨<small>(0.0 ~ 1.0)</small>, 오른쪽 볼륨, 스트림 우선순위<small>(0이면 최저 우선순위)</small>, 반복 재생 여부<small>(0이면 반복 안함, -1이면 무한 반복, 그 외의 숫자는 반복 횟수)</small>, 재생률<small>(1이면 녹음된 속도 그대로, 2는 두 배 빠르게 재생, 0.5는 절반 느리게 재생)</small>이다.</p><p>이제는 음원 재생을 <strong>SoundViewModel</strong>에 통합할 준비가 되었다. 그 전에 테스트에 실패하도록 단위 테스트를 작성한 후 문제점을 해결하자!</p><h2 id="테스트-라이브러리-의존성-추가하기"><a class="markdownIt-Anchor" href="#테스트-라이브러리-의존성-추가하기"></a> 테스트 라이브러리 의존성 추가하기</h2><p>테스트 코드를 작성하기 전에 테스팅 도구인 <strong>Mockito</strong>와 <strong>Hamcrest</strong>를 추가한다.</p><p><strong>Mockito</strong>는 간단한 <b>모의 객체<small>(mock object)</small></b>를 쉽게 생성해주는 프레임워크다. 모의 객체는 테스트를 독립적으로 할 수 있게 도와주므로, 잘못해서 동시에 다른 객체를 테스트하지 않게 해준다.</p><p><strong>Hamcrest</strong>는 <strong>matcher</strong> 라이브러리다. Matcher는 코드에 ‘일치(match)’ 조건을 쉽게 만들어주고, 만일 코드가 우리 바람과 일치하지 않으면 실패로 처리하는 도구다.</p><p><strong>Hamcrest는 JUnit 라이브러리에 자동으로 포함</strong>되며, JUnit은 새로운 안드로이드 스튜디오 프로젝트를 생성할 때 의존성에 자동으로 포함된다. 따라서 테스트 빌드에 Mockito 의존성만 추가하면 된다.</p><blockquote><p>Mockito 의존성 추가하기 (app/build.gradle)</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    testImplementation <span class="string">&#x27;junit:junit:4.13.2&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.mockito:mockito-core:3.3.3&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.mockito:mockito-inline:3.3.3&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>testImplementation</em>은 이 라이브러리 의존성이 이 앱의 테스트 빌드에만 포함됨을 의미한다. 따라서 디버그나 릴리즈 빌드로 생성된 APK에는 포함되지 않는다.</p><p>mockito-core는 모의 객체를 생성하고 구성하는 데 사용하는 모든 함수를 포함한다. mockito-inlin은 Mockito를 코틀린에서 쉽게 사용하도록 해주는 의존성이다.</p><p>기본적으로 모든 코틀린 클래스는 <strong>final</strong>이다. 즉, 클래스에 open 키워드를 지정하지 않으면 상속받는 서브 클래스를 만들 수 없으며, 함수에 open 키워드를 지정하지 않으면 서브 클래스에서 오버라이드할 수 없다. 그런데 Mockito에서 모의 객체의 클래스를 생성할 때는 클래스 상속을 해야 한다. 이때 mockito-inline 의존성을 지정하면 Mockito가 <strong>final</strong> 클래스와 함수들의 모의 객체를 생성한다. 따라서 <strong>코틀린 클래스 소스 코드를 변경하지 않고 모의 객체를 생성할 수 있다.</strong></p><h2 id="테스트-클래스-생성하기"><a class="markdownIt-Anchor" href="#테스트-클래스-생성하기"></a> 테스트 클래스 생성하기</h2><p>단위 테스트를 작성하는 가장 편리한 방법은 <b>테스트 프레임워크<small>(testing framwork)</small></b>를 사용하는 것이다. 테스트 프레임워크를 사용하면 안드로이드 스튜디오에서 테스트 코드를 더 쉽게 작성하고 실행할 수 있으며 결과 출력도 볼 수 있다.</p><p>안드로이드의 테스트 프레임워크로는 JUnit이 사용되며, 안드로이드 스튜디오와 잘 통합되어 있다. 가장 먼저 할 일은 JUnit 테스트 클래스를 생성하는 것이다.</p><p>SoundViewModel.kt를 열어 SoundViewModel 클래스를 클릭한 후 안드로이드 스튜디오 메인 메뉴의 <code>Navigate -&gt; Test</code>를 선택한다. 그러면 안드로이드 스튜디오가 SoundViewModel 클래스와 관련된 테스트 클래스로 이동시켜준다. 그러나 여기처럼 테스트 클래스가 없으면 아래와 같이 팝업으로 새로운 테스트 클래스 생성 옵션을 제공한다.</p><blockquote><p>테스트 클래스 생성 팝업</p></blockquote><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/120896740-c38d2f00-c65d-11eb-931a-5023aa8f56b9.png'></p><p>'Create New Test…'를 선택하면 대화상자<small>(좌)</small>가 나타난다. 아래와 같이 테스트 라이브러리를 JUnit4로 선택하고 SetUp/@Before를 체크한 후 다른 필드는 그대로 두고 OK 버튼을 누른다.</p><p>그러면 생성하는 테스트 클래스의 종류를 선택하는 대화상자<small>(우)</small> 나타난다.</p><blockquote><p>새로운 테스트 클래스 생성하기<small>(좌)</small>, 테스트 클래스의 종류 선택하기<small>(우)</small></p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/120896968-e66c1300-c65e-11eb-81a5-f1f28ce87cea.png'></p><h4 id="장치-테스트smallinstrumentation-testsmall"><a class="markdownIt-Anchor" href="#장치-테스트smallinstrumentation-testsmall"></a> 장치 테스트<small>(instrumentation test)</small></h4><p>androidTest 폴더에 있는 테스트를 <b>장치 테스트<small>(instrumentation test)</small></b>라고 한다. 장치 테스트는 안드로이드 장치나 에뮬레이터에서 실행된다. 앱이 배포된 후 APK가 실행될 시스템 프레임워크와 API를 대상으로 앱 전체를 테스트할 수 있다는 것이 장치 테스트의 장점이다. 그러나 장치 테스트는 <strong>해당 안드로이드 운영체제에서 실행되어서 설정과 실행에 시간이 더 걸린다는 단점</strong>이 있다.</p><h4 id="단위-테스트smallunit-testsmall"><a class="markdownIt-Anchor" href="#단위-테스트smallunit-testsmall"></a> 단위 테스트<small>(unit test)</small></h4><p>이와는 달리 test 폴더에 있는 테스트는 <b>단위 테스트<small>(unit test)</small></b>라고 한다. 단위 테스트는 안드로이드 런타임이 아닌 <strong>로컬 컴퓨터의 JVM<small>(Java Virtual Machine)</small>에서 실행되므로 빠르게 이루어진다.</strong></p><p>안드로이드에서는 '단위 테스트’라는 용어가 폭넓게 사용된다. 즉, 하나의 클래스나 단위 기능을 별개로 검사함을 의미하며, 로컬 컴퓨터에서 실행되는 단위 테스트들은 test 폴더에 포함된다. 또한, 앱의 여러 클래스나 기능이 함께 작동하는 것을 테스트하는 <b>통합 테스트<small>(integreation test)</small></b>를 의미하기도 한다. 통합 테스트는 <a id = "a1"><a href="#f1">궁금증 해소: 통합 테스트</a></a>에서 자세히 알아보자.</p><p>본문의 나머지 부분에서는 test 폴더에 있으면서 JVM에서 실행되는 각 타입의 테스트를 <strong>JVM 테스트</strong>라 하고, 하나의 클래스나 단위 기능을 검사하는 테스트만 <strong>단위 테스트</strong>라고 칭한다.</p><p>단위 테스트는 하나의 컴포넌트<small>(주로 클래스)</small> 자체를 테스트하는 것이므로 작성할 수 있는 가장 작은 종류의 테스트다. 그리고 테스트를 실행하고자 전체 앱이나 장치를 사용할 필요가 없으며, 테스트를 여러 번 실행해도 충분할 만큼 빠르게 실행된다. 따라서 하나의 컴포넌트르 테스트할 때 장치 테스트로 실행하는 경우는 거의 없다. 이 점을 염두에 두고 위의 이미지의 우측 대화상자와 같이 androidTest 폴더가 아닌 test 폴더를 선택하고 OK 버튼을 누른다. 그러면 안드로이드 스튜디오가 SoundViewModelTest.kt를 생성하고 편집기 창에 열어준다.</p><blockquote><p>Project 뷰로 보면 app/src 패키지 밑에 test와 androidTest 패키지가 생성되어 있다</p></blockquote><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/120897965-c8ed7800-c663-11eb-9970-a02fd282a3aa.png'></p><h2 id="테스트-설정하기"><a class="markdownIt-Anchor" href="#테스트-설정하기"></a> 테스트 설정하기</h2><p>자동 생성된 SoundViewModelTest 클래스는 <code>setUp()</code> 함수만 갖고 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModelTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트 클래스에서 특정 클래스를 테스트하는 데 필요한 작업은 대부분 같다. 즉, 테스트할 클래스의 인스턴스와 이 인스턴스가 필요로 하는 다른 객체들도 생성한다. 이에 따라 JUnit에서는 <code>@Before</code>라는 애노테이션을 제공한다. <code>@Before</code>가 지정된 함수 내부의 코드는 각 테스트가 실행되기 전에 한번만 실행되며, JUnit 테스트 클래스는 <code>@Before</code>가 지정된 <code>setUp()</code>이라는 이름의 함수를 갖는다.</p><h3 id="테스트-대상-설정하기"><a class="markdownIt-Anchor" href="#테스트-대상-설정하기"></a> 테스트 대상 설정하기</h3><p><code>setUp()</code> 함수 내부에서는 테스트할 SoundViewModel의 인스턴스와 Sound의 인스턴스를 생성해야 한다. SoundViewModel이 음원 제목을 보여주는 방법을 알려면 Sound 인스턴스를 필요로 하기 때문이다.</p><p>SoundViewModel과 Sound의 인스턴스를 생성하자.</p><blockquote><p>테스트 대상인 SoundViewModel 인스턴스 생성하기 (SSoundViewModelTest.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModelTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sound: Sound</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> subject: SoundViewModel</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sound = Sound(<span class="string">&quot;assetPath&quot;</span>)</span><br><span class="line">        subject = SoundViewModel()</span><br><span class="line">        subject.sound = sound</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지금까지는 <strong>SoundViewModel</strong> 인스턴스를 참조하는 속성 이름을 <em>soundViewModel</em>로 사용했는데, 여기서는 <em>subject</em>라고 했다. 테스트의 대상이 되는 객체이므로 <em><strong>subject</strong></em> 라고 하는 것이 오히려 알기 쉽고, 테스트 함수를 다른 클래스로 옮기더라도 속성 이름을 변경할 필요가 없기 때문이다.</p><h2 id="테스트-작성하기"><a class="markdownIt-Anchor" href="#테스트-작성하기"></a> 테스트 작성하기</h2><p><code>setUp()</code> 함수가 작성되었으니 이제는 테스트를 작성해본다. <code>@Test</code> 애노테이션이 지정된 테스트 클래스의 함수를 테스트라고 한다.</p><p>우선 SoundViewModel의 <em>title</em> 속성값이 Sound의 <em>name</em> 속성값과 일치하는지 검사하는 테스트 함수를 작성하자.</p><blockquote><p><em>title</em> 속성 테스트하기 (SoundViewModelTest.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert.*</span><br><span class="line"><span class="keyword">import</span> org.hamcrest.core.Is.`<span class="keyword">is</span>`</span><br><span class="line"><span class="keyword">import</span> org.hamcrest.MatcherAssert</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModelTest</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">exposesSoundNameAsTitle</span><span class="params">()</span></span> &#123;</span><br><span class="line">        MatcherAssert.assertThat(subject.title, `<span class="keyword">is</span>`(sound.name))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><small>(<code>assertThat(…)</code> 함수와 <code>is(…)</code> 함수는 위의 코드 대로 import해야 한다.)</small></p><p>이 테스트에서는 <code>assertThat(…)</code> 함수와 <code>is(…)</code> 함수를 같이 사용하며, '테스트 대상의 <em>title</em> 속성값이 Sound의 <em>name</em> 속성값과 같아야 함’을 나타낸다. 따라서 두 속성값이 다르면 테스트는 실패한다.</p><p>프로젝트 도구 창의 <strong>‘app/java/com.june0122.beatbox <small>(test)</small>’</strong> 밑에 있는 <strong>SoundViewModelTest</strong>에서 오른쪽 마우스 버튼을 클릭한 후 Run 'SoundViewModelTest’를 선택하면 단위 테스트가 실행되고 안드로이드 스튜디오에서 아래와 같은 실행 결과를 보여준다.</p><blockquote><p>테스트과 통과됨</p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/120898950-36030c80-c668-11eb-84e4-df1d2bedaad5.png'></p><p>여기서는 한 개의 테스트가 실행되어 통과되었음을 보여준다<small>(Tests passed: 1)</small>. 만일 테스트가 실패하면 이에 관한 자세한 내용도 보여준다.</p><h3 id="객체의-상호작용-테스트하기"><a class="markdownIt-Anchor" href="#객체의-상호작용-테스트하기"></a> 객체의 상호작용 테스트하기</h3><p>다음으로 SoundViewModel과 <code>BeatBox.play(Sound)</code> 함수가 잘 연동되는지 검사하는 테스트를 생성한다.</p><p>이때는 주로 연동을 테스트하는 함수를 테스트 클래스에 작성한다. 우선 <code>onButtonClicked()</code>를 호출하는 테스트 함수를 작성한다<small>(<code>onButtonClicked()</code> 함수는 잠시 후에 SoundViewModel에 추가한다)</small>.</p><blockquote><p><code>onButtonClicked()</code>를 호출하는 테스트 함수 작성하기 (SoundViewModelTest.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModelTest</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">exposesSoundNameAsTitle</span><span class="params">()</span></span> &#123;</span><br><span class="line">        MatcherAssert.assertThat(subject.title, `<span class="keyword">is</span>`(sound.name))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">callsBeatBoxPlayOnButtonClicked</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject.onButtonClicked()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 <code>onButtonClicked()</code> 함수는 아직 작성되지 않았기에 붉은색의 에러로 표시된다. 이 함수를 클릭한 후 <code>Alt+Enter [Option+Return]</code> 키를 누르고 Create member function 'SoundViewModel.onButtonClicked’를 선택하면 이 함수가 SoundViewModel.kt에 자동 생성된다. 반드시 TODO를 주석으로 처리해주자!</p><blockquote><p>자동 생성된 <code>onButtonClicked()</code> (SoundViewModel.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModel</span> : <span class="type">BaseObservable</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onButtonClicked</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// TODO(&quot;Not yet implemented&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지금은 <code>onButtonClicked()</code> 함수를 비어 있는 상태로 두고 SoundViewModelTest 클래스를 다시 본다.</p><p>테스트 함수인 <code>callsBeatBoxPlayOnButtonClicked()</code>에서는 SoundViewModel의 <code>onButtonClicked()</code> 함수를 호출한다. 그러나 이 함수에서 <code>BeatBox.play(Sound)</code>를 호출하는 것을 검사해야 한다. 이것을 구현하기 위해 맨 먼저 할 일은 SoundViewModel에 BeatBox 객체를 제공하는 것이다.</p><p>이때 테스트 함수에서 BeatBox 인스턴스를 생성하고 SoundViewModel 생성자에 전달할 수 있다. 그러나 단위 테스트에서 이렇게하면 문제가 생긴다. 만일 BeatBox에서 문제가 생기면 이것을 사용하는 SoundViewModel도 덩달아 문제가 생겨서 SoundViewModel의 단위 테스트가 실패할 수 있기 때문이다. 이것은 우리가 원하는 바가 아니다. <strong>SoundViewModel의 단위 테스트는 SoundViewModel에 국한된 문제가 있을 때만 실패해야 한다.</strong></p><p>다시 말해서 SoundViewModel 자체의 작동과 다른 클래스와의 상호 작용은 별개로 테스트해야 한다. 이것이 단위 테스트에서 중요한 사항이다.</p><p>이런 문제를 해결하고자 BeatBox에 모의 객체<small>(mock object)</small>를 사용한다. 이때 모의 객체는 BeatBox의 서브 클래스가 되며, BeatBox와 같은 함수들을 갖는다. 단, 모든 함수가 아무 일도 하지 않으므로 BeatBox에서는 문제가 생기지 않는다. 따라서 SoundViewModel의 테스트에서는 BeatBox의 작동과는 무관하게 SoundViewModel이 BeatBox를 사용하는 것이 맞는지 검사할 수 있다.</p><p>Mockito를 사용해서 모의 객체를 생성할 때는 <strong>static</strong> 함수인 <code>mock(Class)</code>를 호출하며, 이때 모의 객체를 사용할 클래스를 인자로 전달한다. BeatBox의 모의 객체를 생성하고 이 객체의 참조를 갖는 속성을 SoundViewModelTest에 추가한다.</p><blockquote><p>BeatBox의 모의 객체 생성하기 (SoundViewModelTest.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.mockito.Mockito.mock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModelTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> beatBox: BeatBox</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sound: Sound</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> subject: SoundViewModel</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        beatBox = mock(BeatBox::<span class="keyword">class</span>.java)</span><br><span class="line">        sound = Sound(<span class="string">&quot;assetPath&quot;</span>)</span><br><span class="line">        subject = SoundViewModel()</span><br><span class="line">        subject.sound = sound</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mock(Class)</code> 함수는 클래스 참조처럼 import되며, BeatBox의 모의 객체를 자동으로 생성한다.</p><p>BeatBox의 모의 객체가 준비되었으니 이제는 <code>play(Sound)</code> 함수가 호출되는지 검사하는 테스트 작성을 마무리한다. 모든 Mockito 모의 객체는 자신의 함수들이 호출된 기록은 물론이고, 각 호출에 전달된 매개변수 내역을 유지한다. 그리고 Mockito의 <code>verify(Object)</code> 함수를 사용하면 기대한 대로 모의 객체 함수들이 호출되었는지 확인할 수 있다.</p><p>SoundViewModel에 연결된 Sound 객체를 사용해서 <code>onButtonClicked()</code>가 <code>BeatBox.play(Sound)</code>를 호출하는지 확인하기 위해 <code>verify(Object)</code>를 호출한다<small>(Sound는 문제가 될 함수가 없는 데이터 객체이므로 모의 객체를 생성할 필요가 없다)</small>.</p><blockquote><p><code>BeatBox.play(Sound)</code>가 호출되는지 검사하기 (SoundViewModelTest.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModelTest</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">callsBeatBoxPlayOnButtonClicked</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject.onButtonClicked()</span><br><span class="line">        </span><br><span class="line">        verify(beatBox).play(sound) <span class="comment">// verify(Object) 호출</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 <b>플루언트 인터페이스<small>(fluent interface)</small></b>를 사용한다<small>(플루언트 인터페이슨느 코드를 알기 쉽게 해주며, 일반적으로 함수의 연쇄 호출 형태로 구현된다)</small>. 즉, <code>verify(beatBox)</code>에서 BeatBox 객체를 반환하므로 연속해서 이 객체의 <code>play(sound)</code> 함수를 호출할 수 있다. <code>verify(beatBox).play(sound)</code>는 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">verify(beatBox)</span><br><span class="line">beatBox.play(sound)</span><br></pre></td></tr></table></figure><p>여기서 <code>verify(beatBox)</code>는 'beatBox의 함수가 호출되었는지 검사하려고 함’이라는 의미이며, 그다음 함수 호출인 <code>play(sound)</code>는 ’<code>play(sound)</code> 함수가 이처럼 호출되었는지 검사하라’는 의미로 생각할 수 있다. 결국 <code>verify(beatBox).play(sound)</code>는 sound를 인자로 받는 beatBox의 <code>play(sound)</code> 함수가 호출되었는지 확인하라는 의미다.</p><p>물론, 지금은 이런 일이 생기지 않는다. <code>SoundViewModel.onButtonClicked()</code> 함수의 실행 코드가 아직 없어서 <code>beatBox.play(sound)</code>가 호출되지 않았기 때문이다. 또한, SoundViewModel은 beatBox 참조를 갖고 있지 않아서 beatBox의 어떤 함수도 호출할 수 없다. 따라서 테스트는 실패한다. 현재는 테스트를 먼저 작성했으니 이렇게 되는 것이 정상이다. 처음부터 테스트가 실패하지 않는다면 어떤 것도 테스트할 필요가 없다.</p><p>테스트를 실행해 아래와 같이 테스트가 실패하는 것을 확인해보자.</p><blockquote><p>테스트 실패 내역 출력</p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/120899745-2d143a00-c66c-11eb-8646-3dd24a79692c.png'></p><p>출력 메시지는 다음과 같다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Wanted but not invoked:</span><br><span class="line">beatBox.play(</span><br><span class="line">    com.june0122.beatbox.Sound@1af146</span><br><span class="line">);</span><br><span class="line">-&gt; at com.june0122.beatbox.BeatBox.play(BeatBox.kt:26)</span><br><span class="line">Actually, there were zero interactions with this mock.</span><br></pre></td></tr></table></figure><p><code>beatBox.play(sound)</code>의 호출을 기대했지만 호출되지 않았다.</p><p><code>assertThat(…)</code>과 마찬가지로 <code>verify(Object)</code>은 내부적으로 어서션<small>(<a href="https://ko.wikipedia.org/wiki/%ED%91%9C%EB%AA%85">assertion</a>)</small>을 생성한다. 그리고 어서션에 어긋나면 테스트를 실패로 처리하고, 로그에 그 이유를 설명하는 출력을 남긴다. 그리고 어서션에 어긋나면 테스트를 실패로 처리하고, 로그에 그 이유를 설명하는 출력을 남긴다.</p><p>이제는 테스트의 결함을 수정할 때가 되었다. 우선 SoundViewModel의 생성자에서 BeatBox 인스턴스를 받도록 속성을 추가한다<small>(여기서 기본 생성자에 선언된 beatBox는 매개변수이면서 속성으로도 생성된다)</small>.</p><blockquote><p>BeatBox를 SoundViewModel에 제공하기 (SoundViewModel.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> beatBox: BeatBox) : BaseObservable() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 변경하면 SoundHolder 클래스와 SoundViewModelTest 클래스에서 에러가 발생한다.</p><ul><li>SoundHolder에서 SoundViewModel 인스턴스를 생성할 때 <em>beatBox</em> 객체를 생성자에 전달하도록 변경</li><li>BeatBox의 모의 객체를 SoundViewModel 생성자에 전달</li></ul><blockquote><p>SoundHolder의 에러 수정 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SoundHolder</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> binding: ListItemSoundBinding) : RecyclerView.ViewHolder(binding.root) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        binding.viewModel = SoundViewModel(beatBox)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(sound: <span class="type">Sound</span>)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>테스트에 BeatBox 모의 객체 제공 (SoundViewModelTest.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModelTest</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        beatBox = mock(BeatBox::<span class="keyword">class</span>.java)</span><br><span class="line">        sound = Sound(<span class="string">&quot;assetPath&quot;</span>)</span><br><span class="line">        subject = SoundViewModel(beatBox)</span><br><span class="line">        subject.sound = sound</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음으로 테스트에서 기대하는 것을 수행하도록 <code>onButtonClicked()</code>를 구현한다.</p><blockquote><p><code>onButtonClicked()</code> 구현하기 (SoundViewModel.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> beatBox: BeatBox) : BaseObservable() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onButtonClicked</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sound?.let &#123; </span><br><span class="line">            beatBox.play(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>테스트를 다시 실행하면 이번에는 테스트과 통과되었음을 Run 도구 창에서 확인할 수 있다.</p><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/120900145-32728400-c66e-11eb-8b37-dc3dde85c26e.png'></p><h2 id="데이터-바인딩-콜백"><a class="markdownIt-Anchor" href="#데이터-바인딩-콜백"></a> 데이터 바인딩 콜백</h2><p>이제는 버튼들이 제대로 작동하는지 테스트하는 것만 남았다. 따라서 <code>onButtonClicked()</code>를 버튼과 연결해야 한다.</p><p>사용자 인터페이스인 레이아웃에 데이터를 넣을 때 데이터 바인딩을 사용할 수 있듯이, 클릭 리스너를 연결할 때도 람다식으로 데이터 바인딩을 할 수 있다.</p><p>버튼 클릭을 <code>SoundViewModel.onButtonClicked()</code>에 연결하기 위해 데이터 바인딩으로 호출되는 콜백 표현식을 추가한다.</p><blockquote><p>버튼을 코드와 연결하기 (list_item_sound.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;120dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; viewModel.onButtonClicked()&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@&#123;viewModel.title&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:text</span>=<span class="string">&quot;Sound name&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>이제는 BeatBox 앱을 실행하고 음원 제목을 보여주는 버튼을 누르면 음원이 재생되어야 한다. 테스트를 실행한 뒤에는 <b>실행 구성<small>(run configuration)</small></b>이 변경되므로 실행 구성 드롭다운을 클릭해 <strong>app</strong>으로 변경한다.</p><blockquote><p>실행 구성을 변경하기</p></blockquote><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/120900296-115e6300-c66f-11eb-8ba7-b0301e31984f.png'></p><h2 id="음원-내리기"><a class="markdownIt-Anchor" href="#음원-내리기"></a> 음원 내리기</h2><p>음원 재생이 잘 작동하지만 아직 마무리해야 할 것이 있다. 음원 재생이 끝나면 <code>SoundPool.release()</code>를 호출해 SoundPool을 클린업<small>(리소스 해제)</small>해야 한다. 이 일을 하는 <code>BeatBox.release()</code> 함수를 추가한다.</p><blockquote><p>SoundPool 클린업하기 (BeatBox.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatBox</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> assets: AssetManager) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">play</span><span class="params">(sound: <span class="type">Sound</span>)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">        soundPool.release()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadSounds</span><span class="params">()</span></span>: List&lt;Sound&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그다음에 <code>BeatBox.release()</code> 함수를 호출하는 <code>onDestroy()</code> 함수를 MainActivity에 추가한다. 액티비티가 소멸하면 SoundPool도 클린업해야 하기 때문이다.</p><blockquote><p><code>onDestroy()</code> 함수 추가하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> beatBox: BeatBox</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        beatBox.release()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeatBox 앱을 다시 실행해 <code>release()</code> 함수가 제대로 작동하는지 확인해보자. 대부분 짧은 소리만 나지만, 조금 긴 소리의 음원이 재생되는 동안에 장치를 회전하거나 백 버튼을 누르면 재생이 중단된다.</p><h2 id="b-id-f1궁금증-해소-️-통합-테스트b"><a class="markdownIt-Anchor" href="#b-id-f1궁금증-해소-️-통합-테스트b"></a> <b id = "f1">궁금증 해소 💁🏻‍♂️ : 통합 테스트</b>  <a href="#a1"> ↩</a></h2><p>앞의 <strong>SoundViewModelTest</strong>는 단위 테스트였지만, <b>통합 테스트<small>(integration test)</small></b>를 생성할 수도 있다. 통합 테스트가 무엇일까?</p><p>단위 테스트에서는 테스트 항목이 개별 클래스이지만, 통합 테스트는 여러 클래스나 컴포넌트가 함께 작동하는 앱의 일부가 테스트 대상이다. 단위 테스트와 통합 테스트 모두 중요하지만, 서로 다른 목적을 갖는다.</p><ul><li>단위 테스트에서는 각 단위 클래스가 올바르게 작동하는지, 기대한 대로 다른 단위와 제대로 상호 작용하는지 확인한다.</li><li>반면에 통합 테스트에서는 개별적으로 테스트된 단위들과 기능이 올바르게 통합되어 작동하는지 검사한다.</li></ul><p>통합 테스트는 데이터베이스 사용과 같은 UI가 아닌 부분을 검사하기 위해 작성한다. 그런데 안드로이드에서는 UI와 상호 작용하면서 기대한 대로 잘 되는지 검사하기 때문에 UI 수준에서 앱을 테스트하고자 이러한 테스트를 작성하는 경우가 많다. 따라서 대개는 화면별로 통합 테스트를 작성한다. 예를 들어, MainActivity 화면이 나타날 때 첫 번째 버튼의 제목이 <em>sample_sounds</em>의 첫 번째 파일 이름<small>(예를 들어, MainActivity)</small> 화면이 나타날 때 첫 번째 버튼의 제목이 <em>sample_sounds</em>의 첫 번째 파일 이름<small>(예를 들어, 65_cjipie)</small>을 보여주는지 테스트할 수 있다.</p><p>UI 수준의 통합 테스트는 액티비티나 프래그먼트와 같은 프레임워크 클래스가 필요하며, JVM 단위 테스트에서 사용할 수 없는 시스템 서비스, 파일 시스템 등도 필요할 수 있다. 이런 이유로 안드로이드에서는 통합 테스트는 주로 장치 테스트로 구현된다.</p><p>통합 테스트는 기대한 대로 앱이 <strong>작동</strong>하면 통과된다. <strong>구현</strong>될 때 통과되는 것이 아니다. 버튼 ID의 이름을 변경해도 앱의 작동에는 영향을 주지 않는다. 그런데 <code>findViewById(R.id.button)</code>을 호출해 해당 버튼이 올바른 텍스트를 보여주는지 확인하는 것은 통합 테스트로 작성할 수 있다. 이때 안드로이드에서는 <code>findViewById(R.id.button)</code> 대신 UI 테스트 프레임워크를 사용해서 통합 테스트를 작성한다. 이렇게 하면 기대하는 텍스트를 갖는 버튼이 화면에 있는지 쉽게 확인할 수 있다.</p><p><strong>Espresso는 안드로이드 앱을 테스트하는 구글의 UI 테스트 프레임워크</strong>다. 안드로이드 스튜디오의 프로젝트 도구 창에서 Gradle Scripts 밑의 build.gradle (Module: BeatBox.app) 파일을 보면 다음과 같이 기본적으로 라이브러리 의존성에 추가되어 있다<small>(맨 끝의 버전 번호는 변경될 수 있다)</small>.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.3.0&#x27;</span></span><br></pre></td></tr></table></figure><p>이처럼 Espresso가 의존성에 포함되면 통합 테스트를 하기 위해 시작될 액티비티에 관한 어서션을 만들 수 있다. 여기서는 첫 번째 <em>sample_sounds</em> 테스트 파일 이름을 사용하는 뷰<small>(버튼)</small>가 화면에 있어야 한다는 어서션을 만드는 방법을 보여준다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(AnbdroidJUnit4::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivityTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Rule</span></span><br><span class="line">    <span class="keyword">val</span> activityRule = ActivityTestRule(MainActivity::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">showsFirstFileName</span><span class="params">()</span></span> &#123;</span><br><span class="line">        onView(withText(<span class="string">&quot;65_cjipie&quot;</span>))</span><br><span class="line">                .check(matches(isDisplayed()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 두 개의 애노테이션이 코드를 실행한다. <code>@RunWith(AnbdroidJUnit4::class)</code>는 MainActivityTest가 안드로이드 장치 테스트이며, 액티비티 및 다른 안드로이드 런타임 도구와 함께 작동함을 나타낸다. 그다음에 있는 activityRule의 <code>@get:Rule</code>은 각 테스트를 실행하기 전에 MainActivity의 인스턴스를 시작시켜야 함을 JUnit에게 알린다.</p><p>테스트가 설정되었으니 이제는 테스트할 MainActivity에 관한 어서션을 만들 수 있다. <code>showsFirstFileName()</code>의 <code>onView(withText(&quot;65_cjipie&quot;))</code>에서는 테스트를 수행하기 위해 *“65_cjipie”*라는 텍스트를 갖는 뷰<small>(버튼)</small>을 찾는다. 그다음에 <code>check(matches(isDisplayed()))</code>를 호출해 해당 뷰가 화면에 보이는지 확인한다. 만일 그런 텍스트를 갖는 뷰가 없다면 <code>check(…)</code>는 실패한다. <code>check(…)</code> 함수는 뷰에 관한 <code>assertThat(…)</code> 형태의 어서션을 만드는 Espresso의 방법이다.</p><p>버튼처럼 뷰를 클릭해야 할 때는 클릭한 결과를 검사하는 어서션을 만들면 된다. 이때도 다음과 같이 Espresso를 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onView(withText(<span class="string">&quot;65_cjipie&quot;</span>))</span><br><span class="line">        .perform(click())</span><br></pre></td></tr></table></figure><p>이처럼 뷰와 상호 작용할 때는 Espresso가 테스트를 멈추고 기다리며, UI의 변경이 끝났을 때를 감지한다. 그런데 Espresso를 더 오래 기다리게 할 때는 <strong>IdlingResource</strong>의 서브 클래스를 사용해 Espresso에게 앱의 작업이 아직 끝나지 않았음을 알린다.</p><p>Espresso로 UI를 테스트하는 방법에 관한 자세한 정보는 <a href="https://developer.android.com/training/testing/espresso?hl=ko">Espresso 문서</a>를 참고하자.</p><p>다시 말하지만 <strong>통합 테스트와 단위 테스트는 그 목적이 다르다.</strong> 대부분의 사람은 단위 테스트를 먼저 시작한다. 앱의 개별적인 부분들의 작동을 정의하고 검사하는데 도움이 되기 때문이다. 통합 테스트는 그런 개별적인 부분들에 의존해 여러 부분이 하나로 함께 잘 작동하는지 검사한다. 두 테스트는 각각 앱의 건강에 관한 서로 다른 중요한 관점을 제공하므로 테스트를 같이 하는 것이 가장 좋다.</p><h2 id="궁금증-해소-️-모의-객체와-테스트"><a class="markdownIt-Anchor" href="#궁금증-해소-️-모의-객체와-테스트"></a> 궁금증 해소 💁🏻‍♂️ : 모의 객체와 테스트</h2><p>통합 테스트에서는 모의 객체가 단위 테스트 때와는 다른 역할을 담당한다. 모의 객체는 다른 컴포넌트를 테스트와 관계없는 것처럼 만들어서 테스트할 컴포넌트를 격리하기 위해 존재한다. 단위 테스트는 클래스 단위로 테스트한다. 그런데 각 클래스는 다른 클래스들에 대해 의존성을 가질 수 있으므로 테스트 클래스들은 서로 다른 모의 객체들을 가지며, 모의 객체가 어떻게 작동하는가는 중요하지 않다. 따라서 간단한 모의 객체를 쉽게 생성해주는 모의 프레임워크<small>(예를 들어, Mockito)</small>가 단위 테스트에는 안성맞춤이다.</p><p>이와는 달리 통합 테스트는 앱 전체를 한 덩어리로 테스트한다. 따라서 앱의 각 부분을 격리하는 대신에 앱이 상호 작용하는 외부의 것과 격리하기 위한 모의 객체를 사용한다. 예를 들어, 모의 데이터와 응답을 반호나하는 웹 서비스를 제공하는 경우다. BeatBox 앱에서는 특정 음원 파일이 재생되었음을 알려주는 모의 SoundPool을 제공할 수 있을 것이다. 모의 객체는 점점 더 많아지고 여러 테스트에서 공유되며 모의 행동을 구현하므로, 통합 테스트에서는 자동화된 모의 프레임워크를 사용하지 말고 모의 객체를 직접 작성하는 것이 좋다.</p><p>어떤 경우든 다음 규칙이 적용된다. 즉, 테스트 중인 컴포넌트의 경계에 있는 개체들을 모의 객체로 만든다. 이렇게 하면 테스트하려는 범위에만 집중할 수 있다. 또한, 테스트 컴포넌트 외의 다른 컴포넌트와는 무관하게 테스트 컴포넌트에 문제가 있을 때만 테스트가 실패하므로 정확하게 테스트할 수 있다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/MVVM/">MVVM</category>
      
      <category domain="http://june0122.github.io/tags/Unit-Test/">Unit Test</category>
      
      <category domain="http://june0122.github.io/tags/Mockito/">Mockito</category>
      
      <category domain="http://june0122.github.io/tags/Espresso/">Espresso</category>
      
      <category domain="http://june0122.github.io/tags/SoundPool/">SoundPool</category>
      
      
      <comments>http://june0122.github.io/2021/06/06/android-bnr-20/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Kotlin] Coroutine - Cancellation and Timeouts</title>
      <link>http://june0122.github.io/2021/06/03/coroutines-cancellation-timeouts/</link>
      <guid>http://june0122.github.io/2021/06/03/coroutines-cancellation-timeouts/</guid>
      <pubDate>Thu, 03 Jun 2021 09:15:50 GMT</pubDate>
      
      <description>코루틴이 취소되기 위해서 협조적인 방식을 취하는데 크게 2가지 방법이 있다. 첫 번째, &lt;b&gt;주기적으로 suspend function을 호출하기&lt;/b&gt; &lt;small&gt;(suspend 되었다가 다시 재개될 때 cancel 되었는지를 확인해서 Exception을 던져주는 방식)&lt;/small&gt;. 두 번째, &lt;b&gt;명시적으로 취소 상태를 확인하기&lt;/b&gt; &lt;small&gt;(isActive 상태를 확인하여 false일 때 해당 코루틴을 종료시키는 방식)&lt;/small&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><h3 id="1-b-id-f1cancelling-coroutine-executionb"><a class="markdownIt-Anchor" href="#1-b-id-f1cancelling-coroutine-executionb"></a> ① <b id = "f1">Cancelling coroutine execution</b>  <a href="#a1"> ↩</a></h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancel() <span class="comment">// cancels the job </span></span><br><span class="line">    job.join() <span class="comment">// waits for job&#x27;s completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">job: I&#x27;m sleeping 0 ... [main]</span><br><span class="line">job: I&#x27;m sleeping 1 ... [main]</span><br><span class="line">job: I&#x27;m sleeping 2 ... [main]</span><br><span class="line">main: I&#x27;m tired of waiting! [main]</span><br><span class="line">main: Now I can quit. [main]</span><br></pre></td></tr></table></figure><p>코루틴을 실행할 떄 launch를 해서 반환된 Job 객체에서 <code>cancel()</code>을 호출할 수 있고, 이를 통해 코루틴 실행을 취소시킬 수 있다.</p><blockquote><h3 id="2-cancellation-is-cooperative"><a class="markdownIt-Anchor" href="#2-cancellation-is-cooperative"></a> ② Cancellation is cooperative</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123; <span class="comment">// computation loop, just wastes CPU</span></span><br><span class="line">            <span class="comment">// print a message twice a second</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">job: I&#x27;m sleeping 0 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 1 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 2 ... [DefaultDispatcher-worker-1]</span><br><span class="line">main: I&#x27;m tired of waiting! [main]</span><br><span class="line">job: I&#x27;m sleeping 3 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 4 ... [DefaultDispatcher-worker-1]</span><br><span class="line">main: Now I can quit. [main]</span><br></pre></td></tr></table></figure><p>코드의 의도는 코루틴이 3번정도 실행되고 취소되는 것을 기대했을 것이다. 하지만 <code>main: I'm tired of waiting!</code>이 호출된 뒤 코루틴의 실행은 취소되지 않고 5번의 횟수를 채운 뒤 종료된다.</p><p>왜 이런 것일까? 이는 코루틴 자체가 취소되는데 협조적 <sup>cooperative</sup>이지 않았기 때문이다. 코루틴 내부에 suspend function이 존재하지 않는 것과 달리, <a id = "a1"><a href="#f1">첫 번째 예제</a></a>에서는 코루틴 내부에 <code>delay()</code>라는 suspend function이 존재하므로 취소가 가능했다.</p><p>다시 말해, 첫 번째 예제에서는 suspend function이 있었는데 두 번째 예제에서는 단순 연산만 있고 suspend function의 호출이 코루틴 내부에 없기 때문에 취소가 불가능하다는 것이다. 그럼 첫 번째 예제와 같이 두 번째 예제에도 suspend function을 호출하여 취소에 협조적인 코루틴을 만들어보자. 과연 원하는 실행 결과가 나올까?</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                delay(<span class="number">1L</span>) <span class="comment">// suspend function을 추가</span></span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>)</span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">job: I&#x27;m sleeping 0 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 1 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 2 ... [DefaultDispatcher-worker-1]</span><br><span class="line">main: I&#x27;m tired of waiting! [main]</span><br><span class="line">main: Now I can quit. [main]</span><br></pre></td></tr></table></figure><p>실행을 해보면 의도했던대로 0, 1, 2 까지만 출력이되고 종료가 된 것을 확인할 수 있다.</p><p>suspend function으로써 이런 상황에 <code>delay()</code>가 아닌 더 적합한 함수가 있다. 바로 <code>yield()</code> 이다. <code>yield()</code>를 이용하면 <code>delay(1L)</code>을 이용하지 않고도 취소를 확인할 수 있다. 결과는 위와 동일하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                yield() <span class="comment">// delay 대신 yield 사용</span></span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>)</span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>어떻게 해서 cancel이 일어나게 되었을까?</p><p>코루틴 가이드에 따르면 <code>Job.cancel</code>을 하게 되면 코루틴 내부에서 suspend가 되었다가 다시 재개<small>(resume)</small>되는 시점에 suspend function<small>(여기서는 <code>yield()</code>)</small>이 CancellationException을 던진다고 설명되어 있다. Exception을 체크하기 위해 코루틴 내부에서 <code>try-catch</code> 문을 사용해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123; <span class="comment">// computation loop, just wastes CPU</span></span><br><span class="line">                <span class="comment">// print a message twice a second</span></span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                    yield()</span><br><span class="line">                    kotlin.io.println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                    nextPrintTime += <span class="number">500L</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            kotlin.io.println(<span class="string">&quot;Exception [<span class="variable">$e</span>]&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    kotlin.io.println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    kotlin.io.println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">job: I&#x27;m sleeping 0 ...</span><br><span class="line">job: I&#x27;m sleeping 1 ...</span><br><span class="line">job: I&#x27;m sleeping 2 ...</span><br><span class="line">main: I&#x27;m tired of waiting!</span><br><span class="line">Exception [kotlinx.coroutines.JobCancellationException: StandaloneCoroutine was cancelled; job=StandaloneCoroutine&#123;Cancelling&#125;@54c334f5]</span><br><span class="line">main: Now I can quit.</span><br></pre></td></tr></table></figure><p>결과를 확인해보면 3번 출력한 뒤 Exception이 출력되었고 그 내용이 <em>kotlinx.coroutines.JobCancellationException</em>이라는 것을 확인할 수 있다. 즉 <code>Job.cancel</code>이 동작하는 방법은 코루틴 내부에서 강제로 Exception을 발생시켜 코루틴이 종료되게 하는 것이다.</p><p><strong>Coroutine cancellation is cooperative. A coroutine code has to cooperate to be cancellable.</strong> 코루틴 문서의 협조적이어야 한다는 말은 코루틴 스스로가 cancel을 체크<small>(CancellationException을 체크)</small>해야한다는 뜻이며 suspend function을 하나라도 실행하지 않으면 코루틴은 종료되지 않는다는 것이다<small>(자신의 로직이 완료되어 리턴이 되지 않는 한에서)</small>.</p><blockquote><h3 id="3-making-computation-code-cancellable"><a class="markdownIt-Anchor" href="#3-making-computation-code-cancellable"></a> ③ Making computation code cancellable</h3></blockquote><p>코루틴이 취소되기 위해서 협조적인 방식을 취하는데 크게 2가지 방법이 있다.</p><ol><li><strong>주기적으로 suspend function을 호출하기</strong> <small>(suspend 되었다가 다시 재개될 때 cancel 되었는지를 확인해서 Exception을 던져주는 방식)</small></li><li><strong>명시적으로 취소 상태를 확인하기</strong> <small>(<code>isActive</code>라는 상태를 확인하여 false일 때 해당 코루틴을 종료시키는 방식)</small></li></ol><p>2번 예제에서 첫 번째 방법을 알아보았고, 이번 3번 예제에서 두 번째 방법을 알아본다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (isActive) &#123; <span class="comment">// cancellable computation loop</span></span><br><span class="line">            <span class="comment">// print a message twice a second</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">job: I&#x27;m sleeping 0 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 1 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 2 ... [DefaultDispatcher-worker-1]</span><br><span class="line">main: I&#x27;m tired of waiting! [main]</span><br><span class="line">main: Now I can quit. [main]</span><br></pre></td></tr></table></figure><p>while문을 통해 isActive의 상태를 확인하는 것으로 코루틴이 취소된 것을 확인할 수 있다. <code>isActive</code>가 실제로 잘 동작하였는지 로그를 통해 확인해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        kotlin.io.println(<span class="string">&quot;isActive <span class="variable">$isActive</span> ...&quot;</span>) <span class="comment">// while문에 들어가기 전의 isActive 확인</span></span><br><span class="line">        <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        kotlin.io.println(<span class="string">&quot;isActive <span class="variable">$isActive</span> ...&quot;</span>) <span class="comment">// while문에서 나온 뒤의 isActive 확인</span></span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>)</span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isActive true ...</span><br><span class="line">job: I&#x27;m sleeping 0 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 1 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 2 ... [DefaultDispatcher-worker-1]</span><br><span class="line">main: I&#x27;m tired of waiting! [main]</span><br><span class="line">isActive false ...</span><br><span class="line">main: Now I can quit. [main]</span><br></pre></td></tr></table></figure><p>출력 결과에서 while문에 들어가기 전과 후에 <code>isActive</code>의 상태값이 변경되는 것을 확인할 수 있다. 이러한 상태값을 통해 코루틴 스스로가 종료할 수 있다.</p><p>상태값을 통해 코루틴을 종료시키는 방식은 Exception이 발생하지 않으므로 코루틴 내부를 2번 예제와 같이 코루틴 내부를 <code>try-catch</code>문으로 감싸 예외를 확인해보면 Exception이 발생하지 않는 것을 확인할 수 있다.</p><p><code>isActive</code>는 <strong>확장 프로퍼티</strong>로 내부 구현은 코루틴의 Job이 실제로 종료되었는지를 체크하는 것이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Suppress(<span class="meta-string">&quot;EXTENSION_SHADOWED_BY_MEMBER&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> CoroutineScope.isActive: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = coroutineContext[Job]?.isActive ?: <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="4-closing-resources-with-finally-small코루틴을-종료할-때-리소스를-해제하는-방법small"><a class="markdownIt-Anchor" href="#4-closing-resources-with-finally-small코루틴을-종료할-때-리소스를-해제하는-방법small"></a> ④ Closing resources with finally <small>(코루틴을 종료할 때 리소스를 해제하는 방법)</small></h3></blockquote><p>코루틴에서 네트워크나 DB 등을 사용하다가 갑자기 코루틴이 cancel 되었을 때 코드 상에서 리소스를 해제해줘야 하는 위치를 알아보자.</p><p>아래의 코루틴은 <code>delay()</code>를 포함하여 취소하기에 협조적인 형태로 구현되어 있기에 <code>job.cancel</code>을 하면 취소가 될 것이다. 일시 중단이 되었다가 재개되면서 Exception을 던지면 <code>finally</code> 블록에서 리소스를 해제하면 된다.</p><p><strong>즉, suspend function으로 취소를 체크할 때 리소스 해제 지역은 <code>finally</code> 블록이다.</strong></p><p><code>try &#123;...&#125; finally &#123;...&#125;</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 리소스 해제 위치</span></span><br><span class="line">            println(<span class="string">&quot;job: I&#x27;m running finally&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">job: I&#x27;m sleeping 0 ... [main]</span><br><span class="line">job: I&#x27;m sleeping 1 ... [main]</span><br><span class="line">job: I&#x27;m sleeping 2 ... [main]</span><br><span class="line">main: I&#x27;m tired of waiting! [main]</span><br><span class="line">job: I&#x27;m running finally [main]</span><br><span class="line">main: Now I can quit. [main]</span><br></pre></td></tr></table></figure><blockquote><h3 id="5-run-non-cancellable-block"><a class="markdownIt-Anchor" href="#5-run-non-cancellable-block"></a> ⑤ Run non-cancellable block</h3></blockquote><p>5번 예제는 <strong>rare한 케이스</strong>이다.</p><p>이미 cancel된 코루틴 내부에서 suspend function을 호출해야하는 경우, 즉 <code>finally</code> 블록 안에서 다시 코루틴을 실행하려면 어떻게 해야할까?</p><p>이런 경우에는 <code>withContext</code> 함수에 <code>NonCancellable</code>이라는 CoroutineContext를 넘겨서 <code>withContext(NonCancellable) &#123; ... &#125;</code>에서 해당 코드를 래핑할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            withContext(NonCancellable) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m running finally&quot;</span>)</span><br><span class="line">                delay(<span class="number">1000L</span>)</span><br><span class="line">                println(<span class="string">&quot;job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">job: I&#x27;m sleeping 0 ... [main]</span><br><span class="line">job: I&#x27;m sleeping 1 ... [main]</span><br><span class="line">job: I&#x27;m sleeping 2 ... [main]</span><br><span class="line">main: I&#x27;m tired of waiting! [main]</span><br><span class="line">job: I&#x27;m running finally [main]</span><br><span class="line">job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable [main]</span><br><span class="line">main: Now I can quit. [main]</span><br></pre></td></tr></table></figure><blockquote><h3 id="6-timeout"><a class="markdownIt-Anchor" href="#6-timeout"></a> ⑥ Timeout</h3></blockquote><p>이전 예제들에서는 코루틴 스스로가 내부에서 cancel을 체크하는 2가지 방법을 알아보았다. 그런데 그외에도 다른 방법이 있는데 바로 <strong>Timeout</strong>이다.</p><p><strong>Timeout</strong>은 launch된 코루틴의 Job을 가지고 cancel하는 것이 아니라, 코루틴을 실행할 때 일정 시간이 지나면 취소되도록 미리 Timeout을 지정하는 방식이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    withTimeout(<span class="number">1300L</span>) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m sleeping 0 ... [main]</span><br><span class="line">I&#x27;m sleeping 1 ... [main]</span><br><span class="line">I&#x27;m sleeping 2 ... [main]</span><br><span class="line">Exception in thread &quot;main&quot; kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms</span><br><span class="line">at kotlinx.coroutines.TimeoutKt.TimeoutCancellationException(Timeout.kt:186)</span><br><span class="line">at kotlinx.coroutines.TimeoutCoroutine.run(Timeout.kt:156)</span><br><span class="line">at kotlinx.coroutines.EventLoopImplBase$DelayedRunnableTask.run(EventLoop.common.kt:497)</span><br><span class="line">at kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:274)</span><br><span class="line">at kotlinx.coroutines.DefaultExecutor.run(DefaultExecutor.kt:69)</span><br><span class="line">at java.base/java.lang.Thread.run(Thread.java:834)</span><br></pre></td></tr></table></figure><p>lauch를 통해 실행시킨 것이 아닌, runBlocking 내부 main에서 실행했기 때문에 CancellationException 발생하여 종료되는 것이다. 이런 경우를 해결하기 위해 <code>withTimeoutOrNull(Long)</code>을 사용한다.</p><p><code>withTimeout(Long)</code>이 아닌 <code>withTimeoutOrNull(Long)</code>을 사용하면 Exception이 발생했을 때 결과값이 <code>null</code>이 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result = withTimeoutOrNull(<span class="number">1300L</span>) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">&quot;Done&quot;</span> <span class="comment">// will get cancelled before it produces this result</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Result is <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m sleeping 0 ... [main]</span><br><span class="line">I&#x27;m sleeping 1 ... [main]</span><br><span class="line">I&#x27;m sleeping 2 ... [main]</span><br><span class="line">Result is null [main]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/categories/Kotlin/Coroutine/">Coroutine</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Coroutine/">Coroutine</category>
      
      
      <comments>http://june0122.github.io/2021/06/03/coroutines-cancellation-timeouts/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Kotlin] Coroutine - Basics</title>
      <link>http://june0122.github.io/2021/06/03/coroutines-basics/</link>
      <guid>http://june0122.github.io/2021/06/03/coroutines-basics/</guid>
      <pubDate>Thu, 03 Jun 2021 09:15:50 GMT</pubDate>
      
      <description>코루틴 &lt;sup&gt;Coroutine&lt;/sup&gt;은 비동기 콜백 처리를 순차적인 코드로 작성할 수 있게 해주는 코틀린 기능이자, &lt;b&gt;비동기적으로 실행되는 코드를 간소화하기 위해&lt;/b&gt; Android에서 사용할 수 있는 동시 실행 설계 패턴&lt;small&gt;(concurrency design pattern)&lt;/small&gt;이다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="코루틴-개요"><a class="markdownIt-Anchor" href="#코루틴-개요"></a> 코루틴 개요</h2><ul><li>코루틴은 <strong>루틴</strong>의 일종</li><li>협동 루틴이라 할 수 있으며, Coroutine의 <code>Co</code>는 <em>with</em> 또는 <em>together</em>를 뜻한다.</li></ul><blockquote><p>루틴과 코루틴의 차이</p></blockquote><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/120277451-08783500-c2ef-11eb-96e7-403bf6e5d5bd.png'></p><p>코루틴은 이전에 자신의 실행이 마지막으로 <strong>중단</strong>되었던 지점 다음의 장소에서 실행을 <strong>재개</strong>한다. <small>(함수의 진입점과 출구점이 여러 개 존재한다)</small></p><h3 id="코루틴의-역사"><a class="markdownIt-Anchor" href="#코루틴의-역사"></a> 코루틴의 역사</h3><p>코루틴은 멜빈 콘웨이에 의해 1958년 처음 만들어진 용어이며, 이를 어셈블리 프로그램에 적용했다. 코루틴은 협력 작업 <sup>cooperative tasks</sup>, 예외 <sup>exceptions</sup>, 이벤트 루프 <sup>event loops</sup>, 반복자 <sup> iterators</sup>, 무한 리스트 <sup>infinite lists</sup> 및 파이프 <sup>pipes</sup>와 같은 친숙한 프로그램 구성 요소를 구현하는 데 적합하다고 소개되어있는데 <sup id = "a1"><a href="#f1">1</a></sup> 구글 문서에서는 코루틴의 사용 범위를 좀 더 명확하게 제시하고 있다.</p><h3 id="android-developers-코틀린-가이드에서의-코루틴-정의-sup-id-a12sup"><a class="markdownIt-Anchor" href="#android-developers-코틀린-가이드에서의-코루틴-정의-sup-id-a12sup"></a> Android Developers 코틀린 가이드에서의 코루틴 정의 <sup id = "a1"><a href="#f1">2</a></sup></h3><ul><li>코루틴은 <strong>비동기적으로 실행되는 코드를 간소화하기 위해</strong> Android에서 사용할 수 있는 동시 실행 설계 <strong>패턴</strong><small>(concurrency design pattern)</small>이다.<ul><li>비동기 처리는 callback, cancel, 리소스 관리 등을 해줘야하므로 어려움이 있는데 코루틴을 이용하면 쉽게 처리할 수 있다.</li></ul></li><li>Android에서 코루틴은 <strong>메인 스레드를 blocking하여 앱이 응답하지 않게 만들 수도 있는 장기 실행 작업을 관리하는 데 도움</strong>이 됩니다.</li></ul><h3 id="google-codelabs의-코루틴-정의-sup-id-a13sup"><a class="markdownIt-Anchor" href="#google-codelabs의-코루틴-정의-sup-id-a13sup"></a> Google Codelabs의 코루틴 정의 <sup id = "a1"><a href="#f1">3</a></sup></h3><ul><li>코루틴은 비동기 콜백 처리를 순차적인 코드로 작성할 수 있게 해주는 코틀린 기능이다. <small>(<strong>Coroutines</strong> are a Kotlin feature that <strong>converts async callbacks for long-running tasks</strong>, such as database or network access, into <strong>sequential code</strong>.)</small></li><li><code>suspend</code> 함수를 사용하여 비동기 코드를 순차적으로 만들어준다. <small>(Use suspend functions to <strong>make async code sequential</strong>)</small></li></ul><h2 id="코루틴-기초"><a class="markdownIt-Anchor" href="#코루틴-기초"></a> 코루틴 기초</h2><p>먼저 코루틴을 사용하기 위해 <code>kotlinx.coroutines.*</code>를 import해야하므로 <a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects">공식 프로젝트 README</a>를 참고하여 최신 버전을 의존성에 추가한다.</p><blockquote><h3 id="1-thread"><a class="markdownIt-Anchor" href="#1-thread"></a> ① Thread</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    thread &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Hello, &quot;</span>)</span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>) <span class="comment">// // block main thread for 2 seconds to keep JVM alive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main()</code>이 <code>println(&quot;World!&quot;)</code>가 실행되기도 전에 종료되는 것을 막기 위해 맨 밑줄에 <code>Thread.sleep(2000L)</code>이 추가되어 있다.</p><blockquote><h3 id="2-your-first-coroutine"><a class="markdownIt-Anchor" href="#2-your-first-coroutine"></a> ② Your first Coroutine</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// launch a new coroutine in background and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// non-blocking delay for 1 second</span></span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>) <span class="comment">// print after delay</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;Hello, &quot;</span>) <span class="comment">// main thread continues while coroutine is delayed</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>) <span class="comment">// block main thread for 2 seconds to keep JVM alive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>launch</strong>는 독립적으로 실행이 불가능하며 <strong>CoroutineScope</strong> 내에서만 선언된다.</p><blockquote><h3 id="3-bridging-blocking-and-non-blocking-worlds"><a class="markdownIt-Anchor" href="#3-bridging-blocking-and-non-blocking-worlds"></a> ③ Bridging blocking and non-blocking worlds</h3></blockquote><p><code>Thread.sleep()</code>과 <code>delay()</code>가 혼용되는 것을 막기 위해 <code>delay()</code>로 통일해보자. 하지만 CoroutineScope 외부에 <code>delay()</code>를 추가하려는데 에러가 발생한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/120302445-decc0780-c308-11eb-97ae-ede496319166.png'></p><p><code>Thread.sleep(2000L)</code>은 메인 스레드를 blocking하는 형태였으므로, <code>delay()</code>로 변경하기 위해서는 명시적으로 Blocking하는 코루틴을 만들어줘야 한다. 그 역할을 하는 코루틴 빌더가 <strong>runBlocking</strong>이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// launch a new coroutine in background and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Hello, &quot;</span>) <span class="comment">// main thread continues here immediately</span></span><br><span class="line">    runBlocking &#123; <span class="comment">// but this expression blocks the main thread</span></span><br><span class="line">        delay(<span class="number">2000L</span>) <span class="comment">// ... while we delay for 2 seconds to keep JVM alive</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lauch</strong>는 자신을 호출하는 스레드를 <strong>Blocking 하지 않는다.</strong></p><p><strong>runBlocking</strong>은 자신을 호출하는 스레드를 <strong>Blocking 한다.</strong></p><blockquote><h3 id="4-rewritten-in-a-more-idiomatic-waysmall관용적인-형태로-만들기small"><a class="markdownIt-Anchor" href="#4-rewritten-in-a-more-idiomatic-waysmall관용적인-형태로-만들기small"></a> ④ rewritten in a more idiomatic way<small>(관용적인 형태로 만들기)</small></h3></blockquote><p>이때까지 작성한 코드들은 main 함수 안의 내용이 완료되기 전까지는 return되지 않기를 원하는 것이기 때문에 <strong>runBlocking</strong>을 마지막에만 사용하는 것이 아니라 코드 전체를 <strong>runBlocking</strong>으로 감싸는 형태로 작성한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        println(<span class="string">&quot;Hello, &quot;</span>)</span><br><span class="line">        delay(<span class="number">2000L</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>메인 함수를 <strong>runBlocking</strong>으로 감쌌기 때문에 전체 코드가 실행되기 전까지는 메인 스레드가 <strong>runBlocking</strong> 때문에 return이 되지 않는다. 그리고 위의 코드는 아래와 같이 한 번 더 변경될 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// // start main coroutine</span></span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// launch a new coroutine in background and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Hello, &quot;</span>) <span class="comment">// main coroutine continues here immediately</span></span><br><span class="line">    delay(<span class="number">2000L</span>) <span class="comment">// delaying for 2 seconds to keep JVM alive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="5-waiting-for-a-job"><a class="markdownIt-Anchor" href="#5-waiting-for-a-job"></a> ⑤ Waiting for a job</h3></blockquote><p>프로그램이 종료되는 것을 막기 위해 delay를 사용하는 것은 좋은 접근법이 아니다. 명시적으로 <code>job</code>을 생성하여 기다리게 해보자.</p><p>lauch를 하게 되면 Job이 반환되는데, Job 객체에다가 <code>join()</code>을 하게 되면 해당 Job이 완료될 때까지 기다리게 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Hello, &quot;</span>)</span><br><span class="line">    job.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="6-structured-concurrency"><a class="markdownIt-Anchor" href="#6-structured-concurrency"></a> ⑥ Structured concurrency</h3></blockquote><p>이전 예제들에선 코루틴이 완료되는 것을 기다리기 위해 2초동안 <code>sleep()</code>을 실행하거나 Job 객체를 만들어서 <code>join()</code>을 사용하였다. 하지만 앞으로 여러 개의 코루틴을 실행하게 될텐데 이런 형태라면 아래와 같이 Job을 따로 관리해주는 등, 유지 보수하기 어려운 코드가 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job1 = GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> job2 = GlobalScope.launch &#123;</span><br><span class="line">        delay(<span class="number">2000L</span>)</span><br><span class="line">        println(<span class="string">&quot;Let&#x27;s Go!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Hello, &quot;</span>)</span><br><span class="line">    </span><br><span class="line">    job1.join()</span><br><span class="line">    job2.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코틀린에서는 이를 방지하기 위해서 <strong>Structured concurrency</strong>를 사용하라고 권장한다. runBlocking과 launch에서 실행된 코루틴이 구조적인 관계를 만든다면 서로 기다려주는 일을 할 수 있기 때문이다.</p><p><code>GlobalScope.launch</code>를 사용하게 되면, <strong>top-level 코루틴을 생성</strong>하게 된다. 이렇게 되면 <strong>많은 메모리를 소모</strong>하게 된다. 그러므로 GlobalScope에서 launch를 하는 것이 아닌 runBlocking을 통해 들어온 CoroutineScope에서 lauch를 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; <span class="comment">// // launch a new coroutine in the scope of runBlocking (this. 생략 가능)</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello, &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>즉, <strong>Structured concurrency</strong>는 top-level 코루틴을 만들지 말고 <code>runBlocking</code>의 자식으로 코루틴을 만들면 부모 코루틴이 자식 코루틴이 완료되는 것까지 다 기다려주기 때문에 구조적인 형태를 이용해서 코루틴을 관리하라는 개념이다.</p><p>참고로 GlobalScope는 잘못 사용하기 쉬운 advanced API이므로 <a href="https://blog.jetbrains.com/kotlin/2021/05/kotlin-coroutines-1-5-0-released/#globalscope">Kotlin Coroutines 1.5.0</a>부터 <strong>delicate API</strong>로 표시되어 컴파일러가 경고를 보낸다.</p><blockquote><h3 id="7-extract-function-refactoring"><a class="markdownIt-Anchor" href="#7-extract-function-refactoring"></a> ⑦ Extract function refactoring</h3></blockquote><p>lauch 내부의 코드를 하나의 함수로 추출해보자. 그러면 아래와 같은 오류가 발생한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123; </span><br><span class="line">        doWorld() </span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align = 'center'><img width = '700' src = 'https://user-images.githubusercontent.com/39554623/120296667-5139e900-c303-11eb-8cac-7727a7e86643.png'></p><p><em>Suspend function ‘delay’ should be called only from a coroutine or another suspend function</em>. 즉, 일시 중단되는 함수인 <code>delay()</code>는 오직 코루틴이나 다른 suspend function으로부터만 호출될 수 있다는 뜻이다.</p><p>이를 해결하기 위해선 <code>suspend</code> 키워드를 함수 앞에 붙여주면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123; </span><br><span class="line">        doWorld()</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="8-coroutines-are-light-weight"><a class="markdownIt-Anchor" href="#8-coroutines-are-light-weight"></a> ⑧ Coroutines ARE light-weight</h3></blockquote><p>10만 개의 코루틴을 한 번에 생성하여 1초 뒤에 한 번의 점을 찍게 하는 코드를 실행해본다. 직접 실행해보면 아무런 오류나 성능적 이슈없이 점들이 출력된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    repeat(<span class="number">100_000</span>) &#123; <span class="comment">// launch a lot of coroutines</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">5000L</span>)</span><br><span class="line">            print(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/120319461-ffea2380-c31b-11eb-9d19-0c86475f0b5b.png'></p><p>그렇다면 이번에 코루틴이 아닌 스레드로 바꿔서 똑같은 작업을 해보자. OutOfMemoryError가 발생하는 것을 확인할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    repeat(<span class="number">100_000</span>) &#123; <span class="comment">// launch a lot of coroutines</span></span><br><span class="line">        thread &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000L</span>)</span><br><span class="line">            print(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/120319256-c9140d80-c31b-11eb-9f38-b9e891fd4dcf.png'></p><p>이 두 코드를 통해 <strong>코루틴이 스레드보다 구조적으로 상당히 가볍다</strong>는 것을 확인할 수 있다. 많은 스레드를 만들면 부하가 일어날 수 있지만, 코루틴은 많은 양을 생성하여도 크게 부하가 가지 않는 것이다.</p><blockquote><h3 id="9-global-coroutines-are-like-daemon-threads"><a class="markdownIt-Anchor" href="#9-global-coroutines-are-like-daemon-threads"></a> ⑨ Global coroutines are like daemon threads</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delay(<span class="number">1300L</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m sleeping 0 ...</span><br><span class="line">I&#x27;m sleeping 1 ...</span><br><span class="line">I&#x27;m sleeping 2 ...</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p><strong>코루틴이 계속 실행되고 있다고해서 프로세스가 유지되지는 않는다</strong>라는 것을 보여주는 코드이다. 코루틴은 <strong>데몬 스레드처럼</strong> 프로세스가 살아있을 동안에만 동작할 수 있다라는 것이다.</p><p>즉, <strong>프로세스가 종료되면 코루틴도 끝난다</strong>라는 것이다.</p><blockquote><h3 id="10-suspend-resume"><a class="markdownIt-Anchor" href="#10-suspend-resume"></a> ⑩ suspend &lt;-&gt; resume</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">5</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;Coroutine A, <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">5</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;Coroutine B, <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Coroutine Outer&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Coroutine Outer</span><br><span class="line">Coroutine A, 0</span><br><span class="line">Coroutine A, 1</span><br><span class="line">Coroutine A, 2</span><br><span class="line">Coroutine A, 3</span><br><span class="line">Coroutine A, 4</span><br><span class="line">Coroutine B, 0</span><br><span class="line">Coroutine B, 1</span><br><span class="line">Coroutine B, 2</span><br><span class="line">Coroutine B, 3</span><br><span class="line">Coroutine B, 4</span><br></pre></td></tr></table></figure><p>println을 override 하여 어떤 스레드에서 실행되었는지 확인한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">println</span><span class="params">(msg: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    kotlin.io.println(<span class="string">&quot;<span class="variable">$msg</span> [<span class="subst">$&#123;Thread.currentThread().name&#125;</span>]&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Coroutine Outer [main]</span><br><span class="line">Coroutine A, 0 [main]</span><br><span class="line">Coroutine A, 1 [main]</span><br><span class="line">Coroutine A, 2 [main]</span><br><span class="line">Coroutine A, 3 [main]</span><br><span class="line">Coroutine A, 4 [main]</span><br><span class="line">Coroutine B, 0 [main]</span><br><span class="line">Coroutine B, 1 [main]</span><br><span class="line">Coroutine B, 2 [main]</span><br><span class="line">Coroutine B, 3 [main]</span><br><span class="line">Coroutine B, 4 [main]</span><br></pre></td></tr></table></figure><p><code>Help - Edit Custom VM Options...</code>에서 <strong>-Dkotlinx.coroutines.debug</strong>를 복사한 뒤, 실행 버튼 왼쪽의 탭을 클릭하여 <code>Edit Configurations...</code> 옵션에 들어가 VM options 칸에 복사한 <strong>-Dkotlinx.coroutines.debug</strong>를 붙여 넣어주면 어느 코루틴에서 실행되었는지까지 확인할 수 있다.</p><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/120322472-6886cf80-c31f-11eb-861b-dab8a29df423.png'></p><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/120322546-7b010900-c31f-11eb-92e6-54504ccd150f.png'></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Coroutine Outer [main @coroutine#1]</span><br><span class="line">Coroutine A, 0 [main @coroutine#2]</span><br><span class="line">Coroutine A, 1 [main @coroutine#2]</span><br><span class="line">Coroutine A, 2 [main @coroutine#2]</span><br><span class="line">Coroutine A, 3 [main @coroutine#2]</span><br><span class="line">Coroutine A, 4 [main @coroutine#2]</span><br><span class="line">Coroutine B, 0 [main @coroutine#3]</span><br><span class="line">Coroutine B, 1 [main @coroutine#3]</span><br><span class="line">Coroutine B, 2 [main @coroutine#3]</span><br><span class="line">Coroutine B, 3 [main @coroutine#3]</span><br><span class="line">Coroutine B, 4 [main @coroutine#3]</span><br></pre></td></tr></table></figure><p>첫 번째 코루틴<small>(coroutine#1)</small>은 runBlocking에 의해서 만들어졌고, 나머지 두 번째와 세 번째 코루틴은 launch에 의해 순서대로 만들어졌다.</p><p>이제 Coroutine A에 10ms의 delay를 줘보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">5</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;Coroutine A, <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">10L</span>) <span class="comment">// 10ms의 delay</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">5</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;Coroutine B, <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Coroutine Outer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Coroutine Outer [main @coroutine#1]</span><br><span class="line">Coroutine A, 0 [main @coroutine#2]</span><br><span class="line">Coroutine B, 0 [main @coroutine#3]</span><br><span class="line">Coroutine B, 1 [main @coroutine#3]</span><br><span class="line">Coroutine B, 2 [main @coroutine#3]</span><br><span class="line">Coroutine B, 3 [main @coroutine#3]</span><br><span class="line">Coroutine B, 4 [main @coroutine#3]</span><br><span class="line">Coroutine A, 1 [main @coroutine#2]</span><br><span class="line">Coroutine A, 2 [main @coroutine#2]</span><br><span class="line">Coroutine A, 3 [main @coroutine#2]</span><br><span class="line">Coroutine A, 4 [main @coroutine#2]</span><br></pre></td></tr></table></figure><p>A가 모두 출력되고 B가 출력되었던 이전의 코드와 달리 A가 한 번만 출력되고 B가 모두 출력된 다음에야 나머지 A가 출력된다. A가 한 번 출력되고 <code>delay()</code>가 실행되었을 때, A는 중단되고 B로 실행이 넘어간 것이다. B 내부에는 중단점이 없기 때문에 모두 다 호출이 되고나서야 A가 다시 실행된다.</p><p>그렇다면 A와 B가 사이좋게 오고가며 실행될 수 있도록 하려면 어떻게 해야할까? B에도 중단점을 추가, 즉 delay를 추가해주면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">5</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;Coroutine A, <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">10L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch &#123;</span><br><span class="line">        repeat(<span class="number">5</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;Coroutine B, <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">10L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Coroutine Outer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Coroutine Outer [main @coroutine#1]</span><br><span class="line">Coroutine A, 0 [main @coroutine#2]</span><br><span class="line">Coroutine B, 0 [main @coroutine#3]</span><br><span class="line">Coroutine B, 1 [main @coroutine#3]</span><br><span class="line">Coroutine B, 2 [main @coroutine#3]</span><br><span class="line">Coroutine B, 3 [main @coroutine#3]</span><br><span class="line">Coroutine B, 4 [main @coroutine#3]</span><br><span class="line">Coroutine A, 1 [main @coroutine#2]</span><br><span class="line">Coroutine A, 2 [main @coroutine#2]</span><br><span class="line">Coroutine A, 3 [main @coroutine#2]</span><br><span class="line">Coroutine A, 4 [main @coroutine#2]</span><br></pre></td></tr></table></figure><p><em>Coroutine A</em>가 먼저 출력될 것 같은데 <em>Coroutine Outer</em>가 먼저 출력되는 것을 통해 <code>launch &#123; &#125;</code>가 코루틴이 실행되기 위한 스케줄링을 해놓는다는 것을 추측할 수 있다.</p><h2 id="정리"><a class="markdownIt-Anchor" href="#정리"></a> 정리</h2><p>코루틴은 <strong>일시 중단이 가능한 계산의 인스턴스</strong>다<small>(an instance of suspendable computation)</small>. 다른 코드와 동시에 작동하는 코드 블록을 실행해야 한다는 점에서 스레드와 개념적으로 유사하다. 하지만 코루틴은 특정 스레드에 바인딩되지 않는다. 한 스레드에서 실행을 일시 중지하고 다른 스레드에서 다시 시작할 수 있다.</p><p>코루틴은 경량 스레드라고 생각되어질 수 있지만, 실제 사용하는데 있어 스레드와 매우 다르게 만드는 몇 가지 중요한 차이점이 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; <span class="comment">// launch a new coroutine and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// non-blocking delay for 1 second (default time unit is ms)</span></span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>) <span class="comment">// print after delay</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>) <span class="comment">// main coroutine continues while a previous one is delayed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">World!</span><br></pre></td></tr></table></figure><h4 id="launch-main-thread-를-unblocking-한-채-구문-내-작업을-수행"><a class="markdownIt-Anchor" href="#launch-main-thread-를-unblocking-한-채-구문-내-작업을-수행"></a> <code>launch &#123;&#125;</code> : Main Thread 를 Unblocking 한 채 <code>&#123;&#125;</code> 구문 내 작업을 수행</h4><p><strong>launch</strong>는 <strong>코루틴 빌더 <sup>coroutine builder</sup></strong> 이다. 코루틴 빌더는 새로운 코루틴을 독립적으로 작동하는 나머지 코드들과 <strong>동시에</strong> 실행시킨다. 이것이 <em>Hello</em>가 가장 먼저 출력되는 이유이다.</p><h4 id="delay"><a class="markdownIt-Anchor" href="#delay"></a> <code>delay()</code></h4><p><strong>delay</strong>는 특별한 suspending function으로, 코루틴을 특정 시간동안 일시 중단시킨다. 코루틴을 일시 중단시켜도 메인 스레드가 Blocking 되지는 않지만, 다른 코루틴이 코드에 메인 스레드를 실행하고 사용할 수 있습니다.</p><h4 id="runblocking-main-thread-를-blocking-한-채-구문-내-작업을-새-thread-에-할당하여-수행"><a class="markdownIt-Anchor" href="#runblocking-main-thread-를-blocking-한-채-구문-내-작업을-새-thread-에-할당하여-수행"></a> <code>runBlocking &#123;&#125;</code> : Main Thread 를 Blocking 한 채 <code>&#123;&#125;</code> 구문 내 작업을 새 Thread 에 할당하여 수행</h4><p><strong>runBlocking</strong> 또한 <strong>코루틴 빌더</strong>로써, 코루틴이 아닌 일반적인 <code>fun main()</code> 영역과 <code>runBlocking &#123;&#125;</code> 괄호 안의 코루틴이 있는 코드들을 연결한다.</p><p><strong>launch</strong>는 독립적으로 실행이 불가능하며 <strong>CoroutineScope</strong> 내에서만 선언되기 때문에, 만약 코드에서 <strong>runBlocking</strong>을 제거하거나 잊어버린다면 <strong>launch</strong>를 호출할 때 에러가 발생한다.</p><p><strong>runBlocking</strong>의 이름은 <code>runBlocking &#123;&#125;</code> 내부의 모든 코루틴이 실행을 완료할 때까지 이를 실행하는 스레드<small>(여기선 메인 스레드)</small>가 호출되는 동안 Blocking 된다는 것을 의미한다. 스레드는 값 비싼 리소스이고 스레드를 Blocking하는 것은 비효율적이면서 프로그래머가 종종 원하지 않기 때문에 애플리케이션의 최상위 수준에서 실제 코드 내에서는 거의 사용되지 않는 <strong>runBlocking</strong>을 자주 볼 수 있을 것이다.</p><blockquote><p>구조화된 동시성 <sup>Structured concurrency﻿</sup></p></blockquote><p>코루틴은 구조화된 동시성의 원칙을 따른다. 즉 새로운 코루틴은 코루틴의 수명을 제한하는 특정 CoroutineScope에서만 실행될 수 있다. 위의 예제 코드는 runBlocking이 해당 범위를 설정하며 이것이 *World!*가 1초 지연된 다음 출력되고 종료되는 이유이다.</p><p>실제 어플리케이션에서는 많은 코루틴을 실행하게 될 것이다. 구조화된 동시성은 손실이나 누수가 없는 것을 보장한다. 외부 범위는 모든 하위 코루틴이 완료될 때까지는 완료할 수 없다. 구조화된 동시성은 또한 코드 내부의 오류가 제대로 보고되고 손실되지 않는 것을 보장해준다.</p><h3 id="함수를-추출하여-리팩토링하기"><a class="markdownIt-Anchor" href="#함수를-추출하여-리팩토링하기"></a> 함수를 추출하여 리팩토링하기</h3><p><code>launch &#123;...&#125;</code> 내부의 코드 블록을 별도의 함수로 추출해보자. 이 코드에 IDE의 <em>Extract Function</em> 기능을 수행하면 아래와 같이 <code>suspend</code> 변경자 <sup>modifier</sup>가 있는 새 함수가 생성이 된다. 일시 중단 함수 <sup>suspending function</sup>는 일반 함수와 마찬가지로 코루틴 내부에서 사용할 수 있지만 추가 기능은 다른 일시 중단 함수<small>(<code>delay()</code>와 같은)</small>를 사용하여 코루틴의 실행을 중단시킬 수 있다는 것이다.</p><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/120298097-ba6e2c00-c304-11eb-9271-b3e1f9efe246.png'></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; doWorld() &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is your first suspending function</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>추출한 함수의 <code>suspend</code> 변경자를 제거하면?</p></blockquote><p align = 'center'><img width = '700' src = 'https://user-images.githubusercontent.com/39554623/120296667-5139e900-c303-11eb-8cac-7727a7e86643.png'></p><p>추출한 함수의 <code>suspend</code> 변경자를 제거하면 <em>Suspend function ‘delay’ should be called only from a coroutine or another suspend function</em>라는 경고문이 뜬다. 즉, 일시 중단되는 함수인 <code>delay()</code>는 오직 코루틴이나 다른 일시 중단 함수로부터만 호출될 수 있다는 뜻이다.</p><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li>Kotlin Docs, Coroutines basics : <a href="https://kotlinlang.org/docs/coroutines-basics.html">https://kotlinlang.org/docs/coroutines-basics.html</a></li><li>새차원, 코틀린 코루틴 : <a href="https://youtu.be/14AGUuh8Bp8">https://youtu.be/14AGUuh8Bp8</a></li></ul><hr /><p><b id = "f1"><sup> 1 </sup></b> <a href="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a> <a href="#a1"> ↩</a></p><p><b id = "f1"><sup> 2 </sup></b> <a href="https://developer.android.com/kotlin/coroutines?hl=ko">https://developer.android.com/kotlin/coroutines?hl=ko</a> <a href="#a1"> ↩</a></p><p><b id = "f1"><sup> 3 </sup></b> <a href="https://developer.android.com/codelabs/kotlin-coroutines#0">https://developer.android.com/codelabs/kotlin-coroutines#0</a> <a href="#a1"> ↩</a></p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/categories/Kotlin/Coroutine/">Coroutine</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Coroutine/">Coroutine</category>
      
      
      <comments>http://june0122.github.io/2021/06/03/coroutines-basics/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] 데이터 바인딩과 MVVM</title>
      <link>http://june0122.github.io/2021/06/01/android-bnr-19/</link>
      <guid>http://june0122.github.io/2021/06/01/android-bnr-19/</guid>
      <pubDate>Mon, 31 May 2021 16:18:15 GMT</pubDate>
      
      <description>안드로이드의 &lt;b&gt;데이터 바인딩 &lt;sup&gt;data binding&lt;/sup&gt;&lt;/b&gt; 은 Android Jetpack 라이브러리 중 하나로 &lt;b&gt;UI 구성요소와 데이터를&lt;/b&gt; 프로그램적 방식으로 연결하지 않고, &lt;b&gt;선언적 형식으로 결합&lt;/b&gt;할 수 있게 해주는 지원 라이브러리를 말한다. 간단하게 말하면 XML파일에 data를 연결 &lt;sup&gt;binding&lt;/sup&gt;해서 사용하는 것을 의미한다.</description>
      
      
      
      <content:encoded><![CDATA[<p>앱에 포함된 여러 음원을 사용자가 조회하고 들을 수 있는 BeatBox라는 새로운 프로젝트를 통해 <a href="https://developer.android.com/topic/libraries/data-binding?hl=ko"><strong>데이터 바인딩 <sup>data binding</sup></strong></a> 이라는 Jetpack 아키텍처 컴포넌트 라이브러리를 사용하는 방법을 배운다. 그리고 데이터 바인딩을 사용해서 <strong>MVVM<small>(Model-View-View Model)</small></strong> 아키텍처를 구현하고 애셋 <sup>asset</sup> 시스템을 사용해서 음원 파일을 저장하는 방법도 알아본다.</p><h2 id="다른-아키텍처가-왜-필요할까"><a class="markdownIt-Anchor" href="#다른-아키텍처가-왜-필요할까"></a> 다른 아키텍처가 왜 필요할까?</h2><p>지금까지 작성했던 모든 앱은 간단한 형태의 MVC 아키텍쳐를 사용해 잘 작동하였다. 그런데 무슨 문제가 있길래 아키텍처를 변경해야 할까?</p><h4 id="장점"><a class="markdownIt-Anchor" href="#장점"></a> 장점</h4><p>MVC 아키텍처는 규모가 작고 간단한 앱에는 좋다. 새로운 기능을 추가하기 쉽고 앱의 동적인 부분을 쉽게 알 수 있을 뿐만 아니라 프로젝트의 초기 단계에 확고한 개발 기간을 만들어줘서 앱을 빨리 개발할 수 있다.</p><h4 id="단점"><a class="markdownIt-Anchor" href="#단점"></a> 단점</h4><p>그런데 프로젝트가 커지면 문제가 발생한다. MVC의 컨트롤러 역할인 액티비티나 프래그먼트의 규모가 커지면서 작성과 이해가 어려워져서 새로운 기능을 추가하거나 결함을 해결하는 데 시간이 오래 걸린다. 따라서 언젠가는 그런 컨트롤러들을 더 작은 부분으로 분할해야 한다.</p><h4 id="해결책"><a class="markdownIt-Anchor" href="#해결책"></a> 해결책</h4><p>그렇다면 어떻게 해야 할까? 점점 비대해지는 컨트롤러 클래스들이 하는 작업을 파악하여 하나의 거대한 클래스 대신 여러 클래스가 작업을 분담해 협업하게 하면 된다.</p><p>그런데 서로 다른 작업을 어떻게 분할해야 할까? 이에 대한 답은 MVVM과 같은 아키텍처를 사용하는 것이다. 단, 작업을 분할하는 것은 전적으로 프로그래머의 일이다.</p><p>MVVM에서는 뷰와 밀접한 콘트롤러 코드를 레이아웃 파일로 옮길 수 있다. 게다가 동적인<small>(변하는 데이터를 처리하는)</small> 컨트롤러 코드의 일부를 <strong>뷰 모델 클래스</strong>에 넣어서 앱의 테스트와 검증도 쉽게 할 수 있다. 단, 뷰모델 클래스를 어떤 규모로 할 것인지는 각자의 판단에 달렸다. 뷰모델 클래스가 커지면 작게 분할하면 된다.</p><h2 id="mvvm-뷰모델-vs-jetpack-viewmodel"><a class="markdownIt-Anchor" href="#mvvm-뷰모델-vs-jetpack-viewmodel"></a> MVVM 뷰모델 vs Jetpack ViewModel</h2><p>MVVM의 일부인 뷰모델은 <a href="https://june0122.github.io/2021/05/13/android-bnr-04/">여기</a>에서 다뤘던 <strong>Jetpack ViewModel<small>(AAC ViewModel)</small></strong> 클래스와 같은 것이 아니다. 따라서 혼동되지 않도록 Jetpack 클래스의 이름을 항상 <strong>ViewModel</strong>로 나타내고 MVVM 개념 관련해서는 '뷰모델’이라고 한다.</p><p>다시 정리하자면, Jetpack ViewModel은 액티비티나 프래그먼트의 생명주기에 걸쳐 데이터를 유지하고 관리하는 클래스다. 반면에 MVVM의 뷰모델은 개념적인 아키텍처의 일부분을 말한다. 뷰모델은 Jetpack ViewModel 클래스를 사용해서 구현할 수 있다. 그런데 곧 본문의 내용을 통해 알 수 있지만, ViewModel 클래스를 사용하지 않고도 구현할 수 있다.</p><h2 id="beatbox-프로젝트-준비-작업"><a class="markdownIt-Anchor" href="#beatbox-프로젝트-준비-작업"></a> BeatBox 프로젝트 준비 작업</h2><p>BeatBox 앱의 액티비티에서는 RecyclerView에 격자 <sup>grid</sup> 형태의 버튼을 보여줄 것이다. RecyclerView의 의존성을 build.gradle 파일에 추가하고 res/layout/activity_main.xml의 모든 XML을 삭제하고 아래와 같이 RecyclerView로 교체한다.</p><blockquote><p>MainActivity의 레이아웃 파일 변경하기 (res/layout/activity_main.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/recycler_view&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>이 상태에서 앱을 실행하면 빈화면만 나오는데, 이제부터 데이터 바인딩<small>(data binding)</small>을 구현해보자.</p><h2 id="단순-데이터-바인딩-구현하기"><a class="markdownIt-Anchor" href="#단순-데이터-바인딩-구현하기"></a> 단순 데이터 바인딩 구현하기</h2><p>RecyclerView를 코드와 연결해야 한다. 일반적으로 많이 하는 작업이지만, 이번에는 데이터 바인딩을 사용한다.</p><p>데이터 바인딩은 레이아웃을 사용할 때 몇 가지 장점을 제공한다. 곧 보겠지만 간단한 예로, <code>findViewById(...)</code> 를 호출하지 않고 뷰를 사용할 수 있게 해준다<small>(자동으로 뷰에 데이터를 넘겨줌)</small>. 진보된 데이터 바인딩의 사용법은 추후에 알아본다.</p><p>우선 데이터 바인딩을 활성화 하고 kotlin-kapt 플러그인을 적용하도록 build.gradle 파일에 추가한다.</p><blockquote><p>데이터 바인딩 활성화하기 (build.gradle)</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        enabled = <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin-kapt 플러그인을 적용하면 데이터 바인딩에서 코틀린의 애노테이션을 처리할 수 있다. 이것이 중요한 이유는 본문의 뒷부분에서 알 수 있다.</p><p>레이아웃 파일에서 데이터 바인딩을 사용하려면 &lt;layout&gt; 태그로 레이아웃 XML 전체를 둘러싸서 데이터 바인딩용 레이아웃 파일로 변경하면 된다. <em>activity_main.xml</em>의 파일 이름을 <em>main_activity.xml</em>로 변경하고 코드를 아래와 같이 수정한다<small>(자동으로 생성되는 바인딩 클래스의 이름의 가독성을 올리기 위해 이름 변경)</small>.</p><blockquote><p>데이터 바인딩용 레이아웃 파일로 변경하기 (res/layout/main_activity.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/recycler_view&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&lt;layout&gt; 태그는 이 레이아웃에 데이터 바인딩을 한다는 것을 나타낸다. 레이아웃에 이 태그가 있으면 데이터 바인딩 라이브러리가 <strong>바인딩 클래스<small>(binding class)</small></strong> 를 자동으로 생성한다. 기본적으로 이 클래스 이름은 레이아웃 파일 이름 끝에 <strong>Binding</strong>이 붙은 채로 지정된다<small>(복합 단어이면 각 단어의 첫 자를 대문자로 사용하는 카멜 명명법이 사용됨)</small>.</p><p>따라서 여기서는 <strong>MainActivityBinding</strong>이라는 <em>main_activity.xml</em>의 바인딩 클래스가 자동으로 생성된다. 그리고 이 클래스가 데이터 바인딩에 사용되므로 <code>setContentView(Int)</code>를 사용해서 뷰를 인플레이트하는 대신에 <strong>MainActivityBinding</strong>의 인스턴스를 인플레이트한다.</p><p><strong>MainActivityBinding</strong>은 root 속성에 뷰 계층<small>(레이아웃 전체)</small>의 참조뿐 아니라 레이아웃 파일에 android:id가 지정된 각 자식 뷰의 참조도 갖는다. 따라서 여기서는 <strong>MainActivityBinding</strong> 클래스가 두 개의 참조,  ① 레이아웃 전체의 참조와 ② RecyclerView를 참조하는 recyclerView<small>(자동 생성됨)</small>을 가진다.</p><blockquote><p>바인딩 클래스</p></blockquote><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/120102817-cd0f2680-c187-11eb-89f3-bcda5c8fabef.jpeg'></p><p>그런데 이 레이아웃은 하나의 뷰만 갖고 있어서 두 개의 참조 모두 RecyclerView를 가리킨다.</p><p>이제는 바인딩 클래스를 사용할 수 있다. 우선 DataBindingUtil을 사용해서 MainActivityBinding 인스턴스를 인플레이트하도록 MainActivity의 <code>onCreate(...)</code>을 변경한다. 이때 다른 클래스처럼 MainActivityBinding도 import해야 한다.</p><blockquote><p>바인딩 클래스 인플레이트하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"><span class="comment">//        setContentView(R.layout.activity_main)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 바인딩 클래스 인플레이트</span></span><br><span class="line">        <span class="keyword">val</span> binding: MainActivityBinding =</span><br><span class="line">            DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.main_activity)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>바인딩 클래스가 생성되었다. 이제 RecyclerView를 구성한다.</p><blockquote><p>RecyclerView 구성하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> binding: MainActivityBinding =</span><br><span class="line">            DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.main_activity)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RecyclerView 구성</span></span><br><span class="line">        binding.recyclerView.apply &#123;</span><br><span class="line">            layoutManager = GridLayoutManager(context, <span class="number">3</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RecyclerView</strong>가 한 행에 세 개의 격자를 가지며, 각 격자에는 아래의 버튼 레이아웃이 포함된다.</p><blockquote><p>음원 버튼 레이아웃 생성하기 (res/layout/list_item_sound.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;120dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:text</span>=<span class="string">&quot;Sound name&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이렇게 하면 <strong>ListItemSoundBinding</strong> 클래스가 자동 생성된다. 그다음으로 이 클래스 인스턴스를 통해서 list_item_sound.xml과 연결되는 <strong>SoundHolder</strong>를 생성한다.</p><blockquote><p>SoundHolder 생성하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SoundHolder</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> binding: ListItemSoundBinding) : RecyclerView.ViewHolder(binding.root) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 <strong>SoundHolder</strong>에서는 자동 생성된 바인딩 클래스인 ListItemSoundBinding을 사용한다. 그다음으로 이 <strong>SoundHolder</strong>와 연결되는 어댑터를 생성한다.</p><blockquote><p>SoundAdapter 생성하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SoundHolder</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> binding: ListItemSoundBinding) : RecyclerView.ViewHolder(binding.root) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SoundAdapter</span></span>() : RecyclerView.Adapter&lt;SoundHolder&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: SoundHolder &#123;</span><br><span class="line">            <span class="keyword">val</span> binding = DataBindingUtil.inflate&lt;ListItemSoundBinding&gt;(</span><br><span class="line">                layoutInflater,</span><br><span class="line">                R.layout.list_item_sound,</span><br><span class="line">                parent,</span><br><span class="line">                <span class="literal">false</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span> SoundHolder(binding) </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">SoundHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제는 <code>onCreate(...)</code>에서 <strong>SoundAdapter</strong>르 연결하면 된다.</p><blockquote><p>SoundAdapter 연결하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    <span class="keyword">val</span> binding: MainActivityBinding =</span><br><span class="line">        DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.main_activity)</span><br><span class="line">    binding.recyclerView.apply &#123;</span><br><span class="line">        layoutManager = GridLayoutManager(context, <span class="number">3</span>)</span><br><span class="line">        adapter = SoundAdapter() <span class="comment">// SoundAdapter 연결하기</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>드디어 데이터 바인딩을 사용해서 RecyclerView를 설정하였다. 아직은 앱을 실행해도 화면에 아무것도 나오지 않는다.</p><h2 id="에셋-가져오기"><a class="markdownIt-Anchor" href="#에셋-가져오기"></a> 에셋 가져오기</h2><p>다음으로 음원 파일들을 프로젝트에 추가해 런타임 시에 사용할 수 있게 한다. 이 작업은 리소스 시스템을 사용하는 대신 <strong>애셋 <sup>asset</sup></strong> 을 사용하는데, 애셋은 리소스 자체라고 생각하면 된다. 즉, 리소스처럼 APK에 포함되지만 시스템에서 특별한 구성<small>(디렉터리 구조화와 참조 생성 등)</small>을 하지 않은 리소스다.</p><p>애셋은 구성하는 시스템이 없으므로 원하는 대로 애셋의 이름을 지정하거나 폴더 구조로 구성할 수 있다. 그러나 단점도 있다. 참조를 하기 위한 구성이나 관리하는 시스템이 없으므로 장치의 화면 해상도, 언어, 방향 등이 달라지면 자동으로 대응할 수 없으며, 레이아웃 파일이나 다른 리소스에서 자동으로 사용할 수도 없다.</p><p>일반적으로는 리소스를 사용하는 것이 좋다. 그러나 본문의 BeatBox 앱처럼 코드에서 음원 파일들만 사용할 때는 애셋이 유리하다. 대부분의 게임 앱에서는 그래픽과 음원을 애셋으로 사용한다.</p><p>음원 애셋을 추가하기 위해 프로젝트에 아래 이미지와 같이 프로젝트 도구 창의 <strong>app</strong>에서 오른쪽 마우스 버튼을 클릭한 후 <code>New -&gt; Folder -&gt; Assets Folder</code>를 선택한다. 그리고 대화상자에서 'Change Folder Location’을 체크되지 않은 상태로 두고 'Target Source Set’을 <strong>main</strong>으로 선택한다.</p><p align = 'center'><img width = '700' src = 'https://user-images.githubusercontent.com/39554623/120105687-fedaba00-c194-11eb-8580-0aadf366d4de.png'></p><p><strong>Finish</strong> 버튼을 클릭하면 <strong>app</strong> 아래에 <strong>assets</strong> 폴더가 생성된다.</p><p>그다음에 app/assets 폴더에 서브 디렉터리로 'sample_sounds’를 생성한다. 이렇게 하면 <strong>assets</strong> 폴더에 있는 모든 파일이 이 앱과 함께 배포된다. 여기서는 편리하게 사용하려고 서브 폴더를 생성했지만, 리소스와는 달리 서브 폴더가 없어도 된다.</p><p>에셋 폴더의 음원 파일들은 <a href="https://github.com/Jpub/AndroidBNR4/tree/main/Ch19/BeatBox/app/src/main/assets/sample_sounds">이곳</a>에서 다운로드한다.</p><h2 id="에셋-사용하기"><a class="markdownIt-Anchor" href="#에셋-사용하기"></a> 에셋 사용하기</h2><p>BeatBox에서는 애셋 관리와 연관된 많은 일을 하게 된다. 즉, 애셋을 찾아 유지하고 관리하며 음원으로 재생하는 일이다. 이런 일을 하는 새로운 클래스인 <strong>BeatBox</strong>를 생성하고, 두 개의 상수와 로그 메시지에 사용할 태그 값과 애셋이 저장된 폴더 이름을 추가한다.</p><blockquote><p>새로운 BeatBox 클래스 (BeatBox.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;BeatBox&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SOUNDS_FOLDER = <span class="string">&quot;sample_sounds&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatBox</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>애셋은 <strong>AssetManager</strong> 클래스로 사용하며, <strong>AssetManager</strong> 인스턴스는 어떤 <strong>Context</strong>에서도 생성할 수 있다. BeatBox 생성자는 <strong>AssetManager</strong> 인스턴스 참조를 인자로 받는다.</p><blockquote><p>AssetManager 인스턴스 참조 받기 (BeatBox.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;BeatBox&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SOUNDS_FOLDER = <span class="string">&quot;sample_sounds&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatBox</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> assets: AssetManager) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>애셋을 사용할 때 어떤 <strong>Context</strong>를 사용할 것인지 고민할 필요는 없다. 어떤 상황이든 모든 Context의 AssetManager가 에셋과 연결될 수 있기 때문이다.</p><p>에셋에 있는 파일들의 내역을 얻을 때는 <code>list(String)</code> 함수를 사용한다. 그리고 이 함수를 사용해서 에셋의 파일 내역을 찾는 <code>loadSounds()</code> 함수를 추가한다.</p><blockquote><p>에셋 찾기 (BeatBox.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatBox</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> assets: AssetManager) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadSounds</span><span class="params">()</span></span> : List&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> soundNames = assets.list(SOUNDS_FOLDER)!!</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;Found <span class="subst">$&#123;soundNames.size&#125;</span> sounds&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> soundNames.asList()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Could not list assets&quot;</span>, e)</span><br><span class="line">            <span class="keyword">return</span> emptyList()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AssetManager.list(String)</code>에서는 인자로 전달된 폴더 경로에 포함된 파일들의 이름을 반환한다. 따라서 여기서는 sample_sounds 폴더 이름을 전달해 이 폴더에 넣었던 모든 .wav 파일의 이름을 알 수 있다.</p><p>지금까지 추가한 코드가 잘 작동하는지 BeatBox의 인스턴스를 생성하고 <code>loadSounds()</code> 함수를 호출하는 코드를 MainActivity에 추가해 확인한다.</p><blockquote><p>BeatBox 인스턴스 생성하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> beatBox: BeatBox</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        beatBox = BeatBox(assets)</span><br><span class="line">        beatBox.loadSounds()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> binding: MainActivityBinding =</span><br><span class="line">            DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.main_activity)</span><br><span class="line"></span><br><span class="line">        binding.recyclerView.apply &#123;</span><br><span class="line">            layoutManager = GridLayoutManager(context, <span class="number">3</span>)</span><br><span class="line">            adapter = SoundAdapter()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeatBox 앱을 실행하고 LogCat을 확인해보면, 현재 애셋 폴더에 22개의 .wav 파일이 있으므로 아래와 같은 메시지가 보인다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-05-31 01:29:02.299 26730-26730/com.june0122.beatbox D/BeatBox: Found 22 sounds</span><br></pre></td></tr></table></figure><h2 id="애셋-사용-코드-추가하기"><a class="markdownIt-Anchor" href="#애셋-사용-코드-추가하기"></a> 애셋 사용 코드 추가하기</h2><p>애셋 파일들의 이름을 갖게 되었으니, 이 이름들을 각 버튼에 설정해 사용자에게 보여줄 수 있다. 궁극적으로는 음원 파일을 재생하므로, 파일 이름과 사용자가 볼 수 있는 이름 및 해당 음원 관련 정보를 유지하고 관리하는 객체가 필요하다.</p><p>이 모든 것을 갖는 <strong>Sound</strong> 클래스를 아래와 같이 생성한다.</p><blockquote><p>Sound 클래스 생성하기 (Sound.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> WAV = <span class="string">&quot;.wav&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sound</span></span>(<span class="keyword">val</span> assetPath: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name = assetPath.split(<span class="string">&quot;/&quot;</span>).last().removeSuffix(WAV)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sound 클래스의 생성자에서는 화면에 보여줄 음원 파일의 이름을 만드는 일을 한다. 즉, <code>String.split(String).last()</code>를 사용해서 경로 문자열 맨 끝에 있는 파일 이름을 얻고, <code>String.removeSuffix(String)</code>을 사용해서 확장자인 .wav를 제거한다.</p><p>그다음으로 <code>BeatBox.loadSounds()</code> 함수에서 Sound 인스턴스들의 List를 생성한다.</p><blockquote><p>Sound 객체를 저장하는 List 생성하기 (BeatBox.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatBox</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> assets: AssetManager) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sounds: List&lt;Sound&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        sounds = loadSounds()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  fun loadSounds() : List&lt;String&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadSounds</span><span class="params">()</span></span>: List&lt;Sound&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> soundNames: Array&lt;String&gt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            soundNames = assets.list(SOUNDS_FOLDER)!!</span><br><span class="line"><span class="comment">//            val soundNames = assets.list(SOUNDS_FOLDER)!!</span></span><br><span class="line"><span class="comment">//            Log.d(TAG, &quot;Found $&#123;soundNames.size&#125; sounds&quot;)</span></span><br><span class="line"><span class="comment">//            return soundNames.asList()</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Could not list assets&quot;</span>, e)</span><br><span class="line">            <span class="keyword">return</span> emptyList()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> sounds = mutableListOf&lt;Sound&gt;()</span><br><span class="line">        soundNames.forEach &#123; fileName -&gt;</span><br><span class="line">            <span class="keyword">val</span> assetPath = <span class="string">&quot;<span class="variable">$SOUNDS_FOLDER</span>/<span class="variable">$fileName</span>&quot;</span></span><br><span class="line">            <span class="keyword">val</span> sound = Sound(assetPath)</span><br><span class="line">            sounds.add(sound)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sounds</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음으로 SoundAdapter를 Sound 인스턴스가 저장된 List에 연결한다. 우선 <code>getItemCount()</code> 함수에서 sounds.size를 반환하게 변경한다<small>(sounds.size는 sounds List에 저장된 음원 파일의 개수를 나타냄)</small>.</p><blockquote><p>음원 파일의 개수 알아내기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SoundAdapter</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> sounds: List&lt;Sound&gt;) : RecyclerView.Adapter&lt;SoundHolder&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: SoundHolder &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">SoundHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = sounds.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그다음에 <code>onCreate(...)</code>에서 BeatBox의 Sound 인스턴스 List를 어댑터 인자로 전달한다.</p><blockquote><p>Sound 인스턴스를 저장한 List를 어댑터에 전달하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    binding.recyclerView.apply &#123;</span><br><span class="line">        layoutManager = GridLayoutManager(context, <span class="number">3</span>)</span><br><span class="line">        adapter = SoundAdapter(beatBox.sounds)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마지막으로 <code>onCreate(...)</code>에서 <code>loadSounds()</code> 함수 호출 코드를 삭제한다.</p><blockquote><p><code>loadSounds()</code> 함수 호출 코드 삭제하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    beatBox = BeatBox(assets)</span><br><span class="line"><span class="comment">//  beatBox.loadSounds()</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제는 BeatBox의 init 블록 외부에서 <code>BeatBox.loadSounds()</code> 함수가 더 이상 호출되지 않는다. 따라서 이 함수의 가시성 <sup>visibility</sup>을 public으로 지정할 필요가 없으므로 private로 변경한다.</p><blockquote><p><code>BeatBox.loadSounds()</code>의 가시성을 private로 변경 (BeatBox.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatBox</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> assets: AssetManager) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadSounds</span><span class="params">()</span></span>: List&lt;Sound&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>앱을 실행해보면 격자 형태로 나타난 버튼들을 볼 수 있다.</p><blockquote><p>비어 있는 버튼들</p></blockquote><p align = 'center'><img width = '200' src = 'https://user-images.githubusercontent.com/39554623/120112870-b8945380-c1b2-11eb-989d-21247299a776.png'></p><p>이제 각 버튼에 음원 이름을 보여주기 위해 데이터 바인딩을 사용해보자.</p><h2 id="데이터-바인딩하기"><a class="markdownIt-Anchor" href="#데이터-바인딩하기"></a> 데이터 바인딩하기</h2><p>데이터 바인딩을 사용할 때는 레이아웃 파일에 데이터를 가진 객체를 선언할 수 있다. 앞의 <a href="https://github.com/june0122/criminal-intent-android/blob/master/app/src/main/java/com/june0122/criminalintent/Crime.kt">다른 프로젝트</a>에서 알아보았던 범죄 객체 <sup>Crime</sup>를 예로 들면 다음과 같다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;crime&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.june0122.criminalintent.Crime&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이렇게 하면 다음과 같이 레이아웃 파일에서 해당 데이터 객체의 값을 <strong>바인딩 연산자 <sup>binding mustache</sup></strong> 인 <code>@&#123;&#125;</code>를 사용해서 바로 참조할 수 있다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CheckBox</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/list_item_crime_solved_check_box&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignParentRight</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:checked</span>=<span class="string">&quot;@&#123;crime.isSolved()&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;4dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>데이터 바인딩을 객체 다이어그램으로 나타내면 다음과 같다.</p><blockquote><p>레이아웃과 코틀린 객체 간의 데이터 바인딩</p></blockquote><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/120102816-cd0f2680-c187-11eb-8972-05d2bc44b5a4.jpeg'></p><p>여기서는 음원 이름을 각 버튼에 넣는다. 이때 데이터 바인딩을 사용해서 list_item_sound.xml 레이아웃 파일에 <strong>Sound</strong> 객체를 직접 바인딩한다.</p><blockquote><p>list_item_sound.xml 레이아웃과 Sound 객체의 바인딩</p></blockquote><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/120102815-cc769000-c187-11eb-92d7-f95c06a2a3a1.jpeg'></p><p>그런데 이렇게 하면 아키텍처 관점에서 문제가 생긴다. 아래의 MVC 모델을 보자.</p><blockquote><p>문제가 있는 MVC 아키텍처</p></blockquote><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/120102813-cb456300-c187-11eb-9202-5ffebb94e732.jpeg'></p><p>대부분의 아키텍처에서 하나의 클래스는 <strong>한 가지 책임 <sup>SRP, single responsibility principle</sup></strong> 만을 가지게 하는 것이 기본 원리다. MVC도 그렇다. 즉, 모델은 앱이 작동하는 방법을 나타내며, 컨트롤러는 모델과 뷰를 중재하면서 앱의 데이터를 보여주는 방법을 결정하고, 뷰는 화면에 데이터를 보여준다.</p><p>위와 같이 데이터 바인딩을 사용하면 각 아키턱처 요소의 역할 분담이 분명하게 이루어지지 않는다. 보여줄 뷰의 데이터를 준비하는 코드를 <strong>Sound</strong> 모델 객체가 갖게 되어 컨트롤러 역할을 하기 때문이다. 따라서 Sound.kt에는 앱이 작동하는 방법을 나타내는 코드와 보여줄 뷰의 데이터를 준비하는 코드가 뒤섞이게 된다.</p><p>그러므로 데이터 바인딩을 제대로 사용하려면 뷰모델이라는 새로운 객체가 필요하다. 그리고 이 객체는 보여줄 뷰의 데이터를 준비하는 방법을 결정하는 책임을 갖는다.</p><blockquote><p>모델-뷰-뷰모델</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/120102810-c97b9f80-c187-11eb-82dd-896e37523c78.jpeg'></p><p>이런 아키텍처를 <strong>MVVM</strong>이라고 하며, 보여줄 데이터를 형식화하기 위해 MVC의 컨트롤러 클래스가 런타임 시에 했던 대부분의 일을 뷰모델이 담당한다. 즉, 레이아웃에서 위젯들을 데이터와 바인딩하던 일을 뷰모델이 하게 된다. 그리고 컨트롤러<small>(액티비티나 프래그먼트)</small>는 데이터 바인딩과 뷰모델을 초기화하고 연결하는 일을 맞게 된다.</p><h3 id="뷰모델-생성하기"><a class="markdownIt-Anchor" href="#뷰모델-생성하기"></a> 뷰모델 생성하기</h3><p>뷰모델인 <strong>SoundViewModel</strong> 클래스를 생성하고, 사용할 Sound 객체 참조를 갖는 sound 속성을 추가한다.</p><blockquote><p>SoundViewModel 생성하기 (SoundViewModel.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModel</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> sound: Sound? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">set</span>(sound) &#123;</span><br><span class="line">            field = sound</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 각 버튼에 보여줄 제목을 갖는 title 속성도 추가한다.</p><blockquote><p>버튼 제목을 갖는 속성 추가하기 (SoundViewModel.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sound: Sound? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">set</span>(sound) &#123;</span><br><span class="line">            field = sound</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> title: String?</span><br><span class="line">        <span class="keyword">get</span>() = sound?.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="뷰모델에-바인딩하기"><a class="markdownIt-Anchor" href="#뷰모델에-바인딩하기"></a> 뷰모델에 바인딩하기</h3><p>다음으로 뷰모델을 레이아웃 파일과 연결한다. 우선 레이아웃 파일에 속성을 선언한다.</p><blockquote><p>뷰모델을 바인딩하는 속성 선언하기 (res/layout/list_item_sound.xml)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;layout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;<span class="keyword">data</span>&gt;</span><br><span class="line">        &lt;variable</span><br><span class="line">            name=<span class="string">&quot;viewModel&quot;</span></span><br><span class="line">            type=<span class="string">&quot;com.june0122.beatbox.SoundViewModel&quot;</span> /&gt;</span><br><span class="line">    &lt;/<span class="keyword">data</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;120dp&quot;</span></span><br><span class="line">        android:layout_marginStart=<span class="string">&quot;5dp&quot;</span></span><br><span class="line">        android:layout_marginEnd=<span class="string">&quot;5dp&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;@&#123;viewModel.title&#125;&quot;</span></span><br><span class="line">        tools:text=<span class="string">&quot;Sound name&quot;</span> /&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure><p>바인딩 연산자인 <code>@&#123;&#125;</code> 내부에서는 간단한 코틀린 표현식을 사용할 수 있다. 예를 들어, 함수 연쇄 호출이나 수식 등이다.</p><p>RecyclerView의 각 항목<small>(여기서는 버튼)</small> 데이터를 갖는 SoundHolder에 다음 코드를 추가한다. 우선 SoundViewModel 인스턴스를 생성하고 이것의 참조를 바인딩 클래스인 ListItemSoundBinding의 viewModel 속성에 설정한다. 그리고 바인딩 함수인 <code>bind(...)</code>를 추가한다.</p><blockquote><p>뷰모델과 바인딩하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SoundHolder</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> binding: ListItemSoundBinding) : RecyclerView.ViewHolder(binding.root) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        binding.viewModel = SoundViewModel()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(sound: <span class="type">Sound</span>)</span></span> &#123;</span><br><span class="line">        binding.apply &#123; </span><br><span class="line">            viewModel?.sound = sound</span><br><span class="line">            executePendingBindings()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 init 초기화 블록에서 뷰모델 인스턴스를 생성하고 바인딩 클래스의 ViewModel 속성을 초기화한다. 그리고 바인딩 함수인 <code>bind(Sound)</code>에서는 viewModel 속성을 변경한다.</p><p>보통은 <code>executePendingBindings()</code>를 호출할 필요 없다. 그러나 이 앱에서는 RecyclerView에 포함된 바인딩 데이터를 변경해야 하며, RecyclerView는 빠른 속도로 뷰를 변경해야 한다. 따라서 RecyclerView에 포함된 레이아웃을 즉각 변경하도록 <code>executePendingBindings()</code>를 호출한 것이다. 이렇게 함으로써 RecyclerView와 RecyclerView.Adapter가 즉시 동기화되어 화면에서 RecyclerView를 스크롤할 때 훨씬 매끄럽게 보인다.</p><p>마지막으로 <code>onBindViewHolder(...)</code>에서 <code>bind(Sound)</code> 함수를 호출하여 뷰모델의 각 Sound 인스턴스를 SoundHolder 인스턴스와 연결한다.</p><blockquote><p><code>bind(Sound)</code> 함수 호출하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SoundAdapter</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> sounds: List&lt;Sound&gt;) : RecyclerView.Adapter&lt;SoundHolder&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: SoundHolder &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">SoundHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> sound = sounds[position]</span><br><span class="line">        holder.bind(sound)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = sounds.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>앱을 다시 실행하면 이제는 모든 버튼의 제목이 나타난다.</p><blockquote><p>제목이 있는 버튼들</p></blockquote><p align = 'center'><img width = '200' src = 'https://user-images.githubusercontent.com/39554623/120133878-e3f55d80-c207-11eb-9b69-9984ee03110e.png'></p><h3 id="관찰-가능한-데이터"><a class="markdownIt-Anchor" href="#관찰-가능한-데이터"></a> 관찰 가능한 데이터</h3><p>이제는 모든 게 잘되는 것처럼 보인다. 그러나 이 코드에는 문제가 있다. 앱을 실행하여 가로 방향으로 회전해서 스크롤해보자.</p><blockquote><p>이전에 본 데이터가 또다시 나타난다</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/120134432-09369b80-c209-11eb-8d8d-0f440061238e.gif'></p><p>위에서 '65_CJIPIE’가 보였었는데 아래로 스크롤하니 또다시 '65_CJIPIE’가 보인다. 위아래로 스크롤을 해보면 계속해서 다른 음원 파일의 제목이 보일 것이다.</p><p>왜 이런 것일까? 이는 레이아웃이 <code>SoundHolder.bind(sound)</code> 함수 내부에서 SoundViewModel의 Sound 객체를 변경했음을 알 수 있는 방법이 없기 때문이다. MVVM 아키텍처에서는 바로 이 방법을 찾는 것이 중요하다.</p><p>따라서 바인딩 데이터가 변경되면 뷰모델이 레이아웃 파일과 소통하게 만드는 것이 다음으로 할 일이다. 이렇게 하려면 뷰모델에서 데이터 바인딩의 <strong>Observable</strong> 인터페이스를 구현해야 한다. 이 인터페이스를 사용하면 바인딩 클래스가 뷰모델에 리스너를 설정할 수 있다. 따라서 바인딩 데이터가 변경되면 자동으로 콜백 호출을 받을 수 있다.</p><p>그런데 <strong>Observable</strong> 인터페이스의 모든 함수를 구현할 필요는 없으므로 여기서는 데이터 바인딩의 <strong>BaseObservable</strong> 클래스를 사용하여 다음과 같이 구현한다<small>(이 클래스는 기본적으로 Observable 클래스를 구현하고 있다.)</small>.</p><ol><li>뷰모델인 <strong>SoundViewModel</strong>을 <strong>BaseObservable</strong>의 서브 클래스로 선언한다.</li><li><strong>SoundViewModel</strong>의 바인딩되는 속성에 <code>@Bindable</code> 애노테이션을 지정한다.</li><li>바인딩되는 속성의 값이 변경될 때마다 <code>notifyChange()</code> 또는 <code>notifyPropertyChanged(Int)</code>를 호출한다.</li></ol><p>여기서는 SoundViewModel에 약간의 코드만 추가하면 된다. SoundViewModel이 관찰 가능하게<small>(observable)</small> 변경한다.</p><blockquote><p>뷰모델이 관찰 가능하게 만들기 (SoundViewModel.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.databinding.BaseObservable</span><br><span class="line"><span class="keyword">import</span> androidx.databinding.Bindable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModel</span> : <span class="type">BaseObservable</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sound: Sound? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">set</span>(sound) &#123;</span><br><span class="line">            field = sound</span><br><span class="line">            notifyChange()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Bindable</span></span><br><span class="line">    <span class="keyword">val</span> title: String?</span><br><span class="line">        <span class="keyword">get</span>() = sound?.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>notifyChange()</code>를 호출하면 데이터 객체<small>(여기서는 Sound)</small>의 모든 바인딩 속성값이 변경되었음을 바인딩 클래스<small>(여기서는 ListItemSoundBinding)</small>에 알린다. 따라서 sound 속성의 값<small>(Sound 인스턴스 참조)</small>이 설정되면 list_item_sound.xml의 바인딩 클래스인 ListItemSoundBinding이 알림을 받게 되어 list_item_sound.xml의 버튼 제목이 변경된다<small>(<code>Button.setText(String)</code>이 호출됨)</small>.</p><p>앞에서 얘기했던 또 다른 함수인 <code>notifyPropertyChanged(Int)</code>도 <code>notifyChange()</code>와 같은 기능을 수행한다. 그러나 모든 바인딩 속성이 아닌 특정 바인딩 속성의 값이 변경되었음을 알려준다는 점이 다르다. 예를 들어, <code>notifyPropertyChanged(BR.title)</code>의 경우는 <code>title 속성값만 변경되었음</code>을 나타낸다.</p><p>여기서 <strong>BR.title</strong>은 데이터 바인딩 라이브러리가 생성한 상수다. 클래스 이름인 <strong>BR</strong>은 'binding resource’의 단축어다. <strong>BR</strong> 상수는 <code>@Bindable</code> 애노테이션이 지정된 각 속성에 대해 해당 속성과 같은 이름으로 생성된다.</p><blockquote><p>BR 상수 예시</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get:Bindable</span> <span class="keyword">val</span> title: String    <span class="comment">// BR.title 상수가 생성됨</span></span><br><span class="line"><span class="meta">@get:Bindable</span> <span class="keyword">val</span> volumn: <span class="built_in">Int</span>      <span class="comment">// BR.volumn 상수가 생성됨</span></span><br><span class="line"><span class="meta">@get:Bindable</span> <span class="keyword">val</span> etcetera: String <span class="comment">// BR.etcetera 상수가 생성됨</span></span><br></pre></td></tr></table></figure><p><strong>Observable</strong> 인터페이스를 사용하는 것이 <a href="https://june0122.github.io/2021/05/24/android-bnr-11/">데이터베이스와 Room 라이브러리</a>에서 기술한 <strong>LiveData</strong>를 사용하는 것과 유사하다고 생각할 수 있다. 실제로 <strong>Observable</strong> 인터페이스 대신 <strong>LiveData</strong>를 데이터 바인딩에 사용할 수 있다. 이 내용은 <a id = "a1"><a href="#f1">궁금증 해소 : LiveData와 데이터 바인딩</a></a>에서 설명한다.</p><p>앱을 다시 실행해보면 이번에는 가로나 세로, 어느 방향에서 스크롤해도 정상적으로 작동한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/120136860-12763700-c20e-11eb-84b8-1b49d5e5b015.gif'></p><h2 id="궁금증-해소-️-데이터-바인딩-추가로-알아보기"><a class="markdownIt-Anchor" href="#궁금증-해소-️-데이터-바인딩-추가로-알아보기"></a> 궁금증 해소 💁🏻‍♂️ : 데이터 바인딩 추가로 알아보기</h2><h3 id="람다식"><a class="markdownIt-Anchor" href="#람다식"></a> 람다식</h3><p>레이아웃 파일에 지정한 바인딩 연산자인 <code>@&#123;&#125;</code> 내부에는 간단한 코틀린 표현식은 물론이고 **람다식 <sup>lambda expression</sup>**도 사용할 수 있다. 예를 들면 다음과 같다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;120dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@&#123;viewModel.title&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;(view) -&gt; viewModel.onButtonClick()&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:text</span>=<span class="string">&quot;Sound name&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>자바 8의 람다식처럼 이것은 리스너 인터페이스의 구현 코드로 변환한다. 단, 여기처럼 정확한 문법을 사용해야 한다. 즉, 매개변수는 반드시 괄호로 둘러싸야 하고 <code>-&gt;</code> 오른쪽에는 하나의 표현식만 포함할 수 있다.</p><p>또한, 자바의 람다식과는 다르게 람다식 매개변수를 생략할 수도 있다. 따라서 다음과 같이 해도 된다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick=&quot;@&#123;() -&gt; viewModel.onButtonClick()&#125;&quot;</span><br></pre></td></tr></table></figure><h3 id="더-편리한-문법"><a class="markdownIt-Anchor" href="#더-편리한-문법"></a> 더 편리한 문법</h3><p>데이터 바인딩에는 큰따옴표 안에 백틱 <code>`</code> 기호도 사용할 수 있다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;`File name: ` + viewModel.title&#125;&quot;</span><br></pre></td></tr></table></figure><p>여기서 <code>`File name`</code>은 **“File name”**과 같은 의미다. 또한, 데이터 바인딩 표현식에는 null 처리 연산자를 넣을 수 있다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;`File name: ` + viewModel.title ?? `No file`&#125;&quot;</span><br></pre></td></tr></table></figure><p>여기서 title 값이 null이면 <code>??</code> 연산자가 null 대신 'No file’을 결괏값으로 산출한다.</p><p>또한, 데이터 바인딩 표현식에는 null 값을 자동으로 처리한다. 심지어는 앞의 코드에서 viewModel이 null일지라도 앱이 중단되지 않게 데이터 바인딩에서 null 값 여부를 검사하고 조치한다. 따라서 viewModel이 null일 때는 viewModel.title의 결과를 &quot;null&quot;로 반환한다.</p><h3 id="bindingadapter"><a class="markdownIt-Anchor" href="#bindingadapter"></a> BindingAdapter</h3><p>기본적으로 데이터 바인딩에서는 바인딩 표현식을 레이아웃 속성의 게터/세터 호출로 변환한다. 예를 들어, 다음 표현식은 text 속성의 세터인 <code>setText(String)</code> 함수 호출로 변환되어 처리된다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;`File name: ` + viewModel.title ?? `No file`&#125;&quot;</span><br></pre></td></tr></table></figure><p>그러나 이 정도로는 충분치 않고 특정 속성에 나름의 추가 처리가 필요할 때가 있다. 이때는 다음과 같이 <strong>BindingAdapter</strong>를 사용한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">&quot;app:soundName&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bindAssetSound</span><span class="params">(button: <span class="type">Button</span>, assetFileName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>즉, 프로젝트의 어디서든 파일 수준 함수를 생성하고 <code>@BindingAdapter</code> 애노테이션을 지정하면 된다. 그리고 바인딩할 속성 이름을 <code>@BindingAdapter</code> 애노테이션의 인자로 전달한다<small>(여기서는 app:soundName)</small>. 그다음에 <code>@BindingAdapter</code> 애노테이션이 적용되는 <strong>View</strong>를 해당 함수의 첫 번째 인자로 전달한다.</p><p>앞의 예에서는 app:soundName 속성을 갖는 <strong>Button</strong>을 데이터 바인딩이 접할 때마다 <code>bindAssetSound(...)</code> 함수를 호출한다. 이때 해당 <strong>Button</strong>과 <strong>바인딩 표현식 <sup>binding expression</sup></strong> 의 결과가 인자로 전달된다<small>(여기서는 나타나지 않았지만, 바인딩 표현식은 app:soundName 속성에 지정되어 있다.)</small>.</p><p><strong>View</strong>나 <strong>ViewGroup</strong> 같은 더 일반화된 뷰의 <strong>BindingAdapter</strong>도 생성할 수 있다. 이때 <strong>BindingAdapter</strong>가 해당 <strong>View</strong>와 이것의 모든 서브 클래스에 적용된다.</p><p>예를 들어, Boolean 값을 기준으로 View<small>(와 이것의 모든 서브 클래스 뷰)</small>의 가시성을 설정하는 app:isGone 속성을 정의할 때는 다음과 같이 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="meta-string">&quot;app:isGone&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bindIsGone</span><span class="params">(view: <span class="type">View</span>, isGone: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    view.visibility = <span class="keyword">if</span> (isGone) View.GONE <span class="keyword">else</span> View.VISIBLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 View가 <code>bindIsGone(...)</code>의 첫 번째 인자이므로 isGone 속성은 app 모듈의 View와 이것의 모든 서브 클래스 View에 대해 사용할 수 있다. 예를 들면 Button, TextView, LinearLayout 등에서 사용 가능하다.</p><p>안드로이드 표준 라이브러리의 위젯에는 이미 바인딩 어댑터가 정의되어 있다. 예를 들어, TextView에는 TextViewBindingAdapter가 정의되어 있어서 TextView의 속성들에 데이터 바인딩을 할 수 있다<small>(TextViewBindingAdapter는 androidx.databinding.adapters 패키지에 있다)</small>.</p><h2 id="b-id-f1궁금증-해소-️-livedata와-데이터-바인딩b"><a class="markdownIt-Anchor" href="#b-id-f1궁금증-해소-️-livedata와-데이터-바인딩b"></a> <b id = "f1">궁금증 해소 💁🏻‍♂️ : LiveData와 데이터 바인딩</b>  <a href="#a1"> ↩</a></h2><p><strong>LiveData</strong>와 데이터 바인딩은 데이터가 변경되는지 관찰하면서 변경될 때 반응하는 방법을 제공한다는 면에서 서로 유사하다. 실제로 <strong>LiveData</strong>와 데이터 바인딩을 같이 사용할 수 있다. 다음 코드에서는 <strong>Observable</strong> 대신 <strong>LiveData</strong>를 사용해서 title 속성을 SoundViewModel에 바인딩했다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class SoundViewModel : BaseObservable() &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> title: MutableLiveData&lt;String?&gt; = MutableLiveData()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> sound: Sound? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">set</span>(sound) &#123;</span><br><span class="line">            field = sound</span><br><span class="line"><span class="comment">//            notifyChange()</span></span><br><span class="line">            title.postValue(sound?.name)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @get:Bindable</span></span><br><span class="line"><span class="comment">//    val title: String?</span></span><br><span class="line"><span class="comment">//        get() = sound?.name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이때는 SoundViewModel이 BaseObservable의 서브 클래스가 되지 않아도 되며, <code>@Bindable</code> 애노테이션도 지정하지 않아도 된다. LiveData는 자신의 알림 매커니즘을 갖고 있기 때문이다. 그러나 <a href="https://june0122.github.io/2021/05/24/android-bnr-11/">데이터베이스와 Room 라이브러리</a>에서 설명한듯이 LiveData는 LifeCycleOwner가 필요하므로 여기서는 title 속성을 관찰할 때 사용할 LifeCycleOwner를 데이터 바인딩 프레임워크에 알려주어야 한다. 따라서 바인딩 객체가 생성된 후 lifeCycleOwner 속성을 설정하기 위해 SoundAdapter를 변경해야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SoundAdapter</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> sounds: List&lt;Sound&gt;) : RecyclerView.Adapter&lt;SoundHolder&gt;() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: SoundHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> binding = DataBindingUtil.inflate&lt;ListItemSoundBinding&gt;(</span><br><span class="line">            layoutInflater,</span><br><span class="line">            R.layout.list_item_sound,</span><br><span class="line">            parent,</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        binding.lifecycleOwner = <span class="keyword">this</span><span class="symbol">@MainActivity</span> <span class="comment">// lifeCycleOwner 속성 설정</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> SoundHolder(binding)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 MainActivity를 LifeCycleOwner로 설정한다. 따라서 속성 이름인 title만 바뀌지 않는다면 뷰를 변경할 필요가 없다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Data-Binding/">Data Binding</category>
      
      <category domain="http://june0122.github.io/tags/MVVM/">MVVM</category>
      
      
      <comments>http://june0122.github.io/2021/06/01/android-bnr-19/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] 암시적 인텐트를 이용한 촬영 및 저장</title>
      <link>http://june0122.github.io/2021/05/31/android-bnr-16/</link>
      <guid>http://june0122.github.io/2021/05/31/android-bnr-16/</guid>
      <pubDate>Sun, 30 May 2021 17:07:40 GMT</pubDate>
      
      <description>&lt;b&gt;암시적 인텐트&lt;/b&gt;를 사용해 사용자의 카메라 앱을 실행시켜서 사진을 찍고, 데이터에 추가로 저장하고 사용해보도록 한다. 사진을 어디에 저장하고 저장된 사진을 어떻게 보여주어야 할지도 본문에서 알아보도록 한다. 이를 위해 Context 클래스의 파일과 디렉터리 함수, File Provider, Bitmap 등의 개념도 함께 알아본다.</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://june0122.github.io/2021/05/30/android-bnr-15/">암시적 인텐트</a>를 사용해 사용자의 카메라 앱을 실행시켜서 사진을 찍고, 데이터에 추가로 저장하고 사용해보도록 한다. 사진을 어디에 저장하고 저장된 사진을 어떻게 보여주어야 할지도 본문에서 알아보도록 한다.</p><h2 id="사진을-위한-장소"><a class="markdownIt-Anchor" href="#사진을-위한-장소"></a> 사진을 위한 장소</h2><p>먼저 상세 내역 화면에 사진을 보여줄 곳을 만든다.</p><blockquote><p>새로운 사용자 인터페이스</p></blockquote><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/120074276-0e93c900-c0d7-11eb-8769-7e40c845693d.png'></p><h2 id="파일-스토리지"><a class="markdownIt-Anchor" href="#파일-스토리지"></a> 파일 스토리지</h2><p>사진 파일은 화면이 아닌 다른 곳에 저장해야 한다. 그런데 실제 크기의 사진은 용량이 너무 커서 SQLite 데이터베이스에 넣기도 어렵다. 따라서 장치의 파일 시스템에 저장해야 한다.</p><p>다행스럽게도 이런 파일은 장치의 개인 스토리지 영역에 저장할 수 있다. SQLite 데이터베이스도 마찬가지다. <code>Context.getFileStreamPath(String)</code>이나 <code>Context.getFilesDir()</code> 같은 함수를 사용하면 일반 파일도 개인 스토리지 영역에 저장할 수 있다<small>(SQLite 데이터베이스가 저장된 databases 서브 폴더와 인접한 다른 서브 폴더에 저장된다)</small>.</p><p><strong>Context</strong> 클래스에 있는 기본적인 파일과 디렉터리 함수는 다음과 같다.</p><p><code>getFilesDir(): File</code></p><ul><li>앱 전용 파일들의 디렉터리 핸들을 반환한다.</li></ul><p><code>openFileInput(name: String): FileInputStream</code></p><ul><li>데이터를 읽기 위해 파일 디렉터리의 기존 파일을 연다.</li></ul><p><code>openFileOutput(name: String, mode: Int): FileOutputStream</code></p><ul><li>데이터를 쓰기 위해 파일 디렉터리의 파일을 연다(생성도 한다).</li></ul><p><code>getDir(name: String, mode: Int): File</code></p><ul><li>파일 디렉터리 내부의 서브 디렉터리를 알아낸다.</li></ul><p><code>fileList(...): Array&lt;String&gt;</code></p><ul><li>파일 디렉터리의 파일 이름들을 알아낸다. 예를 들면, <code>openFileInput(String)</code>과 함께 사용한다.</li></ul><p><code>getCacheDir(): File</code></p><ul><li>캐시 파일 저장에 사용할 수 있는 디렉터리의 핸들을 반환한다. 단, 이 디렉터리는 가능한 한 작은 용량을 사용하도록 주의해야 한다.</li></ul><p>그런데 문제가 있다. 개인 스토리지 영역의 파일들은 <strong>이 앱에서만</strong> 읽거나 쓸 수 있기 때문이다. 물론, 다른 앱에서 해당 파일들을 사용하지 않는다면 앞의 함수들만 사용해도 충분하다.</p><p>그러나 다른 애플리케이션이 파일에 써야 한다면 앞의 함수들로는 충분하지 않다. 본문의 CriminalIntent 앱의 경우가 바로 그렇다. 왜냐하면 외부의 카메라 앱에서 개인 스토리지 영역의 파일로 사진을 저장해야 하기 때문이다.</p><p>이때 Context.MODE_WORLD_READABLE 플래그를 <code>openFileOutput(String, Int)</code> 함수에 전달해서 쓸 수 있지만, 이제는 사용 금지되어 있어서 새로운 안드로이드 버전의 장치에서도 잘 된다는 보장이 없다. 그리고 이전에는 공용의 외부 스토리지를 사용해서 파일을 전송할 수 있었지만, 보안상의 이유로 최근 버전의 안드로이드에서는 금지되었다.</p><p>따라서 다른 앱과 파일을 공유하거나 받으려면 <strong>ContentProvider</strong>를 통해서 해야 한다. <strong>ContentProvider</strong>로 파일을 콘텐츠 URI로 다른 앱에 노출하면 다른 앱에서는 해당 URI로부터 파일을 다운로드하거나 쓸 수 있다. 그리고 제어할 수도 있으며, 읽거나 쓰는 것을 거부할 수 있다.</p><h3 id="fileprovider-사용하기"><a class="markdownIt-Anchor" href="#fileprovider-사용하기"></a> FileProvider 사용하기</h3><p>다른 앱으로부터 파일을 받는 것이 전부라면 굳이 <strong>ContentProvider</strong> 전체를 구현할 필요 없다. 이런 용도로 사용하라고 구글에서는 <strong>FileProvider</strong>라는 편의 클래스를 제공한다.</p><p>ContentProvider로 FileProvider를 선언하기 위해 매니페스트 파일에 콘텐츠 제공자 선언을 추가한다.</p><blockquote><p>FileProvider 선언 추가하기 (manifests/AndroidManifest.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;androidx.core.content.FileProvider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">&quot;com.june0122.criminalintent.fileprovider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>여기서 android:authorities 속성은 이 FileProvider의 파일이 저장되는 위치이며, 시스템 전체에서 고유한 문자열이어야 한다. 따라서 패키지 이름을 문자열에 포함하는 것이 좋다<small>(여기선 com.june0122.criminalintent가 패키지 이름)</small>.</p><p>그리고 exported=“false” 속성을 추가하면 우리 자신 및 우리가 권한을 부여한 사람 외에는 FileProvider를 사용할 수 없다. 그리고 grantUriPermissions 속성을 추가하면 인텐트로 android:authorities의 URI를 전송할 때 전송된 URI에 다른 앱이 쓸 수 있는 권한을 부여할 수 있다.</p><p>안드로이드 시스템에 FileProvider가 어디에 있는지 알려주었으니, 어떤 경로 <sup>path</sup>의 파일들을 노출할 것인지도 별도의 XML 리소스 파일에 정의해서 FileProvider에게 알려준다. app/res 폴더에서 'files’라는 이름의 XML Resource type의 Android Resource File을 생성하고 아래와 같이 코드를 변경한다.</p><blockquote><p>경로 추가하기 (res/xml/files.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span></span><br><span class="line"><span class="comment">&lt;/PreferenceScreen&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">&quot;crime_photos&quot;</span> <span class="attr">path</span>=<span class="string">&quot;.&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이 XML 파일은 개인 스토리지의 루트 경로를 crime_photos로 매핑하며, 이 이름은 FileProvider가 내부적으로 사용한다.</p><p>다음으로 매니페스트 파일에 meta-data 태그를 추가해 FileProvider에 files.xml을 연결한다.</p><blockquote><p>경로를 FileProvider에 연결하기 (manifests/AndroidManifest.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;androidx.core.content.FileProvider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">&quot;com.june0122.criminalintent.fileprovider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resource</span>=<span class="string">&quot;@xml/files&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="사진-위치-지정하기"><a class="markdownIt-Anchor" href="#사진-위치-지정하기"></a> 사진 위치 지정하기</h3><p>다음으로 사진을 개인 스토리지에 저장할 위치를 지정한다. 먼저 파일 이름을 얻는 연산 속성 <sup>computed property</sup>을 Crime 클래스에 추가한다<small>(코틀린에서 연산 속성은 다른 속성의 값으로 자신의 값을 산출하므로 값을 저장하는 필드 즉, backing field를 갖지 않는다)</small>.</p><blockquote><p>파일 이름 속성 추가하기 (Crime.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Crime</span></span>(<span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: UUID = UUID.randomUUID(),</span><br><span class="line">                 <span class="keyword">var</span> title: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">                 <span class="keyword">var</span> date: Date = Date(),</span><br><span class="line">                 <span class="keyword">var</span> isSolved: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">                 <span class="keyword">var</span> suspect: String = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> photoFileName</span><br><span class="line">        <span class="keyword">get</span>() = <span class="string">&quot;IMG_<span class="variable">$id</span>.jpg&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>photoFileName은 사진 파일이 저장되는 폴더의 경로를 포함하지 않지만, 파일 이름은 고유한 것이 된다. 이는 Crime 클래스의 id 속성 값이 이름 속에 포함되어 있기 때문이다.</p><p>다음으로 사진이 저장되는 위치를 찾는다. 본문의 앱에서는 CrimeRepository가 데이터 저장에 관련된 모든 것을 책임지고 있으므로 CrimeRepository에 <code>getPhotoFile(Crime)</code> 함수를 추가한다. 이 함수는 Crime 클래스의 photoFileName 속성이 참조하는 사진 파일의 경로를 제공한다.</p><blockquote><p>사진 파일 위치 찾기 (CrimeRepository.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeRepository</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(context: Context) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> executor = Executors.newSingleThreadExecutor()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> filesDir = context.applicationContext.filesDir</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addCrime</span><span class="params">(crime: <span class="type">Crime</span>)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPhotoFile</span><span class="params">(crime: <span class="type">Crime</span>)</span></span>: File = File(filesDir, crime.photoFileName)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드에서는 파일 시스템의 어떤 파일도 생성하지 않는다. 단지 올바른 위치를 가리키는 File 객체만 반환한다. 향후에 FileProvider를 사용해서 이 경로를 URI로 노출할 것이다.</p><p>끝으로 사진 파일 정보를 CrimeFragment에 제공하는 함수를 CrimeDetailViewModel에 추가한다.</p><blockquote><p>CrimeDetailViewModel을 통해 사진 파일 정보 제공하기 (CrimeDetailViewModel.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeDetailViewModel</span>: <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">saveCrime</span><span class="params">(crime: <span class="type">Crime</span>)</span></span> &#123;</span><br><span class="line">        crimeRepository.updateCrime(crime)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 사진 파일 정보를 CrimeFragment에 제공하는 함수 추가</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPhotoFile</span><span class="params">(crime: <span class="type">Crime</span>)</span></span>: File &#123;</span><br><span class="line">        <span class="keyword">return</span> crimeRepository.getPhotoFile(crime)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="카메라-인텐트-사용하기"><a class="markdownIt-Anchor" href="#카메라-인텐트-사용하기"></a> 카메라 인텐트 사용하기</h2><p>다음으로 할 일은 실제로 사진을 찍을 수 있게 하는 작업이다. 암시적 인텐트를 사용하면 되므로 매운 쉬운 작업이다.</p><p>먼저, 사진 파일의 위치를 CrimeFragment의 photoFile 속성에 저장한다. 이 속성은 이후에도 몇 번 더 사용한다.</p><blockquote><p>사진 파일 위치 저장하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crime: Crime</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> photoFile: File</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        crimeDetailViewModel.crimeLiveData.observe(</span><br><span class="line">            viewLifecycleOwner,</span><br><span class="line">            Observer &#123; crime -&gt;</span><br><span class="line">                crime?.let &#123;</span><br><span class="line">                    <span class="keyword">this</span>.crime = crime</span><br><span class="line">                    photoFile = crimeDetailViewModel.getPhotoFile(crime) <span class="comment">// 사진 파일 위치 저장</span></span><br><span class="line">                    updateUI()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음으로 사진을 찍고 받을 수 있게 MeidaStore를 사용해 카메라 버튼을 코드와 연결한다. <strong>MeidaStore</strong>는 미디어와 관련된 모든 것을 갖고 있는 안드로이드 클래스다.</p><h3 id="인텐트-실행-요청하기"><a class="markdownIt-Anchor" href="#인텐트-실행-요청하기"></a> 인텐트 실행 요청하기</h3><p>카메라 인텐트를 실행 요청할 준비가 되었다<small>인텐트는 안드로이드 운영체제가 실행하므로 실행을 요청한다는 표현이 적합</small>. 이때 필요한 액션은 ACTION_IMAGE_CAPTURE이며, <strong>MediaStore</strong> 클래스에 상수로 정의되어 있다. 여기서는 MediaStore.ACTION_IMAGE_CAPTURE 액션을 갖는 암시적 인텐트를 요청하면 안드로이드가 카메라 액티비티를 시작시켜 사진을 찍을 수 있다. MediaStore에는 이미지, 비디오, 음악 등의 미디어를 처리하는 안드로이드에서 사용되는 <strong>public</strong> 인터페이스가 정의되어 있다. 그리고 카메라 앱을 시작시키는 이미지 캡처 인텐트 상수도 포함한다.</p><p>기본적으로 ACTION_IMAGE_CAPTURE 액션은 카메라 앱을 시작시키고 찍은 사진을 받을 수 있게 해준다. 다만 전체 해상도의 사진은 아니고 낮은 해상도의 섬네일 사진이다. 그리고 찍은 사진은 <code>onActivityResult(...)</code>에서 반환하는 <strong>Intent</strong> 객체에 포함된다.</p><p>전체 해상도의 사진을 받으려면 이미지를 저장할 파일 시스템의 위치를 알려주어야 한다. 이때는 MediaStore.EXTRA_OUTPUT 상수를 엑스트라의 키로, 사진 파일을 저장할 위치를 가리키는 Uri를 엑스트라의 값으로 설정해 인텐트에 전달하면 된다. 여기서 <strong>Uri</strong>는 <strong>FileProvider</strong>에 의해 서비스되는 위치를 가리킨다.</p><p>우선 사진 URI를 저장하는 photoUri 속성을 추가한다. 그리고 사진 파일의 참조를 얻은 후에 FileProvider가 반환하는 Uri로 photoUri 속성을 초기화한다.</p><blockquote><p>사진 URI 속성 추가하고 초기화하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crime: Crime</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> photoFile: File</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> photoUri: Uri</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        crimeDetailViewModel.crimeLiveData.observe(</span><br><span class="line">            viewLifecycleOwner,</span><br><span class="line">            Observer &#123; crime -&gt;</span><br><span class="line">                crime?.let &#123;</span><br><span class="line">                    <span class="keyword">this</span>.crime = crime</span><br><span class="line">                    photoFile = crimeDetailViewModel.getPhotoFile(crime)</span><br><span class="line">                    photoUri = FileProvider.getUriForFile(</span><br><span class="line">                        requireActivity(),</span><br><span class="line">                        <span class="string">&quot;com.june0122.criminalintent.fileprovider&quot;</span>,</span><br><span class="line">                        photoFile</span><br><span class="line">                    )</span><br><span class="line">                    updateUI()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>FileProvider.getUriForFile(...)</code>을 호출하면 로컬 파일 시스템의 파일 경로를 카메라 앱에서 알 수 있는 Uri로 변환한다. 이 함수의 두 번째 인자는 FileProvider를 나타내며, 매니페스트의 android:authorities 속성에 정의했던 것과 같아야 한다.</p><p>다음으로 photoUri가 가리키는 위치에 저장할 새로운 사진을 요청하는 암시적 인텐트를 작성한다. 그리고 카메라 앱이 장치에 없거나 사진을 저장할 위치가 없으면, 카메라 버튼을 비활성화하는 코드도 추가한다<small>(사용할 수 있는 카메라 앱이 있는지 판단하기 위해 여기서는 카메라 암시적 인텐트에 응답하는 액티비티의 <strong>PackageManager</strong>를 쿼리한다)</small>.</p><blockquote><p>카메라 인텐트 실행 요청하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CONTACT = <span class="number">2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_PHOTO = <span class="number">3</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DATE_FORMAT = <span class="string">&quot;yyyy년 M월 d일 H시 m분, E요일&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        suspectButton.apply &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        photoButton.apply &#123;</span><br><span class="line">            <span class="keyword">val</span> packageManager: PackageManager = requireActivity().packageManager</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> captureImage = Intent(MediaStore.ACTION_IMAGE_CAPTURE)</span><br><span class="line">            <span class="keyword">val</span> resolvedActivity: ResolveInfo? =</span><br><span class="line">                packageManager.resolveActivity(captureImage, PackageManager.MATCH_DEFAULT_ONLY)</span><br><span class="line">            <span class="keyword">if</span> (resolvedActivity == <span class="literal">null</span>) &#123;</span><br><span class="line">                isEnabled = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setOnClickListener &#123;</span><br><span class="line">                captureImage.putExtra(MediaStore.EXTRA_OUTPUT, photoUri)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> cameraActivities: List&lt;ResolveInfo&gt; =</span><br><span class="line">                    packageManager.queryIntentActivities(captureImage, PackageManager.MATCH_DEFAULT_ONLY)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (cameraActivity <span class="keyword">in</span> cameraActivities) &#123;</span><br><span class="line">                    requireActivity().grantUriPermission(</span><br><span class="line">                        cameraActivity.activityInfo.packageName,</span><br><span class="line">                        photoUri,</span><br><span class="line">                        Intent.FLAG_GRANT_WRITE_URI_PERMISSION</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                startActivityForResult(captureImage, REQUEST_PHOTO)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>photoUri가 가리키는 위치에 실제로 사진 파일을 쓰려면 카메라 앱 퍼미션이 필요하다. 따라서 cameraImage 인텐트를 처리할 수 있는 모든 액티비티에 Intent.FLAG_GRANT_WRITE_URI_PERMISSION을 부여한다<small>(매니페스트에 grantUriPermissions 속성을 추가했으므로 이처럼 퍼미션을 부여할 수 있다)</small>. 이렇게 하면 해당 액티비티들이 Uri에 쓸 수 있는 퍼미션을 갖는다.</p><p>앱을 실행해 상세 내역 화면에서 카메라 버튼을 눌러보면 각자 장치에 설치된 카메라 앱이 실행되는 것을 확인할 수 있다.</p><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/120077897-b0bbad00-c0e7-11eb-8558-98e057c00d8f.gif'></p><h2 id="비트맵의-크기-조정과-보여주기"><a class="markdownIt-Anchor" href="#비트맵의-크기-조정과-보여주기"></a> 비트맵의 크기 조정과 보여주기</h2><p>이제는 사진을 찍을 수 있게 되었다. 그리고 이 앱에서 사용할 수 있도록 사진은 파일 시스템의 파일로 저장된다.</p><p>다음으로 사진 파일을 읽어서 로드한 후 사용자에게 보여주자. 이렇게 하려면 적합한 크기의 Bitmap 객체로 로드해야 한다. 파일로부터 Bitmap 객체를 얻을 때는 BitmapFactory 클래스를 사용하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bitmap = BitmapFactory.decodeFile(photoFile.getPath())</span><br></pre></td></tr></table></figure><p>그런데 한 가지 문제가 있다. 바로 <em>적합한 크기</em>에 관한 것이다. Bitmap은 화소 <sup>pixel</sup> 데이터를 저장하는 간단한 객체다. 즉, 원래 파일이 압축되었더라도 Bitmap 자체는 압축되지 않는다. 따라서 1600만 화소의 24비트 카메라 이미지는 5MB 크기의 JPG로 압축될 수 있지만, Bitmap 객체로 로드하면 48MB 크기로 커진다.</p><p>이 문제를 해결하려면 직접 비트맵의 크기를 줄여야 한다. 이때 파일 크기를 먼저 확인하고, 지정된 영역에 맞추기 위해 얼마나 줄여야 할지 파악한 후 해당 파일을 읽어서 크기를 줄인 Bitmap 객체를 생성하면 된다.</p><p>PictureUtil.kt라는 이름의 새로운 코틀린 파일을 생성하고 <code>getScaledBitmap(String, Int, Int)</code>라는 이름의 파일 수준 함수<small>(코틀린 파일 내에서 클래스 외부에 정의된 함수이며, 앱의 어떤 코드에서도 사용 가능)</small>를 추가한다.</p><blockquote><p><code>getScaledBitmap(...)</code> 함수 생성하기 (PictureUtils.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScaledBitmap</span><span class="params">(path: <span class="type">String</span>, destWidth: <span class="type">Int</span>, destHeight: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="comment">// 이미지 파일의 크기를 읽는다</span></span><br><span class="line">    <span class="keyword">var</span> options = BitmapFactory.Options()</span><br><span class="line">    options.inJustDecodeBounds = <span class="literal">true</span></span><br><span class="line">    BitmapFactory.decodeFile(path, options)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> srcWidth = options.outWidth.toFloat()</span><br><span class="line">    <span class="keyword">val</span> srcHeight = options.outHeight.toFloat()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 크기를 얼마나 줄일지 파악한다</span></span><br><span class="line">    <span class="keyword">var</span> inSampleSize = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (srcHeight &gt; destHeight || srcWidth &gt; destWidth) &#123;</span><br><span class="line">        <span class="keyword">val</span> heightScale = srcHeight / destHeight</span><br><span class="line">        <span class="keyword">val</span> widthScale = srcWidth / destWidth</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> sampleScale = <span class="keyword">if</span> (heightScale &gt; widthScale) &#123;</span><br><span class="line">            heightScale</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            widthScale</span><br><span class="line">        &#125;</span><br><span class="line">        inSampleSize = Math.round(sampleScale)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    options = BitmapFactory.Options()</span><br><span class="line">    options.inSampleSize = inSampleSize</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 최종 Bitmap을 생성한다</span></span><br><span class="line">    <span class="keyword">return</span> BitmapFactory.decodeFile(path, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 중요한 것은 <code>inSampleSize</code>다. 각 화소에 대해 각 '샘플 <sup>sample</sup>’이 얼마나 큰지를 결정한다. 예를 들어, <code>inSampleSize</code>가 1이면 원래 파일의 각 수평 화소당 하나의 최종 수평 화소를 갖는다. 그리고 2이면 원래 파일의 두 개의 수평 화소마다 하나의 수평 화소를 갖는다. 따라서 <code>inSampleSize</code>가 2일 때는 원래 이미지 화소의 1/4에 해당하는 화소 개수를 갖는 이미지가 된다.</p><p>그런데 문제가 하나 더 있다. 프래그먼트가 최초로 시작될 때는 PhotoView의 크기를 미리 알 수 없다. 왜냐하면 프래그먼트의 <code>onCreate(...)</code>와 <code>onStart(...)</code> 및 <code>onResume(...)</code>이 차례대로 호출되어 실행된 후에 레이아웃이 뷰 객체로 생성되기 때문이다<small>(레이아웃이 뷰 객체로 생성될 때까지는 이것의 뷰들이 화면상의 크기를 갖지 않는다)</small>.</p><p>이 문제의 해결 방법은 두 가지가 있다. 레이아웃이 뷰 객체로 생성될 때까지 기다리거나, PhotoView의 크기가 어느 정도 될지 추정하는 것이다. 크기를 추정하는 방법은 효율성은 떨어지지만 구현은 쉽다.</p><p>여기서는 파일 수준 함수인 <code>getScaledBitmap(String, Activity)</code>를 작성해 특정 액티비티의 화면 크기에 맞춰 Bitmap의 크기를 조정한다.</p><blockquote><p>크기 추정 함수 추가하기 (PictureUtils.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScaledBitmap</span><span class="params">(path: <span class="type">String</span>, activity: <span class="type">Activity</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    <span class="keyword">val</span> size = Point()</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Suppress(<span class="meta-string">&quot;DEPRECATION&quot;</span>)</span></span><br><span class="line">    activity.windowManager.defaultDisplay.getSize(size)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> getScaledBitmap(path, size.x, size.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScaledBitmap</span><span class="params">(path: <span class="type">String</span>, destWidth: <span class="type">Int</span>, destHeight: <span class="type">Int</span>)</span></span>: Bitmap &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getScaledBitmap(String, Activity)</code> 함수에서는 화면 크기를 확인해서 해당 크기에 맞춰 이미지 크기를 줄이기 위해 오버로딩된 <code>getScaledBitmap(String, Int, Int)</code> 함수를 호출한다.</p><p>다음으로 ImageView에 Bitmap을 로드하기 위해 CrimeFragment에 새로운 함수를 추가하고 photoView를 변경한다.</p><blockquote><p>photoView 변경하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updatePhotoView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (photoFile.exists()) &#123;</span><br><span class="line">            <span class="keyword">val</span> bitmap = getScaledBitmap(photoFile.path, requireActivity())</span><br><span class="line">            photoView.setImageBitmap(bitmap)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            photoView.setImageDrawable(<span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그다음에 <code>updatePhotoView()</code> 함수를 <code>updateUI()</code>와 <code>onActivityResult(...)</code> 내부에서 호출하게 한다.</p><blockquote><p><code>updatePhotoView()</code> 호출하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (crime.suspect.isNotEmpty()) &#123;</span><br><span class="line">            suspectButton.text = crime.suspect</span><br><span class="line">        &#125;</span><br><span class="line">        updatePhotoView()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            resultCode != Activity.RESULT_OK -&gt; <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            requestCode == REQUEST_CONTACT &amp;&amp; <span class="keyword">data</span> != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            requestCode == REQUEST_PHOTO -&gt; &#123;</span><br><span class="line">                updatePhotoView()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>이제는 카메라 앱에서 저장한 사진 파일을 처리할 수 있게 되었다. 따라서 Uri에 파일을 쓸 수 있는 퍼미션을 취소할 수 있다. 카메라 앱에서 정상적으로 사진 파일을 쓴 이후에 URI 퍼미션을 취소하도록 <code>onActivityResult(...)</code>를 변경하고 <code>onDetach()</code>를 추가해보자<small>(<code>onDetach()</code>는 부적합한 응답이 생길 가능성에 대비한 것이다)</small>.</p><blockquote><p>URI 퍼미션 취소하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDetach</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDetach()</span><br><span class="line">        requireActivity().revokeUriPermission(photoUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION)</span><br><span class="line">        updatePhotoView()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            requestCode == REQUEST_PHOTO -&gt; &#123;</span><br><span class="line">                requireActivity().revokeUriPermission(photoUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION)</span><br><span class="line">                updatePhotoView()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>앱을 다시 실행해 범죄 리스트에서 한 항목을 클릭한 후 상세 내역 화면에서 카메라 버튼을 눌러 카메라 앱이 실행되면 사진을 찍는다. ‘확인’ 또는 ‘다시 시도’ 선택 버튼이 나타나면 '확인’을 클릭한다. 그러면 아래의 이미지와 같이 사진의 섬네일 이미지가 상세 내역 화면에 나타난다.</p><blockquote><p>상세 내역 화면에 나타난 섬네일 이미지</p></blockquote><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/120093824-b94bcc00-c157-11eb-94b5-17aaafc9ac53.png'></p><h2 id="사용하는-장치-기능-선언하기"><a class="markdownIt-Anchor" href="#사용하는-장치-기능-선언하기"></a> 사용하는 장치 기능 선언하기</h2><p>사진 관련 기능을 구현해보았다. 그런데 할 일이 한 가지 더 있다. 앱에서 장치마다 다를 수 있는 기능<small>(카메라나 NFC 등)</small>을 사용할 때는 안드로이드에게 알려주는 것이 좋다. 장치가 지원하지 않는 기능을 앱이 사용하면 다른 앱<small>(예를 들어, 플레이스토어)</small>에서 해당 앱의 설치를 거부할 수 있기 때문이다.</p><p>카메라 사용을 선언하기 위해 매니페스트에 &lt;uses-feature&gt; 태그를 추가한다.</p><blockquote><p>&lt;uses-feature&gt; 태그 추가하기 (manifests/AndroidManifest.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.june0122.criminalintent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-feature</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.camera2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:required</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>여기서는 생략 가능한 속성인 android:required 가 있다. 왜 그랬을까? 이 속성값을 true로 지정하면 해당 기능 없이는 앱이 제대로 동작하지 않음을 의미한다. 그런데 본문의 앱에서는 그렇지 않으므로 false를 지정하였다. 왜냐하면 <code>resolveActivity(...)</code>를 호출해 작동 가능한 카메라 앱이 있는지 확인해서 없으면 카메라 버튼을 사용할 수 없게 비활성화하기 때문이다.</p><p>즉, android:required 속성의 값으로 false를 지정하면 카메라 없이도 앱이 잘 실행될 수 있음을 안드로이드에게 알려주는 것이다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Intent/">Intent</category>
      
      <category domain="http://june0122.github.io/tags/Content-Provider/">Content Provider</category>
      
      <category domain="http://june0122.github.io/tags/File-Provider/">File Provider</category>
      
      <category domain="http://june0122.github.io/tags/Bitmap/">Bitmap</category>
      
      
      <comments>http://june0122.github.io/2021/05/31/android-bnr-16/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] 암시적 인텐트</title>
      <link>http://june0122.github.io/2021/05/30/android-bnr-15/</link>
      <guid>http://june0122.github.io/2021/05/30/android-bnr-15/</guid>
      <pubDate>Sat, 29 May 2021 16:40:29 GMT</pubDate>
      
      <description>안드로이드에서는 &lt;b&gt;인텐트 &lt;sup&gt;intent&lt;/sup&gt;&lt;/b&gt; 를 사용해 장치의 다른 앱에 있는 액티비티를 시작시킬 수 있다. &lt;b&gt;명시적 인텐트 &lt;sup&gt;explicit intent&lt;/sup&gt;&lt;/b&gt; 에서는 시작시킬 액티비티 클래스를 지정하면 안드로이드 운영체제가 해당 액티비티를 시작시킨다. 반면에 &lt;b&gt;암시적 인텐트 &lt;sup&gt;implicit intent&lt;/sup&gt;&lt;/b&gt; 에서는 해야 할 작업을 알려주면 안드로이드 운영체제가 이 작업을 수행하는 데 적합한 앱의 액티비티를 찾아서 시작시킨다.</description>
      
      
      
      <content:encoded><![CDATA[<p>안드로이드에서는 <strong>인텐트 <sup>intent</sup></strong> 를 사용해 장치의 다른 앱에 있는 액티비티를 시작시킬 수 있다. <strong>명시적 인텐트 <sup>explicit intent</sup></strong> 에서는 시작시킬 액티비티 클래스를 지정하면 안드로이드 운영체제가 해당 액티비티를 시작시킨다. 반면에 <strong>암시적 인텐트 <sup>implicit intent</sup></strong> 에서는 해야 할 작업을 알려주면 안드로이드 운영체제가 이 작업을 수행하는 데 적합한 앱의 액티비티를 찾아서 시작시킨다.</p><p>본문에서는 ① 암시적 인텐트를 사용해서 사용자의 연락처에서 범죄 용의자를 한 명 선택하고, ② 텍스트 형태의 범죄 보고서를 전송할 수 있게 한다. 이때 사용자는 장치에 설치된 연락처 앱과 텍스트 전송 앱을 선택해 사용할 수 있다.</p><p>암시적 인텐트를 사용하면 추가로 앱을 개발하지 않아도 다른 앱을 이용할 수 있다. 따라서 모바일 장치의 여러 앱들에게 공통으로 필요한 작업을 쉽게 처리할 수 있다. 따라서 모바일 장치의 여러 앱들에게 공통으로 필요한 작업을 쉽게 처리할 수 있다. 그리고 사용자 또한 다른 앱들을 이 앱과 연계해 사용할 수 있다.</p><p>암시적 인텐트 생성에 앞서 다음과 같이 몇 가지 준비할 것이 있다.</p><ul><li>‘용의자 선택’ 버튼과 ‘범죄 보고서 전송’ 버튼을 CrimeFragment의 레이아웃에 추가한다.</li><li>용의자 이름을 저장하는 <code>suspect</code> 속성을 Crime 클래스에 추가한다.</li><li><strong>포맷 리소스 문자열 <sup>format resource string</sup></strong> 을 사용해서 범죄 보고서를 생성한다.</li></ul><h2 id="모델-계층에-용의자-추가하기"><a class="markdownIt-Anchor" href="#모델-계층에-용의자-추가하기"></a> 모델 계층에 용의자 추가하기</h2><p>용의자 이름을 저장할 새로운 속성을 Crime 클래스에 추가한다.</p><blockquote><p><code>suspect</code> 속성 추가하기 (Crime.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Crime</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: UUID = UUID.randomUUID(),</span><br><span class="line">    <span class="keyword">var</span> title: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">var</span> date: Date = Date(),</span><br><span class="line">    <span class="keyword">var</span> isSolved: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">var</span> suspect: String = <span class="string">&quot;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>그런 다음 <code>suspect</code> 속성값을 저장하도록 데이터베이스의 Crime 테이블 열 <sup>column</sup>도 추가해야 한다. 이렇게 하려면 CrimeDatabase 클래스의 버전을 높여서 Room이 데이터베이스를 새 버전으로 이행 <sup>migration</sup>하게 해야 한다<small>(이행은 기존 데이터베이스의 스키마를 업데이트하고 데이터를 새 버전의 스키마에 맞춰 옮기는 것을 말한다.)</small>. 이때 <strong>Migration</strong> 클래스를 사용한다.</p><blockquote><p>새 버전의 데이터베이스로 이행하기 (database/CrimeDatabase.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Database(entities = [Crime::class], version = 1)</span></span><br><span class="line"><span class="meta">@Database(entities = [Crime::class], version = 2)</span></span><br><span class="line"><span class="meta">@TypeConverters(CrimeTypeConverters::class)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">crimeDao</span><span class="params">()</span></span>: CrimeDao</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> migration_1_2 = <span class="keyword">object</span> : Migration(<span class="number">1</span>, <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">migrate</span><span class="params">(database: <span class="type">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class="line">        database.execSQL(</span><br><span class="line">            <span class="string">&quot;ALTER TABLE Crime ADD COLUMN suspect TEXT NOT NULL DEFAULT &#x27;&#x27;&quot;</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>데이터베이스의 초기 버전이 1이었으므로 위의 코드에서는 2로 올렸다. 그리고 Migration 객체를 생성해 데이터베이스를 업데이트한다.</p><p>Migration 클래스의 생성자는 두 개의 인자를 받는다. 첫 번째는 업데이트 전의 데이터베이스 버전이고, 두 번째는 업데이트할 버전이다. 여기서는 버전 번호를 1과 2로 지정하였다.</p><p>Migration 객체에는 <code>migrate(SupportSQLiteDatabase)</code> 함수만 구현하면 된다. 이 함수에서는 인자로 전달된 데이터베이스를 사용해서 테이블을 업그레이드하는 데 필요한 SQL 명령을 실행한다. 여기서는 <code>ALTER TABLE</code> 명령으로 suspect 열을 Crime 테이블에 추가한다.</p><p>생성된 Migration 객체는 데이터베이스를 생성할 때 제공해야 한다. CrimeRepository에서 CrimeDatabase 인스턴스를 생성할 때 Migration 객체를 Room에 제공하도록 변경한다.</p><blockquote><p>Migration 객체를 Room에 제공하기 (CrimeRepository.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> com.june0122.criminalintent.database.migration_1_2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeRepository</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(context: Context) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> database: CrimeDatabase = Room.databaseBuilder(</span><br><span class="line">        context.applicationContext,</span><br><span class="line">        CrimeDatabase::<span class="keyword">class</span>.java,</span><br><span class="line">        DATABASE_NAME</span><br><span class="line"><span class="comment">//    ).build()</span></span><br><span class="line">    ).addMigrations(migration_1_2)</span><br><span class="line">        .build()</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeDao = database.crimeDao()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Migration 객체를 설정하려면 <code>addMigration(...)</code>를 호출한 후에 <code>build()</code> 함수를 호출해야 한다. <code>addMigration(...)</code> 함수는 여러 개의 Migration 객체를 인자로 받을 수 있으므로 선언했던 모든 Migration 객체를 한꺼번에 전달할 수 있다.</p><p>앱이 실행되어 Room이 데이터베이스를 빌드할 때는 맨 먼저 장치의 기존 데이터베이스 버전을 확인한다. 그리고 이 버전이 CrimeDatabase 클래스의 <code>@Database</code> 애노테이션에 지정된 것과 일치하지 않으면, Room이 <code>@Database</code>에 지정된 버전에 맞는 Migration 객체를 찾아서 해당 버전으로 데이터베이스를 업데이트한다.</p><p>만일 데이터베이스 버전을 변경할 때 Migration 객체를 제공하지 않으면 Room이 기존 버전의 데이터베이스를 삭제하고 새 버전의 데이터베이스를 다시 생성한다. 이때 기존 데이터가 모두 없어지므로 주의해야 한다.</p><h2 id="포맷-문자열-사용하기"><a class="markdownIt-Anchor" href="#포맷-문자열-사용하기"></a> 포맷 문자열 사용하기</h2><p>마지막으로 특정 범죄의 상세 정보로 구성되는 범죄 보고서의 템플릿을 생성하면 모든 준비가 끝난다. 앱이 실행되기 전까지는 범죄의 상세 정보를 알 수 없으니 런타임 시에 대체될 수 있는 플레이스 홀더를 갖는 다음 포맷 문자열을 사용해야 한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%1$s! 이 범죄가 발견된 날짜는 %2$s. %3$s, 그리고 %4$s</span><br></pre></td></tr></table></figure><p><code>%1$s</code>, <code>%2$s</code> 등 이 문자열 이자로 대체되는 플레이스 홀더들이다. 이 포맷 문자열을 코드에서 사용할 때는 <code>getString(...)</code> 함수를 호출하며, 이때 포맷 문자열 리소스 ID, 그리고 플레이스 홀더들을 대체하는 순서대로 네 개의 문자열을 인자로 전달한다.</p><blockquote><p>문자열 리소스 추가하기 (res/values/strings.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;crime_suspect_text&quot;</span>&gt;</span>용의자 선택<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;crime_report_text&quot;</span>&gt;</span>범죄 보고서 전송<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;crime_report&quot;</span>&gt;</span>%1$s!</span><br><span class="line">      이 범죄가 발견된 날짜는 %2$s. %3$s, 그리고 %4$s</span><br><span class="line">    <span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;crime_report_solved&quot;</span>&gt;</span>이 건은 해결되었음<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;crime_report_unsolved&quot;</span>&gt;</span>이 건은 미해결임<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;crime_report_no_suspect&quot;</span>&gt;</span>용의자가 없음.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;crime_report_suspect&quot;</span>&gt;</span>용의자는 %s.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;crime_report_subject&quot;</span>&gt;</span>CriminalIntent 범죄 보고서<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;send_report&quot;</span>&gt;</span>범죄 보고서 전송<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>다음으로 문자열 네 개를 생성하고 결합해 하나의 완전한 보고서 문자열로 반환하는 함수를 CrimeFragment.kt에 추가한다.</p><blockquote><p><code>getCrimeReport()</code> 함수 추가하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_TIME = <span class="number">1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DATE_FORMAT = <span class="string">&quot;yyyy년 M월 d일 H시 m분, E요일&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCrimeReport</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> solvedString = <span class="keyword">if</span> (crime.isSolved) &#123;</span><br><span class="line">            getString(R.string.crime_report_solved)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getString(R.string.crime_report_unsolved)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> dateString = DateFormat.format(DATE_FORMAT, crime.date).toString()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> suspect = <span class="keyword">if</span> (crime.suspect.isBlank()) &#123;</span><br><span class="line">            getString(R.string.crime_report_no_suspect)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getString(R.string.crime_report_suspect, crime.suspect)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> getString(R.string.crime_report, crime.title, dateString, solvedString, suspect)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><small>(DateFormat 클래스의 import 문을 추가할 때는 android.text.format.DateFormat을 선택해야 한다.)</small></p><p>준비 작업이 끝났으니 이제 암시적 인텐트를 자세히 알아본다.</p><h2 id="암시적-인텐트-사용하기"><a class="markdownIt-Anchor" href="#암시적-인텐트-사용하기"></a> 암시적 인텐트 사용하기</h2><p><strong>인텐트</strong>는 하고자 원하는 것을 안드로이드 운영체제에 알려주는 객체다. 지금까지는 우리가 생성했던 <strong>명시적</strong> 인텐트를 사용해서 안드로이드 운영체제가 시작시킬 액티비티 이름을 명시적으로 지정하였다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, CheatActivity::<span class="keyword">class</span>.java)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p><strong>암시적</strong> 인텐트를 사용할 때는 원하는 작업을 안드로이드 운영체제에 알려준다. 그러면 해당 작업을 할 수 있다고 자신을 알린 액티비티를 안드로이드 운영체제가 찾아서 시작시킨다. 단, 안드로이드 운영체제가 그런 능력을 가진 액티비티를 두 개 이상 찾으면 사용자가 선택할 수 있게 해준다.</p><h3 id="암시적-인텐트의-구성-요소"><a class="markdownIt-Anchor" href="#암시적-인텐트의-구성-요소"></a> 암시적 인텐트의 구성 요소</h3><p>원하는 작업을 정의할 때 사용하는 암시적 인텐트의 주요 구성 요소는 다음과 같다.</p><p>수행하고자 하는 액션 <sup>action</sup></p><ul><li><strong>Intent</strong> 클래스의 상수다. 예를 들어, 웹 URL을 보기 원한다면 Intent.ACTION_VIEW를 액션으로 사용하며, 텍스트 등을 전송할 때는 Intent.ACTION_SEND를 사용한다. 이외에도 여러 가지 상수가 있다.</li></ul><p>데이터의 위치</p><ul><li>웹 페이지의 URL과 같은 장치 외부 것이 될 수 있다. 또는 파일에 대한 URI나 <strong>Content Provider</strong>의 레코드<small>(주로 데이터베이스 테이블의 행)</small>를 가리키는 <strong>콘텐츠 URI</strong>도 될 수 있다.</li></ul><p>액션에서 필요한 데이터의 타입</p><ul><li>text/html이나 audio/mpeg3과 같은 MIME 타입이다. 인텐트가 데이터의 위치를 포함하면 해당 데이터로부터 타입을 유추할 수 있다.</li></ul><p>선택적으로 사용하는 카테고리</p><ul><li>액션이 <strong>무엇<small>(what)</small></strong> 을 하는지를 나타내는 데 사용되는 것이라면 카테고리는 액티비티를 <strong>어디서<small>(where)</small>, 언제<small>(when)</small>, 어떻게<small>(how)</small></strong> 사용할지를 나타낸다. 액티비티가 최상위 수준의 앱 론처에 보여야 함을 나타내기 위해 안드로이드는 <em>android.intent.category.LAUNCHER</em> 카테고리를 사용한다. 반면에 액티비티의 패키지에 관한 정보를 사용자에게 보여주되 론처에는 나타나지 않아야 하는 액티비티를 나타내려면 <em>android.intent.category.INFO</em> 카테고리를 사용한다.</li></ul><p>예를 들어, 웹 사이트의 페이지를 보는 간단한 암시적 인텐트는 Intent.ACTION_VIEW 액션과 웹 사이트의 URL인 데이터 URI<small>(Uri 객체)</small>를 포함한다.</p><p>안드로이드 운영체제는 이런 정보를 기준으로 적합한 애플리케이션의 액티비티를 찾아서 실행한다<small>(만일 하나 이상의 액티비티를 찾으면 대화상자를 보여주고 사용자가 선택하게 해준다)</small>.</p><p>액티비티는 매니페스트<small>(AndroidManifest.xml)</small>의 인텐트 필터를 통해서 지정된 액션을 수행할 수 있음을 알린다. 예를 들어, 웹 브라우저 앱이라면 ACTION_VIEW를 수행할 수 있는 액티비티를 선언할 때 다음과 같이 인텐트 필터를 포함하면 된다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.BrowserActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;http&quot;</span> <span class="attr">android:host</span>=<span class="string">&quot;www.naver.com&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>액티비티가 암시적 인텐트에 응답하려면 인텐트 필터에 DEFAULT 카테고리를 갖고 있어야 한다. 인텐트 필터의 action 요소는 이 액티비티가 해당 작업<small>(여기서는 VIEW, 즉 웹 URL의 브라우징)</small>을 수행할 수 있음을 안ㄴ드로이드 운영체제에 알린다. 그리고 DEFAULT 카테고리는 해당 작업을 할 의향이 있음을<small>(암시적으로 인텐트를 받겠다는)</small> 안드로이드 운영체제에 알린다. DEFAULT 카테고리는 모든 암시적 이벤트에 기본으로 추가된다.</p><p>명시적 인텐트처럼 암시적 인텐트도 엑스트라를 포함할 수 있다. 그러나 암시적 인텐트의 엑스트라는 안드로이드 운영체제가 적합한 액티비티를 찾기 위해 사용하는 것이 아니라 액션에 따른 추가 데이터를 보낼 때 사용한다.</p><p>그리고 인텐트의 액션<small>(action 태그로 지정됨)</small>과 데이터<small>(data 태그로 지정됨)</small>는 명시적 인텐트에서도 사용할 수 있다.</p><h3 id="범죄-보고서-전송하기"><a class="markdownIt-Anchor" href="#범죄-보고서-전송하기"></a> 범죄 보고서 전송하기</h3><p>지금부터는 CriminalIntent 앱에서 암시적 인텐트를 생성해 범죄 보고서를 발송하는 방법을 알아본다. 범죄 보고서는 문자열이므로 텍스트를 전송하는 작업을 해야 한다. 따라서 암시적 인텐트의 액션은 ACTION_SEND가 되며, 어떤 데이터나 카테고리도 지정하지 않지만 타입은 text/plain으로 지정한다.</p><p>CrimeFragment의 <code>onCreatView(...)</code>에서 ‘범죄 보고서 전송’ 버튼의 참조를 얻은 후, <code>onStart()</code>에서 이 버튼의 리스너를 설정한다. 그리고 이 리스너 내부에서는 암시적 인텐트를 생성해 <code>startActivity(Intent)</code>의 인자로 전달한다.</p><blockquote><p>범죄 보고서 전송하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> solvedCheckBox: CheckBox</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> reportButton: Button</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        ...</span><br><span class="line">        solvedCheckBox = view.findViewById(R.id.crime_solved) <span class="keyword">as</span> CheckBox</span><br><span class="line">        reportButton = view.findViewById(R.id.crime_report) <span class="keyword">as</span> Button</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        dateButton.setOnClickListener &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timeButton.setOnClickListener &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reportButton.setOnClickListener &#123;</span><br><span class="line">            Intent(Intent.ACTION_SEND).apply &#123;</span><br><span class="line">                type = <span class="string">&quot;text/plain&quot;</span></span><br><span class="line">                putExtra(Intent.EXTRA_TEXT, getCrimeReport())</span><br><span class="line">                putExtra(Intent.EXTRA_SUBJECT, getString(R.string.crime_report_subject))</span><br><span class="line">            &#125;.also &#123; intent -&gt;</span><br><span class="line">                startActivity(intent)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 액션을 정의하는 상수 문자열을 인자로 받는 Intent 생성자를 사용한다. 생성하야 할 암시적 인텐트의 종류에 따라 사용할 수 있는 생성자도 달라진다. 이와 관련된 내용은 <a href="https://developer.android.com/reference/kotlin/android/content/Intent#public-constructors">API 문서</a>에서 <strong>Intent</strong> 클래스를 찾아보면 알 수 있다. 그런데 타입을 인자로 받는 생성자는 없으므로 Intent의 <strong>type</strong> 속성으로 지정해야 한다.</p><p>보고서의 텍스트와 제목 문자열은 엑스트라의 값에 포함되며, 엑스트라의 키는 Intent 클래스에 정의한 상수들을 사용한다<small>(<strong>EXTRA_SUBJECT</strong>는 메시지의 제목이며, <strong>EXTRA_TEXT</strong>는 메시지의 데이터다)</small>. 이 인텐트에 응답해 시작되는 액티비티는 엑스트라의 키로 사용된 상수들과 각 키의 값이 무엇을 의미하는지 알아야 한다.</p><p>프래그먼트에서 액티비티르 시작시키는 것은 액티비티에서 다른 액티비티를 시작시키는 것과 거의 같다. 위의 코드에서는 Fragment의 <code>startActivity(Intent)</code> 함수를 호출하며, 이 함수는 내부적으로 이것과 대응되는 Activity 함수를 호출한다.</p><p>CriminalIntent 앱을 실행하고 범죄 리스트에서 한 항목을 클릭한 후 상세 내역 화면이 나타나면 ‘범죄 보고서 전송’ 버튼을 눌러보면 이 인텐트는 장치의 많은 액티비티와 일치하므로 아래의 이미지과 같이 선택할 액티비티들을 보여준다<small>(ACTION_SEND 인텐트에 응답할 수 있는 액티비티가 하나만 있다면 해당 액티비티의 앱이 바로 실행된다)</small>.</p><blockquote><p>범죄 보고서를 전송할 수 있는 액티비티들</p></blockquote><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/120061369-e6d14080-c097-11eb-9298-6d48cd88d9f1.png'></p><p>선택기 <sup>chooser</sup>가 보여주는 액티비티 중에서 하나를 선택해 액티비티의 앱에서 범죄 보고서를 전송하고, 종료하면 다시 범죄 상세 내역 화면으로 돌아온다.</p><p>‘메시지’ 앱을 선택하면 아래 이미지와 같이 범죄 보고서가 메시지로 작성된 상태에서 새 메시지 화면이 나타난다. 그래고 맨 위의 '받는 사람’만 지정하고 '보내기’를 누르면 메시지가 전송된다.</p><blockquote><p>‘메시지’ 앱으로 범죄 보고서 전송하기</p></blockquote><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/120061526-a6be8d80-c098-11eb-92ae-da44438daa8b.png'></p><p>만일 선택기가 나타나지 않는다면 이미 이와 같은 암시적 인텐트의 기본 앱을 설정했거나, 이 인텐트에 응답할 수 있는 액티비티가 장치에 하나만 있어서 그렇다.</p><p>액티비티를 시작시키기 위해 암시적 인텐트가 사용될 때마다 매번 선택기가 나타나게 할 수도 있다. 그렇게 하려면 이전처럼 암시적 인텐트를 생성한 후에 <code>Intent.createChooser(Intent, String)</code> 함수를 호출하면 된다. 이때 암시적 인텐트와 선택기의 제목 문자열을 인자로 전달한다. 그다음에 <code>createChooser(...)</code>로부터 반환된 인텐트를 <code>startActivity(...)</code>의 인자로 전달한다.</p><p>암시적 인텐트에 응답하는 액티비티들을 보여줄 선택기를 생성하는 코드를 CrimeFragment.kt에 추가한다.</p><blockquote><p>선택기 사용하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">reportButton.setOnClickListener &#123;</span><br><span class="line">    Intent(Intent.ACTION_SEND).apply &#123;</span><br><span class="line">        type = <span class="string">&quot;text/plain&quot;</span></span><br><span class="line">        putExtra(Intent.EXTRA_TEXT, getCrimeReport())</span><br><span class="line">        putExtra(Intent.EXTRA_SUBJECT, getString(R.string.crime_report_subject))</span><br><span class="line">    &#125;.also &#123; intent -&gt;</span><br><span class="line"><span class="comment">//      startActivity(intent)</span></span><br><span class="line">        <span class="keyword">val</span> chooserIntent = Intent.createChooser(intent, getString(R.string.send_report))</span><br><span class="line">        startActivity(chooserIntent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>앱을 다시 실행해 범죄 리스트에서 한 항목을 선택한 후, 상세 내역 화면이 나타나면 ‘범죄 보고서 전송’ 버튼을 눌러보자. 선택기의 제목이 '범죄 보고서 전송’으로 나타나며, 인텐트를 처리할 수 있는 액티비티가 하나 이상이면 항상 앱 선택 리스트가 나타난다.</p><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/120062056-0a49ba80-c09b-11eb-9877-1e248be815ca.png'></p><h3 id="안드로이드에-연락처-요청하기"><a class="markdownIt-Anchor" href="#안드로이드에-연락처-요청하기"></a> 안드로이드에 연락처 요청하기</h3><p>지금부터는 사용자가 자신의 연락처에서 용의자를 선택할 수 있게 또 다른 암시적 인텐트를 생성해본다. 이 암시적 인텐트는 액션 및 관련된 데이터를 찾을 수 있는 위치를 갖는다. 이때 액션은 Intent.ACTION_PICK이며, 연락처의 데이터는 ContactsContract.Contacts.CONTENT_URI에 있다. 요컨대 연락처 데이터베이스에서 한 항목을 선택할 수 있게 해달라고 안드로이드에 요청하는 것이다.</p><p>여기서는 인텐트로 시작된 액티비티로부터 결과<small>(연락처 데이터)</small>를 돌려받아야 한다. 따라서 <code>startActivityForResult(...)</code> 함수를 호출하면서 인텐트와 요청 코드를 인자로 전달해야 한다. 그리고 요청 코드의 상수와 ‘용의자 선택’ 버튼을 참조하는 속성을 CrimeFragment.kt에 추가한다.</p><blockquote><p>‘용의자 선택’ 버튼을 참조하는 속성 추가하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_DATE = <span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_TIME = <span class="number">1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CONTACT = <span class="number">2</span> <span class="comment">// 연락처 요청 코드의 상수</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> reportButton: Button</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> suspectButton: Button <span class="comment">// 버튼 참조 속성</span></span><br></pre></td></tr></table></figure><p>그다음에 <code>onCreateView(...)</code>의 끝에서 ‘용의자 선택’ 버튼 객체의 참조를 얻고, <code>onStart()</code>에서 이 버튼의 클릭 리스너를 설정한다. 클릭 리스너 구현 코드에서는 연락처를 요청하는 암시적 인텐트를 생성해서 <code>startActivityForResult(...)</code>의 인자로 전달한다. 그리고 용의자가 선정되면 이 사람들의 이름을 ‘용의자 선택’ 버튼에 보여준다.</p><blockquote><p>암시적 인텐트 전달하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        ...</span><br><span class="line">        reportButton = view.findViewById(R.id.crime_report) <span class="keyword">as</span> Button</span><br><span class="line">        suspectButton = view.findViewById(R.id.crime_suspect) <span class="keyword">as</span> Button</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        reportButton.setOnClickListener &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        suspectButton.apply &#123; </span><br><span class="line">            <span class="keyword">val</span> pickContactIntent = Intent(Intent.ACTION_PICK, ContactsContract.Contacts.CONTENT_URI)</span><br><span class="line">            </span><br><span class="line">            setOnClickListener &#123; </span><br><span class="line">                startActivityForResult(pickContactIntent, REQUEST_CONTACT)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pickContactIntent는 잠시 후에 한번 더 사용하므로 OnClickListener의 외부에 선언하였다.</p><p>다음으로 용의자가 선정되었을 때 ‘용의자 선택’ 버튼에 텍스트를 설정하도록 <code>updateUI()</code>를 변경한다.</p><blockquote><p>‘용의자 선택’ 버튼에 텍스트 설정하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    titleField.setText(crime.title)</span><br><span class="line">    dateButton.text = crime.date.toString()</span><br><span class="line">    solvedCheckBox.apply &#123;</span><br><span class="line">        isChecked = crime.isSolved</span><br><span class="line">        jumpDrawablesToCurrentState()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (crime.suspect.isNotEmpty()) &#123;</span><br><span class="line">        suspectButton.text = crime.suspect</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>앱을 다시 실행해 범죄 리스트에서 한 항목을 선택한 후 상세 내역 화면이 나타나면 ‘용의자 선택’ 버튼을 눌러보자. 아래의 이미지와 같이 연락처 리스트가 나타난다.</p><blockquote><p>용의자 선택을 위한 연락처 리스트</p></blockquote><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/120063255-35370d00-c0a1-11eb-9a63-1b5f9e70e5bb.gif'></p><h4 id="연락처-리스트에서-데이터-가져오기"><a class="markdownIt-Anchor" href="#연락처-리스트에서-데이터-가져오기"></a> 연락처 리스트에서 데이터 가져오기</h4><p>이제 연락처 앱으로부터 결과를 돌려받아야 한다. 그런데 연락처 정보는 많은 앱이 공유한다. 따라서 안드로이드에서는 <strong>ContentProvider</strong>를 통해 연락처 데이터와 함께 작동하는 상세한 API를 제공한다. 이 API 클래스의 인스턴스들은 데이터베이스를 포함하며, 다른 앱에서 이 데이터베이스의 데이터를 사용할 수 있게 한다. <strong>ContentProvider</strong>는 <strong>ContentReslover</strong>를 통해서 사용할 수 있다<small>(연락처 데이터베이스의 자세한 내용은 <a href="https://developer.android.com/guide/topics/providers/content-provider-basics?hl=ko">Content Provider 기본 사항</a>에서 Content Provider API 참고한다)</small>.</p><p>다음으로 연락처 앱으로부터 연락처의 이름을 가져오는 <code>onActivityResult(...)</code>를 CrimeFragment에 구현한다. 일단 코드를 작성한 후 하나씩 알아본다.</p><blockquote><p>연락처의 이름 가져오기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            requestCode != Activity.RESULT_OK -&gt; <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            requestCode == REQUEST_CONTACT &amp;&amp; <span class="keyword">data</span> != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> contactUri: Uri = <span class="keyword">data</span>.<span class="keyword">data</span> ?: <span class="keyword">return</span></span><br><span class="line">                <span class="comment">// 쿼리에서 값으로 반환할 필드를 지정한다</span></span><br><span class="line">                <span class="keyword">val</span> queryFields = arrayOf(ContactsContract.Contacts.DISPLAY_NAME)</span><br><span class="line">                <span class="comment">// 쿼리를 수행한다. contactUri는 콘텐츠 제공자의 테이블을 나타낸다</span></span><br><span class="line">                <span class="keyword">val</span> cursor = requireActivity().contentResolver</span><br><span class="line">                    .query(contactUri, queryFields, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">                cursor?.use &#123;</span><br><span class="line">                    <span class="comment">// 쿼리 결과 데이터가 있는지 확인한다</span></span><br><span class="line">                    <span class="keyword">if</span> (it.count == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 첫 번째 데이터 행의 첫 번째 열의 값을 가져온다</span></span><br><span class="line">                    <span class="comment">// 이 값이 용의자의 이름이다</span></span><br><span class="line">                    it.moveToFirst()</span><br><span class="line">                    <span class="keyword">val</span> suspect = it.getString(<span class="number">0</span>)</span><br><span class="line">                    crime.suspect = suspect</span><br><span class="line">                    crimeDetailViewModel.saveCrime(crime)</span><br><span class="line">                    suspectButton.text = suspect</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드에서는 반환된 데이터에 있는 연락처의 모든 표시명<small>(display name, 쉽게 말해 테이블의 열 이름)</small>을 가져온다. 그리고 연락처 데이터베이스를 쿼리한 후 반환된 결과셋 <sup>result set</sup>의 행들을 읽는 데 사용할 <strong>Cursor</strong> 객체를 얻는다. 그다음에 커서가 최소한 한 행의 데이터를 갖고 있는지 확인한 후, <code>Cursor.moveToFirst()</code>를 호출해 첫 번째 행으로 커서를 이동시킨다. 그리고 <code>Cursor.getString(Int)</code>를 호출해 첫 번째 행의 첫 번째 열 값을 가져오며, 이때 이 값이 바로 용의자의 이름이다. 그다음에 이 값을 Crime 객체의 suspect 속성과 ‘용의자 선택’ 버튼의 text 속성에 설정한다.</p><p>여기서는 연락처 앱으로부터 용의자 이름을 받으면 그 즉시 범죄 데이터베이스의 Crime 테이블에 저장한다. 이렇게 해야 하는 이유는 다음과 같다.</p><ul><li>CrimeFragment가 실행 재개 <sup>resumed</sup> 상태일 때는 <code>onViewCreated(...)</code> 함수가 호출되므로, 범죄 데이터베이스로부터 범죄 데이터를 쿼리하게 된다.</li><li>그러나 <code>onActivityResult(...)</code>가 호출된 후에 <code>onViewCreated(...)</code>가 호출되므로 연락처 앱으로부터 받은 용의자 이름을 범죄 데이터베이스의 범죄 데이터<small>(Crime 테이블의 suspect 열 값)</small>로 덮어쓰게 된다.</li><li>따라서 연락처 앱으로부터 받은 용의자 이름이 유실되지 않도록 범죄 데이터베이스에 저장해야 한다.</li></ul><p>연락처 앱과 범죄 데이터가 있는 장치에서 앱을 다시 실행한다. 범죄 리스트가 나타나면 한 항목을 선택한 후 상세 내역 화면에서 ‘용의자 선택’ 버튼을 누른다. 그다음에 연락처 리스트에서 한 명을 선택하면 상세 내역 화면으로 돌아오면서 ‘용의자 선택’ 버튼에 해당 이름이 나타난다. 그리고 ‘범죄 보고서 전송’ 버튼을 누른 후 ‘메시지’ 앱을 선택하면, 해당 용의자 이름이 범죄 보고서 메시지에도 나타난다.</p><blockquote><p>‘용의자 선택’ 버튼과 범죄 보고서 메시지에 나타난 용의자 이름</p></blockquote><p align = 'center'><img width = '200' src = 'https://user-images.githubusercontent.com/39554623/120064979-01acb080-c0aa-11eb-938a-175dca8599c7.png'><img width = '212' src = 'https://user-images.githubusercontent.com/39554623/120065111-aa5b1000-c0aa-11eb-8774-22dfe371d738.png'></p><h4 id="연락처-앱의-퍼미션"><a class="markdownIt-Anchor" href="#연락처-앱의-퍼미션"></a> 연락처 앱의 퍼미션</h4><p>연락처 데이터베이스를 읽기 위한 퍼미션 <sup>permission</sup>은 어떻게 얻을까? 연락처 앱이 우리에게 퍼미션을 부여한다. 연락처 앱은 연락처 데이터베이스의 모든 퍼미션을 갖고 있으며, Intent의 데이터 URI를 부모 액티비티에 반환할 때 Intent.FLAG_GRANT_READ_URI_PERMISSION 플래그도 추가한다. 이 플래그는 안드로이드에게 앱의 부모 액티비티가 해당 데이터를 한번 읽는 것을 허용한다고 알린다. 여기서는 연락처 데이터베이스의 전체 데이터를 액세스할 필요가 없고 하나의 연락처 데이터만 필요하므로 퍼미션 문제는 없다.</p><h3 id="응답하는-액티비티-확인하기"><a class="markdownIt-Anchor" href="#응답하는-액티비티-확인하기"></a> 응답하는 액티비티 확인하기</h3><p>본문에서 생성했던 첫 번째 암시적 인텐트<small>(범죄 보고서 전송)</small>는 어떤 경우에도 항상 응답을 받는다. 안드로이드 장치에는 이런저런 종류의 메시지 전송 앱이 반드시 있기 때문이다. 그런데 연락처에서 용의자를 선택하기 위한 두 번째 암시적 인텐트에서는 다르다. 일부 사용자나 장치에는 연락처 앱이 없을 수 있기 때문이다. 따라서 이때는 문제가 되는데, 안드로이드 운영체제가 일치하는 액티비티를 찾을 수 없어 앱이 중단되기 때문이다.</p><p>이런 문제의 해결책은 <code>onStart()</code> 함수에서 안드로이드 운영체제의 일부인 <strong>PackageManager</strong>를 먼저 확인하는 것이다.</p><blockquote><p>연락처 앱이 없을 때를 대비하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    suspectButton.apply &#123;</span><br><span class="line">        <span class="keyword">val</span> pickContactIntent = Intent(Intent.ACTION_PICK, ContactsContract.Contacts.CONTENT_URI)</span><br><span class="line">        setOnClickListener &#123;</span><br><span class="line">            startActivityForResult(pickContactIntent, REQUEST_CONTACT)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> packageManager: PackageManager = requireActivity().packageManager</span><br><span class="line">        <span class="keyword">val</span> resolvedActivity: ResolveInfo? =</span><br><span class="line">            packageManager.resolveActivity(pickContactIntent, PackageManager.MATCH_DEFAULT_ONLY)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (resolvedActivity == <span class="literal">null</span>) &#123;</span><br><span class="line">            isEnabled = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PackageManager</strong>는 안드로이드 장치에 설치된 모든 컴포넌트와 이것들의 모든 액티비티를 알고 있다. 따라서 <code>resolveActivity(Intent, Int)</code> 함수를 호출하면 첫 번째 인자로 전달된 인텐트와 일치하는 액티비티를 찾도록 요청한다. 그리고 두 번째 인자로 우리가 원하는 플래그를 전달하면 이 플래그를 갖는 액티비티들만 찾는다. 여기서는 MATCH_DEFAULT_ONLY 플래그를 전달해 CATEGORY_DEFAULT가 매니페스트의 인텐트 필터에 정의된 액티비티들만 찾는데, <code>startActivity(Intent)</code>가 하는 것과 같다.</p><p>그리고 찾은 액티비티들이 있으면 이것들의 정보를 갖는 <strong>ResolveInfo</strong> 인스턴스가 반환되고, 찾지 못하면 null을 반환하므로 이때는 ‘용의자 선택’ 버튼이 작동하지 않도록 비활성화한다.</p><p>인텐트 필터의 검사가 제대로 되는지 알아보고 싶지만 연락처 앱이 없는 장치가 없을 수도 있다. 이때는 인텐트에 임의의 카테고리를 추가해 테스트하면 된다. 아래 코드에서는 CATEGORY_HOME 플래그를 인텐트의 카테고리로 추가했다. 이 카테고리는 인텐트와 일치하는 연락처 애플리케이션을 찾지 못하게 일부러 추가한 것이다.</p><blockquote><p>인텐트 필터 테스트 코드 추가하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    suspectButton.apply &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// CATEGORY_HOME 플래그를 인텐트의 카테고리로 추가</span></span><br><span class="line">        pickContactIntent.addCategory(Intent.CATEGORY_HOME) </span><br><span class="line">        <span class="keyword">val</span> packageManager: PackageManager = requireActivity().packageManager</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>앱을 다시 실행해 범죄 리스트에서 한 항목을 선택하면 상세 내역 화면의 ‘용의자 선택’ 버튼이 비활성화된 것을 확인할 수 있다.</p><blockquote><p>비활성화된 ‘용의자 선택’ 버튼</p></blockquote><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/120065605-1b032c00-c0ad-11eb-8f7d-907b8af398c5.png'></p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Intent/">Intent</category>
      
      <category domain="http://june0122.github.io/tags/Content-Provider/">Content Provider</category>
      
      
      <comments>http://june0122.github.io/2021/05/30/android-bnr-15/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] 앱 바와 메뉴</title>
      <link>http://june0122.github.io/2021/05/29/android-bnr-14/</link>
      <guid>http://june0122.github.io/2021/05/29/android-bnr-14/</guid>
      <pubDate>Sat, 29 May 2021 04:13:12 GMT</pubDate>
      
      <description>잘 디자인된 안드로이드 앱에서 중요한 컴포넌트 중 하나가 &lt;b&gt;앱 바 &lt;sup&gt;app bar&lt;/sup&gt;&lt;/b&gt;다. 앱 바는 사용자가 수행할 수 있는 액션과 화면 간을 이동할 수 있는 매커니즘을 제공한다. 더불어 디자인의 일관성도 제공한다. 앱 바의 오른쪽 위에는 메뉴를 넣을 수 있다. 메뉴는 &lt;b&gt;액션 항목 &lt;sup&gt;action item&lt;/sup&gt;&lt;/b&gt; 으로 구성되며, 액션 항목은 현재 화면과 관련된 액션 또는 앱 전체의 액션을 수행할 수 있다.</description>
      
      
      
      <content:encoded><![CDATA[<p>잘 디자인된 안드로이드 앱에서 중요한 컴포넌트 중 하나가 <strong>앱 바 <sup>app bar</sup></strong> 다. 앱 바는 사용자가 수행할 수 있는 액션과 화면 간을 이동할 수 있는 매커니즘을 제공한다. 더불어 디자인의 일관성도 제공한다.</p><p>앱 바는 <strong>액션 바 <sup>action bar</sup></strong> 또는 <strong>툴바 <sup>toolbar</sup></strong> 자세한 내용은 <a id = "a1"><a href="#f1">앱 바 vs 액션 바 vs 툴바</a></a> 에서 다룬다.</p><h2 id="appcompat의-기본-앱-바"><a class="markdownIt-Anchor" href="#appcompat의-기본-앱-바"></a> AppCompat의 기본 앱 바</h2><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/119933287-c5505600-bfbe-11eb-9e94-68569fcfa7c6.png'></p><p>앱 바를 포함하는 이유는 새로운 프로젝트를 생성할 때 안드로이드 스튜디오가 <strong>AppCompatActivity</strong>의 서브 클래스인 모든 액티비티에 앱 바를 기본으로 포함하도록 설정하기 때문이다. 이때 안드로이드 스튜디오가 다음 내용을 수행함으로써 아래와 같은 일이 가능해진다.</p><ul><li>Jetpack의 <strong>AppCompat</strong> 라이브러리 의존성을 추가한다.</li><li>앱 바를 포함하는 <strong>AppCompat</strong> 테마 중 하나를 적용한다.</li></ul><p><em>app/build.gradle</em> 파일을 열면 <strong>AppCompat</strong> 라이브러리의 의존성이 이미 추가되어 있는 걸 확인할 수 있다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation <span class="string">&#x27;androidx.appcompat:appcompat:1.3.0&#x27;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AppCompat</strong>은 'application compatibility’의 단축어다. Jetpack의 AppCompat 라이브러리는 안드로이드 버전이 달라도 일관된 UI를 유지하는 데 핵심이 되는 클래스와 리소스들을 포함한다. AppCompat의 각 하위 패키지와 관련된 내용은 <a href="https://developer.android.com/jetpack/androidx/releases/appcompat?hl=ko">이곳</a>에서 확인 가능하다.</p><p>안드로이드 스튜디오 4.1.1 버전부터는 새 프로젝트를 생성할 때 앱의 테마를 자동으로 <code>Theme.MaterialComponents.DayNight.DarkActionBar</code>으로 설정한다. 이 테마는 <em>res/values/themes.xml</em>에 설정되어 있으며, 앱 전체의 기본 스타일을 지정한다.<small>(스타일 이름은 <strong>Theme.앱이름</strong>으로 지정된다.)</small></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.CriminalIntent&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>애플리케이션의 테마는 매니페스트 파일에 애플리케이션 수준으로 지정되며, 액티비티마다 선택적으로 지정될 수도 있다. 매니페스트 파일의 <application> 태그에 포함된 android:theme 속성을 보면 아래와 같이 지정되어 있음을 볼 수 있다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.CriminalIntent&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="메뉴"><a class="markdownIt-Anchor" href="#메뉴"></a> 메뉴</h2><p>앱 바의 오른쪽 위에는 메뉴를 넣을 수 있다. 메뉴는 <strong>액션 항목 <sup>action item</sup></strong> 으로 구성되며 <small>(때로는 <strong>메뉴 항목</strong>이라고도 함)</small>, 액션 항목은 현재 화면과 관련된 액션 또는 앱 전체의 액션을 수행할 수 있다.</p><p>본문에선 사용자가 새로운 데이터를 추가할 수 있는 액션 항목을 생성해본다. 액션 항목의 이름은 문자열 리소스로 만들어야 하므로 <em>res/values/strings.xml</em>을 열어 새로운 액션을 나타내는 문자열을 추가한다.</p><blockquote><p>메뉴 문자열 추가 (res/values/strings.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;new_crime&quot;</span>&gt;</span>새로운 범죄<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="xml로-메뉴-정의하기"><a class="markdownIt-Anchor" href="#xml로-메뉴-정의하기"></a> XML로 메뉴 정의하기</h3><p>메뉴는 레이아웃과 유사한 리소스로, XML 파일로 생성해 프로젝트의 res/menu 디렉터리에 둔다. 그리고 코드에서 메뉴를 인플레이트해 사용할 수 있도록 앱을 빌드하면 메뉴 파일의 리소스 ID가 자동 생성된다.</p><blockquote><p>메뉴 파일 생성하기</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119936549-4fe78400-bfc4-11eb-9f57-52e9b913c1c8.png'></p><p>메뉴 파일의 이름이 CrimeListFragment의 레이아웃 파일의 이름과 같지만 메뉴 파일은 res/menu/ 에 생성된다.</p><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/119936581-5bd34600-bfc4-11eb-8db9-ec217538954d.png'></p><blockquote><p>CrimeListFragment의 메뉴 리소스 생성하기 (res/menu/fragment_crime_list.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/new_crime&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@android:drawable/ic_menu_add&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">&quot;@string/new_crime&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:showAsAction</span>=<span class="string">&quot;ifRoom|withText&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>showAsAction 속성은 액션 항목이 앱 바 자체에 보이게 할 것인지, 아니면 <strong>오버플로 메뉴 <sup>overflow menu</sup></strong> 에 포함되어 보이게 될 것인지를 나타낸다. 여기서는 ifRoom과 withText 두 값을 같이 지정했으므로 앱 바에 공간이 있으면 액션 항목의 아이콘과 텍스트 모두 앱 바에 나타난다. 만일 아이콘을 보여줄 공간은 있지만 텍스트의 공간은 없다면 아이콘만 나타나고, 둘 다 보여줄 공간이 없으면 해당 액션 항목은 오버플로 메뉴에 들어간다.</p><p>showAsAction 속성의 다른 값으로는 always와 never가 있는데, always는 액션 항목을 항상 앱 바에 보여주기 때문에 권장하지 않는다. 대신에 ifRoom을 사용해서 안드로이드 운영체제가 결정하게 하는 것이 좋다. 자주 사용하지 않는 액션에는 never를 지정해서 오버플로 메뉴에 두는 것이 좋다. 화면이 너무 어수선해지는 것을 피하려면 사용자가 자주 사용할 액션 항목들만 앱 바에 두어야 한다. 따라서 위와 같이 ifRoom과 withText 두 값을 같이 지정하는 것이 좋다.</p><h4 id="앱의-네임스페이스"><a class="markdownIt-Anchor" href="#앱의-네임스페이스"></a> 앱의 네임스페이스</h4><p>fragment_crime_list.xml에서는 xmls 태그를 사용해서 새로운 네임스페이스로 app을 정의하는데, 보통의 android 네임스페이스와는 다르다. 여기서는 showAsAction 속성을 지정하기 위해 app 네임스페이스가 사용되었다.</p><p><strong>app</strong>과 같이 특이한 네임스페이스에는 <strong>AppCompat</strong> 라이브러리와 관련해서 필요하다. 앱 바 API는 안드로이드 3.0에서 처음 추가되었다<small>(당시에는 액션 바라고 했다)</small>. 원래 AppCompat 라이브러리의 앱 바는 더 이전 버전의 안드로이드를 지원하는 앱에 호환성 버전의 액션 바를 넣을 수 있게 만든 것으로, 액션 바를 지원하지 않는 안드로이드 버전을 실행하는 장치까지도 액션 바가 나타날 수 있게 한다.</p><p>AppCompat 라이브러리는 커스텀 showAsAction 속성을 정의하고 있으며, 안드로이드의 내장된 showAsAction 속성을 사용하지 않는다.</p><h3 id="메뉴-생성하기"><a class="markdownIt-Anchor" href="#메뉴-생성하기"></a> 메뉴 생성하기</h3><p>메뉴는 Activity 클래스의 콜백 함수가 관리한다. 메뉴가 필요하면 안드로이드는 Activity 함수인 <code>onCreateOptionsMenu(Menu)</code>를 호출한다.</p><p>그런데 이 앱에서는 액티비티가 아닌 프래그먼트에 구현된 코드를 호출한다. Fragment는 자신의 메뉴 콜백 함수들을 갖고 있다. 본문에서는 이 함수들을 CrimeListFragment에 구현한다. 메뉴를 생성하고 액션 항목의 선택에 응답하는 함수들은 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onCreateOptionsMenu(menu: Menu, inflater: MenuInflater)</span><br><span class="line">onOptionsItemSelected(item: MenuItem): <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure><p>CrimeListFragment.kt에서 <code>onCreateOptionsMenu(Menu, MenuInflater)</code>를 오버라이드해 fragment_crime_list.xml에 정의된 메뉴를 인플레이트하자.</p><blockquote><p>메뉴 리소스 인플레이트하기 (CrimeListFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDetach</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateOptionsMenu</span><span class="params">(menu: <span class="type">Menu</span>, inflater: <span class="type">MenuInflater</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreateOptionsMenu(menu, inflater)</span><br><span class="line">        inflater.inflate(R.menu.fragment_crime_list, menu)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 함수에서는 <code>MenuInflater.inflate(Int, Menu)</code>를 호출할 때 메뉴 파일의 리소스 ID를 인자로 전달한다. 이렇게 함으로써 파일에 정의된 액션 항목들로 Menu 인스턴스가 채워진다.</p><p>여기서는 슈퍼 클래스에 구현된 <code>onCreateOptionsMenu(...)</code>를 먼저 호출했다. 따라서 슈퍼 클래스에 정의된 어떤 메뉴 기능도 여전히 작동할 수 있다. 하지만 슈퍼 클래스인 Fragment의 <code>onCreateOptionsMenu(...)</code> 함수에서는 아무 일도 하지 않기 때문에 특별한 의미는 없다.</p><p>CrimeListFragment를 호스팅하는 액티비티가 운영체제로부터 자신의 <code>onCreateOptionsMenu(...)</code> 콜백 함수 호출을 받았을 때 FragmentManager는 <code>Fragment.onCreateOptionsMenu(Menu, MenuInflater)</code>를 호출하는 책임을 갖는다. 단, 다음의 Fragment 함수를 호출해서 CrimeListFragment가 <code>onCreateOptionsMenu(...)</code> 호출을 받아야 함을 FragmentManager가 명시적으로 알려주어야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setHasOptionsMenu(hasMenu: <span class="built_in">Boolean</span>)</span><br></pre></td></tr></table></figure><p>따라서 <code>CrimeListFragment.onCreate(Bundle?)</code>에 CrimeListFragment가 메뉴 콜백 호출을 받아야 함을 FragmentManager에 알려주는 코드를 추가한다.</p><blockquote><p>메뉴 콜백 호출을 받도록 하기 (CrimeListFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttach</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setHasOptionsMenu(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>앱 바에 나타난 범죄 추가 액션 항목 아이콘과 텍스트</p></blockquote><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/119939626-1f561900-bfc9-11eb-844b-52512102a48e.png'></p><blockquote><p>앱 바의 아이콘 제목 보기</p></blockquote><p>대부분의 폰에서는 아이콘을 보여줄 공간밖에 없기에 액션 항목의 텍스트가 표시되지 않는다. 앱 바의 + 아이콘을 길게 누르면 텍스트를 볼 수 있다.</p><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/119968508-8a631800-bfe8-11eb-928b-dce3f0458bae.gif'></p><h3 id="메뉴-선택에-응답하기"><a class="markdownIt-Anchor" href="#메뉴-선택에-응답하기"></a> 메뉴 선택에 응답하기</h3><p>사용자가 <strong>‘새로운 범죄’</strong> 액션 항목을 눌렀을 때 그에 대한 응답을 하려면 CrimeListFragment가 데이터베이스에 새로운 범죄 데이터<small>(Crime 인스턴스)</small>를 추가할 방법이 필요하다. 그러기 위해서는 리포지터리의 addCrime(Crime) 함수를 호출하는 코드를 CrimeListViewModel에 추가하면 된다.</p><blockquote><p>새로운 범죄 데이터 추가하기 (CrimeListViewModel.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeRepository = CrimeRepository.<span class="keyword">get</span>()</span><br><span class="line">    <span class="keyword">val</span> crimeListLiveData = crimeRepository.getCrimes()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addCrime</span><span class="params">(crime: <span class="type">Crime</span>)</span></span> &#123;</span><br><span class="line">        crimeRepository.addCrime(crime)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용자가 메뉴 항목을 누르면 프래그먼트에서 <code>onOptionsItemSelected(MenuItem)</code> 함수의 콜백 호출을 받게 되고, 이 함수는 사용자가 선택한 MenuItem의 인스턴스를 인자로 받는다.</p><p>지금 메뉴에는 액션 항목 하나만 있지만, 메뉴는 대개 둘 이상의 액션 항목을 갖는다. 이때 어떤 액션 항목이 선택되었는지는 MenuItem의 ID를 확인해서 알아낸 뒤 해당 항목에 적합한 응답을 하면된다. 이 ID는 메뉴 파일의 MenuItem에 지정한 리소스 ID와 일치한다.</p><p>이제 CrimeListFragment.kt의 <code>onOptionsItemSeleceted(MenuItem)</code> 함수를 구현해서 MenuItem의 선택에 응답하게 한다. 이 함수에서는 새로운 Crime 객체를 생성하고 데이터베이스에 추가한다. 그다음에 부모 액티비티에 구현된 <code>onCrimeSelected(...)</code> 콜백 함수를 호출해 CrimeListFragment를 CrimeFragment로 교체한다. 이렇게 하면 데이터베이스에 새로 추가된 범죄 데이터가 상세 내역 화면에 보이고, 사용자가 변경할 수도 있게 된다.</p><blockquote><p>메뉴 선택에 응답하기 (CrimeListFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateOptionsMenu</span><span class="params">(menu: <span class="type">Menu</span>, inflater: <span class="type">MenuInflater</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreateOptionsMenu(menu, inflater)</span><br><span class="line">        inflater.inflate(R.menu.fragment_crime_list, menu)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOptionsItemSelected</span><span class="params">(item: <span class="type">MenuItem</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> (item.itemId) &#123;</span><br><span class="line">            R.id.new_crime -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> crime = Crime()</span><br><span class="line">                crimeListViewModel.addCrime(crime)</span><br><span class="line">                callbacks?.onCrimeSelected(crime.id)</span><br><span class="line">                <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onOptionsItemSeleceted(MenuItem)</code> 함수는 Boolean 값을 반환한다. 즉, 선택된 MenuItem을 정상적으로 처리하고 나면 더 이상의 처리가 필요 없음을 나타내는 true를 반환해야 한다. 만일 false를 반환하면, 호스팅 액티비티의 <code>onOptionsItemSeleceted(MenuItem)</code> 함수를 호출해 메뉴 처리가 계속된다. 그리고 처리를 구현하지 않은 액션 항목 ID에는 슈퍼 클래스에 구현된 <code>onOptionsItemSeleceted(MenuItem)</code> 함수를 호출한다.</p><blockquote><p>새로운 범죄 데이터 추가</p></blockquote><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/119941477-9c828d80-bfcb-11eb-8639-d00e2c9b678f.gif'></p><h2 id="궁금증-해소-️-b-id-f1-앱-바-vs-액션-바-vs-툴바b"><a class="markdownIt-Anchor" href="#궁금증-해소-️-b-id-f1-앱-바-vs-액션-바-vs-툴바b"></a> 궁금증 해소 💁🏻‍♂️ : <b id = "f1"> 앱 바 vs 액션 바 vs 툴바</b>  <a href="#a1"> ↩</a></h2><p>앱 바를 ‘툴바’ 또는 '액션 바’라고 하는 경우를 심심치 않게 볼 수 있으며 안드로이드 문서에서도 이 용어들을 혼용해서 사용한다. 하지만 앱 바, 액션 바, 툴바는 정말로 같은 것일까? 이 용어들은 서로 관련이 있으나 정확하게 같은 것은 아니며, UI 설계 요소로는 '앱 바’라고 한다.</p><p>안드로이드 5.0<small>(롤리팝, API 레벨 21)</small> 이전에는 앱 바가 <strong>ActionBar</strong> 클래스를 사용해서 구현되었다. 따라서 액션 바와 앱 바 두 용어는 같은 것으로 간주했다. 그러나 안드로이드 5.0부터는 앱 바를 구현하는 방법으로 <strong>Toolbar</strong> 클래스가 도입되었다.</p><p>2021년을 기준으로 <strong>AppCompat</strong> 라이브러리는 Jetpack의 <strong>Toolbar</strong> 위젯을 사용해서 액션 바<small>(앱 바)</small>를 아래와 같이 구현한다.</p><blockquote><p>레이아웃 검사기로 본 액션 바</p></blockquote><p><small>앱을 실행하고 리스트에서 항목을 하나 선택해 상세 내역의 화면이 나타나게 한다. 그리고 안드로이드 스튜디오 메뉴 바의 <code>Tools -&gt; Layout Inspector</code> 를 선택하면 아래와 같이 레이아웃 검사기 도구 창이 열린다. 그리고 왼쪽의 컴포넌트 트리 패널에서 원하는 레이아웃이나 컴포넌트를 확장하고 선택하면 중앙의 레이아웃 화면에 표시해주며, 속성과 상세 정보를 오른쪽 패널에 보여준다.</small></p><p align = 'center'><img width = '850' src = 'https://user-images.githubusercontent.com/39554623/119947070-4c5af980-bfd2-11eb-9c37-ecf271bc5168.png'></p><p>ActionBar와 Toolbar는 매우 유사한 컴포넌트다. 그러나 툴바는 변경된 UI를 가지며 액션 바보다 유연성 있게 사용할 수 있는 반면에, 액션 바는 항상 화면의 제일 위쪽에 나타나며 한 화면에 하나만 있는 등 많은 제약을 가졌다. 게다가 액션 바의 크기는 정해져 있어서 변경할 수 없지만, 툴바는 이런 제약을 갖지 않는다.</p><p>본문에서는 AppCompat 테마 중 하나에서 제공한 툴바를 사용했지만, 액티비티나 프래그먼트의 레이아웃 파일에 포함된 뷰로 툴바를 포함할 수 있다. 그리고 화면의 어떤 위치에도 툴바를 둘 수 있고 여러 개를 넣을 수도 있다. 이런 유연성 덕분에 흥미로운 화면 디자인이 가능하다. 예를 들어, 각 프래그먼트가 자신의 툴바를 갖는다고 해보자. 그리고 한 화면에서 동시에 여러 개의 프래그먼트를 수용한다면, 화면 위에 하나의 툴바를 공유하지 않고 각 프래그먼트가 자신의 툴바를 갖고 나타날 수 있다. 또한 툴바는 내부에 다른 뷰들을 둘 수 있고 높이도 조정할 수 있어서 앱의 작동 방식에 훨씬 더 좋은 유연성을 제공한다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/AppCompat/">AppCompat</category>
      
      <category domain="http://june0122.github.io/tags/App-Bar/">App Bar</category>
      
      <category domain="http://june0122.github.io/tags/Action-Bar/">Action Bar</category>
      
      <category domain="http://june0122.github.io/tags/Toolbar/">Toolbar</category>
      
      <category domain="http://june0122.github.io/tags/Menu/">Menu</category>
      
      
      <comments>http://june0122.github.io/2021/05/29/android-bnr-14/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Dialog - 대화상자</title>
      <link>http://june0122.github.io/2021/05/28/android-bnr-13/</link>
      <guid>http://june0122.github.io/2021/05/28/android-bnr-13/</guid>
      <pubDate>Fri, 28 May 2021 01:20:19 GMT</pubDate>
      
      <description>&lt;b&gt;대화상자 &lt;sup&gt;Dialog&lt;/sup&gt;&lt;/b&gt;는 사용자의 주의를 끌고 입력을 받는 데 사용되며 사용자의 선택을 받거나 중요한 정보를 보여줄 때 유용하다. DatePickerDialog는 사용자가 날짜를 선택할 수 있게 해주며 사용자 선택을 알아내기 위해 구현하는 리스너 인터페이스를 제공한다. AlertDialog는 다목적의 Dialog 서브 클래스이며 커스텀 대화상자를 생성할 때 흔히 사용한다.</description>
      
      
      
      <content:encoded><![CDATA[<p><strong>대화상자 <sup>Dialog</sup></strong> 는 사용자의 주의를 끌고 입력을 받는 데 사용되며 사용자의 선택을 받거나 중요한 정보를 보여줄 때도 유용하다.</p><blockquote><p>범죄 발생일자를 선택하는 대화상자</p></blockquote><p align = 'center'><img width = '200' src = 'https://user-images.githubusercontent.com/39554623/119682086-91214c00-be7d-11eb-9907-b8a5cd9c29b1.png'></p><p>위의 대화상자는 <strong>AlertDialog</strong>의 서브 클래스인 <strong>DatePickerDialog</strong>의 인스턴스다. DatePickerDialog는 사용자가 날짜를 선택할 수 있게 해주며 사용자 선택을 알아내기 위해 구현하는 리스너 인터페이스를 제공한다. AlertDialog는 다목적의 Dialog 서브 클래스이며 커스텀 대화상자를 생성할 때 흔히 사용한다.</p><h2 id="dialogfragment-생성하기"><a class="markdownIt-Anchor" href="#dialogfragment-생성하기"></a> DialogFragment 생성하기</h2><p>DatePickerDialog를 화면에 보여줄 때는 <strong>Fragment의 서브 클래스인 DialogFragment 인스턴스에 포함시키는 것이 좋다.</strong></p><p>DialogFragment 없이 DatePickerDialog를 보여줄 수 있지만, FragmentManager로 DatePickerDialog를 관리하는 것이 유연성이 좋다. 그냥 DatePickerDialog만 사용하면 장치가 회전할 때 화면에서 사라지지만, DatePickerDialog가 프래그먼트에 포함되면 장치 회전 후에도 대화상자가 다시 생성되어 화면에 다시 나타난다.</p><blockquote><p>MainActivity에 의해 호스팅되는 두 프래그먼트의 객체 다이어그램</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119649087-337d0780-be5d-11eb-8c3f-58d1428e3df0.jpeg'></p><p>할 일은 다음과 같다.</p><ul><li>DatePickerFragment 클래스 생성한다.</li><li>DatePickerDialog 인스턴스를 생성해 대화상자를 만든다.</li><li>FragmentManager를 통해 대화상자를 화면에 보여준다.</li></ul><blockquote><p>DialogFragment 생성하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.DialogFragment</span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatePickerFragment</span>: <span class="type">DialogFragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateDialog</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span>: Dialog &#123;</span><br><span class="line">        <span class="keyword">val</span> calendar = Calendar.getInstance()</span><br><span class="line">        <span class="keyword">val</span> initialYear = calendar.<span class="keyword">get</span>(Calendar.YEAR)</span><br><span class="line">        <span class="keyword">val</span> initialMonth = calendar.<span class="keyword">get</span>(Calendar.MONTH)</span><br><span class="line">        <span class="keyword">val</span> initialDay = calendar.<span class="keyword">get</span>(Calendar.DAY_OF_MONTH)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> DatePickerDialog(</span><br><span class="line">            requireContext(),</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            initialYear,</span><br><span class="line">            initialMonth,</span><br><span class="line">            initialDay</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DatePickerDialog 생성자는 여러 개의 인자를 받는다. 첫 번째는 이 뷰에서 필요한 리소스를 사용하려면 지정해야 하는 Context 객체다. 두 번째는 날짜 리스너로 본문의 뒤에서 추가한다. 나머지 세 개는 년, 월, 일의 초기값으로, 일단 오늘 날짜로 초기화한다.</p><h3 id="dialogfragment-보여주기"><a class="markdownIt-Anchor" href="#dialogfragment-보여주기"></a> DialogFragment 보여주기</h3><p>다른 모든 프래그먼트처럼 DialogFragment의 인스턴스도 호스팅 액티비티의 FragmentManager가 관리한다.</p><p>FragmentManager에 추가되는 DialogFragment를 화면에 나타나게 하려면 다음 프래그먼트 인스턴스 함수 중 하나를 호출하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show(manager: FragmentManager, tag: String)</span><br><span class="line">show(transaction: FragmentTransaction, tag: String)</span><br></pre></td></tr></table></figure><p>String 인자는 FragmentManager의 리스트에서 DialogFragment를 고유하게 식별할 때 사용된다.</p><p>FragmentManager나 FragmentTransaction 중 어떤 것을 사용하는가는 프로그래머에게 달렸다.</p><ul><li>FragmentTransaction을 인자로 전달할 때는 <strong>직접 트랜잭션을 생성</strong>한 후 커밋해야 한다.</li><li>FragmentManager를 인자로 전달하면 <strong>트랜잭션이 자동으로 생성</strong>되어 커밋된다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;CrimeFragment&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ARG_CRIME_ID = <span class="string">&quot;crime_id&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DIALOG_DATE = <span class="string">&quot;DialogDate&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        ...</span><br><span class="line">        solvedCheckBox = view.findViewById(R.id.crime_solved) <span class="keyword">as</span> CheckBox</span><br><span class="line"></span><br><span class="line"><span class="comment">//        dateButton.apply &#123;</span></span><br><span class="line"><span class="comment">//            text = crime.date.toString()</span></span><br><span class="line"><span class="comment">//            isEnabled = false</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        solvedCheckBox.apply &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dateButton.setOnClickListener &#123; </span><br><span class="line">            DatePickerFragment().apply &#123; </span><br><span class="line">                show(<span class="keyword">this</span><span class="symbol">@CrimeFragment</span>.parentFragmentManager, DIALOG_DATE)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>this@CrimeFragment</code>는 DatePickerFragment가 아닌 CrimeFragment로부터 <code>requireFragmentManager()</code>를 호출하기 위해 필요하다. 여기서는 <em>apply</em> 블록 내부의 <code>this</code>가 DatePickerFragment를 참조하므로 this 다음에 <code>@CrimeFragment</code>를 지정했다.</p><blockquote><p><em>apply</em> 블록 내부의 <code>this</code>가 DatePickerFragment를 참조</p></blockquote><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/119652122-ae93ed00-be60-11eb-98f7-f6999424dfe5.png'></p><p>DialogFragment의 <code>show(FragmentManager, String)</code> 함수에서 첫 번째 인자인 프래그먼트매니저 인스턴스 참조는 null 값이 될 수 없는 타입니다. 그런데 Fragment.fragmentManager 속성은 null 값이 될 수 있는 타입이므로 첫 번재 인자로 전달 할 수 없다. 따라서 여기서는 Fragment의 <code>getParentFragmentManager()</code> 함수를 사용했는데 이 함수는 null이 아닌 FragmentManager 인스턴스를 반환하기 때문이다. 만일 <code>Fragment.requireFragmentManager()</code>가 호출되었는데 프래그먼트의 fragmentManager 속성이 null이면 IllegalStateException이 발생한다. 이 예외는 해당 프래그먼트와 연관된 프래그먼트 매니저가 없음을 나타낸다.</p><blockquote><p>날짜 선택 대화 상자</p></blockquote><p align = 'center'><img width = '200' src = 'https://user-images.githubusercontent.com/39554623/119654067-029fd100-be63-11eb-83fd-4c7cbb42e986.png'></p><h2 id="두-프래그먼트-간의-데이터-전달하기"><a class="markdownIt-Anchor" href="#두-프래그먼트-간의-데이터-전달하기"></a> 두 프래그먼트 간의 데이터 전달하기</h2><p><a href="https://june0122.github.io/2021/05/17/android-bnr-06/">인텐트 엑스트라를 사용한 두 액티비티 간의 데이터 전달</a>, <a href="https://june0122.github.io/2021/05/26/android-bnr-12/">콜백 인터페이스를 사용한 프래그먼트와 액티비티 간의 데이터 전달, 프래그먼트 인자를 사용한 액티비티로부터 프래그먼트로의 데이터 전달</a>에 관해서는 다른 글에 정리되어 있다.</p><p>본문에서는 같은 액티비티에 의해 호스팅되는 두 프래그먼트, 즉 CrimeFragment와 DatePickerFragment 간의 데이터 전달이 필요하다.</p><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/119649085-324bda80-be5d-11eb-9a3b-c4f164105e45.jpeg'></p><p>DatePickerFragment에 범죄 발생일자 <small>(Crime 객체의 date)</small>를 전달하기 위해 <code>newInstance(Date)</code> 함수를 작성하고, 이 함수의 인자로 전달된 발생일자를 DatePickerFragment의 프래그먼트 인자로 전달한다.</p><p>그다음에 대화상자에서 사용자가 선택한 날짜를 DatePickerFragment에서 CrimeFragment로 돌려준다. 더불어 사용자가 선택한 날짜를 인자로 받는 콜백 인스턴스 함수를 DatePickerFragment에 선언하기 위해 CrimeFragment가 모델 계층 <small>(Crime 객체)</small>과 자신의 뷰 <small>(범죄 상세 내역 화면)</small>를 변경한다.</p><blockquote><p>CrimeFragment와 DatePickerFragment 간의 처리 흐름</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119649074-30821700-be5d-11eb-8072-2063c4718276.jpeg'></p><h3 id="datepickerfragment에-데이터-전달하기"><a class="markdownIt-Anchor" href="#datepickerfragment에-데이터-전달하기"></a> DatePickerFragment에 데이터 전달하기</h3><p>DatePickerFragment에 현재의 범죄 발생일자를 전달하고자 여기서는 DatePickerFragment의 인자 번들에 해당 날짜를 저장한다.</p><p>일반적으로 프래그먼트 인자의 생성과 설정은 프래그먼트 생성자를 대체하는 <code>newInstance(...)</code> 함수에서 처리한다. 따라서 DatePickerFragment.kt에서 동반 객체 내부에 <code>newInstance(Date)</code> 함수를 추가하면 된다.</p><blockquote><p><code>newInstance(Date)</code> 함수를 추가하기 (DatePickerFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ARG_DATE = <span class="string">&quot;date&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatePickerFragment</span>: <span class="type">DialogFragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateDialog</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span>: Dialog &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newInstance</span><span class="params">(date: <span class="type">Date</span>)</span></span>: DatePickerFragment &#123;</span><br><span class="line">            <span class="keyword">val</span> args = Bundle().apply &#123; </span><br><span class="line">                putSerializable(ARG_DATE, date)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> DatePickerFragment().apply &#123; </span><br><span class="line">                arguments = args</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 <code>arguments</code>는 DatePickerFragment의 속성 <small>(최상위 슈퍼 클래스인 Fragment로부터 DialogFragment로 상속되고 다시 DatePickerFragment로 상속됨)</small>이며, 프래그먼트 인자를 갖는다.</p><p>그다음에 CrimeFragment에서 DatePickerFragment의 생성자 호출 코드를 삭제하고, <code>DatePickerFragment.newInstance(Date)</code></p><blockquote><p><code>newInstance(...)</code> 호출 추가하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    dateButton.setOnClickListener &#123;</span><br><span class="line"><span class="comment">//      DatePickerFragment().apply &#123;</span></span><br><span class="line">        DatePickerFragment.newInstance(crime.date).apply &#123;</span><br><span class="line">            show(<span class="keyword">this</span><span class="symbol">@CrimeFragment</span>.parentFragmentManager, DIALOG_DATE)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DatePickerFragment는 Date 객체의 데이터를 사용해서 DatePickerDialog를 초기화해야 한다. DatePickerDialog를 초기화하려면 월, 일, 년의 정수 값들이 필요하다. 그러나 Date 객체는 타임스탬프 형태이므로 이런 형식의 정수를 제공할 수 없다.</p><p>따라서 필요한 정수들을 얻으려면 Date 객체를 사용해서 Calendar 객체를 생성해야 한다. 그렇게 해야 이 Calendar 객체로부터 필요한 형태의 정수를 얻을 수 있다.</p><p>프래그먼트 인자로부터 얻은 Date 객체의 값을 Calendar 객체로 옮긴 후 DatePickerDialog를 초기화하는 코드를 DatePickerFragment.kt의 <code>onCreateDialog(Bundle?)</code>에 추가한다.</p><blockquote><p>DatePickerDialog 초기화하기 (DatePickerFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatePickerFragment</span>: <span class="type">DialogFragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateDialog</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span>: Dialog &#123;</span><br><span class="line">        <span class="keyword">val</span> date = arguments?.getSerializable(ARG_DATE) <span class="keyword">as</span> Date <span class="comment">// ①</span></span><br><span class="line">        <span class="keyword">val</span> calendar = Calendar.getInstance()</span><br><span class="line">        calendar.time = date <span class="comment">// ②</span></span><br><span class="line">        <span class="keyword">val</span> initialYear = calendar.<span class="keyword">get</span>(Calendar.YEAR)</span><br><span class="line">        <span class="keyword">val</span> initialMonth = calendar.<span class="keyword">get</span>(Calendar.MONTH)</span><br><span class="line">        <span class="keyword">val</span> initialDay = calendar.<span class="keyword">get</span>(Calendar.DAY_OF_MONTH)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DatePickerDialog(</span><br><span class="line">            requireContext(),</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            initialYear,</span><br><span class="line">            initialMonth,</span><br><span class="line">            initialDay</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제는 CrimeFragment가 DatePickerFragment에 범죄 발생일자를 전달할 수 있다.</p><h3 id="crimefragment로-데이터-반환하기"><a class="markdownIt-Anchor" href="#crimefragment로-데이터-반환하기"></a> CrimeFragment로 데이터 반환하기</h3><p>CrimeFragment가 DatePickerFragment로부터 사용자가 선택한 날짜를 돌려받으려면 두 프래그먼트 간의 관계를 계속해서 유지하고 관리하는 방법이 필요하다.</p><p>액티비티의 경우에 <code>startActivityForResult(...)</code> 함수를 호출하면 ActivityManager가 부모-자식 액티비티 관계를 계속해서 유지하고 관리한다. 따라서 자식 액티비티가 끝나면 이것의 결과를 어떤 액티비티가 받아야 하는지 ActivityManager가 안다.</p><h4 id="대상-프래그먼트-설정하기"><a class="markdownIt-Anchor" href="#대상-프래그먼트-설정하기"></a> 대상 프래그먼트 설정하기</h4><p>CrimeFragment를 DatePickerFragment의 <strong>대상 프래그먼트 <sup>target fragment</sup></strong> 로 만들면 액티비티의 경우와 유사한 연결을 만들 수 있다. 그리고 CrimeFragment 인스턴스와 DatePickerFragment 인스턴스 모두가 안드로이드 운영체제에 의해 소멸되었다가 다시 생성되더라도 두 프래그먼트 간의 연결은 자동으로 복구된다. 이렇게 하려면 다음 Fragment 함수를 호출하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTargetFragment(fragment: Fragment, requestCode: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>이 함수는 대상이 되는 프래그먼트와 요청 코드를 인자로 받는데, 이 요청 코드는 <code>startActivityForResult(...)</code>의 인자로 전달되는 것과 같은 의미를 갖는다.</p><p>이때 FragmentManager는 대상 프래그먼트와 요청 코드를 계속 관리한다. 대상을 설정했던 프래그먼트의 targetFragment와 targetRequestCode 속성을 사용하면 이 정보를 알 수 있다.</p><p>이제 CrimeFragment.kt에서 요청 코드의 상수를 정의하고 DatePickerFragment 인스턴스의 대상 프래그먼트로 CrimeFragment를 설정한다.</p><blockquote><p>대상 프래그먼트 설정하기 (CriemFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DIALOG_DATE = <span class="string">&quot;DialogDate&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_DATE = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        dateButton.setOnClickListener &#123;</span><br><span class="line">            DatePickerFragment.newInstance(crime.date).apply &#123;</span><br><span class="line">                setTargetFragment(<span class="keyword">this</span><span class="symbol">@CrimeFragment</span>, REQUEST_DATE)</span><br><span class="line">                show(<span class="keyword">this</span><span class="symbol">@CrimeFragment</span>.parentFragmentManager, DIALOG_DATE)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="대상-프래그먼트로-데이터-전달하기"><a class="markdownIt-Anchor" href="#대상-프래그먼트로-데이터-전달하기"></a> 대상 프래그먼트로 데이터 전달하기</h4><p>CrimeFragment와 DatePickerFragment가 연결되었으니 CrimeFragment로 데이터<small>(사용자가 선택한 날짜)</small>를 반환해야 한다. 여기서는 DatePickerFragment에 콜백 인터페이스를 생성한다. 이때 이 콜백 인터페이스는 CrimeFragment가 구현한다.</p><p>우선 DatePickerFragment에 <code>onDateSelected()</code>라는 하나의 함수를 갖는 콜백 인터페이스를 생성한다.</p><blockquote><p>콜백 인터페이스 생성하기 (DatePickerFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatePickerFragment</span>: <span class="type">DialogFragment</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Callbacks</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">onDateSelected</span><span class="params">(date: <span class="type">Date</span>)</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateDialog</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span>: Dialog &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음으로 Callbacks 인터페이스를 CrimeFragment에 구현한다. 이때 <code>onDateSelected(Date)</code>에서는 인자로 전달된 Date 객체를 Crime 객체의 date 속성<small>(CrimeFragment의 crime 속성이 참조함)</small>에 설정하고 UI를 변경한다.</p><blockquote><p>콜백 인터페이스 구현하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>(), DatePickerFragment.Callbacks &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDateSelected</span><span class="params">(date: <span class="type">Date</span>)</span></span> &#123;</span><br><span class="line">        crime.date = date</span><br><span class="line">        updateUI()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제는 CrimeFragment 사용자가 선택한 날짜를 처리할 수 있으므로 이 날짜를 DatePickerFragment가 전달해야 한다. DatePickerDialog의 리스너를 DatePickerFragment에 추가하면, 이 리스너에서는 사용자가 선택한 날짜를 CrimeFragment에 전달한다.</p><blockquote><p>사용자가 선택한 날짜 전달하기 (DatePickerFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatePickerFragment</span> : <span class="type">DialogFragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateDialog</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span>: Dialog &#123;</span><br><span class="line">        <span class="keyword">val</span> dateListener = DatePickerDialog.OnDateSetListener &#123; _: DatePicker, year: <span class="built_in">Int</span>, month: <span class="built_in">Int</span>, day: <span class="built_in">Int</span> -&gt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> resultDate: Date = GregorianCalendar(year, month, day).time</span><br><span class="line"></span><br><span class="line">            targetFragment?.let &#123; fragment -&gt;</span><br><span class="line">                (fragment <span class="keyword">as</span> Callbacks).onDateSelected(resultDate)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> date = arguments?.getSerializable(ARG_DATE) <span class="keyword">as</span> Date</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DatePickerDialog(</span><br><span class="line">            requireContext(),</span><br><span class="line"><span class="comment">//            null,</span></span><br><span class="line">            dateListener,</span><br><span class="line">            initialYear,</span><br><span class="line">            initialMonth,</span><br><span class="line">            initialDay</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OnDateSetListener는 사용자가 선택한 날짜를 받는데 사용된다. 첫 번째 매개변수는 결과가 산출되는 DatePicker 객체이며, 여기서는 사용하지 않으므로 밑줄 <code>_</code>을 지정하였다.<small>(코틀린에서 사용되지 않은 매개변수를 나타낼 때 밑줄을 사용)</small></p><p>선택된 날짜는 년, 월, 일 형식으로 제공된다. 그러나 이 값들을 Date 타입으로 CrimeFragment에 전달해야 하므로 GregorianCalendar의 인자로 이 값들을 전달한 후 <code>time</code> 속성을 사용해서 Date 객체를 얻는다.</p><p><code>targetFragment</code> 속성은 DatePickerFragment와 연관된 프래그먼트<small>(여기선 CrimeFragment)</small> 인스턴스 참조를 갖는다. 이 속성은 null 값을 가질 수 있으므로 <em>null에 안전한 let 블록이 사용되었다.</em> let 블록에서는 <code>targetFragment</code> 속성이 참조하는 프래그먼트 인스턴스의 타입을 Callbacks 인터페이스 타입으로 변환한 후, 새로운 날짜를 인자로 전달해 <code>onDateSelected()</code> 함수를 호출한다. 따라서 CrimeFragment에 구현된 <code>onDateSelected()</code> 함수가 호출되어 실행되므로, 사용자가 선택한 날자가 CrimeFragment에 전달될 수 있다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Dialog/">Dialog</category>
      
      
      <comments>http://june0122.github.io/2021/05/28/android-bnr-13/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Codility] FrogJmp</title>
      <link>http://june0122.github.io/2021/05/28/codility-frog-jmp/</link>
      <guid>http://june0122.github.io/2021/05/28/codility-frog-jmp/</guid>
      <pubDate>Fri, 28 May 2021 01:19:59 GMT</pubDate>
      
      <description>Lesson 3 - Time Complexity : FrogJmp</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="lesson-3-time-complexity-frogjmp"><a class="markdownIt-Anchor" href="#lesson-3-time-complexity-frogjmp"></a> Lesson 3 - Time Complexity : <a href="https://app.codility.com/programmers/lessons/3-time_complexity/frog_jmp/">FrogJmp</a></h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p><code>ceil()</code> 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(X: <span class="type">Int</span>, Y: <span class="type">Int</span>, D: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ceil((Y - X) / D.toDouble()).toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>ceil()</code> 사용하지 않고 풀기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(X: <span class="type">Int</span>, Y: <span class="type">Int</span>, D: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (X == Y) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> quotient = (Y - X) / D </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (X + D * quotient &lt; Y) <span class="keyword">return</span> quotient + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quotient</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Codility/">Codility</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Codility/">Codility</category>
      
      
      <comments>http://june0122.github.io/2021/05/28/codility-frog-jmp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Codility] PermMissingElem</title>
      <link>http://june0122.github.io/2021/05/28/codility-perm-missing-elem/</link>
      <guid>http://june0122.github.io/2021/05/28/codility-perm-missing-elem/</guid>
      <pubDate>Fri, 28 May 2021 01:19:53 GMT</pubDate>
      
      <description>Lesson 3 - Time Complexity : PermMissingElem</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="lesson-3-time-complexity-permmissingelem"><a class="markdownIt-Anchor" href="#lesson-3-time-complexity-permmissingelem"></a> Lesson 3 - Time Complexity : <a href="https://app.codility.com/programmers/lessons/3-time_complexity/perm_missing_elem/">PermMissingElem</a></h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>케이스 하나하나 처리해주기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(A: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    A.sort()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (A.isEmpty() || A[<span class="number">0</span>] != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (A.last() != A.size + <span class="number">1</span>) <span class="keyword">return</span> A.size + <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until A.size - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] + <span class="number">1</span> != A[i + <span class="number">1</span>]) <span class="keyword">return</span> A[i] + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다소 무식한 방법이라 할 수 있겠다.</p><blockquote><p>BooleanArray 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(A: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> B = BooleanArray(A.size + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> A.indices) &#123;</span><br><span class="line">        B[A[i]] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span> until B.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[j].not()) <span class="keyword">return</span> j</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>등차수열의 합공식 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(A: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> n = (A.size + <span class="number">1</span>).toLong()</span><br><span class="line">    <span class="keyword">val</span> sequence = n * (<span class="number">1</span> + n) / <span class="number">2L</span></span><br><span class="line">    <span class="keyword">val</span> sum = A.sum().toLong()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (sequence - sum).toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align = 'center'><img width = '150' src = 'https://user-images.githubusercontent.com/39554623/119914574-7513cc80-bf9b-11eb-97c0-f16effd609d0.png'></p><p>구글 검색을 해보니 등차수열의 합공식을 이용하여 <a href="https://medium.com/@ydh0256/codility-lesson-3-1-permmissingelem-e7477d1a180d">멋지게 풀이한 코드</a>가 있어서 참고하였다.</p><p>배열 A는 <strong>1 ~ N+1</strong> 까지의 범위를 가진 N개의 원소로 이루어져 있고, 1씩 증가하는 등차수열의 형태를 보여준다. 비어있는 원소 하나를 찾는 문제이므로 등차수열의 합과 배열 A 요소들의 합의 차이가 비어있는 원소의 값이다.</p><p>주의할 점은 배열 A가 <strong>0 ~ 100,000</strong> 범위의 크기를 가져서 <code>Int</code> 타입으로 계산할 경우 overflow가 발생하므로 <code>Long</code> 타입으로 변환해줘야 한다.</p><p>위의 모든 코드들은 아래의 결과를 보여준다.</p><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/119912976-8fe44200-bf97-11eb-9048-188cc80bb251.png'></p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Codility/">Codility</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Codility/">Codility</category>
      
      
      <comments>http://june0122.github.io/2021/05/28/codility-perm-missing-elem/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Fragment간 데이터 전달</title>
      <link>http://june0122.github.io/2021/05/26/android-bnr-12/</link>
      <guid>http://june0122.github.io/2021/05/26/android-bnr-12/</guid>
      <pubDate>Tue, 25 May 2021 23:45:13 GMT</pubDate>
      
      <description>&lt;b&gt;프래그먼트 인자 &lt;sup&gt;fragment argument&lt;/sup&gt;&lt;/b&gt;는 프래그먼트 생애에 걸쳐 보존된다. 구성 변경이 생기더라도 프래그먼트 매니저가 새 프래그먼트 인스턴스를 생성하면서 프래그먼트 인자를 다시 첨부하기 때문이다. 따라서 새 프래그먼트는 첨부된 인자 번들을 사용해서 자신의 상태 데이터를 다시 생성할 수 있다.</description>
      
      
      
      <content:encoded><![CDATA[<p>RecyclerView의 특정 항목을 누르면 MainActivity에서 RecyclerView가 존재하는 프래그먼트를 상세 항목을 보여주는 프래그먼트의 새로운 인스턴스로 교체하여 선택된 데이터의 상세 내역을 보여주도록 해보자. 이를 위해선 아래의 방법들을 알고 있어야 한다.</p><ul><li>호스팅 액티비티가 프래그먼트들을 바꿔치기해서 이동을 구현하는 방법</li><li><strong>프래그먼트 인자 <sup>fragment argument</sup></strong> 를 사용해서 프래그먼트 인스턴스에게 데이터를 전달하는 방법</li><li>UI 변경에 따라 LiveData를 <strong>변환 <sup>transform</sup></strong> 하는 방법</li></ul><h2 id="단일-액티비티-프래그먼트의-우두머리"><a class="markdownIt-Anchor" href="#단일-액티비티-프래그먼트의-우두머리"></a> 단일 액티비티: 프래그먼트의 우두머리</h2><p>이전에는 한 액티비티가 다른 액티비티를 시작시켰지만, 본문의 예시 앱인 CriminalIntent 앱에서는 <strong>단일 액티비티 아키텍쳐 <sup>single activity architecture</sup></strong> 를 사용한다. 단일 액티비티 아키텍처를 사용하는 앱은 하나의 액티비티와 다수의 프래그먼트를 가지며, 그 액티비티는 사용자 이벤트에 반응해 프래그먼트들을 상호 교체한다.</p><p>리스트의 특정 범죄 데이터를 사용자가 누르면 CrimeListFragment로부터 CrimeFragment로의 이동(혹은 교체)을 구현하기 위해 호스팅 액티비티의 프래그먼트 매니저에서 프래그먼트 트랜잭션을 시작시킨다 그리고 이 일을 수행하는 코드를 CrimeListFragment의 <code>CrimeHolder.onClick(view)</code>에 둔다. 이때 <code>onClick(View)</code>에서는 MainActivity의 FragmentManager 인스턴스를 생성한 후 CrimeListFragment를 CrimeFragement로 교체하는 트랜잭션을 커밋한다.</p><p>그런데 CrimeListFragment의 <code>CrimeHolder.onClick(view)</code>의 코드를 아래와 같이 작성하면 <strong>작동은 잘 되지만 바람직한 방법은 아니다.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> fragment = CrimeFragment.newInstance(crime.id)</span><br><span class="line">    <span class="keyword">val</span> fm = activity.supportFragmentManager</span><br><span class="line">    fm.beginTransaction()</span><br><span class="line">        .replace(R.id.fragment_container, fragment)</span><br><span class="line">        .commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>프래그먼트는 독자적이고 구성 가능한 단위가 되어야 하는데 그렇지가 않기 때문이다. 이처럼 액티비티의 FragmentManager에서 다른 프래그먼트로 교체하는 일을 액티비티가 아닌 프래그먼트에서 하려면 이 프래그먼트는 자신을 호스팅하는 액티비티가 어떤 레이아웃을 갖고 어떻게 작동하는지 알아야 한다. 따라서 프래그먼트의 기본 취지에 어긋난다.</p><p>즉, 위의 코드에서 CrimeListFragment는 CrimeFragment를 MainActivity에 추가하면서 MainActivity의 레이아웃에 fragment_container가 있을 것이라고 가정한다. 그러나 이런 일은 CrimeListFragment의 호스팅 액티비티인 MainActivity가 해야 할 일이다.</p><p>따라서 여기서는 프래그먼트의 독립성을 유지하기 위해 프래그먼트에 콜백 인터페이스를 정의하고 호스팅 액티비티가 해당 콜백 인터페이스를 구현해 프래그먼트 교체를 수행하게 한다.</p><h3 id="프래그먼트-콜백-인터페이스"><a class="markdownIt-Anchor" href="#프래그먼트-콜백-인터페이스"></a> 프래그먼트 콜백 인터페이스</h3><p>프래그먼트 교체 기능을 호스팅 액티비티에 위임하기 위해 프래그먼트에는 Callbacks라는 이름의 커스텀 콜백 인터페이스를 정의하고, 이 인터페이스에는 프래그먼트가 필요로 하는 일을 수행하게 하는 함수를 정의한다. 그리고 이 프래그먼트를 호스팅하는 모든 액티비티는 반드시 해당 인터페이스를 구현해야 한다.</p><p>콜백 인터페이스를 사용하면 어떤 액티비티가 호스팅하는지 알 필요 없이 프래그먼트가 자신을 호스팅하는 액티비티의 함수들을 호출할 수 있다.</p><p>콜백 인터페이스를 사용해서 CrimeListFragment의 클릭 이벤트 처리를 호스팅 액티비티에게 위임하자.</p><blockquote><p>콜백 인터페이스 추가하기 (CrimeListFragment.kt)</p></blockquote><p>하나의 콜백 함수를 갖는 <strong>Callbacks</strong> 인터페이스를 선언하고 Callbacks를 구현하는 객체 참조를 저장하기 위해 callbacks 속성을 추가한다. 그리고 <code>onAttach(context)</code>와 <code>onDetach()</code>를 오버라이드해 callbacks 속성을 설정 또는 설정 해제한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 호스팅 액티비티에서 구현할 인터페이스</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Callbacks</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">onCrimeSelected</span><span class="params">(crimeId: <span class="type">UUID</span>)</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// callbacks 속성 추가</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> callbacks: Callbacks? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// callbacks 속성 설정</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAttach</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttach(context)</span><br><span class="line">        callbacks = context <span class="keyword">as</span> Callbacks?</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(...)</span></span>: View? &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// callbacks 속성 해제</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDetach</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDetach()</span><br><span class="line">        callbacks = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="중요supsup"><a class="markdownIt-Anchor" href="#중요supsup"></a> 중요<sup>★</sup></h4><p><code>Fragment.onAttach(Context)</code> 생명주기 함수는 <strong>프래그먼트가 호스팅 액티비티에 연결될 때 호출</strong>된다. 여기서는 <code>onAttach(...)</code>의 인자로 전달된 Context 객체의 참조를 callbacks 속성에 저장하며, CrimeListFragment를 호스팅하는 액티비티 인스턴스가 Context 객체다.</p><p><strong>Activity는 Context의 서브 클래스다.</strong> 따라서 <code>onAttach(...)</code>의 인자로 Activity 타입을 전달해도 되지만, 슈퍼 타입인 <strong>Context를 전달하는 것이 코드의 유연성이 좋다.</strong> 또한, <code>onAttach(Activity)</code>는 향후 API 버전에서 없어질 수 있으므로 <sup>deprecated</sup>, <code>onAttach(Context)</code>를 사용한다.</p><p><code>onAttach(Context)</code>와 반대로, <strong>프래그먼트가 액티비티에서 분리될 때 호출</strong>되는 생명주기 함수인 <code>Fragment.onDetach()</code>에서는 callbacks 속성을 null로 설정한다. 이 함수가 호출될 때는 호스팅 액티비티를 사용할 수 없거나 호스팅 액티비티가 계속 존재한다는 보장이 없기 때문이다.</p><p><code>onAttach(Context)</code>에서 인자로 전달된 Context 객체의 참조를 callbacks 속성에 지정할 때는 <code>CrimeListFragment.Callbacks</code> 타입으로 변환한다. 따라서 CrimeListFragment를 호스팅하는 액티비티는 <strong>반드시 <code>CrimeListFragment.Callbacks</code> 인터페이스를 구현해야 한다.</strong></p><blockquote><p>호스팅 액티비티의 <code>onCrimeSelected(...)</code> 호출하기 (CrimeListFragment.kt)</p></blockquote><p>어떤 액티비티가 호스팅을 하든 이제는 CrimeListFragment가 호스팅 액티비티의 콜백 구현 함수 <sub>(여기서는 <code>onCrimeSelected(UUID)</code>)</sub> 를 호출할 수 있게 되었다. <code>CrimeListFragment.Callbacks</code> 인터페이스를 구현하는 호스팅 액티비티면 어떠한 것도 가능하다.</p><p>현재는 범죄 리스트의 특정 항목을 누르면 CrimeListFragment의 내부 클래스인 CrimeHolder의 <code>onClick(View)</code>가 호출되고 토스트 메시지만 보여주므로, Callbacks 인터페이스를 통해 호스팅 액티비티의 <code>onCrimeSelected(UUID)</code>를 호출하도록 변경하고 호스팅 액티비티가 Callbacks 인터페이스의 <code>onCrimeSelected(UUID)</code> 구현하도록 변경한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view), View.OnClickListener &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(crime: <span class="type">Crime</span>)</span></span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//            Toast.makeText(context, &quot;$&#123;crime.title&#125; pressed!&quot;, Toast.LENGTH_SHORT).show()</span></span><br><span class="line">            callbacks?.onCrimeSelected(crime.id)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>호스팅 액티비티에서 콜백 인터페이스 구현하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), CrimeListFragment.Callbacks &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCrimeSelected</span><span class="params">(crimeId: <span class="type">UUID</span>)</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;MainActivity.onCrimeSelected: <span class="variable">$crimeId</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LogCat을 확인해보면 범죄 리스트의 각 항목을 클릭할 때마다 MainActivity의 <code>onCrimeSelected(UUID)</code>가 호출되어 로그 메시지가 나타난다. 이 함수는 Callbacks 인터페이슬르 통해 CrimeListFragment로부터 호출된 것이다.</p><h3 id="프래그먼트-교체하기"><a class="markdownIt-Anchor" href="#프래그먼트-교체하기"></a> 프래그먼트 교체하기</h3><p>콜백 인터페이스를 제대로 연결하였으니 사용자가 CrimeListFragment의 범죄 리스트에서 특정 항목을 누르면 MainActivity의 <code>onCrimeSelected(UUID)</code>에서 CrimeListFragment가 CrimeFragment 인스턴트로 교체되도록 변경한다. 현재는 콜백으로 전달되는 Crime 객체의 ID를 사용하지 않는다.</p><blockquote><p>CrimeListFragment를 CrimeFragment로 교체하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), CrimeListFragment.Callbacks &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCrimeSelected</span><span class="params">(crimeId: <span class="type">UUID</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> fragment = CrimeFragment()</span><br><span class="line">        supportFragmentManager</span><br><span class="line">            .beginTransaction()</span><br><span class="line">            .replace(R.id.fragment_container, fragment)</span><br><span class="line">            .commit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FragmentTransaction.replace(Int, Fragment)</code>는 액티비티에 현재 호스팅된 프래그먼트를 두 번째 인자로 전달된 프래그먼트로 교체하여 첫 번째 인자로 전달된 리소스 ID를 갖는 컨테이너에 넣는다. 만일 기존에 호스팅된 프래그먼트가 없으면 <code>FragmentTransaction.add(Int, Fragment)</code>를 호출할 때와 같게 새로운 프래그먼트로 추가된다.</p><p align = 'center'><img width = '200' src = 'https://user-images.githubusercontent.com/39554623/119394546-4385d180-bd0d-11eb-98e5-9702783fca0b.gif'></p><p>지금은 범죄의 상세 내역 화면이 비어 있는데, 어떤 Crime 객체를 보여줄 것인지 CrimeFragment에게 알려주지 않았기 때문이다. 이 작업은 잠시 후에 하고 프래그먼트 간의 이동을 구현하는데 추가로 해야 할 작업을 먼저 실시하자.</p><p>현재 화면에서 백 버튼을 클릭해보면 범죄 리스트를 보여주는 CrimeListFragment 화면으로 돌아가지 않는다. 앱을 시작할 당시에 실행되었던 MainActivity 인스턴스만이 앱의 백 스택에 존재했기 때문이다. 프래그먼트 교체 트랜잭션을 백 스택에 추가해서 구현하여 이전 프래그먼트로 돌아가도록 구현한다.</p><blockquote><p>플래그먼트 트랜잭션을 백 스택에 추가하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), CrimeListFragment.Callbacks &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCrimeSelected</span><span class="params">(crimeId: <span class="type">UUID</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> fragment = CrimeFragment()</span><br><span class="line">        supportFragmentManager</span><br><span class="line">            .beginTransaction()</span><br><span class="line">            .replace(R.id.fragment_container, fragment)</span><br><span class="line">            .addToBackStack(<span class="literal">null</span>) <span class="comment">// 백 스택에 추가</span></span><br><span class="line">            .commit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이처럼 트랜잭션을 백 스택에 추가하면 사용자가 백 버튼을 누를 때 해당 트랜잭션이 취소되면서 이전 상태로 복원되며, 여기서는 CrimeFragment가 CrimeListFragment로 교체된다.</p><p><code>FragmentTransaction.addToBackStack(String)</code>을 호출할 때 백 스택 상태의 이름을 나타내는 문자열을 인자로 전달할 수 있다. 그러나 여기서는 그럴 필요가 없어서 null을 전달하였다.</p><h2 id="프래그먼트-인자"><a class="markdownIt-Anchor" href="#프래그먼트-인자"></a> 프래그먼트 인자</h2><p>프래그먼트 인자 <sup>fragment argument</sup>를 사용하면 프래그먼트에 속하는 어딘가에 데이터를 저장할 수 있다. 여기서 프래그먼트에 속하는 <em>‘어딘가’</em> 는 <strong>인자 번들 <sup>argument bundle</sup></strong> 을 말한다. 프래그먼트는 자신의 부모 액티비티나 다른 외부 소스에 의존하지 않고 인자 번들로부터 데이터를 가져올 수 있다.</p><p>프래그먼트 인자는 프래그먼트의 캡슐화를 도와준다. 그리고 캡슐화가 잘된 프래그먼트는 재사용할 수 있는 구성 요소가 되므로 어떤 액티비티에도 쉽게 호스팅될 수 있다.</p><p>프래그먼트 인자를 생성하기 위해 우선 <strong>Bundle</strong> 객체를 생성한다. 이 Bundle 객체는 액티비티의 인텐트 엑스트라와 마찬가지로 키와 값의 쌍으로 된 데이터를 포함하며, 각 쌍의 데이터를 인자라고 한다. 그다음에 타입마다 따로 있는 Bundle의 <code>put</code> 함수들을 이용해서 인자들을 Bundle 객체에 추가한다.</p><blockquote><p>Bunlde 객체에 인자들을 추가하는 예시</p></blockquote><p>모든 프래그먼트 인스턴스는 자신에게 첨부된 Bundle 객체에 프래그먼트 인자들을 저장할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> args = Bundle().apply &#123;</span><br><span class="line">    putSerializable(ARG_MY_OBJECT, myObject)</span><br><span class="line">    putInt(ARG_MY_INT, myInt)</span><br><span class="line">    putCharSequence(ARG_MY_STRING, myString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="인자를-프래그먼트에-첨부하기"><a class="markdownIt-Anchor" href="#인자를-프래그먼트에-첨부하기"></a> 인자를 프래그먼트에 첨부하기</h3><p>인자 번들을 프래그먼트에 추가할 때는 <code>Fragment.setArguments(Bundle)</code>을 호출한다. 단, 프래그먼트가 생성되어 해당 프래그먼트가 액티비티에 추가되기 전에 프래그먼트에 첨부해야 한다.</p><p>이렇게 하려면 <code>newInstance(...)</code>라는 이름의 함수를 포함하는 동반 객체 <sup>companion object</sup>를 Fragment 클래스에 추가하는 것이 좋다. 이 함수에서는 프래그먼트 인스턴스와 번들 인스턴스를 생성하고 번들 인스턴스에 인자를 저장한 후 프래그먼트 인자로 첨부한다.</p><p>그리고 호스팅 액티비티가 프래그먼트의 인스턴스를 필요로 할 때 이 프래그먼트의 생성자를 직접 호출하는 대신 <code>newInstance(...)</code> 함수를 호출하면 된다. 그러면 이 함수에서 필요한 인자들을 전달할 수 있다.</p><blockquote><p><code>newInstance(UUID)</code> 함수 작성하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ARG_CRIME_ID = <span class="string">&quot;crime_id&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newInstance</span><span class="params">(crimeId: <span class="type">UUID</span>)</span></span>: CrimeFragment &#123;</span><br><span class="line">            <span class="keyword">val</span> args = Bundle().apply &#123;</span><br><span class="line">                putSerializable(ARG_CRIME_ID, crimeId)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> CrimeFragment().apply &#123; </span><br><span class="line">                arguments = args</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>newInstance(UUID)</code> 함수에서는 UUID 타입의 인자를 받아서 인자 번들 인스턴스를 생성하고 인자를 저장하며, 프래그먼트 인스턴스를 생성한 후 인자 번들을 프래그먼트에 첨부한다.</li><li>아래의 동반 객체 리턴 값에서 <code>arguments</code>는 Fragment의 속성이며, 코틀린에서는 속성에 값을 설정할 때 setter를 자동 호출한다. 따라서 끝에 있는 <code>arguments = args</code>는 <code>setArguments(args)</code>와 같다.</li></ul><p>다음으로 MainActivity에서 CrimeFragment 인스턴스를 생성할 때 UUID를 인자로 전달해 <code>CrimeFragment.newInstance(UUID)</code>를 호출하도록 변경한다.</p><blockquote><p>`CrimeFragment.newInstance(UUID) 사용하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), CrimeListFragment.Callbacks &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCrimeSelected</span><span class="params">(crimeId: <span class="type">UUID</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//        val fragment = CrimeFragment()</span></span><br><span class="line">        <span class="keyword">val</span> fragment = CrimeFragment.newInstance(crimeId)</span><br><span class="line">        supportFragmentManager</span><br><span class="line">            .beginTransaction()</span><br><span class="line">            .replace(R.id.fragment_container, fragment)</span><br><span class="line">            .addToBackStack(<span class="literal">null</span>)</span><br><span class="line">            .commit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드의 독립성이 액티비티와 프래그먼트 양쪽 모두에 필요한 것은 아니다. 즉, MainActivity는 CrimeFragment에 관해 많은 것을 알아야 한다. 예를 들면, CrimeFragment가 <code>newInstance(UUID)</code> 함수를 갖고 있다는 것 등이다.</p><p>호스팅 액티비티는 자신의 프래그먼트들을 호스팅하는 방법을 자세히 알아야 하므로 지극히 정상적이다. 이와 달리 프래그먼트는 자신의 호스팅 액티비티를 자세히 알 필요가 없다.</p><h3 id="프래그먼트-인자-가져오기"><a class="markdownIt-Anchor" href="#프래그먼트-인자-가져오기"></a> 프래그먼트 인자 가져오기</h3><p>프래그먼트가 자신에게 전달된 인자를 액세스할 때는 Fragment 클래스의 <code>arguments</code> 속성을 참조하면 된다. 그런 다음에 Bundle의 <code>get</code> 함수들 중 하나를 호출하면 된다.</p><blockquote><p>프래그먼트 인자에서 범죄 데이터 ID 얻기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;CrimeFragment&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ARG_CRIME_ID = <span class="string">&quot;crime_id&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        crime = Crime()</span><br><span class="line">        <span class="keyword">val</span> crimeId: UUID = arguments?.getSerializable(ARG_CRIME_ID) <span class="keyword">as</span> UUID</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;args bundle crime ID: <span class="variable">$crimeId</span>&quot;</span>)</span><br><span class="line">        <span class="comment">// 궁극적으로는 데이터베이스로부터 데이터를 로드해야 한다.</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>코틀린에서는 속성을 참조할 때 getter를 자동 호출해준다. 따라서 끝에 새로 추가한 코드의 <code>arguments</code> 대신 <code>getArguments()</code>를 사용해도 된다.</li></ul><h2 id="상세-내역-화면에-보여줄-crime-객체를-livedata-변환으로-얻기"><a class="markdownIt-Anchor" href="#상세-내역-화면에-보여줄-crime-객체를-livedata-변환으로-얻기"></a> 상세 내역 화면에 보여줄 Crime 객체를 LiveData 변환으로 얻기</h2><p>CrimeFragment가 범죄 데이터 ID를 갖게 되었으니 이 ID를 갖는 범죄 데이터가 화면에 보이도록 데이터베이스에서 범죄 데이터(Crime 객체)를 가져와보자. 이렇게 하기 위해 ViewModel의 서브 클래스로 CrimeDetailViewModel을 생성해 데이터베이스를 검색할 것이다. ViewModel을 사용하면 장치 회전 시에도 데이터가 보존되므로 데이터베이스 검색 쿼리를 매번 다시 할 필요가 없기 때문이다.</p><p>지정된 ID를 갖는 범죄 데이터를 CrimeFragment가 CrimeDetailViewModel에 요청하면 리포지터리의 <code>getCrime(UUID)</code>를 호출한 후 쿼리 결과로 받은 범죄 데이터를 CrimeFragment에 전달한다. 이때 리포지터리와 CrimeDetailViewModel, 그리고 CrimeFragment 간의 데이터 전달을 쉽게 하기 위해 Crime 객체를 갖는 <strong>LiveData</strong>를 사용한다.</p><blockquote><p>CrimeDetailViewModel 생성하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeDetailViewModel</span></span>(): ViewModel() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeRepository = CrimeRepository.<span class="keyword">get</span>()</span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeIdLiveData = MutableLiveData&lt;UUID&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ③</span></span><br><span class="line">    <span class="keyword">var</span> crimeLiveData: LiveData&lt;Crime?&gt; =</span><br><span class="line">        Transformations.switchMap(crimeIdLiveData) &#123; crimeId -&gt;</span><br><span class="line">            crimeRepository.getCrime(crimeId)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ④</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadCrime</span><span class="params">(crimeId: <span class="type">UUID</span>)</span></span> &#123;</span><br><span class="line">        crimeIdLiveData.value = crimeId</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① <code>crimeRepository</code> 속성은 CrimeRepository 인스턴스 참조를 보존한다. 이렇게 속성을 사용한 이유는 향후에 CrimeDetailViewModel의 여러 곳에서 CrimeRepository 인스턴스를 사용하기 때문이다.</p><p>② <code>crimeIdLiveData</code> 속성은 변경 가능한 UUID 타입의 데이터를 저장한 LiveData를 참조한다. 여기서는 CrimeFragment가 현재 화면에 보여주거나 보여줄 범죄 데이터 ID가 LiveData에 저장된 데이터다. CrimeDetailViewModel 인스턴스가 최초 생성될 때는 <code>crimeIdLiveData</code>가 설정되지 않는다. 그러나 향후에 CrimeFragment 인스턴스가 생성될 때 CrimeFragment의 <code>onCreate(Bundle?)</code>에서 <code>CrimeDetailViewModel.loadCrime(UUID)</code>를 호출하므로, 이때 <code>crimeIdLiveData</code>가 범죄 ID로 설정되어 어떤 범죄 데이터를 가져올 것인지 CrimeDetailViewModel이 알 수 있다.</p><p>③ <code>crimeLiveData</code> 속성은 상세 내역 화면에 보여줄 Crime 객체를 저장한 LiveData를 참조하며, 이 LiveData는 <code>Transformations.switchMap(crimeIdLiveData) &#123;...&#125;</code>로부터 반환한다. 그리고 <code>switchMap(crimeIdLiveData) &#123;...&#125;</code>에서는 인자로 전달된 <code>crimeIdLiveData</code>의 범죄 ID를 갖는 범죄 데이터를 데이터베이스로부터 가져와서 LiveData로 반환한다.</p><p>Transformations 클래스는 두 LiveData 객체 간의 변환을 해주는 함수들을 갖고 있다. <code>switchMap(LiveData&lt;X&gt;, Function&lt;X, LiveData&lt;Y&gt;!&gt;)</code> 함수에서는 첫 번째 인자로 전달된 LiveData에 설정된 각 값에 대해 두 번째 인자의 함수를 적용해서 변환하며, 이 결과를 LiveData로 반환한다.</p><p><code>switchMap(...)</code> 함수에는 <code>crimeIdLiveData</code> 속성이 첫 번째 인자로 전달되고, 두 번째 인자의 변환 함수로는 람다식이 지정되었다. 이 람다식의 <code>crimeRepository.getCrime(crimeId)</code> 함수는 <code>crimeIdLiveData</code> 속성값(범죄 ID)을 갖는 범죄 데이터를 데이터베이스에서 검색해 가져와서 Crime 객체를 갖는 LiveData로 반환한다. 그리고 이 LiveData가 <code>crimeIdLiveData</code> 속성에 설정된다. 이렇게 상세 내역 화면에 보여줄 Crime 객체를 저장한 LiveData가 준비된다.</p><blockquote><p>CrimeFragment를 CrimeDetailViewModel에 연결하기 (CrimeFragment.kt)</p></blockquote><p><code>onCreate(...)</code>에서 CrimeDetailViewModel의 <code>loadCrime(UUID)</code>를 호출해 CrimeFragment를 CrimeDetailViewModel과 연결한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crime: Crime</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeDetailViewModel: CrimeDetailViewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(CrimeDetailViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        crime = Crime()</span><br><span class="line">        <span class="keyword">val</span> crimeId: UUID = arguments?.getSerializable(ARG_CRIME_ID) <span class="keyword">as</span> UUID</span><br><span class="line"><span class="comment">//        Log.d(TAG, &quot;args bundle crime ID: $crimeId&quot;)</span></span><br><span class="line">        crimeDetailViewModel.loadCrime(crimeId)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음으로 CrimeDetailViewModel의 <code>crimeLiveData</code>가 변경되는지 관찰해서 새 데이터가 있으면 UI를 변경하도록 CrimeFragment를 변경한다. 그리고 Observer의 import문도 추가한다.</p><blockquote><p>범죄 데이터 변경 관찰하기 (CrimeFragment.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModelProvider</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.Observer</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crime: Crime</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(...)</span></span>: View? &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        crimeDetailViewModel.crimeLiveData.observe(</span><br><span class="line">            viewLifecycleOwner,</span><br><span class="line">            Observer &#123; crime -&gt;</span><br><span class="line">                crime?.let &#123;</span><br><span class="line">                    <span class="keyword">this</span>.crime = crime</span><br><span class="line">                    updateUI()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">        titleField.setText(crime.title)</span><br><span class="line">        dateButton.text = crime.date.toString()</span><br><span class="line">        solvedCheckBox.isChecked = crime.isSolved</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CrimeFragment는 자신의 <code>crime</code> 속성에 Crime 객체 참조를 따로 갖고 있다. 이 속성은 사용자가 화면에서 변경한 현재의 데이터를 갖는 Crime 객체를 나타낸다. 반면에 <code>CrimeDetailViewModel.crimeLiveData</code>의 Crime 객체 데이터는 데이터베이스에 현재 저장된 것을 나타낸다. CrimeFragment의 crime 속성을 사용해서 현재 화면의 데이터를 데이터베이스에 변경하는 것은 잠시 후에 다룬다.</p><blockquote><p>CriminalIntent 앱의 백 스택</p></blockquote><p align = 'center'><img width = '200' src = 'https://user-images.githubusercontent.com/39554623/119422693-91fe9480-bd3c-11eb-8809-1e86f2be6e21.gif'></p><h4 id="애니메이션-깜빡거림-없애기"><a class="markdownIt-Anchor" href="#애니메이션-깜빡거림-없애기"></a> 애니메이션 깜빡거림 없애기</h4><p>위의 이미지에서 수갑 이미지가 있는 범죄 데이터를 선택하면 CrimeFragment가 상세 내역 화면을 보여줄 때 CheckBox의 표시가 깜빡거리면서 나타나는 것을 볼 수 있다. 이것은 정상으로, 사용자가 범죄 리스트에서 특정 데이터를 선택할 때 CrimeFragment가 시작되어 해당 데이터의 데이터베이스 쿼리가 시작된다. 그리고 쿼리가 끝나면 CrimeFragment의 <code>CrimeDetailViewModel.crimeLiveData</code> 옵저버가 실행되어 각 위젯의 데이터(제목, 발생일자, 해결 여부)를 화면에 보여준다. 이때 CheckBox는 클릭 시 생동감을 주기 위해 기본적으로 애니메이션을 수행해서 깜빡거리는 것처럼 보인다. 이런 깜빡거림은 <code>View.jumpDrawablesToCurrentState()</code>를 호출해서 애니메이션을 생략하면 해결할 수 있다.</p><p>CheckBox의 깜빡거림만이 아닌 상세 내역 화면 전체가 나타나는데 Delay가 생긴다면, 일정 개수의 범죄 데이터를 메모리에 미리 로드한 후 공유되는 곳에 보존해서 사용하면 된다. 본문의 앱에서는 이런 시간 지연이 없으니 필요에 따라 애니메이션 정도만 생략해주면 된다.</p><h2 id="데이터베이스-변경하기"><a class="markdownIt-Anchor" href="#데이터베이스-변경하기"></a> 데이터베이스 변경하기</h2><p>사용자가 상세 내역 화면을 벗어날 때 사용자가 변경한 데이터를 데이터베이스에 저장해야 한다.</p><p>우선 기존의 범죄 데이터를 변경하는 함수와 새로운 데이터를 추가하는 함수를 <strong>CrimeDao</strong>에 추가한다. 단, 새 데이터 추가 함수는 <a href="">링크 추가 예정</a>에서 다룬다.</p><blockquote><p>데이터베이스 함수 추가하기 (database/CrimeDao.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CrimeDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">&quot;SELECT * FROM crime&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrimes</span><span class="params">()</span></span>: LiveData&lt;List&lt;Crime&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">&quot;SELECT * FROM crime WHERE id=(:id)&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrime</span><span class="params">(id: <span class="type">UUID</span>)</span></span>: LiveData&lt;Crime?&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateCrime</span><span class="params">(crime: <span class="type">Crime</span>)</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addCrime</span><span class="params">(crime: <span class="type">Crime</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>변경 함수와 추가 함수의 애노테이션에는 매개변수를 지정하지 않아도 Room이 적합한 SQL 명령을 생성한다.</p><p><code>updateCrime()</code> 함수에는 <code>@Update</code> 애노테이션을 사용한다. 이 함수는 Crime 객체를 인자로 받아 이 객체에 저장된 ID를 사용해서 데이터베이스 테이블의 관련 행을 찾은 후 이 객체의 데이터로 변경한다.</p><p><code>addCrime()</code> 함수에는 <code>@Insert</code> 애노테이션을 사용한다. 이 함수는 인자로 받은 Crime 객체의 데이터를 데이터베이스 테이블에 추가한다.</p><p>다음으로 방금 CrimeDao에 추가한 두 함수를 호출하도록 리포지터리를 변경한다. 다시 말하지만, 이 DAO 함수들이 LiveData를 반환하므로 Room은 <code>CrimeDao.getCrimes()</code>와 <code>CrimeDao.getCrime(UUID)</code>의 데이터베이스 쿼리를 백그라운드 스레드로 자동 실행된다. 이 경우 LiveData가 해당 데이터를 main 스레드로 전달하기 때문에 UI를 변경할 수 있다.</p><p>그러나 <strong>변경이나 추가의 경우에는 Room이 백그라운드 스레드로 자동 실행하지 못한다.</strong> 따라서 백그라운드 스레드로 변경이나 추가 함수들을 호출해야 하는데, 이때 주로 <strong>executor</strong>를 사용한다.</p><h2 id="executors-사용하기"><a class="markdownIt-Anchor" href="#executors-사용하기"></a> Executors 사용하기</h2><p>Excutors는 스레드를 참조하는 객체다. Excutors 인스턴스는 <code>execute</code>라는 함수를 가지며, 이 함수는 실행할 코드 블록을 받는다. Executors 인스턴스를 생성하면 이 인스턴스가 새로운 백그라운드 스레드를 사용해 블록의 코드를 실행한다. 따라서 main 스레드를 방해하지 않고 데이터베이스 작업을 안전하게 수행할 수 있다.</p><p>여기서는 Executors를 CrimeDao에 직접 구현할 수 없다. 정의한 인터페이스를 기반으로 Room이 함수를 자동 생성하기 때문이다. 따라서 CrimeRepository에 Excutors를 구현해야 한다.</p><blockquote><p>executor를 사용해서 데이터 변경과 추가하기 (CrimeRepository.kt)</p></blockquote><p>Executors 인스턴스의 참조를 저장하는 속성과 Executors를 사용하는 함수를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeRepository</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(context: Context)&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeDao = database.crimeDao()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> executor = Executors.newSingleThreadExecutor()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrimes</span><span class="params">()</span></span>: LiveData&lt;List&lt;Crime&gt;&gt; = crimeDao.getCrimes()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrime</span><span class="params">(id: <span class="type">UUID</span>)</span></span>: LiveData&lt;Crime?&gt; = crimeDao.getCrime(id)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateCrime</span><span class="params">(crime: <span class="type">Crime</span>)</span></span> &#123;</span><br><span class="line">        executor.execute &#123; </span><br><span class="line">            crimeDao.updateCrime(crime)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addCrime</span><span class="params">(crime: <span class="type">Crime</span>)</span></span> &#123;</span><br><span class="line">        executor.execute &#123; </span><br><span class="line">            crimeDao.addCrime(crime)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p><code>newSingleThreadExecutor()</code> 함수는 새로운 스레드를 참조하는 <code>executors</code> 인스턴스를 반환한다. 따라서 이 인스턴스를 사용해서 실행하는 어떤 작업도 main 스레드와 별개로 수행되므로 UI를 방해하지 않는다. <code>updateCrime(Crime)</code>과 <code>addCrime(Crime)</code> 모두 <code>execute &#123;&#125;</code> 블록 내부에서 DAO 함수를 호출한다.</p><h3 id="프래그먼트-생명주기에-맞춰-데이터베이스에-데이터-쓰기"><a class="markdownIt-Anchor" href="#프래그먼트-생명주기에-맞춰-데이터베이스에-데이터-쓰기"></a> 프래그먼트 생명주기에 맞춰 데이터베이스에 데이터 쓰기</h3><p>마지막으로 사용자가 상세 내역 화면에서 입력한 데이터를 데이터베이스에 쓰도록 변경한다. 이 작업은 사용자가 상세 내역 화면을 벗어날 때 수행한다.</p><blockquote><p>데이터베이스에 변경하기 (<a href="http://CrimeDetailViewModel.ky">CrimeDetailViewModel.ky</a>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeDetailViewModel</span>: <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadCrime</span><span class="params">(crimeId: <span class="type">UUID</span>)</span></span> &#123;</span><br><span class="line">        crimeIdLiveData.value = crimeId</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">saveCrime</span><span class="params">(crime: <span class="type">Crime</span>)</span></span> &#123;</span><br><span class="line">        crimeRepository.updateCrime(crime)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>saveCrime(Crime)</code>에서는 인자로 받은 Crime 객체를 데이터베이스에 변경한다. CrimeRepository는 백그라운드 스레드에서 데이터베이스의 데이터 변경을 처리하므로 <code>saveCrime(Crime)</code> 함수의 코드는 매우 간단하다.</p><p>다음으로 사용자가 변경한 범죄 데이터를 데이터베이스에 저장하도록 CrimeFragment를 변경한다.</p><blockquote><p><code>onStop()</code>에서 저장하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        crimeDetailViewModel.saveCrime(crime)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Fragment.onStop()</code>은 프래그먼트가 중단 상태 <sub>(프래그먼트 화면 전체가 안보이게 될 때)</sub>가 되면 언제든 호출된다. 따라서 여기서는 사용자가 상세 내역 화면을 떠나거나 <sub>(백 버튼)</sub> 작업을 전환 <sub>(홈 버튼 혹은 오버뷰 화면에서 다른 앱으로 전환)</sub>하면 데이터가 저장된다. 그러므로 <code>onStop()</code>에서 데이터를 저장하면 사용자가 상세 내역 화면을 떠나거나 메모리 부족으로 안드로이드가 프로세스를 종료할 때도 데이터가 유실되지 않고 저장된다.</p><p align = 'center'><img width = '200' src = 'https://user-images.githubusercontent.com/39554623/119434140-861dcd00-bd52-11eb-8011-bebaa074fd7e.gif'></p><hr /><h2 id="️-궁금증-프래그먼트-인자를-사용하는-이유는"><a class="markdownIt-Anchor" href="#️-궁금증-프래그먼트-인자를-사용하는-이유는"></a> <code>💁🏻‍♂️ 궁금증</code> 프래그먼트 인자를 사용하는 이유는?</h2><p>본문에서 프래그먼트의 새로운 인스턴스를 생성할 때 인자를 전달하려고 <code>newInstance(...)</code> 함수를 프래그먼트에 추가하였다. 이런 패턴은 코드 구성 관점이나 프래그먼트 인자 모두에 유용하다. 이와는 달리, 생성자를 사용하면 프래그먼트 인스턴스에 인자를 전달할 수 없다.</p><p>예를 들어, <code>newInstance(UUID)</code> 함수를 추가하는 대신 UUID 타입의 범죄 ID를 인자로 받는 생성자를 CrimeFragment에 추가할 수 있다. 그런데 <strong>이 방법에는 결함이 있다.</strong> 장치 회전에 따른 구성 변경이 생기면 현재 액티비티의 프래그먼트 매니저는 구성 변경이 생기기 전에 호스팅되었던 프래그먼트 인스턴스를 자동으로 재생성한다. 그다음으로는 재생성된 프래그먼트 인스턴스를 새 액티비티 인스턴스에 추가한다. 그리고 <strong>구성 변경 후에 프래그먼트 매니저가 프래그먼트를 다시 생성할 때는 해당 프래그먼트의 인자가 없는 기본 생성자를 호출</strong>한다. 따라서 구성 변경 후에는 새로 생성된 프래그먼트 인스턴스가 범죄 ID를 받지 못하게 된다.</p><p>그렇다면 프래그먼트 인자를 사용할 때는 무엇이 다를까? 프래그먼트 인자는 프래그먼트 생애에 걸쳐 보존된다. 구성 변경이 생기더라도 프래그먼트 매니저가 새 프래그먼트 인스턴스를 생성하면서 프래그먼트 인자를 다시 첨부하기 때문이다. 따라서 새 프래그먼트는 첨부된 인자 번들을 사용해서 자신의 상태 데이터를 다시 생성할 수 있다.</p><p>그런데 이렇게 복잡하게 프래그먼트 인자를 사용하지 않고 프래그먼트의 인스턴스 변수를 사용해서 상태 데이터를 보존하면 되지 않을까? 그러나 항상 보존된다는 보장이 없다. 구성 변경이 생기거나 사용자가 다른 앱 화면으로 이동해서 안드로이드 운영체제가 프래그먼트를 다시 생성하면 프래그먼트의 모든 인스턴스 변수들이 갖는 값이 없어진다.</p><p>다른 방법으로는 SIS <sup>Saved Instance State</sup> 매커니즘이 있다. 이때는 범죄 ID를 프래그먼트 인스턴스 변수에 저장하고 프래그먼트가 소멸하면 자동 호출되는 <code>onSaveInstanceState(Bundle)</code>에서 범죄 ID를 Bundle 객체에 저장했다가 나중에 프래그먼트 인스턴스가 재생성되면 호출되는 <code>onCreate(Bunlde)</code>에서 Bundle 객체의 범죄 ID를 꺼내어 사용하면 된다. 이 방법도 모든 경우에 통용된다.</p><p><strong>그런데 이 방법은 유지 보수가 어렵다.</strong> 기간이 지난 후에 해당 프래그먼트의 코드를 다시 보면서 또 다른 인자를 추가할 때 <code>onSaveInstanceState(Bundle)</code>에서 해당 인자를 저장했는지 기억하기 어렵기 때문이다.</p><p>따라서 모든 경우에 프래그먼트의 상태 데이터를 잘 보존하려면 프래그먼트 인자를 사용하는 것이 가장 좋다.</p><h2 id="그외의-fragment간-데이터-전달-방법들"><a class="markdownIt-Anchor" href="#그외의-fragment간-데이터-전달-방법들"></a> 그외의 Fragment간 데이터 전달 방법들</h2><ul><li><a href="https://developer.android.com/guide/fragments/communicate">https://developer.android.com/guide/fragments/communicate</a></li><li><a href="https://developer.android.com/guide/navigation/navigation-pass-data">https://developer.android.com/guide/navigation/navigation-pass-data</a></li></ul><h2 id="챌린지-diffutil-효율적으로-recyclerview-다시-로드하기"><a class="markdownIt-Anchor" href="#챌린지-diffutil-효율적으로-recyclerview-다시-로드하기"></a> <code>👨🏻‍💻 챌린지</code> <a href="https://developer.android.com/reference/androidx/recyclerview/widget/DiffUtil"><strong>DiffUtil</strong></a> : 효율적으로 RecyclerView 다시 로드하기</h2><p>본문의 코드는 상세 내역 화면의 데이터를 변경하고 리스트 화면으로 돌아오면 CrimeListFragment가 모든 범죄 데이터를 RecylcerView에 다시 채워서 보여준다. <strong>하나의 범죄 데이터만 변경되었을 뿐인데 이렇게 모두 변경하는 것은 매우 비효율적이다.</strong></p><p>변경된 범죄 데이터와 연관된 행만 다시 채워서 보여주도록 CrimeListFragment의 RecyclerView를 변경하자.</p><p>CrimeListFragment의 내부 클래스로 정의된 CrimeAdapter의 슈퍼 클래스를 <strong>RecycelrView.Adapter&lt;CrimeHolder&gt;</strong> 대신 <strong>androidx.recyclerview.widget.ListAdapter&lt;Crime, CrimeHolder&gt;</strong> 로 변경하면 된다.</p><p>ListAdapter는 현재의 RecyclerView 데이터와 새로 RecyclerView에 설정하는 데이터 간의 차이를 아는 RecyclerView의 어댑터다. 이런 차이점 비교는 백그라운드 스레드에서 수행되므로 UI에 영향을 주지 않는다. 그리고 비교가 끝난 후 ListAdapter는 변경된 데이터의 행들만 다시 채워서 보여주도록 RecyclerView에게 알려준다.</p><p>ListAdapter는 <strong>androidx.recyclerview.widget.DiffUtil</strong>을 사용해서 데이터 셋의 어떤 부분이 변경되었는지 판단한다. 이 챌린지를 완료하려면 <code>DiffUtil.ItemCallback&lt;Crime&gt;</code>을 구현하는 클래스를 ListAdapter에 제공해야 한다.</p><p>또한, 변경된 범죄 리스트가 RecyclerView의 어댑터에 전달되도록 <code>ListAdapter.submitList(MutableList&lt;T&gt;?)</code>를 호출해서 CrimeListFragment를 변경한다 <sub>(UI를 변경할 때마다 RecyclerView의 어댑터를 새로운 어댑터 객체에 다시 지정하지 않게 한다)</sub>.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        crimeListViewModel.crimeListLiveData.observe(</span><br><span class="line">            viewLifecycleOwner,</span><br><span class="line">            Observer &#123; crimes -&gt;</span><br><span class="line">                updateUI(crimes)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">(crimes: <span class="type">List</span>&lt;<span class="type">Crime</span>&gt;)</span></span> &#123;</span><br><span class="line">        adapter = CrimeAdapter(crimes)</span><br><span class="line">        crimeRecyclerView.adapter = adapter</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ListAdapter에게 새로운 리스트가 생겼다는 것을 submitList()를 통해 알려준다.</span></span><br><span class="line">        adapter?.submitList(crimes)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view), View.OnClickListener &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CrimeAdapter의 슈퍼 클래스를 ListAdapter로 변경</span></span><br><span class="line"><span class="comment">     * RecycelrView.Adapter&lt;CrimeHolder&gt; 대신 androidx.recyclerview.widget.ListAdapter&lt;Crime, CrimeHolder&gt; 로 변경하면 된다.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeAdapter</span></span>(<span class="keyword">var</span> crimes: List&lt;Crime&gt;) : ListAdapter&lt;Crime, CrimeHolder&gt;(CrimeDiffCallback()) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span></span><br><span class="line">                : CrimeHolder &#123;</span><br><span class="line">            <span class="keyword">val</span> view = layoutInflater.inflate(R.layout.list_item_crime, parent, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> CrimeHolder(view)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getItemCount() 오버라이드 함수를 제거한다. ListAdapter가 해당 메서드를 구현하기 때문</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">CrimeHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> crime = getItem(position)</span><br><span class="line">            holder.bind(crime)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DiffUtil.ItemCallback을 구현하는 클래스 생성 -&gt; ListAdapter에게 제공</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeDiffCallback</span> : <span class="type">DiffUtil.ItemCallback</span>&lt;<span class="type">Crime</span>&gt;</span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areItemsTheSame</span><span class="params">(oldItem: <span class="type">Crime</span>, newItem: <span class="type">Crime</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> oldItem.id == newItem.id</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areContentsTheSame</span><span class="params">(oldItem: <span class="type">Crime</span>, newItem: <span class="type">Crime</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> oldItem == newItem</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="api-문서-페이지"><a class="markdownIt-Anchor" href="#api-문서-페이지"></a> API 문서 페이지</h3><ul><li><a href="https://developer.android.com/reference/kotlin/androidx/recyclerview/widget/DiffUtil">Android Developers Reference: DiffUtil</a></li><li><a href="https://developer.android.com/reference/kotlin/androidx/recyclerview/widget/ListAdapter">Android Developers Reference: ListAdapter</a></li><li><a href="https://developer.android.com/codelabs/kotlin-android-training-diffutil-databinding#0">Android Kotlin Fundamentals: DiffUtil and data binding with RecyclerView</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/RecyclerView/">RecyclerView</category>
      
      <category domain="http://june0122.github.io/tags/Database/">Database</category>
      
      <category domain="http://june0122.github.io/tags/Room/">Room</category>
      
      <category domain="http://june0122.github.io/tags/Fragment/">Fragment</category>
      
      <category domain="http://june0122.github.io/tags/DiffUtil/">DiffUtil</category>
      
      <category domain="http://june0122.github.io/tags/Executors/">Executors</category>
      
      
      <comments>http://june0122.github.io/2021/05/26/android-bnr-12/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Codility] OddOccurrencesInArray</title>
      <link>http://june0122.github.io/2021/05/24/codility-odd-occurrences/</link>
      <guid>http://june0122.github.io/2021/05/24/codility-odd-occurrences/</guid>
      <pubDate>Mon, 24 May 2021 06:14:27 GMT</pubDate>
      
      <description>Lesson 2 - Arrays : OddOccurrencesInArray</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="lesson-2-arrays-oddoccurrencesinarray"><a class="markdownIt-Anchor" href="#lesson-2-arrays-oddoccurrencesinarray"></a> Lesson 2 - Arrays : <a href="https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/">OddOccurrencesInArray</a></h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>첫 시도</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(A: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> A.groupBy &#123; it &#125;.filter &#123; it.value.size % <span class="number">2</span> == <span class="number">1</span> &#125;.map &#123; it.key &#125;.first()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>날먹 시도 실패 😩</p><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/119300036-07198d80-bc9b-11eb-8fe0-3c9c837ef015.png'></p><blockquote><p>두 번째 시도 : HashMap 이용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(A: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> hashMap = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    A.forEach &#123;</span><br><span class="line">        hashMap[it] = hashMap.getOrDefault(it, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hashMap.keys.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashMap.getValue(it) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> it</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/119299593-27951800-bc9a-11eb-92a9-150c587edccc.png'></p><blockquote><p>번외 : <code>step</code>을 이용한 비교</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(A: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size == <span class="number">1</span>) <span class="keyword">return</span> A[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    A.sort()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> A.indices step <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> == A.size) <span class="keyword">return</span> A[i]</span><br><span class="line">        <span class="keyword">if</span> (A[i] != A[i + <span class="number">1</span>]) <span class="keyword">return</span> A[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/119301003-b5720280-bc9c-11eb-824c-637478b6acfe.png'></p><blockquote><p><code>xor</code> 연산 이용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(A: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    A.forEach &#123;</span><br><span class="line">        result = result xor it</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여러 방법으로 시도해도 효율성 테스트의 마지막 케이스가 실패했기에 검색을 해보니 비트 연산자를 활용하는 방법이 있었다!</p><p><code>xor</code> 연산은 숫자가 같으면 0, 숫자가 다르면 1을 반환하기 때문에 중복되지 않은 요소를 찾아내는데 유용하다.</p><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/119304589-6cbd4800-bca2-11eb-9764-563b75397646.png'></p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Codility/">Codility</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Codility/">Codility</category>
      
      
      <comments>http://june0122.github.io/2021/05/24/codility-odd-occurrences/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] 데이터베이스와 Room 라이브러리</title>
      <link>http://june0122.github.io/2021/05/24/android-bnr-11/</link>
      <guid>http://june0122.github.io/2021/05/24/android-bnr-11/</guid>
      <pubDate>Sun, 23 May 2021 23:14:22 GMT</pubDate>
      
      <description>&lt;b&gt;Room&lt;/b&gt;은 Jetpack의 아키텍처 컴포넌트 라이브러리로, 데이터베이스 설정과 사용을 쉽게 해준다. Room을 사용하면 애노테이션이 지정된 코틀린 클래스로 데이터베이스 구조와 쿼리를 정의할 수 있다.</description>
      
      
      
      <content:encoded><![CDATA[<p>거의 모든 애플리케이션은 장시간 동안 데이터를 저장할 곳이 필요하다. 본문에서는 <strong>Room 라이브러리</strong>를 사용해서 앱의 데이터베이스를 쿼리할 수 있는 코드를 구현하고, 데이터베이스로부터 데이터를 가져와서 리스트에 보여주도록 한다.</p><p><a href="https://june0122.github.io/2021/05/13/android-bnr-04/">ViewModel과 SIS</a>에서 장치 회전 및 프로세스 종료 시에 ViewModel과 SIS <sup>Saved Instance Status</sup>를 사용해서 일시적인 UI 상태 데이터를 지속하는 방법을 기술했다. ViewModel과 SIS는 UI와 관련된 적은 수의 데이터에는 아주 좋지만 UI와 결부되지 않는 데이터의 저장에는 사용할 수 없다. 또한, 액티비티나 프래그먼트 인스턴스에 연관되지 않으면서 UI 상태와 무관하게 영구적으로 지속할 필요가 있는 데이터의 저장에도 사용할 수 없다.</p><p>따라서 이런 앱 데이터는 ViewModel이나 SIS 대신 로컬 파일 시스템이나 로컬 데이터베이스 또는 웹 서버에 저장해야 한다.</p><h2 id="room-아키텍처-컴포넌트-라이브러리"><a class="markdownIt-Anchor" href="#room-아키텍처-컴포넌트-라이브러리"></a> Room 아키텍처 컴포넌트 라이브러리</h2><p>Room은 Jetpack의 아키텍처 컴포넌트 라이브러리로, 데이터베이스 설정과 사용을 쉽게 해준다. Room을 사용하면 애노테이션이 지정된 코틀린 클래스로 데이터베이스 구조와 쿼리를 정의할 수 있다.</p><p>Room은 <strong>API, 애노테이션 <sup>annotation</sup>, 컴파일러로 구성</strong>되어 있다.</p><ul><li>데이터베이스를 정의하고 인스턴스를 생성하기 위해 상속받는 클래스들이 <strong>API</strong>에 포함되어 있다.</li><li>데이터베이스에 저장할 필요가 있는 클래스, 데이터베이스를 나타내는 클래스, 데이터베이스 테이블을 사용하는 함수들을 정의하는 클래스 등을 나타내기 위해 <strong>애노테이션</strong>을 사용한다.</li><li><strong>컴파일러</strong>는 지정한 애노테이션을 컴파일해서 데이터베이스 구현체 <sub>(클래스나 인터페이스 등)</sub>를 생성한다.</li></ul><blockquote><p>Room을 사용하는데 필요한 의존성 추가</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin annotation processor tool 추가</span></span><br><span class="line">    id <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation <span class="string">&#x27;androidx.core:core-ktx:1.3.2&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// room-runtime과 room-compiler 추가</span></span><br><span class="line">    implementation <span class="string">&#x27;androidx.room:room-runtime:2.3.0&#x27;</span></span><br><span class="line">    kapt <span class="string">&#x27;androidx.room:room-compiler:2.3.0&#x27;</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>먼저 안드로이드 스튜디오의 <strong>플러그인 <sup>plug-in</sup></strong> 으로 <strong>kotlin-kapt</strong>를 추가한다. 플러그인은 안드로이드 스튜디오 같은 IDE에 기능을 추가하는 방법이다.</p><p>kotlin-kapt는 코틀린 애노테이션 처리 도구 <sup>Kotlin annotation processor tool</sup>다. 라이브러리에서 생성한 클래스를 코드에서 직접 사용하고자 할 때가 있다. 그런데 기본적으로 라이브러리가 생성한 클래스들은 안드로이드 스튜디오에서 알 수 가 없어 이런 클래스들을 import해서 사용하려고 하면 에러가 발생한다. kotlin-kapt 플러그인을 추가하면 라이브러리가 생성한 클래스들을 안드로이드 스튜디오에서 알 수 있으므로 import해서 사용할 수 있다.</p><p>위에서 추가한 첫 번째 의존성인 <em>room-runtime</em>은 데이터베이스를 정의하는 데 필요한 모든 클래스와 애노테이션을 포함하는 Room API다.</p><p>두 번째 의존성인 <em>room-compiler</em>는 지정한 애노테이션을 컴파일해서 데이터베이스 구현채를 생성한다. room-compiler 의존성을 지정할 때는 <code>implementation</code> 대신 <code>kapt</code> 키워드를 사용해 Room 컴파일러가 생성한 클래스들을 안드로이드 스튜디오가 알 수 있게 한다.</p><h2 id="데이터베이스-생성하기"><a class="markdownIt-Anchor" href="#데이터베이스-생성하기"></a> 데이터베이스 생성하기</h2><p>Room으로 데이터베이스를 생성할 때는 다음 세 단계로 한다.</p><ol><li>모델 클래스에 애노테이션을 지정해 데이터베이스 <strong>엔터티 <sup>entity</sup></strong> 로 만든다.</li><li>데이터베이스 자체를 나타내는 클래스를 생성한다.</li><li>데이터베이스가 모델 데이터를 처리할 수 있게 타입 변환기 <sup>type converter</sup>를 생성한다.</li></ol><p>Room은 이 단계가 수월하게 이루어지도록 해준다.</p><h3 id="entity-정의하기"><a class="markdownIt-Anchor" href="#entity-정의하기"></a> Entity 정의하기</h3><p>Room은 우리가 정의한 <strong>엔터티</strong>를 기반으로 앱의 데이터베이스 테이블 구조를 만든다. 엔터티는 우리가 생성하는 모델 클래스로, <code>@Entity</code> 애노테이션으로 지정한다. 그러면 이 애노테이션으로 Room이 해당하는 클래스의 데이터베이스 테이블을 생성한다.</p><p>본문의 예시로는 Crime 객체를 데이터베이스에 저장할 것이므로 Crime 클래스를 엔터티로 변경한다.</p><blockquote><p>Crime을 엔터티로 만들기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Crime</span></span>(</span><br><span class="line">    <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: UUID = UUID.randomUUID(),</span><br><span class="line">    <span class="keyword">var</span> title: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">var</span> date: Date = Date(),</span><br><span class="line">    <span class="keyword">var</span> isSolved: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>@Entity</code> 애노테이션은 클래스 수준에 적용된다. 이 엔터티 애노테이션은 Crime 클래스가 데이터베이스 테이블의 구조를 정의함을 나타낸다. 따라서 테이블의 <strong>각 행 <sup>row</sup>이 하나의 Crime 객체를 나타내며, 클래스에 정의된 각 속성은 테이블의 열 <sup>column</sup>이므로 속성 이름은 열의 이름</strong>이 된다. 따라서 Crime 객체 데이터를 저장하는 테이블은 id, title, date, isSolved 열을 갖는다.</p><p>id 속성에는 <code>@PrimaryKey</code> 애노테이션이 추가되었다. 이 애노테이션은 <strong>기본 키 <sup>primary key</sup></strong> 열을 지정한다. 기본 키는 테이블의 모든 행에 고유한 데이터를 갖는 열이므로 각 행을 검색하는데 사용할 수 있다. 여기서는 id 속성값이 모든 Crime 객체에 고유하다. 따라서 id 속성에 <code>@PrimaryKey</code>를 지정하면 이 속성을 사용해 특정 Crime 객체 데이터를 쿼리할 수 있다.</p><h3 id="데이터베이스-클래스-생성하기"><a class="markdownIt-Anchor" href="#데이터베이스-클래스-생성하기"></a> 데이터베이스 클래스 생성하기</h3><p>엔터티 클래스는 데이터베이스 테이블의 구조를 정의한다. 앱에 여러 개의 데이터베이스가 있을 때는 특정 엔터티 클래스는 여러 데이터베이스에서 사용될 수 있다. 이런 경우가 흔하지는 않지만 가능하다. 이런 이유로 엔터티 클래스를 데이터베이스와 연관시켜 주어야 Room이 테이블을 생성하는데 사용할 수 있다.</p><p>우선 데이터베이스에 특정한 코드를 모아둘 패키지인 database를 생성하여 데이터베이스 클래스를 생성한다.</p><blockquote><p>초기의 CrimeDatabase 클래스 (database/CrimeDatabase.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(entities = [Crime::class], version = 1)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Database</code> 애노테이션은 이 클래스가 앱의 데이터베이스를 나태난다고 Room에게 알려준다. 이 애노테이션에는 두 개의 매개변수를 지정해야 한다.</p><ol><li>첫 번째 매개변수에는 이 데이터베이스의 테이블들을 생성하고 관리하는 데 사용할 엔터티 클래스들을 지정한다<ul><li>여기서는 앱에서 유일한 엔터티 클래스인 Crime 클래스만 지정하였다.</li></ul></li><li>두 번째 매개변수에는 데이터베이스의 버전을 지정한다.<ul><li>데이터베이스를 처음 생성했을 때는 버전이 <code>1</code>이다.</li><li>앱을 계속 개발하는 동안 새로운 엔터티를 추가하거나 기존 엔터티에 새로운 속성을 추가할 수 있다. 추가할 대는 <code>@Database</code> 애노테이션의 엔터티를을 변경하거나 데이터벵스 버전 번호를 증가시켜야 한다.</li></ul></li></ol><p>데이터베이스 클래스인 CrimeDatabase는 <strong>RoomDatabase</strong>의 서브 클래스다. 현재는 아무것도 갖고 있지 않으며, <code>abstract</code>로 지정되어서 이 클래스의 인스턴스를 생성할 수 없다. Room을 사용해서 데이터베이스 인스턴스를 얻는 방법은 이번 장 뒤에서 기술한다.</p><h3 id="타입-변환기-생성하기"><a class="markdownIt-Anchor" href="#타입-변환기-생성하기"></a> 타입 변환기 생성하기</h3><p>Room은 내부적으로 SQLite를 사용한다. SQLite는 MySQL이나 PostgreSQL 같은 오픈 소스 관계형 데이터베이스다 <sub>(SQL은 Structured Query Language의 약어이며 표준 데이터베이스 언어다)</sub>. 다른 데이터베이스와 달리 SQLite는 라이브러리를 사용해서 데이터를 읽거나 데이터를 쓸 수 있는 파일에 저장한다. 안드로이드는 추가 도우미 클래스들과 함께 SQLite 라이브러리를 표준 라이브러리에 포함하고 있다.</p><p>Room은 코틀린 객체와 데이터베이스 사이에서 객체-관계 매핑 <sup>ORM, Object-Relational Mapping</sup>계층의 역할을 하면서 SQLite 사용을 쉽게 해준다. Room을 사용하면 대부분의 경우에 SQLite를 자세히 알 필요 없다.</p><p>Room은 기본 데이터 타입을 SQLite 데이터베이스 테이블에 쉽게 저장할 수 있지만, 이외의 다른 타입은 문제가 생길 수 있다. Crime 클래스에는 Room이 저장 방법을 모르는 Date와 UUID 타임 속성이 있다. 따라서 이런 타입의 데이터를 데이터베이스 테이블에 저장하거나 가져오는 방법을 Room에게 알려줘야 한다.</p><p>데이터 타입을 변환하는 방법을 Room에게 알려주려면 <strong>타입 변환기</strong>를 지정하면 된다. 타입 변환기는 Room에게 특정 타입을 데이터베이스에 저장되는 타입으로 변환하는 방법을 알려준다. 이때 각 타입에 대해서 <strong><code>@TypeConverter</code> 애노테이션이 지정된 두 개의 함수가 필요</strong>하다.</p><ol><li>데이터베이스에 데이터를 저장하기 위해 타입을 변환하는 함수</li><li>데이터베이스로부터 읽은 데이터를 우리가 원하는 타입으로 변환하는 함수</li></ol><blockquote><p>타입 변환 클래스와 함수 추가하기 (database/CrimeTypeConverters.kt)</p></blockquote><p>Date, UUID 타입에 대해 변환을 처리하는 두 개의 함수를 각각 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeTypeConverters</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fromDate</span><span class="params">(date: <span class="type">Date</span>?)</span></span>: <span class="built_in">Long</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> date?.time</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toDate</span><span class="params">(millisSinceEpoch: <span class="type">Long</span>?)</span></span>: Date? &#123;</span><br><span class="line">        <span class="keyword">return</span> millisSinceEpoch?.let &#123; </span><br><span class="line">            Date(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toUUID</span><span class="params">(uuid: <span class="type">String</span>?)</span></span>: UUID? &#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.fromString(uuid)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fromUUID</span><span class="params">(uuid: <span class="type">UUID</span>?)</span></span>: String? &#123;</span><br><span class="line">        <span class="keyword">return</span> uuid?.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>타입 변환기 활성화하기 (database/CrimeDatabase.kt)</p></blockquote><p>변환기 클래스를 데이터베이스 클래스에 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(entities = [Crime::class], version = 1)</span></span><br><span class="line"><span class="meta">@TypeConverters(CrimeTypeConverters::class)</span> <span class="comment">// 변환기 클래스 추가</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이처럼 <code>@TypeConverters</code> 애노테이션을 추가하면서 CrimeTypeConverters 클래스를 전달하면, Room은 타입을 변환할 때 해당 클래스의 함수들을 사용한다.</p><p>이것으로 데이터베이스와 테이블 정의는 완료되었다.</p><h2 id="dao-정의하기"><a class="markdownIt-Anchor" href="#dao-정의하기"></a> DAO 정의하기</h2><p>데이터베이스 테이블의 데이터를 액세스하려면 DAO <sup>Data Access Object</sup>를 생성해야 한다. DAO는 데이터베이스 작업을 수행하는 함수들을 포함하는 인터페이스다.</p><p>본문에서의 예시의 DAO에는 두 개의 쿼리 함수가 필요하다. 바로 데이터베이스의 모든 범죄 데이터를 반환하는 함수와 지정된 UUID를 갖는 하나의 범죄 데이터를 반환하는 함수다.</p><blockquote><p>DAO 인터페이스 (database/CrimeDao.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CrimeDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이처럼 <code>@Dao</code> 애노테이션을 지정하면 CrimeDao가 DAO 중 하나임을 Room이 알게 된다. 그리고 데이터베이스 클래스에 CrimeDao를 등록하면 이 인터페이스에 추가된 함수들의 실행 코드를 Room이 생성한다.</p><blockquote><p>DAO에 두 개의 쿼리 함수 추가하기 (database/CrimeDao.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CrimeDao</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">&quot;SELECT * FROM crime&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrimes</span><span class="params">()</span></span>: List&lt;Crime&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">&quot;SELECT * FROM crime WHERE id=(:id)&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrime</span><span class="params">(id: <span class="type">UUID</span>)</span></span>: Crime?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Query</code> 애노테이션은 <code>getCrimes()</code>와 <code>getCrime(UUID)</code> 함수가 데이터베이스의 데이터를 읽는다는 것을 나타낸다(추가, 변경, 삭제가 아님). 이 DAO에 정의된 각 쿼리 함수의 반환 타입은 쿼리가 반환하는 결과의 타입을 반영한다.</p><p><code>@Query</code> 애노테이션은 문자열로 된 SQL 명령을 받는다. 대부분의 경우에는 간단한 SQL만 알면 되지만, SQL에 관한 더 자세한 내용은 <a href="https://www.sqlite.org">https://www.sqlite.org</a> 사이트의 <a href="https://www.sqlite.org/lang.html">SQL Syntax</a>에서 참고할 수 있다.</p><p><code>SELECT * FROM crime</code>은 crime 데이터베이스 테이블에 저장된 모든 행의 모든 열을 가져오며, <code>SELECT * FROM crime WHERE id=(:id)</code>는 id 값이 일치하는 행의 모든 열만 가져온다.</p><p>기존 데이터를 변경하는 함수를 인터페이스에 추가하는 것은 <a href="">링크 추가 예정</a>에서, 새로운 데이터를 추가하는 함수의 추가는 <a href="">링크 추가 예정</a>에서 다룬다.</p><p>다음으로 CrimeDao 인터페이스를 데이터베이스 클래스에 등록해야 한다. CrimeDao는 인터페이스이므로 이것을 구현하는 클래스를 Room이 생성한다. 하지만 이렇게 되려면 CrimeDao의 인스턴스를 생성하게 데이터베이스 클래스에 알려주어야 한다.</p><p>아래와 같이 CrimeDao를 반환 타입으로 갖는 추상 함수를 CrimeDatabase.kt에 추가한다.</p><blockquote><p>데이터베이스에 CrimeDao 등록하기 (database/CrimeDatabase.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(entities = [Crime::class], version = 1)</span></span><br><span class="line"><span class="meta">@TypeConverters(CrimeTypeConverters::class)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CrimeDao 등록</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">crimeDao</span><span class="params">()</span></span>: CrimeDao</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제는 데이터베이스가 생성되면 우리가 사용할 수 있는 CrimeDao 구현 클래스를 Room이 생성한다. 따라서 CrimeDao의 참조를 가지면 CrimeDao에 정의된 함수들을 호출해서 데이터베이스를 사용할 수 있다.</p><h2 id="리포지터리-패턴으로-데이터베이스-액세스하기"><a class="markdownIt-Anchor" href="#리포지터리-패턴으로-데이터베이스-액세스하기"></a> 리포지터리 패턴으로 데이터베이스 액세스하기</h2><blockquote><p>리포지터리 패턴 다이어그램</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119275355-7e293480-bc4f-11eb-9c51-a4b6cb604d21.png'></p><p>데이터베이스 액세스를 위해 본문에서는 <a href="https://developer.android.com/jetpack/guide">구글의 앱 아키텍처 지침</a>에서 권장하는 <strong>리포지터리 패턴 <sup>repository pattern</sup></strong> 을 사용한다.</p><p><strong>리포지터리</strong> 클래스는 리포지터리 <sup>데이터 저장소</sup>를 구현한다. 또한 단일 또는 여러 소스로부터 데이터를 액세스하는 로직을 캡슐화하고, 로컬 데이터베이스나 원격 서버로부터 특정 데이터 셋을 가져오거나 저장하는 방법을 결정한다. 그리고 UI 코드에서는 리포지터리에 모든 데이터를 요청한다. UI는 어떻게 데이터를 저장하거나 가져오는지에 관여하지 않으므로 이런 일은 리포지터리에서 구현한다.</p><blockquote><p><b id = "f1">리포지터리 구현하기</b>  <a href="#a1"> ↩</a> (CrimeRepository.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeRepository</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(context: Context)&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> INSTANCE: CrimeRepository? = <span class="literal">null</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">initialize</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                INSTANCE = CrimeRepository(context)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: CrimeRepository &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;CrimeRepository must be initialized&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CrimeRepository는 <strong>싱글톤 <sup>singleton</sup></strong> 이다. 즉, 앱이 실행되는 동안 하나의 인스턴스만 생성된다는 의미다.</p><p>싱글톤은 앱이 메모리에 있는 한 계속 존재하므로, 싱글톤이 갖는 속성은 액티비티나 프래그먼트의 생명주기 상태가 변경되어도 계속 유지될 수 있다. 그러나 안드로이드 운영체제가 메모리에서 앱을 제거하면 싱글톤도 같이 소멸한다. 따라서 CrimeRepository 싱글톤은 데이터를 장기간 저장하기 위한 해결책이 될 수 없지만, 대신에 CriminalIntent 앱에서 범죄 데이터를 갖고 있으면서 컨트롤러 클래스 간의 데이터를 쉽게 전달하는 방법을 제공한다.</p><p>CrimeRepository를 싱글톤으로 만들고자 여기서는 두 개의 함수를 동반 객체에 추가하였다. 하나는 CrimeRepository의 인스턴스를 생성하는 함수이고, 다른 하나는 기존에 생성된 CrimeRepository 인스턴스를 반환하는 함수다. 그리고 CrimeRepository의 생성자를 <code>private</code>로 지정해서 외부에서 <code>CrimeRepository.initialize(Context)</code>를 호출해야만 CrimeRepository 인스턴스를 생성할 수 있게 했다.</p><p>게터 함수인 <code>get()</code>에서는 CrimeRepository 인스턴스가 생성되지 않으면 IllegalStateException을 발생시킨다. 따라서 앱이 시작될 대 리포지터리인 CrimeRepository 인스턴스를 생성해야 한다.</p><p>이렇게 하려면 <strong>Application</strong>의 서브 클래스를 생성하면 된다.</p><blockquote><p>Application 서브 클래스 생성하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CriminalIntentApplication</span>: <span class="type">Application</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        CrimeRepository.initialize(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Activity.onCreate(...)</code>와 유사하게 <code>Application.onCreate(...)</code>는 앱이 최초로 메모리에 로드될 때 안드로이드 시스템이 자동 호출한다. 따라서 한번만 초기화되는 작업을 수행하는 데 적합하다.</p><p>액티비티나 프래그먼트와는 달리 Application 인스턴스 즉, CriminalIntentApplication 인스턴스는 CriminalIntent 앱이 최초 실행될 때 생성되거나 앱 프로세스 소멸로 인해 CriminalIntentApplication 인스턴스가 소멸된 후 CriminalIntent 앱이 다시 실행될 때 재생성된다.</p><p>CriminalIntentApplication 인스턴스를 안드로이드 시스템에서 사용하려면 매니페스트에 등록해야 한다. AndroidManifest.xml에 <code>android:name</code> 속성을 추가해서 앱을 설정하면 이후부터는 CriminalIntentApplication 인스턴스가 앱의 Context 객체로 사용된다.</p><blockquote><p>CriminalIntentApplication을 등록하기</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.june0122.criminalintent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.CriminalIntentApplication&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이제는 CriminalIntent 앱이 실행될 때 안드로이드 운영체제가 CriminalIntentApplication 인스턴스를 생성하고 이 인스턴스의 <code>onCreate()</code>를 호출한다. 따라서 CrimeRepository 인스턴스가 생성되어 사용할 수 있다.</p><p>다음으로 데이터베이스 객체와 DAO 객체의 참조를 저장하는 두 개의 속성을 CrimeRepository에 추가한다.</p><blockquote><p>리포지터리 속성 설정하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DATABASE_NAME = <span class="string">&quot;crime-database&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeRepository</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(context: Context)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> database: CrimeDatabase = Room.databaseBuilder(</span><br><span class="line">        context.applicationContext,</span><br><span class="line">        CrimeDatabase::<span class="keyword">class</span>.java,</span><br><span class="line">        DATABASE_NAME</span><br><span class="line">    ).build()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeDao = database.crimeDao()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Room.databaseBuilder()</code>는 세 개의 매개변수를 사용해서 CrimeDatabase의 실체 클래스를 생성한다.</p><ol><li>데이터베이스가 안드로이드 장치의 파일 시스템을 액세스하므로 첫 번째 매개변수는 데이터베이스의 컨텍스트로, 주로 앱의 Context <sub>(여기서는 CriminalIntentApplication)</sub> 객체를 전달한다.</li><li>두 번째 매개변수는 Room으로 생성하고자 하는 데이터베이스 클래스 <sub>(여기서는 CrimeDatabase)</sub></li><li>세 번째 매개변수는 Room으로 생성하고자 하는 데이터베이스 파일 이름이다.</li></ol><p>다른 컴포넌트에서는 CrimeDatabase를 액세스할 필요가 없으므로 여기서는 <code>private</code> 문자열로 지정하였다 <sub>(SQLite에서는 한 데이터베이스가 하나의 파일로 생성된다)</sub>.</p><p>다음으로 DAO의 데이터베이스 액세스 함수들을 CrimeRepository에서 사용하기 위한 함수를 추가한다.</p><blockquote><p>리포지터리 함수 추가하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeRepository</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(context: Context)&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeDao = database.crimeDao()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrimes</span><span class="params">()</span></span>: List&lt;Crime&gt; = crimeDao.getCrimes()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrime</span><span class="params">(id: <span class="type">UUID</span>)</span></span>: Crime? = crimeDao.getCrime(id)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Room은 DAO에 쿼리를 구현하므로 리포지터리에 DAO의 함수를 호출하는 함수가 필요하다. 이렇게 하면 리포지터리에서 DAO <sub>(여기서는 CrimeDao)</sub>의 함수를 호출만 하면 되므로 코드가 간단해지고 이해하기 쉬워진다.</p><h2 id="쿼리-테스트하기"><a class="markdownIt-Anchor" href="#쿼리-테스트하기"></a> 쿼리 테스트하기</h2><p>리포지터리가 준비되었지만 쿼리 함수를 테스트하기 전에 할 일이 하나 더 있다. 현재 데이터베이스에는 범죄 데이터가 하나도 없다. 코드에서 모의 데이터를 생성해 데이터베이스에 추가할 수 있찌만, 데이터를 추가하는 DAO 함수를 아직 구현하지 않았기 때문에 <a href="https://github.com/Jpub/AndroidBNR4/tree/main/Ch11/databases">데이터베이스 파일</a>을 이용한다. 안드로이드 스튜디오의 장치 파일 탐색기(Device File Explorer)를 사용해서 에뮬레이터에 파일을 업로드하면 된다.</p><p>참고로 에뮬레이터는 루트 권한으로 사용할 수 있어서 데이터베이스 파일의 업로드 및 앱에서의 사용이 가능하지만, 실제 장치에서는 데이터베이스 파일을 복사하지 못하거나 복사가 되더라도 권한이 없어서 앱에서 사용하지 못할 수 있기 때문에 데이터베이스 파일을 사용할 경우 에뮬레이터에서 테스트한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119275895-a23a4500-bc52-11eb-91af-6688896e4fd8.png'></p><p>리포지터리를 사용해서 퀴리할 수 있는 데이터가 준비되었으니 CrimeListViewModel에서 기존의 모의 데이터 코드를 삭제하고 CrimeRepository의 <code>getCrimes()</code> 함수를 호출하는 코드로 교체한다.</p><blockquote><p>CrimeListViewModel에서 리포지터리 액세스하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListViewModel</span>: <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    val crimes = mutableListOf&lt;Crime&gt;()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    init &#123;</span></span><br><span class="line"><span class="comment">//        for (i in 0 until 100) &#123;</span></span><br><span class="line"><span class="comment">//            val crime = Crime()</span></span><br><span class="line"><span class="comment">//            crime.title = &quot;Crime #$i&quot;</span></span><br><span class="line"><span class="comment">//            crime.isSolved = i % 2 == 0</span></span><br><span class="line"><span class="comment">//            crimes += crime</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeRepository = CrimeRepository.<span class="keyword">get</span>()</span><br><span class="line">    <span class="keyword">val</span> crimes = crimeRepository.getCrimes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>변경 후 앱을 실행하면 앱이 중단이 된다…!</p><p>LogCat의 에러 메시지를 보면 아래와 같다.</p><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/119277726-3fe64200-bc5c-11eb-81d6-055d961f8e93.png'></p><p>이 에러는 Room 라이브러리에서 발생된 것으로, 긴 시간 동안 UI를 차단하는 데이터베이스 액세스를 main 스레드에서 하려고 했기 때문이다. 따라서 데이터베이스 액세스와 같이 시간이 걸리는 작업은 백그라운드에서 수행해야 한다.</p><h2 id="애플리케이션의-스레드"><a class="markdownIt-Anchor" href="#애플리케이션의-스레드"></a> 애플리케이션의 스레드</h2><p>데이터베이스로부터 데이터를 가져오는 것은 즉시 처리되지 않고 오래 걸릴 수 있다. Room은 메인 스레드에서의 데이터베이스 액세스를 허용하지 않으며, 액세스하려고 하면 IllegalStateException을 발생시킨다.</p><p>이것을 이해하려면 스레드가 무엇인지, 그리고 메인 스레드는 무엇이고 무슨 일을 하는지 알아야 한다.</p><p>스레드는 단일의 실행 시퀀스다. 스레드 내부의 코드는 한 단계씩 실행된다. 모든 안드로이드 앱은 <strong>main 스레드</strong>로 시작된다. 그러나 main 스레드는 미리 정해진 순서로 실행되지 않는다. 대신에 무한 루프에 머물면서 사용자나 시스템이 유발한 이벤트를 기다린다. 그리고 이벤트가 발생하면 응답하는 코드를 실행한다.</p><blockquote><p>일반 스레드 vs main 스레드</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/119277908-36110e80-bc5d-11eb-8a3e-d58264bd7fa5.jpeg'></p><p>main 스레드는 UI를 변경하는 모든 코드들을 실행하며, 액티비티 시작, 버튼 클릭 등 서로 다른 UI 관련 이벤트들에 대한 응답으로 실행되는 코드들도 포함된다. 이벤트들은 어떤 형태로든 모두 UI와 관련이 있어서 main 스레드를 <strong>UI 스레드</strong>라고도 한다.</p><p>이벤트 루프에서는 UI 코드를 순서대로 유지한다. 따라서 시기 적절하게 코드가 실행되면서도 상호 충돌이 생기지 않는다. 지금까지 작성했던 모든 코드는 main 스레드에서 실행되었다.</p><h3 id="백그라운드-스레드"><a class="markdownIt-Anchor" href="#백그라운드-스레드"></a> 백그라운드 스레드</h3><p>데이터베이스 액세스는 다른 일보다 시간이 많이 걸린다. 따라서 이 시간 동안 UI는 완전히 응답 불가능이 될 것이고, 결국은 <strong>애플리케이션이 응답하지 않는(ANR, Application Not Responding)</strong> 결과를 초래하게 된다.</p><p>main 스레드가 중요한 이벤트에 대한 응답에 실패했다고 안드로이드의 와치독 <sup>watchdog</sup>이 판단하면 ANR이 발생하며, 애플리케이션이 중단된다 <sub>(10초 이내에 UI 응답이 없으면 사용자가 불편하지 않도록 안드로이드 시스템에서 ANR을 발생시킨다)</sub>.</p><p>이를 해결하기 위해 <strong>백그라운드 스레드</strong>를 생성해서 데이터베이스를 액세스해야 한다. 백그라운드 스레드를 앱에 추가할 때 중요한 규칙이 두 가지 있다.</p><ol><li><p><strong>장시간 실행되는 모든 작업은 백그라운드 스레드로 실행되어야 한다.</strong></p><ul><li>이렇게 하면 main 스레드가 UI 관련 작업을 자유롭게 처리할 수 있어서 사용자를 위한 UI 응답을 지속적으로 처리할 수 있다.</li></ul></li><li><p><strong>UI는 main 스레드에서만 변경할 수 있다.</strong></p><ul><li>백그라운드 스레드에서 UI를 변경하려고 하면 에러가 발생한다. 따라서 백그라운드 스레드에서 생성되는 모든 데이터는 main 스레드에 전달해서 UI를 변경하게 해야 한다.</li></ul></li></ol><p>안드로이드에서 백그라운드 스레드로 작업을 실행하는 방법에는 여러 가지가 있다. 비동기 네트워크를 요청하는 방법은 <a href="">링크 추가 예정</a>에서, 핸들러 <sup>Handler</sup>를 사용해서 많은 소규모 백그라운드 작업을 수행하는 방법은 <a href="">링크 추가 예정</a>에서, <strong>WorkManager</strong>를 사용해서 주기적인 백그라운드 작업을 수행하는 방법은 <a href="">링크 추가 예정</a>에서 알아본다.</p><p>백그라운드에서 데이터베이스 작업을 실행하기 위해 두 가지 방법을 사용하는데, 본문에서는 쿼리 데이터를 포함하는 <strong>LiveData</strong>를 사용하고, 후에 <strong>Executor</strong>를 사용해서 데이터를 추가 및 변경한다.</p><h2 id="livedata-사용하기"><a class="markdownIt-Anchor" href="#livedata-사용하기"></a> LiveData 사용하기</h2><p><strong>LiveData</strong>는 Jetpack의 <em>lifecycle-extensions</em> 라이브러리에 있는 데이터 홀더 클래스이며, Room에서 LiveData를 사용한다.</p><p>LiveData의 목적은 <strong>앱의 서로 다른 부분 간에 데이터 전달을 쉽게 만드는 것</strong>이다.</p><ul><li>범죄 데이터를 보여줘야하는 프래그먼트로 CrimeRepository에서 데이터를 전달할 수 있으며</li><li>스레드 간에도 데이터를 전달할 수 있어서 백그라운드 스레드에서 main 스레드로 데이터를 전달할 수 있다.</li></ul><p>Room DAO의 쿼리에서 LiveData를 반환하도록 구성하면, Room이 백그라운드 스레드에서 쿼리 작업을 자동 실행한 후 그 결과를 LiveData 객체로 반환한다. 따라서 액티비티나 프래그먼트에서는 LiveData 객체를 관찰하도록 설정만 하면 된다. 그리고 LiveData 객체가 준비되면 main 스레드의 액티비티나 프래그먼트에 통보되므로 이때 LiveData를 사용해서 데이터를 처리하면 된다.</p><blockquote><p>DAO에서 LiveData 반환하기</p></blockquote><p>원래의 반환 타입을 포함하는 LiveData 객체를 반환하도록 쿼리 함수들의 반환 타입을 변경한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CrimeDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">&quot;SELECT * FROM crime&quot;</span>)</span></span><br><span class="line"><span class="comment">//    fun getCrimes(): List&lt;Crime&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrimes</span><span class="params">()</span></span>: LiveData&lt;List&lt;Crime&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">&quot;SELECT * FROM crime WHERE id=(:id)&quot;</span>)</span></span><br><span class="line"><span class="comment">//    fun getCrime(id: UUID): Crime?</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrime</span><span class="params">(id: <span class="type">UUID</span>)</span></span>: LiveData&lt;Crime?&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CrimeDao를 구현한 자동 생성된 클래스에서 LiveData의 인스턴스를 반환하므로 Room은 백그라운드 스레드에서 쿼리를 실행한다. 그리고 쿼리가 완료되면 범죄 데이터가 main 스레드로 전달되고 LiveData 객체를 관찰하는 옵저버 <sup>observer</sup>에 통보된다. (본문에서는 CrimeListFragment가 옵저버)</p><p>다음으로 CrimeRepository의 쿼리 함수들이 LiveData를 반환하도록 변경한다.</p><blockquote><p>리포지터리에서 LiveData 반환하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeRepository</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(context: Context)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeDao = database.crimeDao()</span><br><span class="line"></span><br><span class="line"><span class="comment">//    fun getCrimes(): List&lt;Crime&gt; = crimeDao.getCrimes()</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrimes</span><span class="params">()</span></span>: LiveData&lt;List&lt;Crime&gt;&gt; = crimeDao.getCrimes()</span><br><span class="line"></span><br><span class="line"><span class="comment">//    fun getCrime(id: UUID): Crime? = crimeDao.getCrime(id)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCrime</span><span class="params">(id: <span class="type">UUID</span>)</span></span>: LiveData&lt;Crime?&gt; = crimeDao.getCrime(id)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="livedata-관찰하기"><a class="markdownIt-Anchor" href="#livedata-관찰하기"></a> LiveData 관찰하기</h2><p>데이터베이스의 범죄 데이터를 범죄 리스트 화면에 보고자 <code>CrimeRepository.getCrimes()</code>로부터 반환되는 LiveData 객체를 관찰하도록 CrimeListFragment를 변경한다.</p><blockquote><p>속성에서 무슨 데이터를 저장하는지 알기 쉽게 하기 위해 이름 변경</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListViewModel</span>: <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeRepository = CrimeRepository.<span class="keyword">get</span>()</span><br><span class="line"><span class="comment">//    val crimes = crimeRepository.getCrimes()</span></span><br><span class="line">    <span class="keyword">val</span> crimeListLiveData = crimeRepository.getCrimes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LivaData는 데이터베이스로부터 반환되는 범죄 데이터들을 포함한다. 그리고 CrimeListFragment는 데이터베이스로부터 결과가 반환되는 것을 기다렸다가 LiveData가 반환되면 RecyclerView를 범죄 데이터로 채울 수 있다. 따라서 RecyclerView 어댑터를 비어 있는 List로 초기화해야 한다. 그리고 새로운 범죄 데이터가 LiveData로 반환될 때 RecyclerView 어댑터가 새로운 범죄 List를 갖도록 설정한다.</p><blockquote><p>LiveData 옵저버와 RecyclerView 어댑터 설정하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crimeRecyclerView: RecyclerView</span><br><span class="line"><span class="comment">//    private var adapter: CrimeAdapter? = null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> adapter: CrimeAdapter? = CrimeAdapter(emptyList())</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ...</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View? &#123;</span><br><span class="line">        ...</span><br><span class="line">        crimeRecyclerView.layoutManager = LinearLayoutManager(context)</span><br><span class="line">        crimeRecyclerView.adapter = adapter</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        crimeListViewModel.crimeListLiveData.observe(</span><br><span class="line">            viewLifecycleOwner,</span><br><span class="line">            Observer &#123; crimes -&gt;</span><br><span class="line">                crimes.let &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;Got crimes <span class="subst">$&#123;crimes.size&#125;</span>&quot;</span>)</span><br><span class="line">                    updateUI(crimes)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">(crimes: <span class="type">List</span>&lt;<span class="type">Crime</span>&gt;)</span></span> &#123;</span><br><span class="line">        adapter = CrimeAdapter(crimes)</span><br><span class="line">        crimeRecyclerView.adapter = adapter</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>LiveData.observe(LifecycleOwner, Observer)</code> 함수는 LiveData 인스턴스에 옵저버를 등록하기 위해 사용된다.</p><p><code>observe(...)</code> 함수의 첫 번째 인자로 지정된 viewLifeCycleOwner는 코틀린의 속성이며, <em>androidx.fragment.app.fragment</em>의 <code>getViewLifeCycleOwner()</code> 함수를 호출하는 것과 같다. viewLifeCycleOwner는 프래그먼트 뷰의 생명주기를 나타내는 LifecycleOwner 구현 객체를 반환한다. 따라서 여기서는 CrimeListFragment의 생명주기가 아닌 CrimeListFragment의 <strong>뷰의 생명주기</strong>에 맞춰 옵저버가 LiveData 인스턴스의 변경을 관찰하고 변경이 생기면 실행된다는 의미다.</p><p><code>observe(...)</code> 함수의 두 번째 인자는 Observer 인터페이스를 구현하는 객체, 즉 옵저버이며 여기서는 람다식으로 구현되었다. 옵저버는 LiveData의 새로운 데이터를 처리하며, 여기서는 LiveData의 범죄 데이터 리스트가 변경될 때마다 실행된다. 즉, LiveData의 범죄 List를 받아서 로그 메시지를 출력하고 <code>updateUI()</code> 함수를 호출한다.</p><p>만일 LiveData의 변경이 생길 때마다 옵저버가 실행되면 프래그먼트의 뷰가 유효한 상태가 아닐 때(예로, 화면에 보이지 않을 때)도 <code>updateUI(crimes)</code> 함수에서 프래그먼트의 뷰를 변경하려 할 것이고 결국 앱이 중단될 것이다.</p><p>그러므로 <code>LiveData.observe(...)</code> 함수의 첫 번째 인자로 LifecycleOwner 객체를 지정하는 것이다. 이렇게 하면 옵저버의 생명주기는 지정한 LifecycleOwner 객체가 나타내는 안드로이드 컴포넌트의 생명주기에 한정된다.</p><p>따라서 프래그먼트의 뷰가 유효한 상태일 때만 LiveData 객체가 옵저버에게 변경 <sub>(새로운 데이터를 받았음)</sub>을 통보해 UI를 변경할 수 있다. 이처럼 LiveData는 프래그먼트 뷰의 생명주기에 따라 반응해서 이런 컴포넌트를 <strong>생명주기-인식 컴포넌트 <sup>lifecycle-aware component</sup></strong> 라고 한다. 이 내용은 <a href="">링크 추가 예정</a>에서 자세히 다룬다.</p><p>LifecycleOwner 인터페이스를 구현하는 객체는 Lifecycle 객체를 포함한다. Lifecycle은 안드로이드 생명주기의 현재 상태를 유지 관리하는 객체다 <sub>(액티비티, 프래그먼트, 뷰, 심지어 앱 자체도 자신의 생명주기를 갖는다)</sub>. '생성’이나 '실행 재개’와 같은 생명주기 상태는 <code>Lifecycle.State</code> 열거형 <sup>enum</sup>에 정의되어 있으며, <code>Lifecycle.getCurrentState()</code>를 사용하면 Lifecycle 객체의 상태를 알 수 있다.</p><p>AndroidX의 <strong>Fragment</strong> 클래스는 <strong>LifecycleOwner</strong> 인터페이스를 구현하며, 프래그먼트 인스턴스의 생명주기 상태를 나타내는 <strong>Lifecycle</strong> 객체를 갖고 있다.</p><p>프래그먼트 뷰의 생명주기는 <strong>FragmentViewLifecycleOwner</strong>가 별개로 유지 및 관리한다. 각 프래그먼트는 자신의 뷰의 생명주기를 유지 및 관리하는 <strong>FragmentViewLifecycleOwner</strong> 인스턴스를 갖는다.</p><p>위의 코드에서는 <code>observe(...)</code> 함수의 첫 번째 인자로 viewLifecycleOwner를 전달하므로 옵저버의 실행이 프래그먼트 자신이 아닌 프래그먼트 뷰의 생명주기와 연동된다. 프래그먼트 뷰의 생명주기는 프래그먼트 인스턴스의 생명주기와 별개지만 프래그먼트의 생명주기를 반영한다. 그런데 프래그먼트의 <strong>유보 <sup>retaining</sup></strong> 로 이를 변경할 수 있다. 뷰의 생명주기와 프래그먼트 유보는 <a href="">링크 추가 예정</a>에서 더 자세히 다룬다.</p><p><code>Fragment.onViewCreated(...)</code>는 <code>Fragment.OnCreateView(...)</code>가 실행된 후 호출되므로 프래그먼트 뷰의 계층 구조에 맞춰 모든 뷰들이 형성된 후 실행된다. 따라서 <code>onCreated(...)</code>에서 LiveData 변경을 관찰하면 프래그먼트 뷰가 범죄 데이터를 보여줄 준비가 되었음을 확신할 수 있다. <code>observe()</code> 함수의 첫 번째 인자로 프래그먼트 자신이 아닌 viewLifecycleOwner를 전달하는 것도 이 때문이다. 여기서 원하는 것은 프래그먼트의 뷰가 좋은 상태일 때 LiveData로부터 범죄 리스트를 받는 것이다. 따라서 프래그먼트 뷰의 LifecycleOwner 객체를 사용하면 뷰가 화면에 보이지 않을 때는 LiveData 변경 데이터를 받지 않는다.</p><blockquote><p>데이터베이스의 범죄 데이터 보여주기</p></blockquote><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/119278756-4f688980-bc62-11eb-9810-ef978bfa885b.png'></p><h2 id="싱글톤"><a class="markdownIt-Anchor" href="#싱글톤"></a> 싱글톤</h2><p><a id = "a1"><a href="#f1">CrimeRepository에서 사용</a></a>된 것처럼 싱글톤 패턴은 안드로이드에서 매우 자주 사용된다. 그런데 싱글톤이 앱의 유지 보수를 어렵게 만들 수도 있다.</p><p>싱글톤은 프래그먼트나 액티비티보다 더 오래 존재한다. 또한, 싱글톤은 장치를 회전시키더라도 여전히 존재하며 앱의 액티비티와 프래그먼트를 오갈 때도 계속 남는다.</p><p>싱글톤을 사용하면 모델 객체를 소유하는 클래스를 편리하게 만들 수 있다. 범죄 데이터(Crime 객체)를 변경하는 많은 액티비티와 프래그먼트를 갖고 있는 더 복잡한 앱을 생각해보자. 한 컨트롤러가 범죄 데이터를 변경할 때 변경된 데이터를 어떻게 다른 컨트롤러에 전달할 수 있을까?</p><p>이때 만일 CrimeRepository가 범죄 데이터의 소유 클래스이면서 모든 변경 데이터가 CrimeRepository에 전달된다면 변경 데이터의 전달을 훨씬 쉽게 할 수 있다. 즉, 컨트롤러 사이를 이동하는 동안 특정 범죄의 식별자로 범죄 ID를 전달할 수 있으며, 각 컨트롤러는 이 ID를 사용해서 CrimeRepository로부터 해당 범죄 객체의 모든 데이터를 가져올 수 있다.</p><p>그러나 싱글톤은 몇 가지 단점을 가지고 있다.</p><ol><li><p>싱글톤은 컨트롤러보다 더 오랜 생애 동안 데이터를 저장하게 해주지만 <strong>싱글톤 자신도 생애가 있다.</strong> 즉, 앱이 종료된 후 어떤 시점에서 안드로이드 운영체제가 메모리를 회수하면 싱글톤은 자신의 인스턴스 변수와 함께 소멸된다. 따라서 싱글톤은 장기간에 걸쳐 데이터를 저장할 수 있는 방법은 아니며, 데이터를 디스크에 쓰거나 웹 서버로 전송하는 것만이 해결책이다.</p></li><li><p><strong>싱글톤은 코드의 단위 테스트를 어렵게 만들 수 있다.</strong> 안드로이드 개발자들은 주로 <strong>의존성 주입 <sup>dependency injection</sup></strong> 으로 이 문제를 해결한다. 이렇게 하면 객체들을 싱글톤을 공유할 수 있다.</p></li><li><p><strong>싱글톤은 잘못 사용될 수 있다.</strong> 편리하다고 아무 생각 없이 모든 것에 싱글톤을 사용하려고 할 수 있다. 왜냐하면 싱글톤은 코드 어디서나 사용할 수 있으며, 나중에 사용할 데이터가 어떤 것이든 싱글톤에 저장할 수 있기 때문이다. 그러나 '이 데이터는 어디에 사용되는가? 이 기능이 중요한 곳은 어디인가?'라는 매우 중요한 질문을 스스로에게 해야 한다.</p></li></ol><p>싱글톤은 잘 구성된 안드로이드 앱의 핵심 컴포넌트다. 단, 올바르게 사용될 때만 그렇다!</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Database/">Database</category>
      
      <category domain="http://june0122.github.io/tags/Room/">Room</category>
      
      
      <comments>http://june0122.github.io/2021/05/24/android-bnr-11/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] RecyclerView</title>
      <link>http://june0122.github.io/2021/05/23/android-bnr-09/</link>
      <guid>http://june0122.github.io/2021/05/23/android-bnr-09/</guid>
      <pubDate>Sat, 22 May 2021 20:29:02 GMT</pubDate>
      
      <description>ListView는 getView()를 호출하여 list를 뿌리게 되는데 화면 스크롤시 getView()함수가 계속해서 호출되게 되어 inflate를 통해서 view가 생성되며 동시에 findByViewId가 계속해서 호출되게 된다. 그러면 리스트를 생성하는데 있어 메모리의 비효율성이 발생하게 된다. 하지만 RecyclerView는 ViewHolder(findByViewId를 한 번만 호출) 패턴을 강제하여 사용자의 화면을 구성하고 있는데 &lt;b&gt;충분한 수의 ViewHolder가 생성되면 RecyclerView는 기존의 ViewHolder를 재활용해 시간과 메모리를 절약한다.&lt;/b&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>본문에서 예시로 설명할 앱 CriminalIntent의 객체 다이어그램</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119100962-713ff180-ba53-11eb-8175-b7cdc878cea9.jpeg'></p><h2 id="새로운-프래그먼트-및-viewmodel-추가하기"><a class="markdownIt-Anchor" href="#새로운-프래그먼트-및-viewmodel-추가하기"></a> 새로운 프래그먼트 및 ViewModel 추가하기</h2><blockquote><p>CrimeListViewModel</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListViewModel</span>: <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> crimes = mutableListOf&lt;Crime&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 모의 데이터 채우기</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> crime = Crime()</span><br><span class="line">            crime.title = <span class="string">&quot;Crime #<span class="variable">$i</span>&quot;</span></span><br><span class="line">            crime.isSolved = i % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">            crimes += crime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CrimeListFragment 생성 및 구현</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;CrimeListFragment&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span>: <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeListViewModel: CrimeListViewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(CrimeListViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Total crimes: <span class="subst">$&#123;crimeListViewModel.crimes.size&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newInstance</span><span class="params">()</span></span> : CrimeListFragment &#123;</span><br><span class="line">            <span class="keyword">return</span> CrimeListFragment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>동반 객체에서 정의된 <code>newInstance()</code> 함수에서는 CrimeListFragment 인스턴스를 생성하고 반환한다.</p><ul><li>이때 <code>newInstance()</code> 함수는 CrimeListFragment 클래스의 인스턴스를 생성하지 않고 호출할 수 있다.  자바의 static 메서드와 유사</li><li>따라서 액티비티에서 CrimeListFragment 인스턴스를 생성하려면 <code>newInstance()</code> 함수를 호출하면 된다.</li></ul><h3 id="프래그먼트에-사용되는-viewmodel-생명주기"><a class="markdownIt-Anchor" href="#프래그먼트에-사용되는-viewmodel-생명주기"></a> 프래그먼트에 사용되는 ViewModel 생명주기</h3><p><a href="https://june0122.github.io/2021/05/13/android-bnr-04/">[Android] ViewModel과 SIS</a>에서 액티비티와 함께 사용되는 ViewModel의 생명주기를 알아보았다. 그런데 ViewModel이 프래그먼트와 같이 사용되면 생명주기가 약간 달라진다. 이때도 두 개의 상태 <sub>('생성됨’또는 ‘소멸되어 존재하지 않음’)</sub>만 갖는 것은 동일하나, 액티비티 대신 프래그먼트의 생명주기와 결합된다.</p><p>다시 말해, 프래그먼트의 뷰가 화면에 나타나 있는 한 ViewModel은 활성화된 상태를 유지하며, 장치 회전 시에도 유지되어 새로 생성된 프래그먼트 인스턴스가 이어서 사용할 수 있다.</p><p>ViewModel은 프래그먼트가 소멸할 때 같이 소멸한다. 예를 들어, 사용자가 백 버튼을 누르거나 호스팅 액티비티가 프래그먼트를 다른 것으로 교체할 때 해당 액티비티가 화면에 나타나 있더라도 프래그먼트 및 이것과 연관된 ViewModel은 더 이상 필요 없으므로 소멸한다.</p><p>한 가지 특별한 경우는 <em>프래그먼트 트랜잭션을 백 스택에 추가</em>할 때다. 만일 액티비티가 현재 프래그먼트를 다른 것으로 교체할 때 트랜잭션이 백 스택에 추가된다면 해당 프래그먼트 인스턴스와 이것의 ViewModel은 소멸되지 않는다. 따라서 사용자가 백 버튼을 누르면 프래그먼트 트랜잭션이 역으로 수행되어 교체되기 전의 프래그먼트 인스턴스가 다시 화면에 나타나고 ViewModel의 모든 데이터는 보존된다.</p><blockquote><p>프래그먼트 트랜잭션을 사용해서 CrimeListFragment 추가하기</p></blockquote><p>CrimeFragment 대신 CrimeListFragment의 인스턴스를 호스팅하도록 변경</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> currentFragment =</span><br><span class="line">            supportFragmentManager.findFragmentById(R.id.fragment_container)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentFragment == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//          val fragment = CrimeFragment()</span></span><br><span class="line">            <span class="keyword">val</span> fragment = CrimeListFragment.newInstance()</span><br><span class="line">            supportFragmentManager</span><br><span class="line">                .beginTransaction()</span><br><span class="line">                .add(R.id.fragment_container, fragment)</span><br><span class="line">                .commit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>현재는 MainActivity가 항상 CrimeListFragment를 보여주도록 하드코딩되어 있지만, 후에는 사용자가 앱 화면을 이동하는 것에 따라 MainActivity가 CrimeListFragment와 CrimeFragment를 상호 교체하도록 변경할 것이다.</p><h2 id="recyclerview-추가하기"><a class="markdownIt-Anchor" href="#recyclerview-추가하기"></a> RecyclerView 추가하기</h2><p>RecyclerView 클래스는 다른 Jetpack 라이브러리에 있어서 사용하려면 우선 RecyclerView 라이브러리 의존성을 app/build.gradle 파일에 추가해야 한다.</p><blockquote><p>RecyclerView 의존성 추가하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation <span class="string">&#x27;androidx.lifecycle:lifecycle-extensions:2.2.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;androidx.recyclerview:recyclerview:1.2.0&#x27;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RecyclerView를 레이아웃 파일에 추가하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;androidx.recyclerview.widget.RecyclerView xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:id=<span class="string">&quot;@+id/crime_recycler_view&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>CrimeListFragment의 뷰가 준비되었으니 이 뷰를 프래그먼트와 연결한다.</p><blockquote><p>CrimeListFragment의 뷰 설정하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span>: <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crimeRecyclerView: RecyclerView</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeListViewModel: CrimeListViewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(CrimeListViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Total crimes: <span class="subst">$&#123;crimeListViewModel.crimes.size&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">val</span> view = inflater.inflate(R.layout.fragment_crime_list, container, <span class="literal">false</span>)</span><br><span class="line">        </span><br><span class="line">        crimeRecyclerView = view.findViewById(R.id.crime_recycler_view) <span class="keyword">as</span> RecyclerView</span><br><span class="line">        crimeRecyclerView.layoutManager = LinearLayoutManager(context)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RecyclerView가 생성된 후에는 곧바로 LayoutManager를 설정해야 하며, 여기서는 LinearLayoutManager를 설정했다. 만일 설정하지 않으면 RecyclerView가 작동하지 않는다.</p><p>RecyclerView는 항목들을 화면에 위치시키는 일을 직접하지 않고 LayoutManager에게 위임한다. 그러면 LayoutManager는 모든 항목들의 화면 위치를 처리하고 스크롤 동작도 정의한다. 따라서 LayoutManager가 설정되지 않으면 RecyclerView의 작동이 바로 중단된다.</p><p>LayoutManager는 안드로이드 프레임워크에 내장된 것 중 하나를 선택할 수 있으며, 서드파티 라이브러리의 것도 사용할 수 있다. 여기서는 LinearLayoutManager를 사용했는데, 이것은 리스트의 항목들을 수직 방향으로 배치한다. 이 책 후반부에서는 GridLayoutManager를 사용해서 격자 형태로 항목들을 배치할 것이다.</p><h2 id="항목-뷰-레이아웃-생성하기"><a class="markdownIt-Anchor" href="#항목-뷰-레이아웃-생성하기"></a> 항목 뷰 레이아웃 생성하기</h2><p>RecyclerView는 ViewGroup의 서브 클래스이며, <strong>항목 뷰(item view)</strong> 라고 하는 자식 View 객체들의 리스트를 보여준다. 각 itemView는 RecyclerView의 행으로 나타나며 데이터 저장소에서 가져온 하나의 객체를 나타낸다. 객체가 갖는 데이터 중에서 어떤 것들을 화면에 보여주는가에 따라 항목 View가 복잡해질 수도 있고 간단할 수도 있다.</p><blockquote><p>자식 뷰를 갖는 RecyclerView</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119100956-70a75b00-ba53-11eb-9c88-ef18ada6bb37.jpeg'></p><p>한 행으로 보이는 RecyclerView의 각 항목은 자신의 뷰 계층 구조를 가질 수 있다. 여기서는 각 항목의 View 객체가 두 개의 TextView를 포함하는 LinearLayout이 된다.</p><blockquote><p>리스트 항목 레이아웃 변경하기 (layout/list_item_crime.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;8dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/crime_title&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Crime Title&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/crime_date&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Crime Date&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="viewholder-구현하기"><a class="markdownIt-Anchor" href="#viewholder-구현하기"></a> ViewHolder 구현하기</h2><p>RecyclerView는 항목 View가 ViewHolder 인스턴스에 포함되어 있다고 간주한다. ViewHolder는 항목 View의 참조를 갖는다.</p><p>RecyclerView.ViewHolder의 서브 클래스인 CrimeHolder를 CrimeListFragment의 내부 클래스로 정의하자.</p><blockquote><p>초기 버전의 CrimeHolder (CrimeListFragment)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span>: <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ViewHolder와 이것의 itemView 속성</p></blockquote><p align = 'center'><img width = '150' src = 'https://user-images.githubusercontent.com/39554623/119100959-713ff180-ba53-11eb-8aef-6381a025e70d.jpeg'></p><p>CrimeHolder의 생성자는 항목 View를 인자로 받으며, CrimeHolder 인스턴스가 생성될 대 이 View는 슈퍼 클래스인 RecyclerView.ViewHolder의 생성자 인자로 전달된다. 그리고 RecyclerView.ViewHolder 슈퍼 클래스로부터 상속받은 itemView 속성이 생성자로 전달된 항목 View의 참조를 갖는다.</p><p>RecyclerView는 자체적으로 View를 생성하지 않으며, 항상 항목 View를 참조하는 ViewHolder를 생성한다.</p><blockquote><h4 id="b-id-f1viewholderb"><a class="markdownIt-Anchor" href="#b-id-f1viewholderb"></a> <b id = "f1">ViewHolder</b></h4></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119100937-6e450100-ba53-11eb-9320-522a7522d30d.jpeg'></p><p>itemView가 참조하는 항목 View가 간단할 때는 ViewHolder가 할 일이 적다. 그러나 복잡해지면 ViewHolder가 항목 View의 서로 다른 부분(자식 View)을 Crime 객체에 더 쉽고 효율적으로 연결해준다.</p><p>ViewHolder의 인스턴스가 처음 생성될 때 항목 View에 포함된 TextView의 참조를 알아내어 속성에 저장하도록 CrimeHolder를 변경한다.</p><blockquote><p>항목 View의 TextView 참조를 속성에 저장하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">    <span class="keyword">val</span> titleTextView: TextView = itemView.findViewById(R.id.crime_title)</span><br><span class="line">    <span class="keyword">val</span> dateTextView: TextView = itemView.findViewById(R.id.crime_date)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/119100951-700ec480-ba53-11eb-80e0-e6056c6293d2.jpeg'></p><p>여기서 CrimeHolder의 기본 생성자에 정의된 인자 겸 속성인 <code>view</code>는 <code>itemView</code> 속성과 동일한 항목 View의 참조 값을 갖는다. 따라서 새로 추가한 코드에서 <code>itemView</code> 대신 <code>view</code>를 사용해도 된다.</p><p>이제는 변경된 CrimeHolder가 항목 View의 TextView들에 대한 참조를 보존할 수 있으므로 이 TextView들의 값을 쉽게 보여줄 수 있게 되었다.</p><p>그런데 CrimeHolder의 인스턴스는 누가 또는 어디서 생성하는 것일까?</p><h2 id="어댑터를-구현해-recyclerview에-데이터-채우기"><a class="markdownIt-Anchor" href="#어댑터를-구현해-recyclerview에-데이터-채우기"></a> 어댑터를 구현해 RecyclerView에 데이터 채우기</h2><p><a id = "a1"><a href="#f1">ViewHolder 이미지</a></a>에 간단하게 나타나 있지만, RecyclerView는 자신이 ViewHolder를 생성하지 않는다. 대신에 이 일을 <strong>어댑터(adapter)</strong> 에 요청한다. 어댑터는 컨트롤러 객체로, RecyclerView와 RecyclerView가 보여줄 데이터 사이에 위치한다.</p><p><strong>Adapter</strong>는 다음의 일을 처리한다.</p><ul><li>필요한 ViewHolder 인스턴스들을 생성한다.</li><li>모델 계층의 데이터를 ViewHolder들과 바인딩한다.</li></ul><p>그리고 <strong>RecyclerView</strong>는 다음의 일을 처리한다.</p><ul><li>새로운 ViewHolder 인스턴스의 생성을 어댑터에게 요청한다.</li><li>지정된 위치의 데이터 항목에 ViewHolder를 바인딩하도록 어댑터에게 요청한다.</li></ul><p>이제는 어댑터를 생성할 때가 되었다. 아래의 코드와 같이 CrimeAdapter라는 이름의 내부 클래스를 CrimeListFragment에 추가하고 RecyclerView.Adapter의 서브 클래스로 지정한다. 그리고 Crime 객체가 저장된 List를 인자로 받아 crimes 속성에 저장하는 기본 생성자도 추가한다.</p><blockquote><p>CrimeAdapter 생성하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span>: <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeAdapter</span></span>(<span class="keyword">var</span> crimes: List&lt;Crime&gt;) : RecyclerView.Adapter&lt;CrimeHolder&gt;() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: CrimeHolder &#123;</span><br><span class="line">            <span class="keyword">val</span> view = layoutInflater.inflate(R.layout.list_item_crime, parent, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> CrimeHolder(view)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = crimes.size</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">CrimeHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> crime = crimes[position]</span><br><span class="line">            holder.apply &#123; </span><br><span class="line">                titleTextView.text = crime.title</span><br><span class="line">                dateTextView.text = crime.date.toString()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Adapter.onCreateViewHolder(...)</code>는 보여줄 뷰 <sub>(여기서는 list_item_view.xml)</sub>를 인플레이트한 후 이 뷰를 처리하는 ViewHolder <sub>(여기서는 CrimeHolder)</sub> 인스턴스를 생성하고 반환한다. <code>onCreateViewHolder(...)</code>의 매개변수는 <strong>서로 다른 타입의 뷰를 보여줄 때 필요</strong>한데, 아래 <a id = "a2"><a href="#f2">RecyclerView의 ViewType</a></a>에서 볼 수 있다.</p><p><code>Adapter.onBindViewHolder(holder: CrimeHolder, position: Int)</code>는 인자로 전달된 위치에 있는 Crime 객체의 범좌 제목과 발생일자를 CrimeHolder 인스턴스가 참조하는 TextView의 text 속성에 지정한다. 여기서는 Crime 객체가 List에 저장되어 있으므로 인자로 전달된 위치가 List 인덱스로 사용된다.</p><p>데이터가 저장된 데이터 셋에 몇 개의 데이터가 있는지 RecyclerView가 알아야 할 때 <code>Adapter.getItemCount()</code>를 호출해 어댑터에게 요청한다. 여기서는 <code>getItemCount()</code>가 List에 저장된 Crime 객체의 수를 반환한다.</p><p>화면에 보여줄 Crime 객체 또는 이 객체가 저장된 List를 RecyclerView는 모르며, CrimeAdapter가 안다.</p><blockquote><p>CrimeAdapter는 RecyclerView와 List&lt;Crime&gt; 사이에 위치</p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/119100927-6b4a1080-ba53-11eb-8a4f-a3201333d84e.jpeg'></p><p>RecyclerView는 화면에 보여줄 뷰 객체가 필요하면 자신과 연관된 Adapter에게 요청한다.</p><blockquote><p>RecyclerView와 CrimeAdapter 간의 소통 과정</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119100930-6d13d400-ba53-11eb-9f47-f066719fea09.jpeg'></p><p>RecyclerView는 CrimeAdapter의 <code>onCreateViewHolder(ViewGroup, Int)</code> 함수를 호출해 CrimeHolder 인스턴스를 생성한다. 이때 화면에 보여줄 항목 View를 생성자 인자로 전달한다. 그러나 CrimeAdapter가 생성해 RecyclerView에게 반환하는 CrimeHolder <sub>(그리고 이것의 itemView 속성)</sub>는 아직 데이터가 바인딩되지 않았다.</p><p>그런 다음에 RecyclerView는 CrimeAdapter의 <code>onBindViewHolder(ViewHolder, Int)</code> 함수를 호출한다. 이때 CrimeHolder의 데이터 셋 내부의 Crime 객체 위치를 인자로 전달한다. 그리고 CrimeAdapter는 이 함수에서 해당 위치의 모델 데이터인 Crime 객체를 찾아 이것을 CrimeHolder의 항목 View와 <strong>바인딩(binding)</strong> 즉, Crime 객체의 데이터를 항목 View에 채운다.</p><h2 id="recyclerview의-어댑터-설정하기"><a class="markdownIt-Anchor" href="#recyclerview의-어댑터-설정하기"></a> RecyclerView의 어댑터 설정하기</h2><p>이제는 어댑터가 준비되었으니 RecyclerView에 연결해야 한다. CrimeListFragment의 UI를 설정하는 <code>updateUI</code> 함수를 구현할 것인데, 지금은 이 함수에서 CrimeAdapter를 생성해 RecyclerView에 설정한다.</p><blockquote><p>어댑터 설정하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span>: <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crimeRecyclerView: RecyclerView</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> adapter: CrimeAdapter? = <span class="literal">null</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">val</span> view = inflater.inflate(R.layout.fragment_crime_list, container, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">        crimeRecyclerView = view.findViewById(R.id.crime_recycler_view) <span class="keyword">as</span> RecyclerView</span><br><span class="line">        crimeRecyclerView.layoutManager = LinearLayoutManager(context)</span><br><span class="line"></span><br><span class="line">        updateUI()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> crimes = crimeListViewModel.crimes</span><br><span class="line">        adapter = CrimeAdapter(crimes)</span><br><span class="line">        crimeRecyclerView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>맨 끝에 추가한 <code>crimeRecyclerView.adapter</code>에서 adapter는 RecyclerView의 속성이다. 코틀린에서는 속성의 값을 보존하는 필드를 내부적으로 유지하는데, 이것을 후원 필드 <sup>backing field</sup>라고 한다. 또한, 필드의 값을 반환하는 게터와 값을 변경하는 세터가 자동 생성되고 자동 호출된다.(자바와는 다르다) 즉, 속성의 값을 참조할 때는 게터가 자동으로 호출되며, 이 코드처럼 속성의 값을 지정/변경할 때는 세터가 자동 호출된다. 그러므로 게터 <sub><code>getAdapter()</code></sub>나 세터 <sub><code>setAdapter(RecyclerView.Adapter)</code></sub>를 호출할 필요가 없다. <code>crimeRecyclerView.adapter = adapter</code> 대신 <code>crimeRecyclerView.setAdapter(adapter)</code>로 해도 결과는 같다. 두 가지 모두 adapter 속성의 세터를 호출하는 것이기 때문이다. 그러나 코틀린 속성의 특성을 잘 활용하는 코드는 <code>crimeRecyclerView.adapter = adapter</code>이다.</p><blockquote><p>더미 데이터로 채워진 RecyclerView</p></blockquote><p><code>onBindViewHolder(...)</code> 함수가 최소한의 꼭 필요한 일만 수행하도록 작고 효율적으로 만들었기 때문에 상하 스크롤 시 매우 부드럽게 움직일 것이다.</p><p align = 'center'><img width = '200' src = 'https://user-images.githubusercontent.com/39554623/119213129-f11f9780-baf7-11eb-8815-2f2875105d36.jpeg'></p><h2 id="뷰의-재활용-recyclerview"><a class="markdownIt-Anchor" href="#뷰의-재활용-recyclerview"></a> 뷰의 재활용: RecyclerView</h2><p>위의 이미지에서는 한 화면에 14개의 View를 보여준다. 그리고 화면을 스크롤하면 100개의 View를 볼 수 있다. 그렇다면 메모리에 100개의 View를 모두 갖고 있는 것일까? 그렇지 않다. 이게 다 RecyclerView 덕분이다.</p><p>List에 저장된 모든 Crime 객체에 대해 하나씩 항목 View를 생성한다면 앱이 제대로 실행되지 않는다. List가 100개보다 훨씬 많은 데이터를 가질 수 있지만, 화면에서는 하나의 Crime이 하나의 항목 View만 필요하므로 한꺼번에 100개의 항목 View를 미리 생성하고 기다릴 필요가 없다. 그러므로 필요할 때만 항목 View 객체를 생성하는 것이 좋다.</p><p>RecyclerView가 바로 이런 일을 수행한다. 100개의 항목 View를 생성하는 대신에 한 화면을 채우는데 충분한 개수만 생성해, <strong>화면이 스크롤되면서 항목 View가 화면을 벗어날 때 RecyclerView는 해당 항목 View를 버리지 않고 재활용</strong>한다. 이름 그대로 RecyclerView는 끊임없이 항목 View를 재활용한다.</p><p>이런 이유로 <code>onCreateViewHolder(ViewGroup, Int)</code> 함수는 <code>onBindViewHolder(ViewHolder, Int)</code>보다 덜 호출된다. <strong>일단 충분한 수의 ViewHolder가 생성되면 RecyclerView는 <code>onCreateViewHolder(...)</code>의 호출을 중단하고 기존의 ViewHolder를 재활용해 <code>onBindViewHolder(ViewHolder, Int)</code>에 전달함으로써 시간과 메모리를 절약한다.</strong></p><h2 id="리스트-항목의-바인딩-개선하기"><a class="markdownIt-Anchor" href="#리스트-항목의-바인딩-개선하기"></a> 리스트 항목의 바인딩 개선하기</h2><p>현재는 CrimeAdapter가 <code>Adapter.onBindViewHolder(...)</code> 함수에서 Crime 객체의 데이터를 CrimeHolder가 참조하는 TextView로 직접 바인딩한다. 이렇게 해도 앱은 잘 실행된다. 그렇지만 CrimeHolder와 CrimeAdapter 간의 기능 분담을 명쾌하게 하는 것이 좋다. CrimeAdapter는 CrimeHolder가 내부적으로 하는 일을 모르는 것이 좋기 때문이다.</p><p>데이터 바인딩 작업을 수행하는 모든 코드는 CrimeHolder 내부에 두는 것이 좋다. 이렇게 하려면 우선 바인딩되는 Crime 객체의 참조를 보존하는 속성을 추가하면 된다. 그리고 내친 김에 기존의 TextView 참조 속성들을 <code>private</code>으로 변경하고 <code>bind(Crime)</code> 함수를 CrimeHolder에 추가한다. 이 함수에서는 바인딩되는 Crime 객체의 참조를 새로 추가하는 속성에 보존하며, TextView의 text 속성값을 현재 참조되는 Crime 객체의 속성값으로 설정한다.</p><blockquote><p><code>bind(Crime)</code> 함수 작성하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crime: Crime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> titleTextView: TextView = itemView.findViewById(R.id.crime_title)</span><br><span class="line">    <span class="keyword">val</span> dateTextView: TextView = itemView.findViewById(R.id.crime_date)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(crime: <span class="type">Crime</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.crime = crime</span><br><span class="line">        titleTextView.text = <span class="keyword">this</span>.crime.title</span><br><span class="line">        dateTextView.text = <span class="keyword">this</span>.crime.date.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제는 바인딩할 Crime 객체가 전달되면 CrimeHolder가 이 객체의 데이터를 반영해 제목 TextView와 발생일자 TextView의 text 속성값을 변경한다.</p><p>다음으로 RecyclerView가 요청할 때마다 <code>bind(Crime)</code> 함수를 호출하도록 변경해서 지정된 CrimeHolder를 특정 Crime 객체와 바인딩하자.</p><blockquote><p><code>bind(Crime)</code> 함수 호출하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeAdapter</span></span>(<span class="keyword">var</span> crimes: List&lt;Crime&gt;) : RecyclerView.Adapter&lt;CrimeHolder&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: CrimeHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> view = layoutInflater.inflate(R.layout.list_item_crime, parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> CrimeHolder(view)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = crimes.size</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">CrimeHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> crime = crimes[position]</span><br><span class="line"></span><br><span class="line"><span class="comment">//        holder.apply &#123;</span></span><br><span class="line"><span class="comment">//            titleTextView.text = crime.title</span></span><br><span class="line"><span class="comment">//            dateTextView.text = crime.date.toString()</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        holder.bind(crime)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="리스트-항목-선택에-응답하기"><a class="markdownIt-Anchor" href="#리스트-항목-선택에-응답하기"></a> 리스트 항목 선택에 응답하기</h2><p>사용자가 RecyclerView의 리스트 항목을 누르면 앱이 응답하도록 간단하게 Toast 메시지를 보여주자.</p><p>RecyclerView는 강력하고 기능도 좋지만 실질적인 책임은 거의 없다. 여기서도 그렇다. 터치 이벤트를 처리하는 것은 우리의 몫이다.</p><p>따라서 <strong>OnClickListener</strong>를 설정해 터치 이벤트를 처리하면 된다. 이때 각 항목 View는 자신과 연관된 CrimeHolder를 갖고 있으므로 CrimeHolder에서 항목 View의 <strong>OnClickListener</strong>를 구현하면 된다.</p><p>리스트 항목의 모든 View에 클릭 이벤트를 처리하도록 CrimeHolder를 변경한다.</p><blockquote><p>CrimeHolder에서 클릭 이벤트 처리하기</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view), View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crime: Crime</span><br><span class="line">    <span class="keyword">val</span> titleTextView: TextView = itemView.findViewById(R.id.crime_title)</span><br><span class="line">    <span class="keyword">val</span> dateTextView: TextView = itemView.findViewById(R.id.crime_date)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        itemView.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(crime: <span class="type">Crime</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.crime = crime</span><br><span class="line">        titleTextView.text = <span class="keyword">this</span>.crime.title</span><br><span class="line">        dateTextView.text = <span class="keyword">this</span>.crime.date.toString()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;<span class="subst">$&#123;crime.title&#125;</span> pressed!&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CrimeHolder 자신이 <strong>OnClickListener</strong> 인터페이스를 구현하고 있다. 그리고 리스트 행의 항목 View <sub>(itemView 속성이 참조함)</sub>에 발생하는 클릭 이벤트를 CrimeHolder가 받도록 설정되어 있다.</p><h2 id="listview와-gridview"><a class="markdownIt-Anchor" href="#listview와-gridview"></a> ListView와 GridView</h2><p>안드로이드 운영체제에는 ListView, GridView, Adapter 클래스가 포함되어 있다. 안드로이드 5.0까지는 이 클래스들을 사용해서 리스트나 그리드 형태로 항목들을 생성했다.</p><p>이 컴포넌트들의 API는 RecyclerView의 것과 매우 유사하다. ListView나 GridView 클래스는 리스트의 항목들을 스크롤하지만 각 항목에 관해서는 잘 알지 못한다. 그리고 리스트의 각 항목 View를 생성하는 일은 Adapter가 수행하지만, ListView나 GridView에서는 ViewHolder 패턴을 사용하도록 강제하지 않는다 <sub>(하지만 사용하는 것이 좋다)</sub>.</p><p>이런 기존 컴포넌트들은 RecyclerView로 대체되었다. ListView나 GridView의 작동 방식을 변경하려면 복잡하기 때문이다.</p><p>예를 들어, 수평 방향으로 스크롤 가능한 ListView를 생성하는 기능은 ListView API에 포함되어 있지 않아 많은 작업이 필요하다. 커스텀 레이아웃을 갖고 스크롤 가능한 RecyclerView를 생성하는 것도 여전히 많은 작업이 필요하다. 그러나 RecyclerView는 기능 확장이 되도록 설계되었으므로 나쁘지 않다.</p><p>RecyclerView의 또 다른 주요 기능은 리스트 항목의 애니메이션이다. ListView나 GridView의 경우 항목을 추가하거나 삭제할 때 생동감 있게 보이도록 하려면 구현이 복잡하고 에러가 생기기 쉽ㄴ다. 그러나 RecyclerView는 몇 가지 애니메이션 기능이 내장되어 있어서 훨씬 쉬우며, 이런 애니메이션 기능을 쉽게 커스터마이징 할 수 있다.</p><h2 id="b-id-f2recyclerview의-viewtypeb"><a class="markdownIt-Anchor" href="#b-id-f2recyclerview의-viewtypeb"></a> <b id = "f2">RecyclerView의 ViewType</b>  <a href="#a2"> ↩</a></h2><p>RecyclerView에 평범한 범죄를 보여주는 행과 심각한 범죄를 보여주는 행, 두 가지 타입 행을 생성한다.</p><p align = 'center'><img width = '150' src = 'https://user-images.githubusercontent.com/39554623/119218988-027b9a80-bb1e-11eb-8e9e-042f8542e9eb.jpeg'></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Crime</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: UUID = UUID.randomUUID(),</span><br><span class="line">    <span class="keyword">var</span> title: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">var</span> date: Date = Date(),</span><br><span class="line">    <span class="keyword">var</span> isSolved: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">var</span> requirePolice: <span class="built_in">Int</span> = VIEW_TYPE_NORMAL</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> VIEW_TYPE_NORMAL = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> VIEW_TYPE_SERIOUS = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrimeListFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crimeRecyclerView: RecyclerView</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> adapter: CrimeAdapter? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> crimeListViewModel: CrimeListViewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(CrimeListViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Total crimes: <span class="subst">$&#123;crimeListViewModel.crimes.size&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">val</span> view = inflater.inflate(R.layout.fragment_crime_list, container, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">        crimeRecyclerView = view.findViewById(R.id.crime_recycler_view) <span class="keyword">as</span> RecyclerView</span><br><span class="line">        crimeRecyclerView.layoutManager = LinearLayoutManager(context)</span><br><span class="line"></span><br><span class="line">        updateUI()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> crimes = crimeListViewModel.crimes</span><br><span class="line">        adapter = CrimeAdapter(crimes)</span><br><span class="line">        crimeRecyclerView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view), View.OnClickListener &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crime: Crime</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> titleTextView: TextView = itemView.findViewById(R.id.crime_title)</span><br><span class="line">        <span class="keyword">val</span> dateTextView: TextView = itemView.findViewById(R.id.crime_date)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            itemView.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(crime: <span class="type">Crime</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.crime = crime</span><br><span class="line">            titleTextView.text = <span class="keyword">this</span>.crime.title</span><br><span class="line">            dateTextView.text = <span class="keyword">this</span>.crime.date.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">            Toast.makeText(context, <span class="string">&quot;<span class="subst">$&#123;crime.title&#125;</span> pressed!&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SeriousCrimeHolder</span></span>(view: View) : RecyclerView.ViewHolder(view), View.OnClickListener &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> crime: Crime</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> titleTextView: TextView = itemView.findViewById(R.id.crime_title)</span><br><span class="line">        <span class="keyword">val</span> dateTextView: TextView = itemView.findViewById(R.id.crime_date)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span> &#123;</span><br><span class="line">            itemView.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(crime: <span class="type">Crime</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.crime = crime</span><br><span class="line">            titleTextView.text = <span class="keyword">this</span>.crime.title</span><br><span class="line">            dateTextView.text = <span class="keyword">this</span>.crime.date.toString()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">            Toast.makeText(context, <span class="string">&quot;<span class="subst">$&#123;crime.title&#125;</span> pressed!&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CrimeAdapter</span></span>(<span class="keyword">var</span> crimes: List&lt;Crime&gt;) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemViewType</span><span class="params">(position: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> crime = crimes[position]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">when</span> (crime.requirePolice) &#123;</span><br><span class="line">                <span class="number">0</span> -&gt; Crime.VIEW_TYPE_NORMAL</span><br><span class="line">                <span class="number">1</span> -&gt; Crime.VIEW_TYPE_SERIOUS</span><br><span class="line">                <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Unknown View Type Error&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: RecyclerView.ViewHolder &#123;</span><br><span class="line">            <span class="keyword">val</span> view: View?</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">when</span>(viewType) &#123;</span><br><span class="line">                Crime.VIEW_TYPE_NORMAL -&gt; &#123;</span><br><span class="line">                    view = layoutInflater.inflate(R.layout.list_item_crime, parent, <span class="literal">false</span>)</span><br><span class="line">                    CrimeHolder(view)</span><br><span class="line">                &#125;</span><br><span class="line">                Crime.VIEW_TYPE_SERIOUS -&gt; &#123;</span><br><span class="line">                    view = layoutInflater.inflate(R.layout.list_item_serious_crime, parent, <span class="literal">false</span>)</span><br><span class="line">                    SeriousCrimeHolder(view)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Unknown View Type Error&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = crimes.size</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> crime = crimes[position]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">when</span> (crime.requirePolice) &#123;</span><br><span class="line">                Crime.VIEW_TYPE_NORMAL -&gt; &#123;</span><br><span class="line">                    (holder <span class="keyword">as</span> CrimeHolder).bind(crime)</span><br><span class="line">                &#125;</span><br><span class="line">                Crime.VIEW_TYPE_SERIOUS -&gt; &#123;</span><br><span class="line">                    (holder <span class="keyword">as</span> SeriousCrimeHolder).bind(crime)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newInstance</span><span class="params">()</span></span>: CrimeListFragment &#123;</span><br><span class="line">            <span class="keyword">return</span> CrimeListFragment()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="참고하면-좋은-recyclerview-관련-글들"><a class="markdownIt-Anchor" href="#참고하면-좋은-recyclerview-관련-글들"></a> 참고하면 좋은 RecyclerView 관련 글들</h2><ul><li><a href="https://developer.android.com/guide/topics/ui/layout/recyclerview?hl=ko">https://developer.android.com/guide/topics/ui/layout/recyclerview?hl=ko</a></li><li><a href="https://medium.com/hongbeomi-dev/%EB%B2%88%EC%97%AD-recyclerview%EC%9D%98-%EB%82%B4%EB%B6%80-%EB%8F%99%EC%9E%91-941a2827fa5a">https://medium.com/hongbeomi-dev/번역-recyclerview의-내부-동작-941a2827fa5a</a></li><li><a href="https://woovictory.github.io/2019/01/03/Android-Diff-of-ListView-and-RecyclerView/">https://woovictory.github.io/2019/01/03/Android-Diff-of-ListView-and-RecyclerView/</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/RecyclerView/">RecyclerView</category>
      
      
      <comments>http://june0122.github.io/2021/05/23/android-bnr-09/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Codility] CyclicRotation</title>
      <link>http://june0122.github.io/2021/05/21/codility-cyclic-rotation/</link>
      <guid>http://june0122.github.io/2021/05/21/codility-cyclic-rotation/</guid>
      <pubDate>Fri, 21 May 2021 07:03:11 GMT</pubDate>
      
      <description>Lesson 2 - Arrays : CyclicRotation</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="lesson-2-arrays-cyclicrotation"><a class="markdownIt-Anchor" href="#lesson-2-arrays-cyclicrotation"></a> Lesson 2 - Arrays : <a href="https://app.codility.com/programmers/lessons/2-arrays/cyclic_rotation/">CyclicRotation</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>배열 인덱스 활용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(A: <span class="type">IntArray</span>, K: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">val</span> rotatedArray = IntArray(A.size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> A.indices) &#123;</span><br><span class="line">        <span class="keyword">val</span> index = (i + K) % A.size</span><br><span class="line">        rotatedArray[index] = A[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rotatedArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Dequeue <sup>덱</sup> 활용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(A: <span class="type">IntArray</span>, K: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">val</span> dequeue = ArrayDeque&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> rotation = <span class="keyword">when</span>(A.size) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; K % A.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dequeue.addAll(A.toList())</span><br><span class="line">    repeat(rotation) &#123; dequeue.addFirst(dequeue.removeLast()) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dequeue.toIntArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IntArray A의 크기가 0인 경우 <code>java.lang.ArithmeticException: / by zero</code>이 발생하므로 A가 0인 경우 회전하지 않도록 값을 0으로 설정해줘야 한다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Codility/">Codility</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Codility/">Codility</category>
      
      
      <comments>http://june0122.github.io/2021/05/21/codility-cyclic-rotation/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Fragment와 FragmentManager</title>
      <link>http://june0122.github.io/2021/05/21/android-bnr-08/</link>
      <guid>http://june0122.github.io/2021/05/21/android-bnr-08/</guid>
      <pubDate>Fri, 21 May 2021 06:58:59 GMT</pubDate>
      
      <description>하나 이상의 &lt;b&gt;프래그먼트(fragment)&lt;/b&gt; 로 앱의 UI를 관리하면 유연성이 좋아진다. 프래그먼트는 액티비티의 작업 수행을 대행할 수 있는 컨트롤러 객체다. 여기서 작업이란 UI 관리를 말하며, UI는 화면 전체 또는 일부분이 될 수 있다. 그런데 액티비티는 이런 유연성을 제공하도록 설계되지 않았다. 액티비티의 뷰들은 런타임 시에 변경되며, 이 뷰들을 제어하는 코드는 액티비티 내부에 있어야 한다. 따라서 &lt;b&gt;액티비티는 사용하는 특정 화면과 강하게 결합&lt;/b&gt;되어 있다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="ui-유연성의-필요"><a class="markdownIt-Anchor" href="#ui-유연성의-필요"></a> UI 유연성의 필요</h2><p>UI 유연성이라하면 사용자나 장치가 요구하는 것에 따라 런타임 시에 액티비티의 뷰를 구성하거나 변경할 수 있는 능력이다. 그런데 액티비티는 이런 유연성을 제공하도록 설계되지 않았다. 액티비티의 뷰들은 런타임 시에 변경되며, 이 뷰들을 제어하는 코드는 액티비티 내부에 있어야 한다. 따라서 <strong>액티비티는 사용하는 특정 화면과 강하게 결합</strong>되어 있다.</p><h2 id="프래그먼트-개요"><a class="markdownIt-Anchor" href="#프래그먼트-개요"></a> 프래그먼트 개요</h2><p>하나 이상의 <strong>프래그먼트(fragment)</strong> 로 앱의 UI를 관리하면 유연성이 좋아진다. 프래그먼트는 액티비티의 작업 수행을 대행할 수 있는 컨트롤러 객체다. 여기서 작업이란 UI 관리를 말하며, UI는 화면 전체 또는 일부분이 될 수 있다.</p><p>UI를 관리하는 프래그먼트를 <strong>UI 프래그먼트</strong>라 한다. UI 프래그먼트는 레이아웃 파일로부터 인플레이트 <sup>inflate</sup>되는 자신의 뷰를 하나 갖는다. 프래그먼트 뷰는 사용자가 보면서 상호 작용하기를 원하는 UI 요소들을 포함한다.</p><p>액티비티의 뷰는 자신의 UI를 갖는 대신 프래그먼트를 넣을 컨테이너를 가지며, 이 컨테이너에는 인플레이트된 프래그먼트의 뷰가 추가된다. 이 장에서는 액티비티가 하나의 프래그먼트만 포함하지만, 액티비티는 여러 개의 다른 프래그먼트 뷰를 수용하는 다수의 컨테이너를 가질 수 있다.</p><p>UI 프래그먼트를 사용하면 앱의 UI를 조립 가능한 요소로 분리할 수 있어서 유용하며, 탭 인터페이스를 비롯한 여러 가지를 쉽게 만들 수 있다.</p><p>새로운 안드로이드 Jetpack API 중에서도 내비게이션 컨트롤러와 같이 프래그먼트를 잘 활용하는 API가 있다. 따라서 프래그먼트를 사용하면 Jetpack API를 같이 사용할 때도 유용하다.</p><h2 id="프래그먼트를-이용한-앱-개발-시작"><a class="markdownIt-Anchor" href="#프래그먼트를-이용한-앱-개발-시작"></a> 프래그먼트를 이용한 앱 개발 시작</h2><p>예시로 사용되는 앱의 화면은 CrimeFragment라는 UI 프래그먼트가 관리하며, CrimeFragment의 인스턴스는 MainActivity라는 액티비티가 <strong>호스팅</strong>한다.</p><p>액티비티는 자신의 뷰 계층 구조에 프래그먼트와 그 뷰를 포함하는 곳을 제공하는데, 이것을 호스팅이라고 생각하면 된다. 프래그먼트는 화면에 보이는 뷰를 자체적으로 가질 수 없으며, 액티비티의 뷰 계층에 추가될 때만 화면에 자신의 뷰가 보인다.</p><blockquote><p>CrimeFragment를 호스팅하는 MainActivity</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119095167-e78d2580-ba4c-11eb-9438-c63f1c3689c5.jpeg'></p><p>액티비티로만 이루어진 앱에서 액티비티들이 했던, UI를 생성하고 관리하며 모델 객체들과 상호 작용하는 일을 CrimeFragment가 한다는 것을 아래의 다이어그램에서 알 수 있다.</p><blockquote><p>프래그먼트를 사용하는 앱의 객체 다이어그램</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119095164-e65bf880-ba4c-11eb-9f1e-45fc7801f301.jpeg'></p><h2 id="fragmentmanager에-ui-프래그먼트-추가하기"><a class="markdownIt-Anchor" href="#fragmentmanager에-ui-프래그먼트-추가하기"></a> FragmentManager에 UI 프래그먼트 추가하기</h2><p>Fragment 클래스가 허니콤 <sup>honeycomb</sup> 버전에 추가되면서 FragmentManager를 호출하는 코드를 포함하도록 Activity 클래스가 변경되었다. FragmentManager는 프래그먼트 리스트와 프래그먼트 트랜잭션의 백 스택 <sup>back stack</sup>을 처리한다. FragmentManager는 프래그먼트의 뷰를 액티비티의 뷰 계층에 추가하고 프래그먼트의 생명주기를 주도하는 책임을 갖는다.</p><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/119078193-ae46bc80-ba30-11eb-97a3-d88eb24fdf2a.jpeg'></p><h3 id="프래그먼트-트랜잭션"><a class="markdownIt-Anchor" href="#프래그먼트-트랜잭션"></a> 프래그먼트 트랜잭션</h3><p>FragmentManager에 프래그먼트를 관리하도록 넘겨주는 코드를 MainActivity.kt에 추가한다.</p><blockquote><p>CrimeFragment 추가하기<sup id = "a1"> <a href="#f1">코드 1</a></sup> (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> currentFragment =</span><br><span class="line">            supportFragmentManager.findFragmentById(R.id.fragment_container)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentFragment == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> fragment = CrimeFragment()</span><br><span class="line">            supportFragmentManager</span><br><span class="line">                .beginTransaction()</span><br><span class="line">                .add(R.id.fragment_container, fragment)</span><br><span class="line">                .commit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>액티비티에 프래그먼트를 추가하기 위해 액티비티의 FragmentManager를 호출했다. 이때 Jetpack 라이브러리와 AppCompatActivity 클래스를 사용하고 있으므로 supportFragmentMananger 속성을 사용해서 액티비티의 프래그먼트 매니저를 참조할 수 있다.</p><p>supportFragmentMananger의 이름 앞 'support’는 v4 지원 라이브러리로부터 유래된 것이다. 그러나 지금은 v4 지원 라이브러리가 Jetpack 내부에 androidx 라이브러리로 포함되었다.</p><blockquote><p><strong>프래그먼트 트랜잭션 <sup>fragment transaction</sup></strong> 을 생성하고 커밋</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">supportFragmentManager</span><br><span class="line">    .beginTransaction()</span><br><span class="line">    .add(R.id.fragment_container, fragment)</span><br><span class="line">    .commit()</span><br></pre></td></tr></table></figure><p>프래그먼트 트랜잭션은 프래그먼트 리스트에 프래그먼트를 추가 <sup>add</sup>, 삭제 <sup>remove</sup>, 첨부 <sup>attach</sup>, 분리 <sup>detach</sup>, 변경 <sup>replace</sup>하는데 사용된다. 프래그먼트 트랜잭션을 사용하면 여러 개의 오퍼레이션 <sub>(트랜잭션으로 실행되는 각 함수 코드)</sub>을 묶어서 수행할 수 있다. 예를 들어, 다수의 프래그먼트를 동시에 서로 다른 컨테이너에 추가하는 경우다. 프래그먼트로 런타임 시에 화면을 구성 또는 변경하는 방법의 핵심이 바로 프래그먼트 트랜잭션이다.</p><p>FragmentManager는 프래그먼트 트랜잭션의 백 스택을 유지 관리한다. 따라서 프래그먼트 트랜잭션이 다수의 오퍼레이션을 포함한다면 해당 트랜잭션이 백 스택에서 제거될 때 이 오퍼레이션들이 역으로 실행된다. 그러므로 다수의 프래그먼트 오퍼레이션들을 하나의 트랜잭션으로 묶으면 UI 상태를 더욱 잘 제어할 수 있다.</p><p><code>FragmentManager.beginTransaction</code> 함수는 FragmentTranscation의 인스턴스를 생성해 반환한다. FragmentTransaction 클래스는 플루언트 인터페이스 <sup>fluent interface</sup>를 사용한다. <sub>(플루언트 인터페이스는 코드를 이해하기 쉽게 해주는 객체지향 기법이며, 일반적으로 함수의 연쇄 호출 형태로 구현된다.)</sub> 즉, FragmentTransaction을 구성하는 함수들이 Unit 대신 FragmentTransaction 객체를 반환하기 때문에 이 함수들을 연쇄 호출할 수 있다 <sub>(코틀린의 Unit은 하나의 인스턴스만 생성되는 싱글톤 객체이며 자바의 void와 같이 함수의 반환 값이 없음을 나타내는 데 사용된다)</sub>. 따라서 위의 코드는 '새로운 프래그먼트 트랜잭션 인스턴스를 생성하고 이 인스턴스에 <code>add()</code> 오퍼레이션을 포함시킨 후 커밋해라’라는 의미다.</p><p><code>add(...)</code> 함수는 컨테이너 뷰 ID와 새로 생성된 CrimeFragment 인스턴스를 매개변수로 갖는다. 여기서 컨테이너 뷰 ID는 activity_main.xml에 정의했던 FrameLayout의 리소스 ID다.</p><p>컨테이너 뷰 ID는 다음 두 가지 목적으로 사용된다.</p><ol><li>액티비티 뷰의 어느 위치에 프래그먼트 뷰가 나타나야 하는지를 <strong>FragmentManager</strong>에 알려준다.</li><li><strong>FragmentManager</strong>의 리스트에서 프래그먼트를 고유하게 식별하는 데 사용된다.</li></ol><p>FragmentManager로부터 CrimeFragment를 가져오려면 다음의 코드 첫째 줄처럼 컨테이너 뷰 ID로 요청한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> currentFragment =</span><br><span class="line">    supportFragmentManager.findFragmentById(R.id.fragment_container)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentFragment == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> fragment = CrimeFragment()</span><br><span class="line">    supportFragmentManager</span><br><span class="line">        .beginTransaction()</span><br><span class="line">        .add(R.id.fragment_container, fragment)</span><br><span class="line">        .commit()</span><br></pre></td></tr></table></figure><p>FragmentManager가 FrameLayout의 리소스 ID를 사용해서 CrimeFragment를 식별한다는 것이 이상하게 보일지 모른다. 그러나 컨테이너 뷰의 리소스 ID로 UI 프래그먼트를 식별하는 것이 FragmentManager가 작동하는 방법이다. 만일 하나의 액티비티에 여러 개의 프래그먼트를 추가한다면, 각 프래그먼트에 대해 별도의 리소스 ID를 갖는 컨테이너 뷰를 생성하기 때문이다.</p><p>이제 <b id = "f1">코드 1</b> <a href="#a1"> ↩</a>이 어떻게 작동하는지 자세히 살펴보자.</p><p>우선 R.id.fragment_container의 컨테이너 뷰 ID와 연관된 프래그먼트를 FragmentManager에 요청한다. 만일 이 프래그먼트가 리스트에 이미 있다면, FragmentManager가 그것을 반환한다.</p><p>그런데 요청한 프래그먼트가 어째서 이미 프래그먼트 리스트에 있는 것일까? 여러 이유로 액티비티가 소멸되었다가 다시 생성될 때를 대비해서 리스트에 보존하기 대문이다. 즉, 장치가 회전되거나 안드로이드 운영체제의 메모리 회수로 MainActivity가 소멸되었다가 <strong>다시 생성</strong>되면 <code>MainActivity.onCreate(Bundle?)</code>이 다시 호출된다. 따라서 액티비티가 소멸될 때는 이 액티비티의 FragmentManager 인스턴스가 해당 액티비티의 프래그먼트 리스트를 보존한다. 그리고 해당 액티비티가 다시 생성되면 새로운 FragmentManager 인스턴스가 그 리스트를 가져와서 리스트에 있는 프래그먼트를 다시 생성해 이전 상태로 복원한다.</p><p>이와는 달리 지정된 컨테이너 뷰 ID의 프래그먼트가 리스트에 없다면, fragment 변수는 null이 된다. 이때는 새로운 CrimeFragment와 새로운 프래그먼트 트랜잭션(프래그먼트를 리스트에 추가하는)을 생성한다.</p><p>이렇게 MainActivity가 CrimeFragment를 호스팅하게 되었다.</p><h3 id="fragmentmanager와-프래그먼트-생명주기"><a class="markdownIt-Anchor" href="#fragmentmanager와-프래그먼트-생명주기"></a> FragmentManager와 프래그먼트 생명주기</h3><p>프래그먼트 생명주기는 액티비티 생명주기와 유사하다. 즉 중단 <sub>(stopped)</sub> 상태, 일시 중지 <sub>(paused)</sub> 상태, 실행 재개 <sub>(resumed)</sub> 상태를 가지며, 상태가 전환될 대 필요한 일을 처리하기 위해 오버라이드할 수 있는 함수들도 갖는다. 이 함수들은 액티비티 생명주기 함수들과 대응된다.</p><blockquote><p>프래그먼트 생명주기 다이어그램</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/119095152-e3f99e80-ba4c-11eb-88d1-7fb7faeb2415.jpeg'></p><p>액티비티와 프래그먼트의 생명주기 함수가 대응된다는 점이 중요하다. 프래그먼트는 액티비티를 대신해 작동하므로 프래그먼트의 상태는 액티비티의 상태를 반영해야한다. 따라서 프래그먼트는 액티비티의 작업을 처리하기 위해 액티비티와 일치하는 생명주기 함수가 필요하다.</p><p>프래그먼트 생명주기와 액티비티 생명주기가 다른 점은 프래그먼트 생명주기 함수는 안드로이드 운영체제가 아닌 호스팅 액티비티의 FragmentManager가 호출한다는 점이다. 프래그먼트는 액티비티가 내부적으로 처리해서 안드로이드 운영체제는 액티비티가 사용하는 프래그먼트에 관해서는 아무것도 모른다.</p><p><code>onAttach(Context?)</code>, <code>onCreate(Bundle?)</code>, <code>onCreateView(...)</code>, <code>onViewCreated(...)</code> 함수들은 프래그먼트를 FragmentManager애 추가할 때 호출된다.</p><p><code>onActivityCreated(Bundle?)</code> 함수는 호스팅 액티비티의 <code>onCreate(Bundle?)</code> 함수가 실행된 후 호출된다. 앱에서는 <code>MainActivity.onCreate(Bundle?)</code>에서 CrimeFragment를 추가하는데, <code>onActivityCreated(Bundle?)</code> 함수는 프래그먼트가 추가된 후에 호출된다.</p><p>액티비티가 이미 실행 중일 때 프래그먼트를 추가하면 어떻게 될까? 이때 FragmentManager는 해당 프래그먼트가 호스팅 액티비티의 상태를 따라잡는데 필요한 프래그먼트 생명주기 함수를 몇 개이든 차례대로 즉시 호출한다. 예를 들어, 이미 실행 중인 액티비티에 프래그먼트가 추가되면 이 프래그먼트는 <code>onAttach(Context?)</code>, <code>onCreate(Bundle?)</code>, <code>onActivityCreated(Bundle?)</code>, <code>onStart()</code>, <code>onResume()</code>의 순서로 이 함수들의 호출을 연속해서 받게 된다.</p><p>일단 프래그먼트의 상태가 액티비티의 상태를 따라잡으면 이후부터는 호스팅 액티비티의 FragmentManager가 액티비티 상태와 동조된 프래그먼트 상태를 유지한다. 즉, 안드로이드 운영체제로부터 액티비티 생명주기 함수들이 호출되면 이것과 부합되는 프래그먼트 생명주기 함수들을 호출해준다.</p><h2 id="프래그먼트를-사용하는-애플리케이션-아키텍쳐"><a class="markdownIt-Anchor" href="#프래그먼트를-사용하는-애플리케이션-아키텍쳐"></a> 프래그먼트를 사용하는 애플리케이션 아키텍쳐</h2><p>프래그먼트는 주요 컴포넌트를 재사용하게끔 캡슐화한다. 여기서 주요 컴포넌트는 앱의 전체 화면에 나타난다. 만일 한번에 너무 많은 프래그먼트를 화면에 넣는다면, 프래그먼트 트랜잭션 때문에 코드가 지저분하게 된다. 따라서 작은 컴퍼넌트들을 재사용할 때는 프래그먼트 대신 커스텀 뷰 <sub>(View의 서브 클래스 또는 View의 서브 클래스의 서브 클래스)</sub>로 추출하는 것이 좋은 방법이다.</p><p>일반적으로 한 화면에는 최대 두 개 또는 세 개 정도의 프래그먼트를 사용하는 것이 좋다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      
      <comments>http://june0122.github.io/2021/05/21/android-bnr-08/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Codility] BinaryGap</title>
      <link>http://june0122.github.io/2021/05/19/codility-binary-gap/</link>
      <guid>http://june0122.github.io/2021/05/19/codility-binary-gap/</guid>
      <pubDate>Wed, 19 May 2021 00:41:13 GMT</pubDate>
      
      <description>Lesson 1 - Iterations : BinaryGap</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="lesson-1-iterations-binarygap"><a class="markdownIt-Anchor" href="#lesson-1-iterations-binarygap"></a> Lesson 1 - Iterations : <a href="https://app.codility.com/programmers/lessons/1-iterations/binary_gap/">BinaryGap</a></h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>이진수 변환 직접 구현</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(N: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> answer = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> temp = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> quotient = N</span><br><span class="line">    <span class="keyword">var</span> remainder: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (quotient &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        remainder = quotient % <span class="number">2</span></span><br><span class="line">        quotient /= <span class="number">2</span></span><br><span class="line">        temp += remainder.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> binary = temp.reversed()</span><br><span class="line">    <span class="keyword">val</span> oneIndexList = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    binary.forEachIndexed &#123; index, c -&gt;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            oneIndexList.add(index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> gap: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until oneIndexList.size - <span class="number">1</span>) &#123;</span><br><span class="line">        gap = oneIndexList[i+<span class="number">1</span>] - oneIndexList[i] - <span class="number">1</span></span><br><span class="line">        answer = max(gap, answer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>이진수 변환을 직접 구현</li><li>이진수 문자열에서 <code>1</code>이 위치한 인덱스들을 값으로 가지는 리스트 생성</li><li><code>1</code>이 위치한 인접한 인덱스끼리 빼고, 추가적으로 1을 더 빼면 gap의 크기가 나옴</li></ol><blockquote><p><code>Int.toString(radix: Int)</code> 사용하여 이진수 변환</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(N: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> binary = N.toString(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> zeroList = binary.split(<span class="string">&quot;1&quot;</span>).toMutableList()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binary.last() != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">        zeroList.removeAt(zeroList.size - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> zeroList.map &#123; it.length &#125;.max() ?: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>Int.toString(radix: Int)</code> 사용하여 이진수 변환을 매우 간단하게 할 수 있다.</li><li><code>1</code>을 구분자 <sup>delimniter</sup>로 이진수 문자열을 <strong>split</strong> 하여 연결된 <code>0</code>들을 값으로 가진 리스트를 생성</li><li>만약 이진수의 끝자리가 <code>1</code>이 아닐 경우엔 마지막 연결된 <code>0</code>들은 gap으로 인정되지 않으므로 리스트에서 삭제한다.</li><li><code>Iterable&lt;T&gt;.map(transform: (T) -&gt; R)</code>을 통해 리스트 원소의 길이를 기준으로 리스트를 생성한 후 가장 큰 값을 <code>max()</code>를 이용해 리턴한다.</li></ol><p>대부분의 코딩 사이트는 <strong>kotlin 1.4</strong>를 지원하지 않는데 1.4 기준으로는 아래처럼 사용해야하거나 사용할 수 있다.</p><ul><li><code>removeAt(zeroList.size - 1)</code> -&gt; <code>zeroList.removeLast()</code></li><li><code>max()</code> -&gt; <code>maxOrNull()</code></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Codility/">Codility</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Codility/">Codility</category>
      
      
      <comments>http://june0122.github.io/2021/05/19/codility-binary-gap/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] Do not concatenate text displayed with setText</title>
      <link>http://june0122.github.io/2021/05/18/android-memo-text-concatenatation/</link>
      <guid>http://june0122.github.io/2021/05/18/android-memo-text-concatenatation/</guid>
      <pubDate>Tue, 18 May 2021 02:27:19 GMT</pubDate>
      
      <description>TextView의 내용을 setText() 메서드를 이용해 설정할 때 Do not concatenate text displayed with setText. Use resource string with placeholders.라는 경고문을 자주 볼 수 있다. 대략 setText로 표시된 텍스트를 + 로 연결해서 사용하지 말고 리소스 문자열을 placeholder와 함께 사용하라는 내용인데, &lt;b&gt;문자열 서식 지정&lt;/b&gt;을 이용하여 &lt;b&gt;getString(int, Object...)&lt;/b&gt;의 값을 &lt;b&gt;setText()&lt;/b&gt;에 넣어주면 된다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-개요"><a class="markdownIt-Anchor" href="#문제-개요"></a> 문제 개요</h2><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/118576969-83f0c700-b7c4-11eb-956c-cebca0709b8d.png'></p><p>TextView의 내용을 <code>setText()</code> 메서드를 이용해 설정할 때 <strong>Do not concatenate text displayed with setText. Use resource string with placeholders.</strong> 라는 경고문을 자주 볼 수 있다.</p><p>대략 setText로 표시된 텍스트를 <code>+</code>로 연결해서 사용하지 말고 리소스 문자열을 placeholder와 함께 사용하라는 내용인데 어떻게 해결할 수 있을까?</p><h2 id="해결"><a class="markdownIt-Anchor" href="#해결"></a> 해결</h2><p>답은 <a href="https://developer.android.com/guide/topics/resources/string-resource?hl=ko#%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%84%9C%EC%8B%9D-%EC%A7%80%EC%A0%95"><strong>문자열 서식 지정</strong></a>에 있다. 아래의 코드와 같이 문자열 리소스에서 원하는 자리에 들어갈 값을 서식 인수 <sup>format argument</sup>를 추가하여 지정하는 것이다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;welcome_messages&quot;</span>&gt;</span>Hello, %1$s! You have %2$d new messages.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><p>위의 예시는 문자열에 두 개의 서식 인수가 존재하는데 <code>%1$s</code>에는 문자열이, <code>%2$d</code>에는 10진수 값이 들어간다. 여기서 주의해야 할 부분은 서식 인수의 syntax인데 아래와 같은 형태이다.</p><blockquote><p>%[<code>인자의 인덱스</code>$]<code>서식 지정자</code></p></blockquote><ul><li>인자의 인덱스 <sup>argument index</sup>는 문자열 리소스에서 서식 <strong>인수의 인덱스</strong>를 선택할 수 있게 해준다. 첫 번째 인자는 <code>1$</code>, 두 번째는 <code>2$</code>, 세 번째는 <code>3$</code>와 같은 식이다.</li><li>서식 지정자 <sup>format specifier</sup>는 <strong>데이터 타입</strong>을 지정하는 것인데, C언어 등에서 흔히 사용하는 <code>%d</code>, <code>%s</code>와 같은 서식 지정자와 동일한 개념이다.</li></ul><p>문자열 리소스에서 서식 인수를 지정했다면 <a href="https://developer.android.com/reference/android/content/Context?hl=ko#getString(int,%20java.lang.Object...)"><code>getString(int, Object...)</code></a>을 통해 아래의 코드와 같이 매개변수의 첫 번째 인자로 해당 문자열 리소스를 전달하고 차례로 서식 인수들에 들어갈 값을 전달하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = getString(R.string.welcome_messages, username, mailCount)</span><br></pre></td></tr></table></figure><p>결과적으로 <code>+</code>로 연결된 텍스트가 아닌 문자열 서식 지정을 이용하여 <code>getString(int, Object...)</code>의 값을 <code>setText()</code>에 넣어주면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testTextView.text = getString(R.string.welcome_messages, username, mailCount)</span><br></pre></td></tr></table></figure><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li><p>Android Developers 가이드 | <a href="https://developer.android.com/guide/topics/resources/string-resource?hl=ko#%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%84%9C%EC%8B%9D-%EC%A7%80%EC%A0%95">문자열 서식 지정</a></p></li><li><p>Android Developers 가이드 | <a href="https://developer.android.com/reference/android/content/Context?hl=ko#getString(int,%20java.lang.Object...)">getString</a></p></li><li><p>StackOverflow | <a href="https://stackoverflow.com/questions/33164886/android-textview-do-not-concatenate-text-displayed-with-settext">Android TextView : “Do not concatenate text displayed with setText”</a></p></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Memo/">Memo</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      
      <comments>http://june0122.github.io/2021/05/18/android-memo-text-concatenatation/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
