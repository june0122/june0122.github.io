<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>카미유 테크 블로그</title>
    <link>http://june0122.github.io/</link>
    
    <atom:link href="http://june0122.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 19 Jul 2021 14:53:36 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[코틀린 자료구조] 트리 (Tree)</title>
      <link>http://june0122.github.io/2021/07/19/data-structure-trees/</link>
      <guid>http://june0122.github.io/2021/07/19/data-structure-trees/</guid>
      <pubDate>Mon, 19 Jul 2021 14:36:42 GMT</pubDate>
      
      <description>&lt;b&gt;트리&lt;small&gt;(tree)&lt;/small&gt;&lt;/b&gt;는 매우 중요한 자료구조로 다음과 같이 소프트웨어 개발에서 반복되는 많은 문제를 해결하는 데 사용한다.&lt;br&gt;① 계층적 관계를 표현 ② 정렬된 데이터 관리 ③ 빠른 조회 작업을 용이하게 함</description>
      
      
      
      <content:encoded><![CDATA[<p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125863597-4066759b-d019-421a-bcd4-f0383febe0d0.png'></p><p><b>트리<small>(tree)</small></b>는 매우 중요한 자료구조로 다음과 같이 소프트웨어 개발에서 반복되는 많은 문제를 해결하는 데 사용한다.</p><ul><li>계층적 관계를 표현</li><li>정렬된 데이터 관리</li><li>빠른 조회 작업을 용이하게 함</li></ul><h2 id="트리와-관련된-용어들smallterminologysmall"><a class="markdownIt-Anchor" href="#트리와-관련된-용어들smallterminologysmall"></a> 트리와 관련된 용어들<small>(Terminology)</small></h2><h3 id="노드smallnodesmall"><a class="markdownIt-Anchor" href="#노드smallnodesmall"></a> 노드<small>(Node)</small></h3><p>연결 리스트와 마찬가지로 트리도 노드로 구성된다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125863852-f54f02f7-560f-4037-8e11-db6f9ba137b7.png'></p><p>각 노드는 일부 데이터를 캡슐화하고 자식을 추적한다.</p><h3 id="부모와-자식smallparent-and-childsmall"><a class="markdownIt-Anchor" href="#부모와-자식smallparent-and-childsmall"></a> 부모와 자식<small>(Parent and child)</small></h3><p>트리는 거꾸로 뒤집힌 실제 나무처럼 위에서 시작하여 아래쪽으로 가지를 뻗어 나간다.</p><p>첫 번째 노드를 제외한 모든 노드는 <strong>부모</strong> 노드라고 하는 위의 단일 노드에 연결된다. 바로 아래에 있고 부모 노드에 연결된 노드를 <strong>자식</strong> 노드라 한다. 트리에서 모든 자식은 정확히 한 명의 부모를 가진다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125863863-bf9c778e-92b9-4b93-b44a-edf19b0a64af.png'></p><h3 id="뿌리smallrootsmall"><a class="markdownIt-Anchor" href="#뿌리smallrootsmall"></a> 뿌리<small>(Root)</small></h3><p>트리의 최상위 노드를 트리의 뿌리<small>(루트, root)</small>라고 한다. 부모가 없는 유일한 노드이기도 하다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125863874-acebca4c-f298-4ab9-b24e-10376320c968.png'></p><h3 id="잎smallleafsmall"><a class="markdownIt-Anchor" href="#잎smallleafsmall"></a> 잎<small>(Leaf)</small></h3><p>자식이 없는 노드를 리프라고 한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125863886-cfebea5d-2c3d-497c-9848-a1c709baa36c.png'></p><h2 id="구현"><a class="markdownIt-Anchor" href="#구현"></a> 구현</h2><p>트리는 노드로 구성되어 있으므로 제일 처음해야 할 작업은 TreeNode 클래스를 생성하는 것이다.</p><blockquote><p>TreeNode.kt</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> value: T) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> children: MutableList&lt;TreeNode&lt;T&gt;&gt; = mutableListOf()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 노드는 값을 담당하고 MutableList를 사용하여 모든 자식에 대한 참조를 저장한다.</p><p>다음으로 TreeNode 내부에 아래의 메서드를 추가하자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(child: <span class="type">TreeNode</span>&lt;<span class="type">T</span>&gt;)</span></span> = children.add(child)</span><br></pre></td></tr></table></figure><p>이 메서드는 노드에 자식 노드를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> hot = TreeNode(<span class="string">&quot;Hot&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> cold = TreeNode(<span class="string">&quot;Cold&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> beverages = TreeNode(<span class="string">&quot;Beverages&quot;</span>).run &#123;</span><br><span class="line">        add(hot)</span><br><span class="line">        add(cold)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>계층 구조는 트리 구조의 자연스러운 형태 중 하나이다. 위의 코드는 아래와 같은 구조를 가지고 있다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125865331-9c19532f-d417-4f64-88f0-91cd4314520f.png'></p><h2 id="traversal-algorithms"><a class="markdownIt-Anchor" href="#traversal-algorithms"></a> Traversal algorithms</h2><p>배열이나 리스트와 같은 <strong>선형 컬렉션</strong>을 반복<small>(iterating)</small>하는 것은 간단하다. 선형 컬렉션에는 명확한 시작과 끝이 있다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125865349-410b60ee-2e18-41ea-b07c-05d8f3939925.png'></p><p>트리를 반복하는 것은 조금 더 복잡하다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125865353-3a4a0fec-6f60-42d7-8165-cdee3b7d6ddb.png'></p><p>왼쪽에 있는 노드가 우선 순위를 가져야 할까? 노드의 깊이는 우선 순위와 어떤 관련이 있을까? 순회 전략은 해결하려는 문제에 따라 다르게 가져가야 한다.</p><p>서로 다른 트리와 문제에 대해 여러 전략이 존재한다. 이 모든 방법은 노드를 <strong>방문</strong>하고 노드 내부의 정보를 사용할 수 있게 해준다.</p><blockquote><p>TreeNode 클래스의 외부에 정의 추가</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Visitor&lt;T&gt; = (TreeNode&lt;T&gt;) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> value: T) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="depth-first-traversalsmalldepth-first-search-dfs-깊이-우선-탐색small"><a class="markdownIt-Anchor" href="#depth-first-traversalsmalldepth-first-search-dfs-깊이-우선-탐색small"></a> Depth-first traversal<small>(Depth-first search, DFS, 깊이 우선 탐색)</small></h3><p>깊이 우선 탐색은 루트 노드에서 시작하여 리프에 도달한 다음 백트래킹하기 전에 각 분기를 따라 가능한 멀리 트리를 탐색한다.</p><p>TreeNode 내부에 다음을 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">forEachDepthFirst</span><span class="params">(visit: <span class="type">Visitor</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    visit(<span class="keyword">this</span>)</span><br><span class="line">    children.forEach &#123; </span><br><span class="line">        it.forEachDepthFirst(visit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 간단한 코드는 재귀를 사용하여 다음 노드를 처리한다.</p><p>재귀적인 구현을 사용하지 않으려면 스택을 사용할 수 있으나 재귀를 이용한 방법이 더 간단하다.</p><blockquote><p>재귀 깊이 우선 탐색 테스트</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">makeBeverageTree</span><span class="params">()</span></span>: TreeNode&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> tree = TreeNode(<span class="string">&quot;Beverages&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> hot = TreeNode(<span class="string">&quot;hot&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> cold = TreeNode(<span class="string">&quot;cold&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> tea = TreeNode(<span class="string">&quot;tea&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> coffee = TreeNode(<span class="string">&quot;coffee&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> chocolate = TreeNode(<span class="string">&quot;cocoa&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> blackTea = TreeNode(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> greenTea = TreeNode(<span class="string">&quot;green&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> chaiTea = TreeNode(<span class="string">&quot;chai&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> soda = TreeNode(<span class="string">&quot;soda&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> milk = TreeNode(<span class="string">&quot;milk&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> gingerAle = TreeNode(<span class="string">&quot;ginger ale&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> bitterLemon = TreeNode(<span class="string">&quot;bitter lemon&quot;</span>)</span><br><span class="line">    tree.add(hot)</span><br><span class="line">    tree.add(cold)</span><br><span class="line">    hot.add(tea)</span><br><span class="line">    hot.add(coffee)</span><br><span class="line">    hot.add(chocolate)</span><br><span class="line">    cold.add(soda)</span><br><span class="line">    cold.add(milk)</span><br><span class="line">    tea.add(blackTea)</span><br><span class="line">    tea.add(greenTea)</span><br><span class="line">    tea.add(chaiTea)</span><br><span class="line">    soda.add(gingerAle)</span><br><span class="line">    soda.add(bitterLemon)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>makeBeverageTree()</code>는 아래와 같은 트리를 생성한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125865366-20b030f5-3cee-472f-b095-2d50ba7e7151.png'></p><p>트리를 생성한 다음 <code>main()</code>에서 다음과 같은 코드를 실행한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tree = makeBeverageTree()</span><br><span class="line">    tree.forEachDepthFirst &#123; println(it.value) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드의 출력 결과는 깊이 우선 탐색이 각 노드를 방문하는 순서를 보여준다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Beverages</span><br><span class="line">hot</span><br><span class="line">tea</span><br><span class="line">black</span><br><span class="line">green</span><br><span class="line">chai</span><br><span class="line">coffee</span><br><span class="line">cocoa</span><br><span class="line">cold</span><br><span class="line">soda</span><br><span class="line">ginger ale</span><br><span class="line">bitter lemon</span><br><span class="line">milk</span><br></pre></td></tr></table></figure><h3 id="level-order-traversal"><a class="markdownIt-Anchor" href="#level-order-traversal"></a> Level-order traversal</h3><p>Level-order traversal은 노드의 깊이를 기반으로 트리의 각 노드를 방문하는 방법이다. 루트에서 시작하여 하위 레벨로 이동하기 전에 같은 레벨의 모든 노드를 방문한다.</p><p>TreeNode 내부에 다음을 추가한다.</p><blockquote><p><a href="https://github.com/june0122/DataStructureKotlin/tree/master/src/queue">직접 구현한 Queue</a>를 사용할 시</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">forEachLevelOrder</span><span class="params">(visit: <span class="type">Visitor</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    visit(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">val</span> queue = StackQueue&lt;TreeNode&lt;T&gt;&gt;()</span><br><span class="line">    children.forEach &#123; queue.enqueue(it) &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> node = queue.dequeue()</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        visit(node)</span><br><span class="line">        node.children.forEach &#123; queue.enqueue(it) &#125;</span><br><span class="line">        node = queue.dequeue()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>java.util 패키지 내부의 Queue 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">forEachLevelOrder</span><span class="params">(visit: <span class="type">Visitor</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    visit(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;TreeNode&lt;T&gt;&gt; = LinkedList()</span><br><span class="line">    children.forEach &#123; queue.offer(it) &#125;</span><br><span class="line">    <span class="keyword">var</span> node = queue.poll()</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        visit(node)</span><br><span class="line">        node.children.forEach &#123; queue.offer(it) &#125;</span><br><span class="line">        node = queue.poll()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>forEachLevelOrder()</code>는 각 노드를 레벨 순으로 방문한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125865372-a74a4353-1568-422f-ac6c-9abf96f4d858.png'></p><p>노드가 올바른 레벨 순서로 방문되도록 큐를 사용하는 방법에 유의한다. 현재 노드를 방문하여 모든 자식을 큐에 넣는다. 그런 다음 비어 있을 때까지 큐를 사용하기 시작한다. 노드를 방문할 때마다 노드의 모든 자식들도 큐에 넣는다. 이렇게 하면 같은 레벨의 모든 노드를 차례로 방문할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> tree = makeBeverageTree()</span><br><span class="line">  tree.forEachLevelOrder &#123; println(it.value) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">beverages</span><br><span class="line">hot</span><br><span class="line">cold</span><br><span class="line">tea</span><br><span class="line">coffee</span><br><span class="line">cocoa</span><br><span class="line">soda</span><br><span class="line">milk</span><br><span class="line">black</span><br><span class="line">green</span><br><span class="line">chai</span><br><span class="line">ginger ale</span><br><span class="line">bitter lemon</span><br></pre></td></tr></table></figure><h3 id="검색"><a class="markdownIt-Anchor" href="#검색"></a> 검색</h3><p>노드를 반복하는 메서드를 이미 구현했으므로 검색 알고리즘을 구현하는데 오래 걸리지 않는다.</p><p>TreeNode 내부에 아래의 코드를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">search</span><span class="params">(value: <span class="type">T</span>)</span></span>: TreeNode&lt;T&gt;? &#123;</span><br><span class="line">    <span class="keyword">var</span> result: TreeNode&lt;T&gt;? = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    forEachLevelOrder &#123; </span><br><span class="line">        <span class="keyword">if</span> (it.value == value) &#123;</span><br><span class="line">            result = it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드를 테스트하기 위해 <code>main()</code>에 아래의 코드를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tree = makeBeverageTree()</span><br><span class="line">    tree.search(<span class="string">&quot;ginger ale&quot;</span>)?.let &#123;</span><br><span class="line">        println(<span class="string">&quot;Found node: <span class="subst">$&#123;it.value&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tree.search(<span class="string">&quot;WKD Blue&quot;</span>)?.let &#123;</span><br><span class="line">        println(it.value)</span><br><span class="line">    &#125; ?: println(<span class="string">&quot;Couldn&#x27;t find WKD Blue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main()</code>을 실행하면 다음과 같은 출력 결과를 볼 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Found node: ginger ale</span><br><span class="line">Couldn&#x27;t find WKD Blue</span><br></pre></td></tr></table></figure><p>위에서 level-order traversal 알고리즘을 사용했는데, 모든 노드를 방문하기 때문에 일치하는 항목이 여러 개일 경우 마지막으로 일치하는 항목이 채택된다. 이것은 사용하는 순회 방법에 따라 다른 객체를 얻을 수 있음을 의미한다.</p><h2 id="챌린지"><a class="markdownIt-Anchor" href="#챌린지"></a> 챌린지</h2><p>아래 트리의 값을 레벨에 따라 순서대로 출력하시오. 같은 레벨에 속하는 노드는 같은 줄에 출력해야 합니다.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/126172924-394314ff-9136-4639-bd29-65e1615d6edb.png'></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">17</span> <span class="number">20</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">0</span> <span class="number">2</span> <span class="number">5</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><blockquote><p>예제 트리 생성 코드</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">makeSampleTree</span><span class="params">()</span></span>: TreeNode&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> tree = TreeNode(<span class="number">15</span>)</span><br><span class="line">    <span class="keyword">val</span> one = TreeNode(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> seventeen = TreeNode(<span class="number">17</span>)</span><br><span class="line">    <span class="keyword">val</span> twenty = TreeNode(<span class="number">20</span>)</span><br><span class="line">    tree.add(one)</span><br><span class="line">    tree.add(seventeen)</span><br><span class="line">    tree.add(twenty)</span><br><span class="line">    one.add(TreeNode(<span class="number">1</span>))</span><br><span class="line">    one.add(TreeNode(<span class="number">5</span>))</span><br><span class="line">    one.add(TreeNode(<span class="number">0</span>))</span><br><span class="line">    seventeen.add(TreeNode(<span class="number">2</span>))</span><br><span class="line">    twenty.add(TreeNode(<span class="number">5</span>))</span><br><span class="line">    twenty.add(TreeNode(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>레벨 별 노드 출력 코드 (java.util 패키지 내부의 Queue 사용)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printEachLevel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;TreeNode&lt;T&gt;&gt; = LinkedList()</span><br><span class="line">    <span class="keyword">var</span> nodesLeftInCurrentLevel = <span class="number">0</span></span><br><span class="line">    queue.offer(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        nodesLeftInCurrentLevel = queue.size</span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">while</span> (nodesLeftInCurrentLevel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.poll()</span><br><span class="line">            node?.let &#123;</span><br><span class="line">                print(<span class="string">&quot;<span class="subst">$&#123;node.value&#125;</span> &quot;</span>)</span><br><span class="line">                node.children.forEach &#123; queue.offer(it) &#125;</span><br><span class="line">                nodesLeftInCurrentLevel--</span><br><span class="line">            &#125; ?: <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>레벨 별 노드 출력 코드 (<a href="https://github.com/june0122/DataStructureKotlin/tree/master/src/queue">직접 구현한 Queue</a>를 사용)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printEachLevel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> queue = StackQueue&lt;TreeNode&lt;T&gt;&gt;()</span><br><span class="line">    <span class="keyword">var</span> nodesLeftInCurrentLevel = <span class="number">0</span></span><br><span class="line">    queue.enqueue(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty.not()) &#123;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        nodesLeftInCurrentLevel = queue.count</span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">while</span> (nodesLeftInCurrentLevel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.dequeue()</span><br><span class="line">            node?.let &#123;</span><br><span class="line">                print(<span class="string">&quot;<span class="subst">$&#123;node.value&#125;</span> &quot;</span>)</span><br><span class="line">                node.children.forEach &#123; queue.enqueue(it) &#125;</span><br><span class="line">                nodesLeftInCurrentLevel--</span><br><span class="line">            &#125; ?: <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>레벨 순서 순회를 용이하게 하기 위해 큐를 초기화하는 것으로 시작한다. 또한 새 줄을 출력하기 전에 작업해야하는 노드의 수를 추적하기 위해 <em>nodesLeftInCurrentLevel</em>을 만든다.</li><li>레벨 순서 순회는 큐가 빌 때까지 계속된다.</li><li>첫 번째 while 루프 내에서 <em>nodesLeftInCurrentLevel</em>을 큐의 현재 요소로 설정하여 시작한다.</li><li>다른 while 루프를 사용하여 <em>nodesLeftInCurrentLevel</em>의 수만큼 큐에서 요소를 빼낸다. 큐에서 빼는 모든 요소는 다음 줄로 넘어가지 않고 출력되며, 노드의 모든 자식을 큐에 넣는다.</li><li>이 시점에서 <code>println()</code>을 사용하여 새 줄을 생성한다. 다음 반복에서 <em>nodesLeftInCurrentLevel</em>은 이전 반복의 자식 수를 나타내는 <em>queue.count</em>로 업데이트된다.</li></ol><h2 id="요약"><a class="markdownIt-Anchor" href="#요약"></a> 요약</h2><ul><li>트리는 연결 리스트와 몇 가지 유사점을 공유한다. 그러나 트리의 노드는 무한히 많은 노드에 연결할 수 있는 반면 연결 리스트의 노드는 하나의 다른 노드에만 연결할 수 있다.</li><li>깊이 우선 및 레벨 순서 순회는 일반적인 유형의 트리에만 국한되지 않는다. 트리 구조에 따라 구현이 약간 다르지만 다른 유형의 트리에서도 작동할 수 있다.</li></ul><br><div style="text-align: right"> <a href="https://github.com/june0122/DataStructureKotlin/tree/master/src/tree"><b><i>Github에서 본문의 코드 확인하기 </div><br><div style="text-align: right"> <a href="https://www.raywenderlich.com/books/data-structures-algorithms-in-kotlin/v1.0"><b><i>Data Structures & Algorithms in Kotlin</i></b></a> 서적을 참고하여 작성했습니다. </div>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Data-Structure/">Data Structure</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Data-Structure/">Data Structure</category>
      
      <category domain="http://june0122.github.io/tags/Tree/">Tree</category>
      
      
      <comments>http://june0122.github.io/2021/07/19/data-structure-trees/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[코틀린 자료구조] 큐 (Queue)</title>
      <link>http://june0122.github.io/2021/07/16/data-structure-queue/</link>
      <guid>http://june0122.github.io/2021/07/16/data-structure-queue/</guid>
      <pubDate>Thu, 15 Jul 2021 21:53:06 GMT</pubDate>
      
      <description>우리는 모두 줄을 서서 기다리는 것에 익숙하다. 좋아하는 영화의 티켓을 구매하기 위해 줄을 서는 것과 같은 실생활의 예시들은 &lt;b&gt;큐&lt;small&gt;(Queue)&lt;/small&gt;&lt;/b&gt; 자료구조를 모방한다. 큐는 &lt;b&gt;FIFO&lt;small&gt;(first in, first out)&lt;/small&gt;&lt;/b&gt;의 형태로, 처음 추가된 요소가 제일 먼저 제거되는 요소가 된다. 큐는 나중에 처리할 요소의 순서를 유지해야 할 때 편리하다.</description>
      
      
      
      <content:encoded><![CDATA[<p>우리는 모두 줄을 서서 기다리는 것에 익숙하다. 좋아하는 영화의 티켓을 구매하기 위해 줄을 서는 것과 같은 실생활의 예시들은 <b>큐<small>(Queue)</small></b> 자료구조를 모방한다.</p><p>큐는 <b>FIFO<small>(first in, first out)</small></b>의 형태로, 처음 추가된 요소가 제일 먼저 제거되는 요소가 된다. 큐는 나중에 처리할 요소의 순서를 유지해야 할 때 편리하다.</p><h2 id="큐의-일반적인-연산들"><a class="markdownIt-Anchor" href="#큐의-일반적인-연산들"></a> 큐의 일반적인 연산들</h2><p>먼저 큐에 대한 인터페이스를 설정한다. base 패키지 내부에 Queue.kt라는 파일을 만들고 Queue 인터페이스를 정의하는 다음 코드를 추가한다.</p><blockquote><p>큐 인터페이스 정의 (base/Queue.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="type">T : Any</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: T?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = count == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제부터 구현하는 모든 것은 큐의 핵심 작업을 설명하는 위의 인터페이스의 규약을 따른다.</p><p>큐의 핵심 연산들은 다음과 같다.</p><ul><li><code>enqueue</code> : <b>대기열<small>(queue)</small></b>의 뒤에 요소를 삽입하고 연산이 성공하면 true를 반환한다.</li><li><code>dequeue</code> : 대기열의 맨 앞 요소를 제거하고 반환한다.</li><li><code>isEmpty</code> : <em>count</em> 속성을 사용하여 대기열이 비어있는지 확인한다.</li><li><code>peek</code> : 대기열의 맨 앞에 있는 요소를 제거하지 않고 값만 반환한다.</li></ul><p>큐는 앞쪽에서 제거하고 뒤쪽에서 삽입하는 것에만 관심이 있다. 그 사이에 내용이 무엇인지 알 필요가 없다.</p><h2 id="큐의-이해"><a class="markdownIt-Anchor" href="#큐의-이해"></a> 큐의 이해</h2><p>큐의 작동 방식을 이해하는 가장 쉬운 방법은 작동 예제를 보는 것이다. 영화 티켓을 위해 줄을 서서 기다리는 사람들을 상상해보자.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/124502496-9370b180-ddfe-11eb-8e2d-4841fcb3d2ef.png'></p><p>이 대기열에는 현재 Ray, Brian, Sam 및 Mic이 있다. Ray는 티켓을 받으면 줄에서 나간다. <code>dequeue()</code>를 호출하면 Ray가 대기열의 앞쪽에서 제거된다.</p><p><code>peek()</code>을 호출하면 Brian이 현재 맨앞에 있기 때문에 Brian이 반환된다.</p><p>이제 막 표를 사기 위해 비키가 줄에 합류한다. <code>enqueue(&quot;Vicki&quot;)</code>를 호출하면 Vicki가 대기열 뒤에 추가된다.</p><h2 id="큐의-구현-방법들"><a class="markdownIt-Anchor" href="#큐의-구현-방법들"></a> 큐의 구현 방법들</h2><p>본문에선 네 가지 방법의 큐 구현 방법들을 알아본다.</p><ol><li>배열 기반 리스트<small>(array based list)</small> 사용</li><li>이중 연결 리스트<small>(doubly linked list)</small> 사용</li><li>ring buffer 사용</li><li>두 개의 스택 사용</li></ol><h3 id="1-리스트-기반-구현"><a class="markdownIt-Anchor" href="#1-리스트-기반-구현"></a> 1. 리스트 기반 구현</h3><p>코틀린 표준 라이브러리에는 더 높은 수준의 추상화를 구축하는데 사용할 수 있는 고도로 최적화된 자료구조의 핵심 세트가 함께 제공된다. 이들 중 하나가 연속적이고<small>(contiguous)</small> 정렬된 요소들의 리스트를 저장하는 자료구조인 <strong>ArrayList</strong>이다. ArrayList를 이용해서 큐를 구현해보자.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124503376-67563000-de00-11eb-9be3-0bb2fcff0246.png'></p><p>list 패키지 내부에 ArrayListQueue.kt 파일을 생성하고 아래의 코드를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayListQueue</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">Queue</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> list = arrayListOf&lt;T&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Queue 인터페이스를 구현하는 제네릭 ArrayListQueue 클래스를 정의했다. 인터페이스 구현은 저장하는 요소에 대해 동일한 제네릭 타입인 <code>T</code>를 사용한다.</p><p>다음으로 ArrayListQueue 구현을 완료하여 Queue 인터페이스의 규약을 만족시키자.</p><h4 id="arraylist-활용"><a class="markdownIt-Anchor" href="#arraylist-활용"></a> ArrayList 활용</h4><p>ArrayListQueue 클래스에 다음 코드를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayListQueue</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">Queue</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = list.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T? = list.getOrNull(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList의 기능들을 사용하면 다음을 간단히 구현할 수 있다.</p><ol><li>리스트의 동일한 속성을 사용하여 큐의 크기를 가져온다.</li><li>큐의 맨 앞에 요소가 존재한다면 값을 반환한다.</li></ol><p>이 연산들은 모두 *O(1)*이다.</p><h4 id="enqueue"><a class="markdownIt-Anchor" href="#enqueue"></a> Enqueue</h4><p>큐의 뒤에 요소를 추가하는 것은 간단하다. ArrayList의 끝에 요소를 추가하기만 하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    list.add(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>리스트의 크기에 관계없이 요소를 큐에 추가하는 것은 <em>O(1)</em> 연산이다. 리스트 뒤에 빈 공간이 있기 때문이다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124504495-9077c000-de02-11eb-8719-55521aae5db3.png'></p><p>위의 예시에서 Mic를 추가하면 리스트에 두 개의 빈 공간이 있다.</p><p>여러 요소를 추가한 후에는 ArrayList 내부 배열이 결국 가득 차게 된다. 할당된 공간보다 더 많이 사용하려면 추가 공간을 만들기 위해 배열의 크기를 조정해야만 한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124504497-92418380-de02-11eb-8ad1-392ae7528963.png'></p><p>크기 조정<small>(resizing)</small>은 <em>O(n)</em> 연산이다. 크기를 조정하려면 리스트에서 새 메모리를 할당하고 기존의 모든 데이터를 새 리스트에 복사해야 한다. 매번 크기를 두 배로 늘리는 덕분에 자주는 발생하지 않으며, 시간 복잡도는 여전히 <a href = "https://stackoverflow.com/a/249695"><i>Amortized O(1)</i></a>으로 동작한다.</p><h4 id="dequeue"><a class="markdownIt-Anchor" href="#dequeue"></a> Dequeue</h4><p>전면에서 항목<small>(item)</small>을 제거하려면 약간 더 많은 작업이 필요하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: T? = </span><br><span class="line">    <span class="keyword">if</span> (isEmpty) <span class="literal">null</span> <span class="keyword">else</span> list.removeAt(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>큐가 비어 있으면 <code>dequeue()</code>는 단순히 null을 반환한다. 그렇지 않다면 리스트의 맨 앞에서 요소를 제거하고 반환한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124504501-94a3dd80-de02-11eb-9b82-9818df31bf7d.png'></p><p>큐의 전면에서 요소를 제거하는 연산은 <em>O(n)</em> 시간 복잡도를 가진다. 대기열에서 요소를 제거하려면 리스트 시작 부분에서 요소를 제거해야 한다. 리스트의 나머지 모든 요소를 메모리에서 이동시켜야하므로 항상 선형 시간<small>(Linear time, O(n))</small>의 연산이다.</p><h4 id="테스트"><a class="markdownIt-Anchor" href="#테스트"></a> 테스트</h4><p>디버깅을 위해 구현한 큐가 <code>toString()</code>을 재정의하도록 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = list.toString()</span><br></pre></td></tr></table></figure><p>이제 구현한 큐를 직접 사용해보도록 하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = ArrayListQueue&lt;String&gt;().apply &#123;</span><br><span class="line">        enqueue(<span class="string">&quot;Ray&quot;</span>)</span><br><span class="line">        enqueue(<span class="string">&quot;Brian&quot;</span>)</span><br><span class="line">        enqueue(<span class="string">&quot;Eric&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    println(queue)</span><br><span class="line">    println(<span class="string">&quot;Next up: <span class="subst">$&#123;queue.peek()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Ray, Brian, Eric]</span><br><span class="line">[Brian, Eric]</span><br><span class="line">Next up: Brian</span><br></pre></td></tr></table></figure><p>이 코드는 Ray, Brian 및 Eric을 큐에 넣는다<small>(<code>enqueue</code>)</small>. 그런 다음 Ray를 제거하고<small>(<code>dequeue()</code>)</small> Brian을 들여다 보지만 제거하지는 않는다<small>(<code>peek()</code>)</small>.</p><h4 id="장점과-단점"><a class="markdownIt-Anchor" href="#장점과-단점"></a> 장점과 단점</h4><p>다음은 ArrayList 기반 큐 구현의 알고리즘 및 복잡도에 대해 요약하고 있다. 대부분의 작업은 선형 시간이 걸리는 <code>dequeue()</code>를 제외하고는 상수 시간을 가진다. 공간 복잡도는 <em>O(n)</em> 이다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124506381-7344f080-de06-11eb-963b-0c16e0146195.png'></p><p>Kotlin ArrayList를 활용하여 리스트 기반 큐를 간단하게 구현하였다. <em>O(1)</em> 추가 연산 덕분에 큐에 넣는 것이 매우 빠르다.</p><p>하지만 이 구현에는 몇 가지 단점들이 있다. 항목을 제거하면 모든 요소가 하나씩 이동하므로 큐에서 항목을 제거하는 것은 비효율적일 수 있다. 이것은 매우 큰 큐에서 차이를 만든다. 리스트가 가득 차면 크기를 조정해야 하며 사용하지 않는 공간이 있을 수 있다. 이것은 시간이 지남에 따라 메모리 사용량을 증가시킬 수 있다. 이러한 단점을 어떻게 해결할 수 있을까? 연결 리스트 기반 구현을 살펴보고 ArrayListQueue와 비교해보도록 하자.</p><h3 id="2-이중-연결-리스트smalldoubly-linked-listsmall-기반-구현"><a class="markdownIt-Anchor" href="#2-이중-연결-리스트smalldoubly-linked-listsmall-기반-구현"></a> 2. 이중 연결 리스트<small>(doubly linked list)</small> 기반 구현</h3><p>linkedlist 패키지 내부에 LinkedListQueue.kt 파일을 생성한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">Queue</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> list = DoublyLinkedList&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 구현은 <strong>ArrayListQueue</strong>와 유사하지만 <strong>ArrayList</strong> 대신 <strong>DoublyLinkedList</strong>를 생성한다.</p><p>DoublyLinkedList가 제공하지 않는 <em>count</em> 속성 아래로 Queue 인터페이스의 구현을 시작한다.</p><h4 id="enqueue-2"><a class="markdownIt-Anchor" href="#enqueue-2"></a> Enqueue</h4><p>큐의 뒤에 요소를 추가하기 위해 아래의 코드를 작성한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    list.append(element)</span><br><span class="line">    size += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124506865-80161400-de07-11eb-841b-a5acb773c7a8.png'></p><p>이중 연결 리스트는 내부에서 새 노드에 대한 꼬리 노드의 이전<small>(prev)</small> 및 다음<small>(next)</small> 참조를 업데이트하고 크기를 늘린다. 이 과정은 <em>O(1)</em> 연산이다.</p><h4 id="dequeue-2"><a class="markdownIt-Anchor" href="#dequeue-2"></a> Dequeue</h4><p>큐에서 요소를 제거하기 위해서 아래의 코드를 추가한다.</p><blockquote><p>간단한 구현</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: T? = list.pop()</span><br></pre></td></tr></table></figure><p>원서는 DoublyLinkedList에 대한 코드가 제공되지 않은 상태에서 위의 코드를 예시로 들어놓았는데, 직접 구현한 LinkedList를 기반으로 Queue를 구현한다면 <code>dequeue()</code>를 리스트에서 첫 번째 노드를 제거하는 메서드를 호출하는 것으로 간단히 구현할 수 있다.</p><blockquote><p>원서의 코드</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">  <span class="keyword">val</span> firstNode = list.first ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  size--</span><br><span class="line">  <span class="keyword">return</span> list.remove(firstNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>원서의 코드는 큐의 첫 번째 요소가 존재하는지 확인하고 존재하지 않는다면 null을 반환한다. 큐에 첫 번째 요소가 존재한다면 맨 앞에 있는 요소를 제거하고 이를 반환한다. 크기도 감소한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124506868-81dfd780-de07-11eb-875b-2bb97909b55f.png'></p><p>리스트 맨 앞을 제거하는 것 또한 <em>O(1)</em> 연산이다. ArrayList 구현과 비교할 때 요소를 하나씩 이동할 필요가 없는 대신, 위의 이미지처럼 연결 리스트의 처음 두 노드 사이의 전<small>(prev)</small> 및 다음<small>(next)</small> 포인터를 업데이트하기만 하면 된다.</p><h4 id="peek"><a class="markdownIt-Anchor" href="#peek"></a> Peek</h4><p>ArrayList 기반 구현과 유사하게, DoublyLinkedList의 속성을 이용하여 <code>peek()</code>을 간단히 구현할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T? = list.first?.value</span><br></pre></td></tr></table></figure><h4 id="테스트-2"><a class="markdownIt-Anchor" href="#테스트-2"></a> 테스트</h4><p>디버깅을 위해 아래의 코드를 클래스에 추가하고 테스트 해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = list.toString()</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedListQueue&lt;String&gt;().apply &#123;</span><br><span class="line">    enqueue(<span class="string">&quot;Ray&quot;</span>)</span><br><span class="line">    enqueue(<span class="string">&quot;Brian&quot;</span>)</span><br><span class="line">    enqueue(<span class="string">&quot;Eric&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    println(queue)</span><br><span class="line">    println(<span class="string">&quot;Next up: <span class="subst">$&#123;queue.peek()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 테스트 코드는 ArrayListQueue 구현과 동일한 결과를 생성한다.</p><h4 id="장점과-단점-2"><a class="markdownIt-Anchor" href="#장점과-단점-2"></a> 장점과 단점</h4><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124506871-84423180-de07-11eb-8b5b-ae09b51587b4.png'></p><p>ArrayListQueue의 주요 문제점 중 하나는 항목을 대기열에서 빼는데 <i>O(n)</i>이 걸리는 것이다. 연결 리스트 구현을 통해 노드의 이전 및 다음 포인터를 업데이트하는 것만으로 시간 복잡도를 <i>O(1)</i>으로 축소시켰다.</p><p>LinkedListQueue의 주요 단점은 위의 표에서 분명하게 나타나지 않는다. <i>O(1)</i> 성능에도 불구하고 높은 오버헤드가 존재하는데, 각 요소는 이전과 다음의 참조를 위한 추가 공간이 있어야 한다<small>(공간 복잡도 증가)</small>. 또한 새 요소를 만들 때마다 상대적으로 비용이 많이 드는 동적 할당이 필요하다. 이에 비해, ArrayListQueue는 더 빠른 대량 할당을 수행한다.</p><p>할당에 대한 오버헤드를 제거하고 <i>O(1)</i>의 dequeue를 유지할 수 있을까? 큐가 고정된 크기 이상으로 커지는 것에 대해 걱정할 필요가 없는 경우 <strong>링 버퍼</strong>와 같은 다른 접근 방식을 사용할 수 있다. 예를 들어, 5명의 플레이어가 참여하는 모노폴리 게임에 링 버퍼를 기반으로 한 큐를 사용하여 다음에 올 차례를 추적할 수 있다. 다음으로 링 버퍼 구현을 살펴보자.</p><h3 id="3-링-버퍼smallring-buffersmall-기반-구현"><a class="markdownIt-Anchor" href="#3-링-버퍼smallring-buffersmall-기반-구현"></a> 3. 링 버퍼<small>(Ring Buffer)</small> 기반 구현</h3><p>원형 버퍼<small>(circular buffer)</small>라고도 불리는 링 버퍼<small>(ring buffer)</small>는 고정 크기 배열이다. 이 자료구조는 마지막에 제거할 항목이 없을 때 시작 부분으로 래핑된다.</p><p>링 버퍼를 사용하여 큐를 구현하는 방법에 대한 간단한 예를 아래의 이미지들로 살펴보자.</p><blockquote><p>링 버퍼 생성</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/124657417-72cb5900-dedd-11eb-83e7-d1347a5734db.png'></p><p>먼저 고정 크기가 4인 링 버퍼를 만든다. 링 버퍼에는 두 개의 포인터가 존재한다.</p><ol><li>읽기<small>(read)</small> 포인터 : 큐의 앞쪽을 추적</li><li>쓰기<small>(write)</small> 포인터 : 사용 가능한 다음 칸을 추적하여 이미 읽어 들인 기존 요소를 재정의할 수 있다.</li></ol><blockquote><p>대기열에 항목 추가</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/124657442-7828a380-dedd-11eb-9b9e-81cb4ceefc91.png'></p><p>대기열에 항목을 추가할 때마다 쓰기 포인터가 1씩 증가한다.</p><blockquote><p>항목 2개를 더 추가</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/124657453-7bbc2a80-dedd-11eb-9434-92854fd7844a.png'></p><p>쓰기 포인터가 두 자리 더 이동하여 읽기 포인터보다 3칸 앞서 있는 것을 확인 할 수 있다. 이는 대기열이 비어 있지 않다는 것을 의미한다.</p><blockquote><p>대기열에서 두 개의 항목을 빼기</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/124657465-7fe84800-dedd-11eb-80da-d4634f1a86d8.png'></p><p>대기열에서 항목을 빼는 것을 링 버퍼를 읽는 것과 동일하다. 읽기 포인터가 어떻게 두 번 이동했는지 주목하자.</p><blockquote><p>대기열을 채우기 위해 항목을 하나 더 추가</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/124657480-824aa200-dedd-11eb-9928-35956b11d604.png'></p><p>쓰기 포인터가 끝에 도달했으므로 시작 인덱스로 다시 랩핑된다.</p><blockquote><p>마지막으로 남은 두 개의 항목을 대기열에서 빼기</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/124657496-8676bf80-dedd-11eb-8b69-b5961c7d5dc8.png'></p><p>남은 두 항목도 대기열에서 빼면서 읽기 포인터도 시작 부분으로 돌아온다.</p><p>위 이미지를 통해 읽기와 쓰기 포인터가 동일한 인덱스에 있을 경우 대기열, 즉 큐가 비어 있다는 것을 알 수 있다.</p><p>링 버퍼를 통한 큐의 구현은 개념만 확인하고 구현은 생략하였다.</p><h4 id="장점과-단점-3"><a class="markdownIt-Anchor" href="#장점과-단점-3"></a> 장점과 단점</h4><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124657508-8aa2dd00-dedd-11eb-86f7-208f48e10b6b.png'></p><p>링 버퍼 기반 큐는 연결 리스트 기반 구현과 <code>enqueue</code>와 <code>dequeue</code>의 시간 복잡도가 동일하다. 유일한 차이점은 공간 복잡도인데, 링 버퍼의 크기는 고정되어 있으므로 큐에 넣는 것 자체가 실패할 수 있는 단점이 존재한다.</p><p>지금까지 배열, 연결 리스트, 링 버퍼 기반까지 총 세 가지의 구현 방법을 보았는데 마지막으로 두 개의 스택을 사용하여 구현된 큐를 알아 볼 것이다.</p><p>이중 스택 기반 구현 큐는 메모리 상의 공간적 지역성이 연결 리스트보다 훨씬 우수하고, 링 버퍼와 같이 고정된 크기가 필요하지 않다는 장점이 있다.</p><h3 id="4-이중-스택smalldouble-stacksmall-기반-구현"><a class="markdownIt-Anchor" href="#4-이중-스택smalldouble-stacksmall-기반-구현"></a> 4. 이중 스택<small>(Double-Stack)</small> 기반 구현</h3><p>doublestack 패키지 내부에 StackQueue.kt를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackQueue</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">Queue</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> leftStack = StackImpl&lt;T&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> rightStack = StackImpl&lt;T&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>두 개의 스택을 사용하는 아이디어는 요소를 큐에 넣을 때마다 <strong>오른쪽</strong> 스택으로 이동하고, 요소를 큐에서 뺄 때는 FIFO 순서를 사용하여 요소를 검색할 수 있도록 오른쪽 스택을 반대로 뒤집어서 <strong>왼쪽</strong> 스택에 넣는다.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/125627123-d8f7ca3e-d598-4fda-b7e8-bf87d948cef6.png'></p><h4 id="스택-활용하기"><a class="markdownIt-Anchor" href="#스택-활용하기"></a> 스택 활용하기</h4><p>그러면 아래의 코드를 추가하여 큐의 공통 기능들을 구현해본다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = leftStack.count + rightStack.count </span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = leftStack.isEmpty &amp;&amp; rightStack.isEmpty</span><br></pre></td></tr></table></figure><p>큐가 비어 있는지 확인하려면 왼쪽과 오른쪽의 스택이 모두 비어 있는지 확인하면 된다. 큐에 있는 요소의 개수는 두 스택에 있는 요소 개수의 합이다.</p><p>이중 스택으로 구현한 큐는 위에서 설명했듯이 오른쪽 스택에서 왼쪽 스택으로 요소를 전달해야 할 때가 있다. 이는 왼쪽 스택이 비어 있을 때마다 발생한다.</p><p>다음의 헬퍼 메서드를 추가하자.</p><blockquote><p>오른쪽 스택에서 왼쪽 스택으로 요소 이동</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">transferElements</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nextElement = rightStack.pop()</span><br><span class="line">    <span class="keyword">while</span> (nextElement != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftStack.push(nextElement)</span><br><span class="line">        nextElement = rightStack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드를 통해 오른쪽 스택으로부터 요소를 꺼내어 왼쪽 스택에 넣을 수 있다. 스택은 LIFO 방식으로 작동하기 때문에 추가적인 작업 없이 역순으로 요소들을 가져올 수 있다.</p><blockquote><p><code>peek()</code></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftStack.isEmpty) &#123;</span><br><span class="line">        transferElements()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftStack.peek()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>peek()</code>은 최상위 요소를 보는 메서드이다. 만약 왼쪽 스택이 비어 있지 않다면 이 스택의 맨 위에 있는 요소가 큐의 맨 앞에 있다.</p><p>왼쪽 스택이 비어 있으면 <code>transferElements()</code>를 사용한다. 그렇게 하면 <code>leftStack.peek()</code>은 항상 올바른 요소 또는 <em>null</em>을 반환한다. <code>isEmpty()</code>는 여전히 <i>O(1)</i> 작업인 반면 <code>peek()</code>은 <i>O(n)</i>이다.</p><p>이러한 <code>peek()</code>의 구현이 비싼 비용을 요구하는 것처럼 보이지만, 큐의 각 요소는 오른쪽 스택에서 왼쪽 스택으로 한 번만 이동하면 되기 때문에 amortized <i>O(1)</i>이다. 왼쪽 스택이 비어 있을 때 <code>peek()</code> 호출은 오른쪽 요소들을 모두 왼쪽 스택으로 이동시키므로 <i>O(n)</i>이지만, 그 외 추가적인 호출에 대해선 <i>O(1)</i>이 된다.</p><h4 id="enqueue-3"><a class="markdownIt-Anchor" href="#enqueue-3"></a> Enqueue</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    rightStack.push(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>요소를 큐에 추가할 때는 오른쪽 스택이 사용된다. 스택에 요소를 넣는 <code>push()</code>는 <i>O(1)</i>이다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125709812-534b1733-5132-4770-9b10-23b3b17392b7.png'></p><h4 id="dequeue-3"><a class="markdownIt-Anchor" href="#dequeue-3"></a> Dequeue</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftStack.isEmpty) &#123;</span><br><span class="line">        transferElements()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftStack.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>동작 원리는 다음과 같다.</p><ol><li>왼쪽 스택이 비어 있는지 확인한다.</li><li>왼쪽 스택이 비어 있으면 오른쪽 스택의 요소를 역순으로 이동시킨다.</li><li>왼쪽 스택에서 맨 위의 요소를 제거한다.</li></ol><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125709818-4e175602-0dbc-45ef-b299-999bc03ec2d2.png'></p><p>왼쪽 스택이 비어 있을 때에만 오른쪽 스택의 요소를 이동시키므로 <code>dequeue()</code>는 <code>peek()</code>처럼 amortized <i>O(1)</i> 연산이다.</p><h4 id="테스트-3"><a class="markdownIt-Anchor" href="#테스트-3"></a> 테스트</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Left stack: \n<span class="variable">$leftStack</span> \nRight stack: \n<span class="variable">$rightStack</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = StackQueue&lt;String&gt;().apply &#123;</span><br><span class="line">        enqueue(<span class="string">&quot;Ray&quot;</span>)</span><br><span class="line">        enqueue(<span class="string">&quot;Brian&quot;</span>)</span><br><span class="line">        enqueue(<span class="string">&quot;Eric&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    println(queue)</span><br><span class="line">    println(<span class="string">&quot;Next up: <span class="subst">$&#123;queue.peek()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Left stack: </span><br><span class="line">----top----</span><br><span class="line">-----------</span><br><span class="line"> </span><br><span class="line">Right stack: </span><br><span class="line">----top----</span><br><span class="line">Eric</span><br><span class="line">Brian</span><br><span class="line">Ray</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">Left stack: </span><br><span class="line">----top----</span><br><span class="line">Brian</span><br><span class="line">Eric</span><br><span class="line">-----------</span><br><span class="line"> </span><br><span class="line">Right stack: </span><br><span class="line">----top----</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">Next up: Brian</span><br></pre></td></tr></table></figure><h4 id="장점과-단점-4"><a class="markdownIt-Anchor" href="#장점과-단점-4"></a> 장점과 단점</h4><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/125711056-d0be53af-a4b3-4029-bacb-3a914e9d8115.png'></p><p>리스트 기반 구현과 비교했을 때, 두 개의 스택을 활용하면 <code>dequeue()</code>의 구현을 amortized <i>O(1)</i> 연산으로 변환할 수 있다. 또한 이중 스택 기반 구현은 완전히 동적이고 링 버퍼 기반 구현처럼 고정된 크기로 제한되지도 않는다. 마지막으로 공간적 지역성<small>(spatial locality, 메모리 상 인접 데이터의 재이용률이 높음)</small> 측면에서 연결 리스트 기반 구현을 능가하는데, 이는 리스트이 요소가 메모리 블록에서 서로 옆에 있기 때문이다. 따라서 많은 수의 요소가 한 번의 접근<small>(access)</small>으로 캐시에 로드된다.</p><blockquote><p>연속된 배열에 있는 요소들</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125709832-3a3d4f43-4b43-4c06-8319-85f9d593084e.png'></p><blockquote><p>메모리 전체에 흩어져 있는 연결 리스트의 요소들</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125709837-9a7d64d5-f7cf-45ef-825e-33b7f79b5e18.png'></p><p>연결 리스트에서 요소는 메모리 블록에 연속적으로 존재하지 않는다. 이로 인해 더 많은 캐시 미스가 발생하여 접근 시간이 늘어난다.</p><br><div style="text-align: right"> <a href="https://github.com/june0122/DataStructureKotlin/tree/master/src/queue"><b><i>Github에서 본문의 코드 확인하기 </div><br><div style="text-align: right"> <a href="https://www.raywenderlich.com/books/data-structures-algorithms-in-kotlin/v1.0"><b><i>Data Structures & Algorithms in Kotlin</i></b></a> 서적을 참고하여 작성했습니다. </div>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Data-Structure/">Data Structure</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Data-Structure/">Data Structure</category>
      
      <category domain="http://june0122.github.io/tags/Queue/">Queue</category>
      
      
      <comments>http://june0122.github.io/2021/07/16/data-structure-queue/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 레벨 2 : JadenCase 문자열 만들기</title>
      <link>http://june0122.github.io/2021/07/16/programmers-12951/</link>
      <guid>http://june0122.github.io/2021/07/16/programmers-12951/</guid>
      <pubDate>Thu, 15 Jul 2021 20:40:24 GMT</pubDate>
      
      <description>레벨 2</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/12951">문제 보기</a></h3><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>나의 풀이</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> words = s.toLowerCase().toCharArray()</span><br><span class="line"></span><br><span class="line">        words[<span class="number">0</span>] = words[<span class="number">0</span>].toUpperCase()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until words.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (words[i].isLowerCase() &amp;&amp; words[i - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                words[i] = words[i].toUpperCase()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> String(words)  <span class="comment">// words.joinToString(&quot;&quot;) 사용 가능</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>capitalize()</code></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">          <span class="keyword">return</span> s.toLowerCase().split(<span class="string">&quot; &quot;</span>).map &#123;</span><br><span class="line">                it.capitalize()</span><br><span class="line">            &#125;.joinToString(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Programmers/">Programmers</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Programmers/">Programmers</category>
      
      
      <comments>http://june0122.github.io/2021/07/16/programmers-12951/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 1688. Count of Matches in Tournament</title>
      <link>http://june0122.github.io/2021/07/16/leetcode-1688/</link>
      <guid>http://june0122.github.io/2021/07/16/leetcode-1688/</guid>
      <pubDate>Thu, 15 Jul 2021 19:06:59 GMT</pubDate>
      
      <description>1688. Count of Matches in Tournament</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://leetcode.com/problems/count-of-matches-in-tournament/">문제 보기</a></h3><h2 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numberOfMatches</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> remains = n</span><br><span class="line">        <span class="keyword">var</span> cnt = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (remains &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remains % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt += remains / <span class="number">2</span></span><br><span class="line">                remains /= <span class="number">2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt += (remains - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">                remains = (remains - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://june0122.github.io/tags/Simulation/">Simulation</category>
      
      
      <comments>http://june0122.github.io/2021/07/16/leetcode-1688/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 57. Insert Interval</title>
      <link>http://june0122.github.io/2021/07/16/leetcode-57/</link>
      <guid>http://june0122.github.io/2021/07/16/leetcode-57/</guid>
      <pubDate>Thu, 15 Jul 2021 17:48:33 GMT</pubDate>
      
      <description>57. Insert Interval</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://leetcode.com/problems/insert-interval/">문제 보기</a></h3><h2 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h2><blockquote><p><i>O(nlogn)</i> 시간 복잡도 해결법</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;, newInterval: <span class="type">IntArray</span>)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> new = intervals + newInterval</span><br><span class="line">        new.sortWith(compareBy &#123;it[<span class="number">0</span>]&#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> arr = mutableListOf&lt;IntArray&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (interval <span class="keyword">in</span> new) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr.isEmpty() || arr.last()[<span class="number">1</span>] &lt; interval[<span class="number">0</span>]) &#123;</span><br><span class="line">                arr.add(interval)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr.last()[<span class="number">1</span>] = max(arr.last()[<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arr.toTypedArray()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><i>O(n)</i> 시간 복잡도 해결법</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;, newInterval: <span class="type">IntArray</span>)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> merged = mutableListOf&lt;IntArray&gt;()</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (interval <span class="keyword">in</span> intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">1</span>] &gt;= newInterval[<span class="number">0</span>]) <span class="keyword">break</span></span><br><span class="line">            merged.add(interval)</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &lt; intervals.size &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>])&#123;</span><br><span class="line">            newInterval[<span class="number">0</span>] = min(newInterval[<span class="number">0</span>], intervals[i][<span class="number">0</span>])</span><br><span class="line">            newInterval[<span class="number">1</span>] = max(newInterval[<span class="number">1</span>], intervals[i][<span class="number">1</span>])</span><br><span class="line">            i++</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        merged.add(newInterval)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (i &lt; intervals.size)&#123;</span><br><span class="line">            merged.add(intervals[i])</span><br><span class="line">            i++</span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merged.toTypedArray()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://june0122.github.io/2021/07/16/leetcode-57/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 56. Merge Intervals</title>
      <link>http://june0122.github.io/2021/07/15/leetcode-56/</link>
      <guid>http://june0122.github.io/2021/07/15/leetcode-56/</guid>
      <pubDate>Thu, 15 Jul 2021 07:41:39 GMT</pubDate>
      
      <description>56. Merge Intervals</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://leetcode.com/problems/merge-intervals/">문제 보기</a></h3><h2 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">        intervals.sortWith(compareBy &#123; it[<span class="number">0</span>] &#125;)</span><br><span class="line">        <span class="keyword">val</span> merged = mutableListOf&lt;IntArray&gt;()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (interval <span class="keyword">in</span> intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (merged.isEmpty() || merged.last()[<span class="number">1</span>] &lt; interval[<span class="number">0</span>]) &#123;</span><br><span class="line">                merged.add(interval)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged.last()[<span class="number">1</span>] = max(merged.last()[<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merged.toTypedArray()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="복잡도-분석"><a class="markdownIt-Anchor" href="#복잡도-분석"></a> 복잡도 분석</h4><ul><li>시간 복잡도 : <i>O(nlogn)</i><ul><li>정렬로 인한 시간복잡도</li><li><code>java.util.Collections.sort()</code>의 <a href="https://docs.oracle.com/javase/6/docs/api/java/util/Collections.html#sort(java.util.List)">API 문서</a>에 정렬 알고리즘으로 개선된 합병정렬<small>(a modified mergesort)</small>을 사용하고 시간 복잡도는 <i>O(nlogn)</i>으로 명시되어 있다.</li></ul></li><li>공간 복잡도 : <i>O(n)</i></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://june0122.github.io/2021/07/15/leetcode-56/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 495. Teemo Attacking</title>
      <link>http://june0122.github.io/2021/07/15/leetcode-495/</link>
      <guid>http://june0122.github.io/2021/07/15/leetcode-495/</guid>
      <pubDate>Thu, 15 Jul 2021 05:35:23 GMT</pubDate>
      
      <description>495. Teemo Attacking</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://leetcode.com/problems/teemo-attacking/">문제 보기</a></h3><h2 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h2><blockquote><p>시간 초과 코드</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findPoisonedDuration</span><span class="params">(timeSeries: <span class="type">IntArray</span>, duration: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> poisonedTimes = mutableSetOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        </span><br><span class="line">        timeSeries.forEach &#123; t -&gt;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> t until t + duration) &#123;</span><br><span class="line">                poisonedTimes.add(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> poisonedTimes.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>easy 난이도의 문제였기에 간단히 set을 이용하여 중복을 제거하는 식으로 문제를 해결하려 하였으나 시간 초과가 발생하였다. 제약 사항을 보니 아래와 같았다. 입력값의 범위를 보고 문제 접근 방법을 고려할 수 있어야 하는데 연습이 많이 부족하다.</p><p>제약 사항</p><ul><li>1 &lt;= timeSeries.length &lt;= 10<sup>4</sup></li><li>0 &lt;= timeSeries[i], duration &lt;= 10<sup>7</sup></li><li>timeSeries is sorted in <strong>non-decreasing</strong> order.</li></ul><blockquote><p>해답</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.min</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findPoisonedDuration</span><span class="params">(timeSeries: <span class="type">IntArray</span>, duration: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = timeSeries.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span>) &#123;</span><br><span class="line">            total += min(timeSeries[i + <span class="number">1</span>] - timeSeries[i], duration)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> total + duration</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일반적으로 이러한 유형의 문제들은 <a href="https://leetcode.com/problems/insert-interval/">입력 값이 정렬되어 있을 경우</a> <i>O(N)</i>, <a href="https://leetcode.com/problems/merge-intervals/">그렇지 않을 경우</a> <i>O(nlogn)</i>의 시간 복잡도를 가진다.</p><p>두 개의 공격 사이의 간격과 duration 중 작은 값을 독에 중독된 시간에 더해나가는 식으로 값을 구할 수 있다.</p><p>두 개의 공격 사이의 간격이 duration보다 작다는 것은 중첩되는 구간이 있다는 뜻으로 다음 공격 시간과 현재 공격 시간의 차이<small>(<code>timeSeries[i + 1] - timeSeries[i]</code>)</small>만큼만 총 중독 시간에 더한다.</p><p>duration이 두 공격 사이 간격보다 클 경우는 중첩 구간이 없다는 뜻이므로 duration 값 그대로를 총 중독 시간에 더한다. 마지막 공격은 비교군에서 제외되므로 총 중독 시간에 따로 duration을 한 번만 더해준다.</p><h4 id="복잡도-분석"><a class="markdownIt-Anchor" href="#복잡도-분석"></a> 복잡도 분석</h4><ul><li>시간 복잡도 : <i>O(N)</i></li><li>공간 복잡도 : <i>O(1)</i></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://june0122.github.io/2021/07/15/leetcode-495/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 레벨 2 : 가장 큰 수</title>
      <link>http://june0122.github.io/2021/07/13/programmers-42746/</link>
      <guid>http://june0122.github.io/2021/07/13/programmers-42746/</guid>
      <pubDate>Tue, 13 Jul 2021 09:59:37 GMT</pubDate>
      
      <description>[코딩테스트 고득점 Kit - 정렬] 레벨 2</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/42746">문제 보기</a></h3><p><code>정렬</code></p><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(numbers: <span class="type">IntArray</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">var</span> answer = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">var</span> tempArray = numbers.map &#123; it.toString() &#125;.toTypedArray()</span><br><span class="line">        </span><br><span class="line">        tempArray.sortWith(Comparator&lt;String&gt; &#123; a, b -&gt;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                a.length == b.length -&gt; b.compareTo(a)</span><br><span class="line">                <span class="keyword">else</span> -&gt; (b + a).compareTo(a + b)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (tempArray[<span class="number">0</span>] == <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">            answer = <span class="string">&quot;0&quot;</span></span><br><span class="line">            <span class="keyword">return</span> answer</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tempArray.forEach &#123;</span><br><span class="line">            answer += it</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Programmers/">Programmers</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Programmers/">Programmers</category>
      
      <category domain="http://june0122.github.io/tags/%EC%A0%95%EB%A0%AC/">정렬</category>
      
      
      <comments>http://june0122.github.io/2021/07/13/programmers-42746/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 레벨 2 : 전화번호 목록</title>
      <link>http://june0122.github.io/2021/07/12/programmers-42577/</link>
      <guid>http://june0122.github.io/2021/07/12/programmers-42577/</guid>
      <pubDate>Mon, 12 Jul 2021 06:54:19 GMT</pubDate>
      
      <description>[코딩테스트 고득점 Kit - 해시] 레벨 2</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/42577">문제 보기</a></h3><p><code>해시</code></p><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="java"><a class="markdownIt-Anchor" href="#java"></a> java</h3><blockquote><p>정확성 테스트 통과, 효율성 테스트 실패 코드</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solution</span><span class="params">(String[] phone_book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> answer = <span class="keyword">true</span>;</span><br><span class="line">        Arrays.sort(phone_book, Comparator.comparing(String::length));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; phone_book.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; phone_book.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phone_book[i].equals(phone_book[j].substring(<span class="number">0</span>, phone_book[i].length()))) &#123;</span><br><span class="line">                    answer = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Hash 사용</p></blockquote><p><strong>해시</strong>를 사용해야 효율성 통과를 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solution</span><span class="params">(String[] phone_book)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(phone_book, Collections.reverseOrder());</span><br><span class="line">        HashMap&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : phone_book) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.get(s) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                hashMap.put(s.substring(<span class="number">0</span>, i), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solution</span><span class="params">(String[] phone_book)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : phone_book) hashMap.put(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : phone_book) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hashMap.containsKey(s.substring(<span class="number">0</span>, i))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(phone_book: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> hashMap = HashMap&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    phone_book.forEach &#123; hashMap[it] = <span class="number">0</span> &#125;</span><br><span class="line">    phone_book.forEach &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until it.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.containsKey(it.substring(<span class="number">0</span>, i))) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Programmers/">Programmers</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Programmers/">Programmers</category>
      
      <category domain="http://june0122.github.io/tags/%ED%95%B4%EC%8B%9C/">해시</category>
      
      <category domain="http://june0122.github.io/tags/Java/">Java</category>
      
      
      <comments>http://june0122.github.io/2021/07/12/programmers-42577/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 레벨 2 : 행렬 테두리 회전하기</title>
      <link>http://june0122.github.io/2021/07/11/programmers-77485/</link>
      <guid>http://june0122.github.io/2021/07/11/programmers-77485/</guid>
      <pubDate>Sun, 11 Jul 2021 12:08:10 GMT</pubDate>
      
      <description>[2021 Dev-Matching: 웹 백엔드 개발자(상반기)] 레벨 2</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/77485">문제 보기</a></h3><p><code>2021 Dev-Matching: 웹 백엔드 개발자(상반기)</code>, <code>완전 탐색</code></p><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>연결 리스트 이용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(rows: <span class="type">Int</span>, columns: <span class="type">Int</span>, queries: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">if</span> (queries.size == <span class="number">1</span>) <span class="keyword">return</span> intArrayOf(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> answer = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> board = Array(rows) &#123; i -&gt; IntArray(columns) &#123; j -&gt; (i * columns) + j + <span class="number">1</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        queries.forEach &#123;</span><br><span class="line">            <span class="keyword">val</span> list = LinkedList&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">            <span class="keyword">val</span> values = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">val</span> (row1, col1) = it[<span class="number">0</span>] - <span class="number">1</span> to it[<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> (row2, col2) = it[<span class="number">2</span>] - <span class="number">1</span> to it[<span class="number">3</span>] - <span class="number">1</span></span><br><span class="line">            <span class="keyword">var</span> (tempRow, tempCol) = row1 to col1</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (tempCol &lt; col2) &#123;</span><br><span class="line">                list.add(tempRow to tempCol)</span><br><span class="line">                values.add(board[tempRow][tempCol])</span><br><span class="line">                tempCol += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (tempRow &lt; row2) &#123;</span><br><span class="line">                list.add(tempRow to tempCol)</span><br><span class="line">                values.add(board[tempRow][tempCol])</span><br><span class="line">                tempRow += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (tempCol &gt; col1) &#123;</span><br><span class="line">                list.add(tempRow to tempCol)</span><br><span class="line">                values.add(board[tempRow][tempCol])</span><br><span class="line">                tempCol -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (tempRow &gt; row1) &#123;</span><br><span class="line">                list.add(tempRow to tempCol)</span><br><span class="line">                values.add(board[tempRow][tempCol])</span><br><span class="line">                tempRow -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.add(list.removeAt(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> cnt = <span class="number">0</span></span><br><span class="line">            list.forEach &#123; pos -&gt;</span><br><span class="line">                board[pos.first][pos.second] = values[cnt]</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            answer.add(values.min()!!)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer.toIntArray()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>첫 시도에는 연결 리스트를 이용하는 방법으로 풀이하였지만 코드의 복잡도만 올라가는데다 효율성도 그리 좋지 못하여 아래와 같이 배열만을 이용하는 방법으로 풀이하였다.</p><blockquote><p>배열만 이용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.min</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(rows: <span class="type">Int</span>, columns: <span class="type">Int</span>, queries: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">var</span> answer = intArrayOf()</span><br><span class="line">        <span class="keyword">val</span> board = Array(rows) &#123; i -&gt; IntArray(columns) &#123; j -&gt; (columns * i) + j + <span class="number">1</span> &#125; &#125;</span><br><span class="line">        </span><br><span class="line">        queries.forEach &#123;</span><br><span class="line">            <span class="keyword">val</span> (r1, c1) = it[<span class="number">0</span>] - <span class="number">1</span> to it[<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> (r2, c2) = it[<span class="number">2</span>] - <span class="number">1</span> to it[<span class="number">3</span>] - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> a1 = IntArray(c2 - c1) &#123; i -&gt; board[r1][c1 + i] &#125;</span><br><span class="line">            <span class="keyword">val</span> a2 = IntArray(r2 - r1) &#123; i -&gt; board[r1 + i][c2] &#125;</span><br><span class="line">            <span class="keyword">val</span> a3 = IntArray(c2 - c1) &#123; i -&gt; board[r2][c1 + <span class="number">1</span> + i] &#125;</span><br><span class="line">            <span class="keyword">val</span> a4 = IntArray(r2 - r1) &#123; i -&gt; board[r1 + <span class="number">1</span> + i][c1] &#125;</span><br><span class="line">            <span class="keyword">var</span> min = rows * columns</span><br><span class="line">            </span><br><span class="line">            a1.forEachIndexed &#123; i, v -&gt;</span><br><span class="line">                board[r1][c1 + i + <span class="number">1</span>] = v</span><br><span class="line">                min = min(min, v)</span><br><span class="line">            &#125;</span><br><span class="line">            a2.forEachIndexed &#123; i, v -&gt;</span><br><span class="line">                board[r1 + i + <span class="number">1</span>][c2] = v</span><br><span class="line">                min = min(min, v)</span><br><span class="line">            &#125;</span><br><span class="line">            a3.forEachIndexed &#123; i, v -&gt;</span><br><span class="line">                board[r2][c1 + i] = v</span><br><span class="line">                min = min(min, v)</span><br><span class="line">            &#125;</span><br><span class="line">            a4.forEachIndexed &#123; i, v -&gt;</span><br><span class="line">                board[r1 + i][c1] = v</span><br><span class="line">                min = min(min, v)</span><br><span class="line">            &#125;</span><br><span class="line">            answer += min</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Programmers/">Programmers</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Programmers/">Programmers</category>
      
      <category domain="http://june0122.github.io/tags/%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89/">완전 탐색</category>
      
      
      <comments>http://june0122.github.io/2021/07/11/programmers-77485/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[코틀린 자료구조] 스택 (Stack)</title>
      <link>http://june0122.github.io/2021/07/05/data-structure-stack/</link>
      <guid>http://june0122.github.io/2021/07/05/data-structure-stack/</guid>
      <pubDate>Mon, 05 Jul 2021 13:25:08 GMT</pubDate>
      
      <description>&lt;b&gt;Stack&lt;small&gt;(스택)&lt;/small&gt;&lt;/b&gt;은 한 쪽에서만 요소의 추가나 제거가 가능한 자료구조이다. Computer science에선 스택은 LIFO&lt;small&gt;(last-in first-out)&lt;/small&gt; 자료구조라고도 한다. 마지막에 들어간&lt;small&gt;(push)&lt;/small&gt; 요소들은 가장 먼저 나온다&lt;small&gt;(pop)&lt;/small&gt;.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="스택의-연산들"><a class="markdownIt-Anchor" href="#스택의-연산들"></a> 스택의 연산들</h2><p>스택에는 오직 두 개의 필수적인 연산들이 존재한다.</p><ul><li><code>push</code> : 스택 맨 위에 요소를 추가</li><li><code>pop</code> : 스택 맨 위의 요소를 제거</li></ul><p>즉, 스택은 한 쪽에서만 요소의 추가나 제거가 가능한 자료구조이다. Computer science에선 스택은 LIFO<small>(last-in first-out)</small> 자료구조라고도 한다. 마지막에 들어간<small>(push)</small> 요소들은 가장 먼저 나온다<small>(pop)</small>.</p><blockquote><p>stack 패키지 내부에 Stack 인터페이스 선언 (stack/Stack.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="type">T : Any</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(element: <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: T?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">※ 위의 Stack 인터페이스는 Vector 클래스를 상속받고 본문에서 필요로 하지 않는 메서드들을 제공하는 Kotlin과 Java의 Stack 클래스와 다르다.  </span><br></pre></td></tr></table></figure><p>스택은 다음과 같은 프로그래밍 분야에서 눈에 띄게 사용된다.</p><ul><li>안드로이드는 <strong>fragment stack</strong>을 사용하여 Activity의 안팎으로 fragment들을 push 및 pop을 한다.</li><li>메모리 할당은 아키텍처 수준에서 스택을 사용한다. <strong>지역 변수의 메모리</strong>도 스택을 사용하여 관리된다.</li><li>미로에서 길을 찾는 것과 같은 <strong>Search and conquer 알고리즘</strong>은 스택을 사용하여 백트래킹을 용이하게 한다.</li></ul><h2 id="구현"><a class="markdownIt-Anchor" href="#구현"></a> 구현</h2><p>다양한 방식으로 Stack 인터페이스를 구현할 수 있는데 올바른 storage type을 선택하는 것이 중요하다. <strong>ArrayList</strong>는 마지막 인덱스를 매개변수로 사용하여 <code>add</code> 및 <code>removeAt</code>을 통해 한쪽 끝에서 O(1)<small>(상수 시간)</small> 삽입 및 삭제를 제공하므로 확실한 선택이다. 이 두 연산을 사용하면 스택의 LIFO 특성이 쉽게 구현된다.</p><blockquote><p>StackImpl 클래스에 <code>toString</code> 재정의 (StackImpl.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackImpl</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">Stack</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> storage = arrayListOf&lt;T&gt;()  </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = buildString &#123;</span><br><span class="line">      appendLine(<span class="string">&quot;----top----&quot;</span>)</span><br><span class="line">      storage.asReversed().forEach &#123;</span><br><span class="line">        appendLine(<span class="string">&quot;<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      appendLine(<span class="string">&quot;-----------&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>데이터에 대해 ArrayList 유형의 private property를 정의하고 디버그 목적으로 해당 내용을 표시하기 위해 <code>toString</code> 메서드를 재정의한다. <small>(이 코드를 사용하면 아직 push 및 pop 연산을 구현하지 않았기에 오류가 발생한다.)</small></p><h3 id="push-및-pop-연산"><a class="markdownIt-Anchor" href="#push-및-pop-연산"></a> push 및 pop 연산</h3><blockquote><p><code>push</code> 및 <code>pop</code> 추가 (StackImpl.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(element: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    storage.add(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">if</span> (storage.size == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> storage.removeAt(storage.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>push</code> 메서드에서 ArrayList의 <code>add</code> 메서드를 이용해서 매개변수로 전달된 값을 ArrayList의 끝에 추가한다<small>(append)</small>. <code>pop</code> 메서드는 ArrayList가 비어 있으면 null을 반환하고 그렇지 않다면 마지막에 삽입한 요소를 제거하고 반환한다.</p><p>아래의 코드를 통해 직접 구현한 스택이 올바르게 작동하는지 확인한다.</p><blockquote><p>테스트용 코드 작성 (Main.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = StackImpl&lt;<span class="built_in">Int</span>&gt;().apply &#123;</span><br><span class="line">        push(<span class="number">1</span>)</span><br><span class="line">        push(<span class="number">2</span>)</span><br><span class="line">        push(<span class="number">3</span>)</span><br><span class="line">        push(<span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    print(stack)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> poppedElement = stack.pop()</span><br><span class="line">    <span class="keyword">if</span> (poppedElement != <span class="literal">null</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Popped: <span class="variable">$poppedElement</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    print(stack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">----top----</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">-----------</span><br><span class="line">Popped: 4</span><br><span class="line">----top----</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">-----------</span><br></pre></td></tr></table></figure><p><code>push</code> 및 <code>pop</code>은 둘 다 O(1) 시간 복잡도를 가진다.</p><h3 id="유용한-추가-연산들"><a class="markdownIt-Anchor" href="#유용한-추가-연산들"></a> 유용한 추가 연산들</h3><p>스택을 더 쉽게 사용할 수 있는 몇 가지 유용한 연산들을 추가한다.</p><blockquote><p>Stack 인터페이스에 <code>peek</code> 추가 (stack/Stack.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="type">T : Any</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = count == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>peek</code>의 개념은 내용을 변경하지 않고 스택의 맨 위 요소를 보는 것이다. <em>count</em> 속성은 스택의 요소 수를 반환하며 <em>isEmpty</em> 속성을 구현하는데 사용된다.</p><blockquote><p><code>peek</code> 구현하기 (StackImpl.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">return</span> storage.lastOrNull()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = storage.size</span><br></pre></td></tr></table></figure><p><code>peek</code>을 구현함으로써 <code>pop</code>의 구현을 더 깔끔한 코드로 변경할 수 있다.</p><blockquote><p><code>pop</code> 코드를 더 깔끔하게 수정</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> storage.removeAt(storage.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="스택과-kotlin-collection-interfaces"><a class="markdownIt-Anchor" href="#스택과-kotlin-collection-interfaces"></a> 스택과 Kotlin Collection Interfaces</h3><p>스택에 Kotlin Collection 인터페이스를 채택할 수 있을지 궁금할 수 있다. 스택의 목적은 데이터에 액세스하는 방법의 수를 제한하는 것인데, <strong>Iterable</strong>과 같은 인터페이스를 채택하면 iterator를 통해 모든 요소들을 노출함으로써 당초의 목표와 어긋나게 된다.</p><p>액세스 순서가 보장되도록 기존의 List를 가져와 스택으로 변환하는 것을 원할 수 있다. 물론 배열의 요소들을 순회하고 각 요소들을 <code>push</code> 할 수 있다. 하지만 이러한 요소를 Stack 구현에 직접적으로 추가하는 <a href="https://github.com/june0122/Effective-Java/blob/b24a45bbf5e320971bf2dfafe5bcbd38feeb9039/item%2001.md"><b>정적 팩토리 메서드<small>(static factory method)</small></b></a>를 작성할 수 있다.</p><blockquote><p>정적 팩토리 메서드 사용하기 (StackImpl.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">create</span><span class="params">(items: <span class="type">Iterable</span>&lt;<span class="type">T</span>&gt;)</span></span>: Stack&lt;T&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> stack = StackImpl&lt;T&gt;()</span><br><span class="line">      <span class="keyword">for</span> (item <span class="keyword">in</span> items) &#123;</span><br><span class="line">        stack.push(item)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> stack</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>테스트용 코드 (Main.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> stack = StackImpl.create(list)</span><br><span class="line">    print(stack)</span><br><span class="line">    println(<span class="string">&quot;Popped: <span class="subst">$&#123;stack.pop()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">----top----</span><br><span class="line">D</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">A</span><br><span class="line">-----------</span><br><span class="line">Popped: D</span><br></pre></td></tr></table></figure><p>이 코드는 문자열 스택을 생성하고 최상위 요소인 &quot;D&quot;를 pop 한다.</p><p>한 단계 더 나아가 <code>listOf()</code> 및 기타 표준 라이브러리 collection factory 함수와 유사한 요소를 나열하여 스택을 초기화할 수 있다. 이를 Stack.kt의 Stack을 구현한 클래스 외부에 추가한다.</p><blockquote><p>스택 초기화 함수 추가 (Stack.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">stackOf</span><span class="params">(<span class="keyword">vararg</span> elements: <span class="type">T</span>)</span></span>: Stack&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> StackImpl.create(elements.asList())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>테스트용 코드 (Main.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = stackOf(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line">    print(stack)</span><br><span class="line">    println(<span class="string">&quot;Popped: <span class="subst">$&#123;stack.pop()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">----top----</span><br><span class="line">4.0</span><br><span class="line">3.0</span><br><span class="line">2.0</span><br><span class="line">1.0</span><br><span class="line">-----------</span><br><span class="line">Popped: 4.0</span><br></pre></td></tr></table></figure><p>이렇게 하면 Double의 스택이 생성되고 최상위 값인 4.0이 표시된다. 코틀린 컴파일러의 타입 추론 기능 덕분에 <code>stackOf</code> 함수 호출의 제네릭 타입 인자를 지정하지 않아도 된다.</p><p>스택은 트리와 그래프를 검색하는 문제에 매우 중요하다. 미로를 통해 길을 찾는다고 상상할 때, 왼쪽, 오른쪽 또는 직진을 결정해야 하는 지점에 올 때마다 가능한 모든 결정들을 스택에 넣을 수 있다. <small>(When you hit a dead end, backtrack by popping from the stack and continuing until you escape or hit another dead end.)</small></p><h2 id="스택의-활용"><a class="markdownIt-Anchor" href="#스택의-활용"></a> 스택의 활용</h2><h3 id="linkedlist-뒤집기"><a class="markdownIt-Anchor" href="#linkedlist-뒤집기"></a> LinkedList 뒤집기</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> LinkedList<span class="type">&lt;T&gt;</span>.<span class="title">printInReverse</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = StackImpl&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (node <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        stack.push(node)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> node = stack.pop()</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        println(node)</span><br><span class="line">        node = stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="괄호-확인"><a class="markdownIt-Anchor" href="#괄호-확인"></a> 괄호 확인</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">h((e))llo(world)() // balanced parentheses</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">(hello world // unbalanced parentheses</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">checkParentheses</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = StackImpl&lt;<span class="built_in">Char</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (char <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">when</span> (char) &#123;</span><br><span class="line">            <span class="string">&#x27;(&#x27;</span> -&gt; stack.push(char)</span><br><span class="line">            <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                <span class="keyword">else</span> stack.pop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스택은 괄호 관련 코딩 테스트 문제에 자주 등장하므로 사용 방법을 숙지할 필요가 있다.</p><ul><li><a href="https://programmers.co.kr/learn/courses/30/lessons/60058">프로그래머스 레벨 2 - 괄호 변환</a></li><li><a href="https://programmers.co.kr/learn/courses/30/lessons/76502">프로그래머스 레벨 2 - 괄호 회전하기</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Data-Structure/">Data Structure</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Data-Structure/">Data Structure</category>
      
      <category domain="http://june0122.github.io/tags/Stack/">Stack</category>
      
      
      <comments>http://june0122.github.io/2021/07/05/data-structure-stack/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] BFS (Breadth First Search)</title>
      <link>http://june0122.github.io/2021/07/01/boj-bfs/</link>
      <guid>http://june0122.github.io/2021/07/01/boj-bfs/</guid>
      <pubDate>Thu, 01 Jul 2021 14:23:18 GMT</pubDate>
      
      <description>[바킹독의 실전 알고리즘] 0x09강 - BFS</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="설명"><a class="markdownIt-Anchor" href="#설명"></a> 설명</h2><blockquote><h3 id="다차원-배열에서-각-칸을-방문할-때-너비를-우선으로-방문하는-알고리즘"><a class="markdownIt-Anchor" href="#다차원-배열에서-각-칸을-방문할-때-너비를-우선으로-방문하는-알고리즘"></a> 다차원 배열에서 각 칸을 방문할 때 너비를 우선으로 방문하는 알고리즘</h3></blockquote><ol><li>시작하는 칸을 큐에 넣고 방문했다는 표시를 남김</li><li>큐에서 원소를 꺼내어 그 칸에 상하좌우로 인접한 칸에 대해 <code>3번</code>을 진행</li><li>해당 칸을 이전에 방문했다면 아무것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 큐에 삽입</li><li>큐가 빌 때까지 <code>2번</code>을 반복</li></ol><p>모든 칸이 큐에 1번씩 들어가므로 시간복잡도는 칸이 N개일 때 O(N)</p><h4 id="bfs-구현-시-자주하는-실수"><a class="markdownIt-Anchor" href="#bfs-구현-시-자주하는-실수"></a> BFS 구현 시 자주하는 실수</h4><ol><li>시작점을 큐에 넣긴하는데 정작 방문했다는 표시를 남기지 않은 채로 진행하는 경우</li><li>큐에 넣을 때 해당 칸에 방문했다는 표시를 남기지 않고 큐에서 빼낼 때 남기는 경우</li><li>nx, ny가 배열 바깥으로 벗어났는지에 대한 루틴을 아예 빼먹었거나, 아니면 이상하게 구현을 한 상황</li></ol><h2 id="예시-및-응용"><a class="markdownIt-Anchor" href="#예시-및-응용"></a> 예시 및 응용</h2><h3 id="예시-flood-fill"><a class="markdownIt-Anchor" href="#예시-flood-fill"></a> 예시 : Flood Fill</h3><blockquote><p><a href="https://www.acmicpc.net/problem/1926">BOJ 1926, 그림</a></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> (n, m) = Pair(nextInt(), nextInt())</span><br><span class="line">    <span class="keyword">val</span> (dx, dy) = intArrayOf(<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>) to intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>) <span class="comment">// 상하좌우 네 방향을 의미</span></span><br><span class="line">    <span class="keyword">val</span> paper = Array(n) &#123; IntArray(m) &#125;</span><br><span class="line">    <span class="keyword">val</span> visitMap = Array(n) &#123; BooleanArray(m) &#125; <span class="comment">// 해당 칸을 방문했는지 여부를 저장</span></span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span> <span class="comment">// 그림의 최댓값</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span> <span class="comment">// 그림의 개수</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> paper.indices) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> paper[i].indices) &#123;</span><br><span class="line">            paper[i][j] = nextInt()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> paper.indices) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> paper[i].indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (paper[i][j] == <span class="number">0</span> || visitMap[i][j]) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> queue: Queue&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; = LinkedList()</span><br><span class="line">            <span class="keyword">var</span> area = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            visitMap[i][j] = <span class="literal">true</span></span><br><span class="line">            queue.offer(i to j)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">                area += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> cur = queue.poll()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (dir <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123; <span class="comment">// 상하좌우 칸을 탐색</span></span><br><span class="line">                    <span class="keyword">val</span> nx = cur.first + dx[dir]</span><br><span class="line">                    <span class="keyword">val</span> ny = cur.second + dy[dir] <span class="comment">// nx, ny에 dir에서 정한 방향의 인접한 칸의 좌표가 들어감</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span> <span class="comment">// 범위 밖일 경우 넘어감</span></span><br><span class="line">                    <span class="keyword">if</span> (visitMap[nx][ny]|| paper[nx][ny] != <span class="number">1</span>) <span class="keyword">continue</span> <span class="comment">// 이미 방문한 칸이거나 색칠된 칸이 아닐 경우</span></span><br><span class="line"></span><br><span class="line">                    visitMap[nx][ny] = <span class="literal">true</span> <span class="comment">// (nx, ny)를 방문했다고 명시</span></span><br><span class="line">                    queue.offer(nx to ny)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max = max(max, area)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$num</span>\n<span class="variable">$max</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="응용-1-거리-측정"><a class="markdownIt-Anchor" href="#응용-1-거리-측정"></a> 응용 1 : 거리 측정</h3><blockquote><p><a href="https://www.acmicpc.net/problem/2178">BOJ 2178번, 미로 탐색</a></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> (n, m) = nextInt() to nextInt()</span><br><span class="line">    <span class="keyword">val</span> (dx, dy) = intArrayOf(<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>) to intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> maze = Array(n) &#123; IntArray(m) &#125;</span><br><span class="line">    <span class="keyword">val</span> dist = Array(n) &#123; IntArray(m) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123; <span class="comment">// 각각의 수들은 &#x27;붙어서&#x27; 입력으로 주어진다.</span></span><br><span class="line">        <span class="keyword">val</span> line = next()</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            maze[i][j] = line[j] - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; = LinkedList()</span><br><span class="line">    queue.offer(<span class="number">0</span> to <span class="number">0</span>)</span><br><span class="line">    dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> (curX, curY) = queue.poll()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (dir <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> nx = curX + dx[dir]</span><br><span class="line">            <span class="keyword">val</span> ny = curY + dy[dir]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (dist[nx][ny] &gt;= <span class="number">0</span> || maze[nx][ny] != <span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            dist[nx][ny] = dist[curX][curY] + <span class="number">1</span></span><br><span class="line">            queue.offer(nx to ny)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(dist[n - <span class="number">1</span>][m - <span class="number">1</span>] + <span class="number">1</span>) <span class="comment">// 지나는 칸 수를 출력이므로 + 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="응용-2-시작점이-여러-개일-때"><a class="markdownIt-Anchor" href="#응용-2-시작점이-여러-개일-때"></a> 응용 2 : 시작점이 여러 개일 때</h3><blockquote><p><a href="https://www.acmicpc.net/problem/7576">BOJ 7576번, 토마토</a></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">var</span> date = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> (m, n) = nextInt() to nextInt()</span><br><span class="line">    <span class="keyword">val</span> (dx, dy) = intArrayOf(<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>) to intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> box = Array(n) &#123; IntArray(m) &#125;</span><br><span class="line">    <span class="keyword">val</span> vis = Array(n) &#123; BooleanArray(m) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            box[i][j] = nextInt()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; = LinkedList()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (box[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                queue.offer(i to j)</span><br><span class="line">                vis[i][j] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> temp = mutableListOf&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (rottenNum <span class="keyword">in</span> <span class="number">0</span> until queue.size) &#123;</span><br><span class="line">            <span class="keyword">val</span> (curX, curY) = queue.poll()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (dir <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> (nx, ny) = curX + dx[dir] to curY + dy[dir]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> (box[nx][ny] == <span class="number">1</span> || box[nx][ny] == -<span class="number">1</span> || vis[nx][ny]) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                vis[nx][ny] = <span class="literal">true</span></span><br><span class="line">                box[nx][ny] = <span class="number">1</span></span><br><span class="line">                temp.add(nx to ny)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.forEach &#123;</span><br><span class="line">            queue.offer(it)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.clear()</span><br><span class="line"></span><br><span class="line">        date += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (box[i][j] == <span class="number">0</span>) date = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(date - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">var</span> date = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> (m, n) = nextInt() to nextInt()</span><br><span class="line">    <span class="keyword">val</span> (dx, dy) = intArrayOf(<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>) to intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> box = Array(n) &#123; IntArray(m) &#125;</span><br><span class="line">    <span class="keyword">val</span> dist = Array(n) &#123; IntArray(m) &#125; <span class="comment">// 익은 토마토가 들어있거나 토마토가 없는 칸은 값이 0</span></span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; = LinkedList()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            box[i][j] = nextInt()</span><br><span class="line">            <span class="keyword">when</span> (box[i][j]) &#123;</span><br><span class="line">                <span class="number">1</span> -&gt; queue.offer(i to j) <span class="comment">// 익은 토마토, 즉 거리가 0인 칸을 큐에 넣음</span></span><br><span class="line">                <span class="number">0</span> -&gt; dist[i][j] = -<span class="number">1</span> <span class="comment">// 익지 않은 토마토의 dist값을 -1로 설정</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> (curX, curY) = queue.poll()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (dir <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> (nx, ny) = curX + dx[dir] to curY + dy[dir]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (dist[nx][ny] &gt;= <span class="number">0</span>) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            dist[nx][ny] = dist[curX][curY] + <span class="number">1</span></span><br><span class="line">            queue.offer(nx to ny)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i][j] == -<span class="number">1</span>) &#123; <span class="comment">// 익지 않은 토마토가 있다면 -1 출력</span></span><br><span class="line">                print(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            date = max(date, dist[i][j])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(date)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="응용-3-시작점이-두-종류일-때"><a class="markdownIt-Anchor" href="#응용-3-시작점이-두-종류일-때"></a> 응용 3 : 시작점이 두 종류일 때</h3><blockquote><p><a href="https://www.acmicpc.net/problem/4179">BOJ 4179번, 불!</a></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> (row, col) = nextInt() to nextInt()</span><br><span class="line">    <span class="keyword">val</span> (dx, dy) = intArrayOf(<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>) to intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> maze = Array(row) &#123; CharArray(col) &#125;</span><br><span class="line">    <span class="keyword">val</span> fireDist = Array(row) &#123; IntArray(col) &#123; -<span class="number">1</span> &#125; &#125; <span class="comment">// 불의 전파 시간</span></span><br><span class="line">    <span class="keyword">val</span> jihoonDist = Array(row) &#123; IntArray(col) &#123; -<span class="number">1</span> &#125; &#125; <span class="comment">// 지훈이의 이동 시간</span></span><br><span class="line">    <span class="keyword">val</span> fireQueue: Queue&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; = LinkedList()</span><br><span class="line">    <span class="keyword">val</span> jihoonQueue: Queue&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; = LinkedList()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until row) &#123;</span><br><span class="line">        <span class="keyword">val</span> line = next()</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until col) &#123;</span><br><span class="line">            maze[i][j] = line[j]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (maze[i][j] == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">                fireQueue.offer(i to j)</span><br><span class="line">                fireDist[i][j] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maze[i][j] == <span class="string">&#x27;J&#x27;</span>) &#123;</span><br><span class="line">                jihoonQueue.offer(i to j)</span><br><span class="line">                jihoonDist[i][j] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 불에 대한 BFS</span></span><br><span class="line">    <span class="keyword">while</span> (fireQueue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> (curX, curY) = fireQueue.poll()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (dir <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> (nx, ny) = curX + dx[dir] to curY + dy[dir]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= row || ny &lt; <span class="number">0</span> || ny &gt;= col) <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (fireDist[nx][ny] &gt;= <span class="number">0</span> || maze[nx][ny] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            fireDist[nx][ny] = fireDist[curX][curY] + <span class="number">1</span></span><br><span class="line">            fireQueue.offer(nx to ny)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 지훈이에 대한 BFS</span></span><br><span class="line">    <span class="keyword">while</span> (jihoonQueue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> (curX, curY) = jihoonQueue.poll()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (dir <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> (nx, ny) = curX + dx[dir] to curY + dy[dir]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 범위를 벗어난 것은 탈출에 성공했다는 의미. 큐에 거리 순으로 들어가므로 최초에 탈출한 시간을 출력하면 됨.</span></span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= row || ny &lt; <span class="number">0</span> || ny &gt;= col) &#123;</span><br><span class="line">                println(jihoonDist[curX][curY] + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (jihoonDist[nx][ny] &gt;= <span class="number">0</span> || maze[nx][ny] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (fireDist[nx][ny] != -<span class="number">1</span> &amp;&amp; fireDist[nx][ny] &lt;= jihoonDist[curX][curY] + <span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">// 불의 전파 시간을 조건에 추가. 지훈이 도착한 시간과 동시에, 혹은 더 빨리 불이 도착하는 자리로는 갈 수 없음.</span></span><br><span class="line"></span><br><span class="line">            jihoonDist[nx][ny] = jihoonDist[curX][curY] + <span class="number">1</span></span><br><span class="line">            jihoonQueue.offer(nx to ny)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;IMPOSSIBLE&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>fireDist[nx][ny] != -1</code> 조건이 필요한 이유를 설명해주는 input 케이스</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br><span class="line">###F</span><br><span class="line">.J#.</span><br><span class="line">###.</span><br></pre></td></tr></table></figure><blockquote><p>continue를 사용하지 않고 조건을 만족할 떄 로직을 실행</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (jihoonDist[nx][ny] == -<span class="number">1</span> &amp;&amp; maze[nx][ny] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fireDist[nx][ny] == -<span class="number">1</span> || fireDist[nx][ny] &gt; jihoonDist[curX][curY] + <span class="number">1</span>) &#123;</span><br><span class="line">        jihoonDist[nx][ny] = jihoonDist[curX][curY] + <span class="number">1</span></span><br><span class="line">        jihoonQueue.offer(nx to ny)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>maze 초기화 시 forEachIndeded 사용하는 방법</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until row) &#123;</span><br><span class="line">        next().forEachIndexed &#123; j, char -&gt;</span><br><span class="line">            maze[i][j] = char</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>이렇게 시작점이 두 종류인 문제를 해결할 수 있게 되었다. 하지만 시작점이 두 종류인 문제에 관해서 생각해야 할 점이 추가로 존재한다. 본 문제는 지훈이의 이동은 불의 전파에 영향을 받지만 불의 전파는 지훈이의 이동에 영향을 받지 않아서 불만 먼저 전파를 쭉 시키는게 가능했다. 그러나 시작점이 A, B 두 종류가 있고, A의 전파에 B가 영향을 주고 B의 전파에도 A가 영향을 준다고 가정해본다면 어느 하나를 먼저 끝까지 전파시키는게 불가능하다. (예를 들어, 불과 소방수 내지는 불과 물이 전파되는 문제여서 둘이 만나면 뭔가 상호작용이 발생하는 케이스)</p><p>위의 케이스를 다루는 문제가 바로 <a href="https://www.acmicpc.net/problem/18809">BOJ 18809번, Gaaaaaaaaaarden</a> 문제이다. 아쉽게도 이 문제는 <strong>백트래킹 기법</strong>을 추가로 알고 있어야 해결이 가능하기 때문에 당장 풀어볼 수는 없지만, 두 종류의 BFS에서 BFS를 돌 때 어느 하나가 독립적이지 않고 서로에게 영향을 준다면 위의 방법으로는 해결할 수 없다는 것을 꼭 이해해야 한다. 그런 상황에서는 시간 순으로 A와 B를 동시에 진행시켜야 한다.</p><h3 id="응용-4-1차원에서의-bfs"><a class="markdownIt-Anchor" href="#응용-4-1차원에서의-bfs"></a> 응용 4 : 1차원에서의 BFS</h3><blockquote><p><a href="https://www.acmicpc.net/problem/1697">BOJ 1697번, 숨바꼭질</a></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> (n, k) = nextInt() to nextInt()</span><br><span class="line">    <span class="keyword">val</span> line = Array(<span class="number">100001</span>) &#123; -<span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;<span class="built_in">Int</span>&gt; = LinkedList()</span><br><span class="line"></span><br><span class="line">    line[n] = <span class="number">0</span></span><br><span class="line">    queue.offer(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> current = queue.poll()</span><br><span class="line">        <span class="keyword">val</span> dx = intArrayOf(<span class="number">1</span>, -<span class="number">1</span>, current)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (dir <span class="keyword">in</span> dx.indices) &#123;</span><br><span class="line">            <span class="keyword">val</span> next = current + dx[dir]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next &lt; <span class="number">0</span> || next &gt; <span class="number">100000</span>) <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (line[next] != -<span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            line[next] = line[current] + <span class="number">1</span></span><br><span class="line">            queue.offer(next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(line[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><p><a href="https://youtu.be/ftOmGdm95XI">[바킹독의 실전 알고리즘] 0x09강 - BFS</a></p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%94%ED%82%B9%EB%8F%85/">바킹독</category>
      
      <category domain="http://june0122.github.io/tags/BFS/">BFS</category>
      
      
      <comments>http://june0122.github.io/2021/07/01/boj-bfs/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 다이나믹 프로그래밍 (Dynamic Programming, DP)</title>
      <link>http://june0122.github.io/2021/06/30/boj-dynamic-programming/</link>
      <guid>http://june0122.github.io/2021/06/30/boj-dynamic-programming/</guid>
      <pubDate>Tue, 29 Jun 2021 16:23:11 GMT</pubDate>
      
      <description>[바킹독의 실전 알고리즘] 0x10강 - 다이나믹 프로그래밍</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>여러 개의 하위 문제를 먼저 푼 후 그 결과를 쌓아올려 주어진 문제를 해결하는 알고리즘</p></blockquote><h3 id="dp를-푸는-과정"><a class="markdownIt-Anchor" href="#dp를-푸는-과정"></a> DP를 푸는 과정</h3><ol><li>테이블 정의하기</li><li>점화식 찾기</li><li>초기값 정하기</li></ol><h2 id="연습-문제"><a class="markdownIt-Anchor" href="#연습-문제"></a> 연습 문제</h2><h3 id="boj-1463-1로-만들기"><a class="markdownIt-Anchor" href="#boj-1463-1로-만들기"></a> <a href="https://www.acmicpc.net/problem/1463">BOJ 1463 : 1로 만들기</a></h3><blockquote><p>DP</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nextInt()</span><br><span class="line">    <span class="keyword">val</span> d = IntArray(n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">        d[i] = d[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) d[i] = min(d[i], d[i / <span class="number">2</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) d[i] = min(d[i], d[i / <span class="number">3</span>] + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(d[n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>BFS</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nextInt()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;<span class="built_in">Int</span>&gt; = LinkedList()</span><br><span class="line">    <span class="keyword">val</span> dist = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> dx = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    queue.offer(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> cur = queue.poll()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (dir <span class="keyword">in</span> dx.indices) &#123;</span><br><span class="line">            <span class="keyword">val</span> next = <span class="keyword">when</span> (dir) &#123;</span><br><span class="line">                <span class="number">0</span> -&gt; cur + dx[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">else</span> -&gt; cur * dx[dir]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next &gt; n) <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (dist[next] != <span class="number">0</span>) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            dist[next] = dist[cur] + <span class="number">1</span></span><br><span class="line">            queue.offer(next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(dist[n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="boj-9095-1-2-3-더하기"><a class="markdownIt-Anchor" href="#boj-9095-1-2-3-더하기"></a> <a href="https://www.acmicpc.net/problem/9095">BOJ 9095 : 1, 2, 3 더하기</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> t = nextInt()</span><br><span class="line">    <span class="keyword">val</span> d = IntArray(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    d[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    d[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> until <span class="number">11</span>) &#123;</span><br><span class="line">        d[i] = d[i - <span class="number">1</span>] + d[i - <span class="number">2</span>] + d[i - <span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repeat(t) &#123; println(d[nextInt()]) &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="boj-2579-계단-오르기"><a class="markdownIt-Anchor" href="#boj-2579-계단-오르기"></a> <a href="https://www.acmicpc.net/problem/2579">BOJ 2579 : 계단 오르기</a></h3><blockquote><p>2차원 배열 이용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nextInt()</span><br><span class="line">    <span class="keyword">val</span> s = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> d = Array(n + <span class="number">1</span>) &#123; IntArray(<span class="number">3</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.n) s[i] = nextInt()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        println(s[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@with</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>][<span class="number">1</span>] = s[<span class="number">1</span>]</span><br><span class="line">    d[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">    d[<span class="number">2</span>][<span class="number">1</span>] = s[<span class="number">2</span>]</span><br><span class="line">    d[<span class="number">2</span>][<span class="number">2</span>] = s[<span class="number">1</span>] + s[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3.</span>.n) &#123;</span><br><span class="line">        d[i][<span class="number">1</span>] = max(d[i - <span class="number">2</span>][<span class="number">1</span>], d[i - <span class="number">2</span>][<span class="number">2</span>]) + s[i]</span><br><span class="line">        d[i][<span class="number">2</span>] = d[i - <span class="number">1</span>][<span class="number">1</span>] + s[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(max(d[n][<span class="number">1</span>], d[n][<span class="number">2</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>D[i][j]</code> = 현재까지 <code>j</code>개의 계단을 연속해서 밟고 <code>i</code>번째 계단까지 올라섰을 때 점수 합의 최댓값, 단 <code>i</code>번째 계단은 반드시 밟아야 함</p><p>이렇게 2차원 배열을 선언한 이유는 지금까지 몇 개의 계단을 밟았는지에 대한 정보가 추가로 있어야 점화식을 세울 때 계단을 오르는 규칙을 고려할 수 있기 때문이다. 그리고 i번째 계단은 반드시 밟아야 한다는 조건이 있어야 점화식을 이끌어낼 수 있다. 이 2차원 배열에서 <code>j</code>는 어떤 값을 가지냐 보면 <code>i</code>번째 계단을 반드시 밟아야 한다는 조건이 있어서 <code>j = 1</code> 혹은 <code>2</code>이다. 연속된 세 개의 계단을 모두 밟아서는 안된다는 조건으로 인해 <code>j</code>가 <code>3</code> 이상일 수는 없다.</p><blockquote><p>1차원 배열 이용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nextInt()</span><br><span class="line">    <span class="keyword">val</span> s = IntArray(<span class="number">300</span>)</span><br><span class="line">    <span class="keyword">val</span> d = IntArray(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) s[i] = nextInt()</span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>] = s[<span class="number">0</span>]</span><br><span class="line">    d[<span class="number">1</span>] = max(s[<span class="number">0</span>] + s[<span class="number">1</span>], s[<span class="number">1</span>])</span><br><span class="line">    d[<span class="number">2</span>] = max(s[<span class="number">0</span>] + s[<span class="number">2</span>], s[<span class="number">1</span>] + s[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3</span> until n) &#123;</span><br><span class="line">        d[i] = max(d[i - <span class="number">2</span>] + s[i], d[i - <span class="number">3</span>] + s[i - <span class="number">1</span>] + s[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(d[n - <span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="boj-1149-rgb거리"><a class="markdownIt-Anchor" href="#boj-1149-rgb거리"></a> <a href="https://www.acmicpc.net/problem/1149">BOJ 1149 : RGB거리</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.min</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">RGB</span></span>(<span class="keyword">var</span> red: <span class="built_in">Int</span>, <span class="keyword">var</span> green: <span class="built_in">Int</span>, <span class="keyword">var</span> blue: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nextInt()</span><br><span class="line">    <span class="keyword">val</span> colors = Array(n + <span class="number">1</span>) &#123; RGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> d = Array(n + <span class="number">1</span>) &#123; IntArray(<span class="number">3</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        colors[i].red = nextInt()</span><br><span class="line">        colors[i].green = nextInt()</span><br><span class="line">        colors[i].blue = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = colors[<span class="number">0</span>].red</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">1</span>] = colors[<span class="number">0</span>].green</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">2</span>] = colors[<span class="number">0</span>].blue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">        d[i][<span class="number">0</span>] = min(d[i-<span class="number">1</span>][<span class="number">1</span>], d[i-<span class="number">1</span>][<span class="number">2</span>]) + colors[i].red</span><br><span class="line">        d[i][<span class="number">1</span>] = min(d[i-<span class="number">1</span>][<span class="number">0</span>], d[i-<span class="number">1</span>][<span class="number">2</span>]) + colors[i].green</span><br><span class="line">        d[i][<span class="number">2</span>] = min(d[i-<span class="number">1</span>][<span class="number">0</span>], d[i-<span class="number">1</span>][<span class="number">1</span>]) + colors[i].blue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(minOf(d[n - <span class="number">1</span>][<span class="number">0</span>], d[n - <span class="number">1</span>][<span class="number">1</span>], d[n - <span class="number">1</span>][<span class="number">2</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="boj-11726-2n-타일링"><a class="markdownIt-Anchor" href="#boj-11726-2n-타일링"></a> <a href="https://www.acmicpc.net/problem/11726">BOJ 11726 : 2×n 타일링</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nextInt()</span><br><span class="line">    <span class="keyword">val</span> d = IntArray(n + <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> mod = <span class="number">10007</span></span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    d[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3.</span>.n) d[i] = (d[i - <span class="number">1</span>] + d[i - <span class="number">2</span>]) % mod</span><br><span class="line"></span><br><span class="line">    println(d[n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="boj-11659-구간-합-구하기-4"><a class="markdownIt-Anchor" href="#boj-11659-구간-합-구하기-4"></a> <a href="https://www.acmicpc.net/problem/11659">BOJ 11659 : 구간 합 구하기 4</a></h3><blockquote><p>Prefix Sum 기법</p></blockquote><p>Prefix Sum은 시작 위치부터 현재 위치까지의 원소 합을 저장하는 배열이다.</p><p>부분 합(partial sum) 또는 누적 합(cumulative sum)이라고도 한다.</p><table><thead><tr><th style="text-align:center">Number</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:center">Prefix sum</td><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">10</td><td style="text-align:center">15</td></tr></tbody></table><p>Prefix sum은 누적 합을 미리 구하는 전처리 과정을 통해 구간 합(range sum)을 빠르게 구할 때 사용된다.</p><ul><li>prefix sum : <code>0 ~ b</code> 까지의 누적합 (반드시 첫번 째 원소를 포함하는 구간)</li><li>range sum : <code>a ~ b</code> 까지의 구간 합</li></ul><h4 id="시간-복잡도"><a class="markdownIt-Anchor" href="#시간-복잡도"></a> 시간 복잡도</h4><ul><li>전처리 단계<ul><li>1차원 : O(n)</li><li>2차원 : O(n*m)</li></ul></li><li>계산 : O(1)</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> (n, m) = nextInt() to nextInt()</span><br><span class="line">    <span class="keyword">val</span> d = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> a = IntArray(n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">        a[i] = nextInt()</span><br><span class="line">        d[i] = d[i - <span class="number">1</span>] + a[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repeat(m) &#123;</span><br><span class="line">        <span class="keyword">val</span> (i, j) = nextInt() to nextInt()</span><br><span class="line">        println(d[j] - d[i - <span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// O(n^2)</span><br><span class="line">D[i] = A[i] + A[2] + … + A[i]</span><br><span class="line"></span><br><span class="line">// O(n)</span><br><span class="line">D[i] = D[i-1] + A[i]</span><br><span class="line"></span><br><span class="line">// O(1)</span><br><span class="line">A[i] + A[i+1] + … + A[j]</span><br><span class="line">= (A[1] + A[2] + … + A[j]) - (A[1] + A[2] + … + A[i-1])</span><br><span class="line">= D[j] - D[i-1] </span><br></pre></td></tr></table></figure><h2 id="경로-추적"><a class="markdownIt-Anchor" href="#경로-추적"></a> 경로 추적</h2><h3 id="boj-12852-1로-만들기-2"><a class="markdownIt-Anchor" href="#boj-12852-1로-만들기-2"></a> <a href="https://www.acmicpc.net/problem/12852">BOJ 12852 : 1로 만들기 2</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nextInt()</span><br><span class="line">    <span class="keyword">val</span> d = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> pre = IntArray(n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">        d[i] = d[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        pre[i] = i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; d[i] &gt; d[i / <span class="number">2</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">            d[i] = d[i / <span class="number">2</span>] + <span class="number">1</span></span><br><span class="line">            pre[i] = i / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; d[i] &gt; d[i / <span class="number">3</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">            d[i] = d[i / <span class="number">3</span>] + <span class="number">1</span></span><br><span class="line">            pre[i] = i / <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(d[n])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cur = n</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="variable">$cur</span> &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">        cur = pre[cur]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위 문제를 BFS로 경로 복원 문제 풀이도 가능하다.</li></ul><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li>바킹독의 실전 알고리즘 - <a href="https://www.youtube.com/watch?v=5leTtB3PQu0">https://www.youtube.com/watch?v=5leTtB3PQu0</a></li><li>Prefix sum - <a href="https://gamedevlog.tistory.com/68">https://gamedevlog.tistory.com/68</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/DP/">DP</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%94%ED%82%B9%EB%8F%85/">바킹독</category>
      
      
      <comments>http://june0122.github.io/2021/06/30/boj-dynamic-programming/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[코틀린 자료구조] 연결 리스트 (Linked List)</title>
      <link>http://june0122.github.io/2021/06/27/data-structure-linked-list/</link>
      <guid>http://june0122.github.io/2021/06/27/data-structure-linked-list/</guid>
      <pubDate>Sun, 27 Jun 2021 12:51:57 GMT</pubDate>
      
      <description>&lt;b&gt;Linked list&lt;/b&gt;는 선형, 단방향 시퀀스로 배열된 값의 모음이다. linked list는 Kotlin Array, ArrayList와 같은 연속적인 저장소 옵션들&lt;small&gt;(contiguous storage options)&lt;/small&gt;에 비해 몇 가지 이론적인 장점이 있다.</description>
      
      
      
      <content:encoded><![CDATA[<p><b>Linked List<small>(연결 리스트)</small></b>는 선형, 단방향 시퀀스로 배열된 값의 모음이다. linked list는 <em>Kotlin Array, ArrayList</em>와 같은 연속적인 저장소 옵션들<small>(contiguous storage options)</small>에 비해 몇 가지 이론적인 장점이 있다.</p><ol><li>리스트의 앞부분에서 <strong>상수 시간</strong> 삽입 및 제거 수행</li><li>안정적인 성능</li></ol><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/122393576-f87b7900-cfaf-11eb-9b60-ac29477387db.png'></p><p>다이어그램이 보여주듯, linked list는 노드들의 체인이다. 노드는 두 가지의 책임을 가지고 있다.</p><ol><li>값을 가지고 있어야한다.</li><li>다음 노드에 대한 참조를 가지고 있어야 한다. 다음 노드에 대한 참조가 없다면 <em>null</em>을 통해 리스트의 끝을 나타낸다.</li></ol><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/122393617-06c99500-cfb0-11eb-959a-18b6ea1d2fc8.png'></p><h2 id="node"><a class="markdownIt-Anchor" href="#node"></a> Node</h2><blockquote><p>Node.kt</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">var</span> value: T, <span class="keyword">var</span> next: Node&lt;T&gt;? = <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="string">&quot;<span class="variable">$value</span> -&gt; <span class="subst">$&#123;next.toString()&#125;</span>&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="string">&quot;<span class="variable">$value</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 노드 생성 및 연결하기</span></span><br><span class="line">    <span class="keyword">val</span> node1 = Node(value = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> node2 = Node(value = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> node3 = Node(value = <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    node1.next = node2</span><br><span class="line">    node2.next = node3</span><br><span class="line">    </span><br><span class="line">    println(node1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure><p>이런 방법으로 리스트를 작성하는 것은 실용적이지 못하다. 이러한 문제를 해결시켜주는 일반적인 방법은 Node 객체들을 관리하는 <strong>LinkedList</strong>를 사용하는 것이다.</p><h2 id="linkedlist"><a class="markdownIt-Anchor" href="#linkedlist"></a> LinkedList</h2><blockquote><p>LinkedList.kt</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> head: Node&lt;T&gt;? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> tail: Node&lt;T&gt;? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> size = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="string">&quot;Empty list&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.toString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linked list에는 첫 번째와 마지막 노드를 각각 참조하는 <strong>head</strong>와 <strong>tail</strong>의 개념이 있다.</p><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/122397634-1c40be00-cfb4-11eb-8ed1-2db54feb2e5f.png'></p><p>또한 <em>size</em> 속성<small>(property)</small>에서 linked list의 크기를 추적할 수 있다.</p><h2 id="리스트에-값들을-추가하기"><a class="markdownIt-Anchor" href="#리스트에-값들을-추가하기"></a> 리스트에 값들을 추가하기</h2><p>다음으로, Node 객체를 관리하기 위한 인터페이스를 작성한다. 먼저 값 추가를 처리한다. Linked list에 값을 추가하는 방법에는 세 가지가 있으며, 각각 고유한 성능 특징을 지니고 있다.</p><ol><li><strong>push</strong> : 리스트의 맨 앞에 값을 추가</li><li><strong>append</strong> : 리스트의 끝에 값을 추가</li><li><strong>insert</strong> : 리스트의 특정 노드 뒤에 값을 추가</li></ol><p>이들 각각을 차례로 구현하고 성능 특징을 분석해본다.</p><h3 id="push-연산"><a class="markdownIt-Anchor" href="#push-연산"></a> push 연산</h3><p>리스트의 맨 앞에 값을 추가하는 것은 <strong>push</strong> 연산으로 알려져 있다. 또한 <strong>head-first insertion</strong>이라고도 한다. push 연산의 코드는 매우 간단하다.</p><blockquote><p><code>push(…)</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    head = Node(value = value, next = head)</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">null</span>) &#123;</span><br><span class="line">        tail = head</span><br><span class="line">    &#125;</span><br><span class="line">    size += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>빈 리스트에 값을 push할 경우, 새로운 노드는 리스트의 head와 tail이 된다. 리스트에 새로운 노드가 추가되었기 때문에 <em>size</em>의 값도 증가시켜준다.</p><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// push 예시</span></span><br><span class="line">    <span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    println(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure><p>이대로도 괜찮지만 더욱 멋지게 개선할 수 있다. <b><a href="https://ko.wikipedia.org/wiki/%ED%94%8C%EB%A3%A8%EC%96%B8%ED%8A%B8_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">Fluent interface</a></b> 패턴을 사용하여 여러 push 호출을 연결할 수 있다. <code>push()</code>로 돌아가서 <code>LinkedList&lt;T&gt;</code>를 반환 타입으로 추가한다. 그런 다음 마지막 줄에 <code>return this</code>를 추가하여 방금 요소를 push한 목록을 반환한다.</p><blockquote><p>Fluent interface pattern <code>push(…)</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(value: <span class="type">T</span>)</span></span>: LinkedList&lt;T&gt; &#123;</span><br><span class="line">    head = Node(value = value, next = head)</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">null</span>) &#123;</span><br><span class="line">        tail = head</span><br><span class="line">    &#125;</span><br><span class="line">    size += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// fluent interface push 예시</span></span><br><span class="line">    <span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>).push(<span class="number">2</span>).push(<span class="number">1</span>)</span><br><span class="line">    println(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fluent interface 패턴을 통해 복수의 요소들을 리스트의 시작 부분에 쉽게 추가할 수 있게 되었다.</p><h3 id="append-연산"><a class="markdownIt-Anchor" href="#append-연산"></a> append 연산</h3><p>append 연산은 리스트의 끝에 값을 추가하며, <strong>tail-end insertion</strong>이라고도 한다.</p><blockquote><p><code>append(…)</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">append</span><span class="params">(value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ➀</span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        push(value)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ➁</span></span><br><span class="line">    tail?.next = Node(value = value)</span><br><span class="line">    <span class="comment">// ➂</span></span><br><span class="line">    tail = tail?.next</span><br><span class="line">    size += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>이전과 마찬가지로 리스트가 비어있으면 head와 tail을 모두 새 노드로 업데이트해야한다. 빈 리스트에 추가하는 것은 기능적으로 <em>push</em>와 동일하므로 <em>push</em>를 호출하여 작업을 수행한다.</li><li>다른 모든 경우에는 현재 tail 노드 뒤에 새 노드를 만든다. if 문에서 리스트가 비어있는 경우<small>(<code>isEmpty()</code>)</small>를 이미 처리 했으므로 tail은 여기서 null이 되지 않는다.</li><li><strong>tail-end insertion</strong>이므로 새 노드도 리스트의 tail이 된다.</li></ol><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    list.append(<span class="number">1</span>)</span><br><span class="line">    list.append(<span class="number">2</span>)</span><br><span class="line">    list.append(<span class="number">3</span>)</span><br><span class="line">    println(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>append도 물론 Fluent interface 패턴을 적용시킬 수 있다!</p><blockquote><blockquote><p>Fluent interface pattern <code>append(…)</code> (<em>LinkedList.kt</em>)</p></blockquote></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">append</span><span class="params">(value: <span class="type">T</span>)</span></span>: LinkedList&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        push(value)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    tail?.next = Node(value = value)</span><br><span class="line">    tail = tail?.next</span><br><span class="line">    size += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="insert-연산"><a class="markdownIt-Anchor" href="#insert-연산"></a> insert 연산</h3><p><strong>insert</strong> 연산은 리스트의 지정된 위치에 값을 삽입하며 두 단계가 필요하다.</p><ol><li>리스트에서 지정된 노드를 찾는다.</li><li>지정된 노드의 뒤에 새로운 노드를 삽입한다.</li></ol><p>먼저 값을 삽일할 노드를 찾는 코드를 구현하자.</p><blockquote><p><code>nodeAt(…)</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">nodeAt</span><span class="params">(index: <span class="type">Int</span>)</span></span>: Node&lt;T&gt;? &#123;</span><br><span class="line">    <span class="comment">// ➀</span></span><br><span class="line">    <span class="keyword">var</span> currentNode = head</span><br><span class="line">    <span class="keyword">var</span> currentIndex = <span class="number">0</span></span><br><span class="line">    <span class="comment">// ➁</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="literal">null</span> &amp;&amp; currentIndex &lt; index) &#123;</span><br><span class="line">        currentNode = currentNode.next</span><br><span class="line">        currentIndex += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nodeAt()</code>은 주어진 인덱스를 기반으로 리스트에서 노드 검색을 시도한다. head 노드에서만 리스트의 노드에 접근할 수 있으므로 반복 순회<small>(iterative traversals)</small>를 수행해야 한다.</p><ol><li>head에 대한 새 참조를 만들고 현재 순회 수를 추적한다.</li><li>while 루프를 사용하여 원하는 인덱스에 도달할 때까지 리스트 참조를 다음으로 이동시킨다. 빈 리스트 또는 범위를 벗어난 인덱스는 null을 반환한다.</li></ol><p>이제 새로운 노드를 삽입해보자.</p><blockquote><p><code>insert(…)</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(value: <span class="type">T</span>, afterNode: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;)</span></span>: Node&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">if</span> (tail == afterNode) &#123;</span><br><span class="line">        append(value)</span><br><span class="line">        <span class="keyword">return</span> tail!!</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">val</span> newNode = Node(value = value, next = afterNode.next)</span><br><span class="line">    <span class="comment">// ③</span></span><br><span class="line">    afterNode.next = newNode</span><br><span class="line">    size += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> newNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>수행한 작업은 다음과 같다.</p><ol><li>이 메서드가 tail 노드와 함께 호출되는 경우, 기능적으로 동일한 <em>append</em> 메서드를 호출할 수 있다. 이것은 tail의 업데이트를 처리한다.</li><li>그렇지 않으면, 새 노드를 만들고 <em>next</em> 속성을 리스트의 다음 노드에 연결한다.</li><li>지정된 노드의 <em>next</em> 값을 다시 할당하여 방금 만든 새 노드에 연결한다.</li></ol><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    println(<span class="string">&quot;Before inserting: <span class="variable">$list</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> middleNode = list.nodeAt(<span class="number">1</span>)!!</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        middleNode = list.insert(-<span class="number">1</span> * i, middleNode)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;After inserting: <span class="variable">$list</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before inserting: 1 -&gt; 2 -&gt; 3</span><br><span class="line">After inserting: 1 -&gt; 2 -&gt; -1 -&gt; -2 -&gt; -3 -&gt; 3</span><br></pre></td></tr></table></figure><h3 id="성능-분석"><a class="markdownIt-Anchor" href="#성능-분석"></a> 성능 분석</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">push</th><th style="text-align:center">append</th><th style="text-align:center">insert</th><th style="text-align:center">nodeAt</th></tr></thead><tbody><tr><td style="text-align:center">행동</td><td style="text-align:center">head에 삽입</td><td style="text-align:center">tail에 삽입</td><td style="text-align:center">노드 뒤에 삽입</td><td style="text-align:center">주어진 인덱스의 노드를 반환</td></tr><tr><td style="text-align:center">시간 복잡도</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(i), i는 주어진 인덱스</td></tr></tbody></table><h2 id="리스트에서-값들을-제거하기"><a class="markdownIt-Anchor" href="#리스트에서-값들을-제거하기"></a> 리스트에서 값들을 제거하기</h2><p>노드의 제거에는 3가지 대표적인 연산들이 있다.</p><ol><li><strong>pop</strong> : 리스트 앞부분의 값을 제거</li><li><strong>removeLast</strong> : 리스트 끝에 있는 값을 제거</li><li><strong>removeAfter</strong> : 리스트의 어느 곳의 값이든 제거</li></ol><h3 id="pop-연산"><a class="markdownIt-Anchor" href="#pop-연산"></a> pop 연산</h3><blockquote><p><code>pop()</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty()) size -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> result = head?.value</span><br><span class="line">    head = head?.next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) tail = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pop()</code>은 리스트에서 제거된 값을 반환한다. 리스트가 비어있을 수 있으므로 이 값은</p><p>head를 다음 노드로 이동시켜 리스트의 첫 번째 노드를 효과적으로 제거할 수 있다. 더 이상 연결된 참조가 없기 때문에 가비지 컬렉터는 메서드가 완료되면 메모리에서 이전 노드를 제거한다. 리스트가 비어 있으면 tail도 null로 설정한다.</p><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    println(<span class="string">&quot;Before popping list: <span class="variable">$list</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> poppedValue = list.pop()</span><br><span class="line">    println(<span class="string">&quot;After popping list: <span class="variable">$list</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Popped value: <span class="variable">$poppedValue</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before popping list: 1 -&gt; 2 -&gt; 3</span><br><span class="line">After popping list: 2 -&gt; 3</span><br><span class="line">Popped value: 1</span><br></pre></td></tr></table></figure><h3 id="removelast-연산"><a class="markdownIt-Anchor" href="#removelast-연산"></a> removeLast 연산</h3><p>리스트의 마지막 노드를 제거하는 것은 다소 번거로운 작업이다.</p><p>tail 노드에 대한 참조가 있더라도 그 앞에 노드에 대한 참조가 없으면 잘라낼 수 없다. 따라서 마지막 노드 이전의 노드를 찾으려면 전체 리스트를 탐색해야한다.</p><blockquote><p><code>removeLast()</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeLast</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">val</span> head = head ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span> pop()</span><br><span class="line">    <span class="comment">// ③</span></span><br><span class="line">    size -= <span class="number">1</span></span><br><span class="line">    <span class="comment">// ④</span></span><br><span class="line">    <span class="keyword">var</span> prev = head</span><br><span class="line">    <span class="keyword">var</span> current = head</span><br><span class="line">    <span class="keyword">var</span> next = current.next</span><br><span class="line">    <span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">        prev = current</span><br><span class="line">        current = next</span><br><span class="line">        next = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⑤</span></span><br><span class="line">    prev.next = <span class="literal">null</span></span><br><span class="line">    tail = prev</span><br><span class="line">    <span class="keyword">return</span> current.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>head가 null이면 제거할 항목이 없으므로 null을 반환한다.</li><li>목록이 하나의 노드로만 구성된 경우 <em>removeLast</em>는 기능적으로 <em>pop</em>과 동일하다. <em>pop</em>은 head 및 tail의 참조를 업데이트하는 것을 처리하므로 이 작업을 <em>pop</em> 함수에 위임할 수 있다.</li><li>이 시점에서 노드를 제거 할 것임을 알고 있으므로 그에 따라 목록의 크기를 업데이트한다.</li><li>current.next가 null이 될 때까지 다음 노드를 계속 검색한다. 이것은 current가 목록의 마지막 노드임을 나타낸다.</li><li>current가 마지막 노드이므로 prev.next 참조를 사용하여 연결을 끊는다. tail의 참조도 업데이트해야 한다.</li></ol><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    println(<span class="string">&quot;Before removing last node: <span class="variable">$list</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> removedValue = list.removeLast()</span><br><span class="line">    println(<span class="string">&quot;After removing last node: <span class="variable">$list</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Removed value: <span class="variable">$removedValue</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before removing last node: 1 -&gt; 2 -&gt; 3</span><br><span class="line">After removing last node: 1 -&gt; 2</span><br><span class="line">Removed value: 3</span><br></pre></td></tr></table></figure><p><code>removeLast()</code>를 사용하려면 리스트를 순회해야 한다. 이것은 비교적 비용이 많이 드는 <em>O(n)</em> 연산을 하게 된다.</p><h3 id="remove-연산"><a class="markdownIt-Anchor" href="#remove-연산"></a> remove 연산</h3><p>remove 연산은 리스트의 특정 지점에서 노드를 제거하는 것이다. 이것은 <code>insert()</code>와 매우 유사하다. 먼저 제거하려는 노드의 바로 앞 노드를 찾은 다음 연결을 해제<small>(unlink)</small>해야 한다.</p><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/122572442-b40fdc00-d088-11eb-9132-9ac1d7a295f0.png'></p><blockquote><p><code>removeAfter()</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeAfter</span><span class="params">(node: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;)</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">val</span> result = node.next?.value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.next == tail) tail = node</span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>) size -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    node.next = node.next?.next</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tail 참조를 업데이트해야 하므로 제거된 노드가 tail 노드인 경우 특별한 주의가 필요하다.</p><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before removing at particular index: <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br><span class="line">After removing at index <span class="number">1</span>: <span class="number">1</span> -&gt; <span class="number">3</span></span><br><span class="line">Removed value: <span class="number">2</span></span><br></pre></td></tr></table></figure><p><code>insert()</code>와 유사하게 이 작업의 시간 복잡도는 *O(1)*이지만 미리 특정 노드에 대한 참조가 있어야 한다.</p><h3 id="성능-분석-2"><a class="markdownIt-Anchor" href="#성능-분석-2"></a> 성능 분석</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">pop</th><th style="text-align:center">removeLast</th><th style="text-align:center">removeAfter</th></tr></thead><tbody><tr><td style="text-align:center">행동</td><td style="text-align:center">head를 제거</td><td style="text-align:center">tail을 제거</td><td style="text-align:center">바로 다음 노드를 제거</td></tr><tr><td style="text-align:center">시간 복잡도</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td></tr></tbody></table><p>지금까지 대부분의 프로그래머가 공감할 수 있는 linked list에 대한 인터페이스를 정의했다. 하지만 Kotlin semantic을 더욱 돋보이게 하려면 수행해야 할 작업이 존재한다. 본문의 다음 절반에서는 Kotlin의 관용적<small>(idomatic)</small>인 부분을 활용하여 더 나은 인터페이스를 만드는데 초점을 맞출 것이다.</p><h2 id="kotlin-collection-interfaces"><a class="markdownIt-Anchor" href="#kotlin-collection-interfaces"></a> Kotlin collection interfaces</h2><p>Kotlin 표준 라이브러리에는 특정 유형에 대해 예상되는 사항을 정의하는데 도움이 되는 인터페이스 모음이 있다. 이러한 각 인터페이스는 특성과 성능에 대한 특정한 보증을 제공한다. 이러한 인터페이스 모음 중 4개를 컬렉션 인터페이스라고 한다.</p><p>다음은 각 인터페이스가 나타내는 작은 예시들이다.</p><ol><li>Iterable : iterable 타입은 <em>Iterator</em>를 통해 요소들에 대한 순차적 접근을 제공한다.</li><li>Collection : 컬렉션 타입은 추가 기능을 제공하는 iterable 타입으로, 컬렉션이 특정 요소 또는 요소들의 컬렉션을 포함하고 있는지 확인할 수 있게 해준다.</li><li>MutableIterable : 주어진 컬렉션에서 항목들을 제거할 수 있는 MutableIterator를 제공한다.</li><li>MutableCollection : 단순 컬렉션과 달리, MutableCollection 인터페이스는 컬렉션을 변경하는 메서드를 제공한다. 예를 들어, 요소를 <em>추가</em> 및 <em>제거</em>할 수 있으며 전체 <em>컬렉션을 지울 수도</em> 있다.</li></ol><p>Linked list는 컬렉션 인터페이스의 계층 4에 도달 할 수 있습니다. Linked list는 연결된 노드들이므로<small>(chain of nodes)</small> Iterable 인터페이스를 채택하는 것이 합리적이다. 이미 요소 추가 및 제거를 구현 했으므로 MutableCollection 인터페이스로 이동할 수 있다는 것이 매우 분명하다.</p><br><div style="text-align: right"> <a href="https://www.raywenderlich.com/books/data-structures-algorithms-in-kotlin/v1.0"><b><i>Data Structures & Algorithms in Kotlin</i></b></a> 서적을 참고하여 작성했습니다. </div>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Data-Structure/">Data Structure</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Data-Structure/">Data Structure</category>
      
      <category domain="http://june0122.github.io/tags/Linked-List/">Linked List</category>
      
      
      <comments>http://june0122.github.io/2021/06/27/data-structure-linked-list/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 레벨 2 : 카펫</title>
      <link>http://june0122.github.io/2021/06/26/programmers-42842/</link>
      <guid>http://june0122.github.io/2021/06/26/programmers-42842/</guid>
      <pubDate>Sat, 26 Jun 2021 11:28:54 GMT</pubDate>
      
      <description>[코딩테스트 고득점 Kit - 완전탐색] 레벨 2</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/42842">문제 보기</a></h3><p><code>완전탐색</code></p><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>첫 시도</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(brown: <span class="type">Int</span>, yellow: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> total = brown + yellow</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3</span> .. (total / <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">3</span> .. (total / <span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= j &amp;&amp; i * j == total &amp;&amp; checkBrown(i to j, brown)) <span class="keyword">return</span> intArrayOf(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> intArrayOf()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">checkBrown</span><span class="params">(pair: <span class="type">Pair</span>&lt;<span class="type">Int</span>, <span class="built_in">Int</span>&gt;, brown: <span class="type">Int</span>)</span></span> = (pair.first * <span class="number">2</span>) + (pair.second * <span class="number">2</span>) - <span class="number">4</span> == brown</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>(가로 * 2) + (세로 * 2) - 4 = brown</code></p><p>테두리의 갈색 격자의 개수는 가로와 세로를 각각 2를 곱해주고 모서리 부분에서 중복되는 4만큼을 빼서 구할 수 있는 것을 이용하였다.</p><p>이렇게 하면 간단하게 구현할 수 있지만 시간 복잡도적인 측면에서 효율적이진 못한 코드라 개선이 필요해보인다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">테스트 <span class="number">1</span> 〉통과 (<span class="number">0.</span>71ms, <span class="number">54.</span>8MB)</span><br><span class="line">테스트 <span class="number">2</span> 〉통과 (<span class="number">1.</span>04ms, <span class="number">55.</span>1MB)</span><br><span class="line">테스트 <span class="number">3</span> 〉통과 (<span class="number">229.</span>05ms, <span class="number">54.</span>4MB)</span><br><span class="line">테스트 <span class="number">4</span> 〉통과 (<span class="number">30.</span>27ms, <span class="number">55.</span>2MB)</span><br><span class="line">테스트 <span class="number">5</span> 〉통과 (<span class="number">28.</span>67ms, <span class="number">54.</span>5MB)</span><br><span class="line">테스트 <span class="number">6</span> 〉통과 (<span class="number">152.</span>95ms, <span class="number">54.</span>7MB)</span><br><span class="line">테스트 <span class="number">7</span> 〉통과 (<span class="number">688.</span>13ms, <span class="number">54.</span>2MB)</span><br><span class="line">테스트 <span class="number">8</span> 〉통과 (<span class="number">239.</span>40ms, <span class="number">54.</span>4MB)</span><br><span class="line">테스트 <span class="number">9</span> 〉통과 (<span class="number">379.</span>53ms, 55MB)</span><br><span class="line">테스트 <span class="number">10</span> 〉통과 (<span class="number">400.</span>44ms, <span class="number">55.</span>5MB)</span><br><span class="line">테스트 <span class="number">11</span> 〉통과 (<span class="number">0.</span>65ms, <span class="number">55.</span>4MB)</span><br><span class="line">테스트 <span class="number">12</span> 〉통과 (<span class="number">0.</span>66ms, <span class="number">55.</span>8MB)</span><br><span class="line">테스트 <span class="number">13</span> 〉통과 (<span class="number">1.</span>30ms, 55MB)</span><br></pre></td></tr></table></figure><blockquote><p>근의 공식 활용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(brown: <span class="type">Int</span>, yellow: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> D = ((brown + <span class="number">4</span>) / <span class="number">2</span>).toDouble().pow(<span class="number">2.0</span>) - <span class="number">4</span> * (brown + yellow)</span><br><span class="line">        <span class="keyword">val</span> width = ((brown + <span class="number">4</span>) / <span class="number">2</span> + sqrt(D)) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">val</span> height = ((brown + <span class="number">4</span>) / <span class="number">2</span> - sqrt(D)) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> intArrayOf(width.toInt(), height.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>먼저 문제의 지문에서 아래 두 개의 식을 구할 수 있다.</li></ol><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/123511666-9a404b80-d6bd-11eb-99c8-20393430d471.png'></p><ol start="2"><li>그 다음 계산의 편의성을 위해 아래와 같이 <code>A</code>와 <code>B</code>로 치환시킨다.</li></ol><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/123511670-a0cec300-d6bd-11eb-8ba7-03f931e5403b.png'></p><ol start="3"><li>치환한 값을 대입시키면 아래와 같은 이차 방정식을 구할 수 있다.</li></ol><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/123511672-a75d3a80-d6bd-11eb-9968-1bd1a87322b9.png'></p><ol start="4"><li>근의 공식을 이용하면 가로와 세로의 크기를 구할 수 있다. 근의 공식은 다음과 같다.</li></ol><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/123511675-ad531b80-d6bd-11eb-835d-335a687c8714.png'></p><ol start="5"><li>가로가 세로보다 크거나 같으므로 가로인 <code>w</code>에 sqrt(D)를 더하고 세로인 <code>h</code>에서는 빼면 값을 구할 수 있다.</li></ol><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/123511680-b348fc80-d6bd-11eb-9c14-4cc2bb606850.png'></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">테스트 <span class="number">1</span> 〉통과 (<span class="number">0.</span>05ms, <span class="number">55.</span>3MB)</span><br><span class="line">테스트 <span class="number">2</span> 〉통과 (<span class="number">0.</span>04ms, <span class="number">55.</span>4MB)</span><br><span class="line">테스트 <span class="number">3</span> 〉통과 (<span class="number">0.</span>04ms, <span class="number">54.</span>6MB)</span><br><span class="line">테스트 <span class="number">4</span> 〉통과 (<span class="number">0.</span>05ms, 55MB)</span><br><span class="line">테스트 <span class="number">5</span> 〉통과 (<span class="number">0.</span>05ms, <span class="number">55.</span>1MB)</span><br><span class="line">테스트 <span class="number">6</span> 〉통과 (<span class="number">0.</span>07ms, <span class="number">54.</span>9MB)</span><br><span class="line">테스트 <span class="number">7</span> 〉통과 (<span class="number">0.</span>06ms, <span class="number">54.</span>6MB)</span><br><span class="line">테스트 <span class="number">8</span> 〉통과 (<span class="number">0.</span>04ms, <span class="number">54.</span>8MB)</span><br><span class="line">테스트 <span class="number">9</span> 〉통과 (<span class="number">0.</span>06ms, <span class="number">54.</span>6MB)</span><br><span class="line">테스트 <span class="number">10</span> 〉통과 (<span class="number">0.</span>05ms, <span class="number">55.</span>3MB)</span><br><span class="line">테스트 <span class="number">11</span> 〉통과 (<span class="number">0.</span>04ms, <span class="number">54.</span>7MB)</span><br><span class="line">테스트 <span class="number">12</span> 〉통과 (<span class="number">0.</span>05ms, 55MB)</span><br><span class="line">테스트 <span class="number">13</span> 〉통과 (<span class="number">0.</span>04ms, <span class="number">54.</span>5MB)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Programmers/">Programmers</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Programmers/">Programmers</category>
      
      <category domain="http://june0122.github.io/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/">완전탐색</category>
      
      
      <comments>http://june0122.github.io/2021/06/26/programmers-42842/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 레벨 2 : H-Index</title>
      <link>http://june0122.github.io/2021/06/25/programmers-42747/</link>
      <guid>http://june0122.github.io/2021/06/25/programmers-42747/</guid>
      <pubDate>Fri, 25 Jun 2021 04:46:25 GMT</pubDate>
      
      <description>[코딩테스트 고득점 Kit - 정렬] 레벨 2</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/42747">문제 보기</a></h3><p><code>정렬</code></p><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>나의 풀이</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(citations: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> h = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> citedList = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> uncitedList = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">        citations.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &lt;= citations.size) &#123;</span><br><span class="line">            citations.forEach &#123;</span><br><span class="line">                <span class="keyword">if</span> (it &gt;= count) citedList.add(it)</span><br><span class="line">                <span class="keyword">else</span> uncitedList.add(it)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (citedList.size &gt;= count &amp;&amp; uncitedList.size &lt;= count) h = count</span><br><span class="line">            &#125;</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            citedList.clear()</span><br><span class="line">            uncitedList.clear()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>다른 사람의 풀이</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.min</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(citations: <span class="type">IntArray</span>)</span></span> = citations.sortedDescending().mapIndexed &#123; idx, item -&gt; min(idx + <span class="number">1</span>, item) &#125;.max()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Programmers/">Programmers</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Programmers/">Programmers</category>
      
      <category domain="http://june0122.github.io/tags/%EC%A0%95%EB%A0%AC/">정렬</category>
      
      
      <comments>http://june0122.github.io/2021/06/25/programmers-42747/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 레벨 2 : 튜플</title>
      <link>http://june0122.github.io/2021/06/25/programmers-64065/</link>
      <guid>http://june0122.github.io/2021/06/25/programmers-64065/</guid>
      <pubDate>Fri, 25 Jun 2021 04:39:51 GMT</pubDate>
      
      <description>[2019 카카오 개발자 겨울 인턴십] 레벨 2</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/64065">문제 보기</a></h3><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>나의 풀이</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(s: <span class="type">String</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">set</span> = mutableSetOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> elements = s.replace(<span class="string">&quot;&#123;&#123;&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#125;&#125;&quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;&#125;,&#123;&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> arr = elements.map &#123; it.split(<span class="string">&quot;,&quot;</span>) &#125;.sortedBy &#123; it.size &#125;</span><br><span class="line"></span><br><span class="line">        arr.forEach &#123;</span><br><span class="line">            it.forEach &#123; </span><br><span class="line">                <span class="keyword">set</span>.add(it.toInt())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">set</span>.toIntArray()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>fold(…)</code> 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(s: <span class="type">String</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">return</span> s.split(<span class="string">&quot;&#125;,&#123;&quot;</span>)</span><br><span class="line">            .map &#123; it.replace(<span class="string">&quot;[^0-9,]&quot;</span>.toRegex(), <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;,&quot;</span>).map &#123; it.toInt() &#125; &#125;</span><br><span class="line">            .sortedBy &#123; it.size &#125;</span><br><span class="line">            .fold(setOf&lt;<span class="built_in">Int</span>&gt;()) &#123; acc, list -&gt; acc.union(list) &#125;</span><br><span class="line">            .toIntArray()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Programmers/">Programmers</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Programmers/">Programmers</category>
      
      <category domain="http://june0122.github.io/tags/%EC%A0%95%EB%A0%AC/">정렬</category>
      
      
      <comments>http://june0122.github.io/2021/06/25/programmers-64065/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 2. Add Two Numbers</title>
      <link>http://june0122.github.io/2021/06/15/leetcode-2/</link>
      <guid>http://june0122.github.io/2021/06/15/leetcode-2/</guid>
      <pubDate>Tue, 15 Jun 2021 04:59:28 GMT</pubDate>
      
      <description>2. Add Two Numbers</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="leetcode-2-add-two-numbers"><a class="markdownIt-Anchor" href="#leetcode-2-add-two-numbers"></a> <a href="https://leetcode.com/problems/add-two-numbers/">[LeetCode] 2. Add Two Numbers</a></h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h3><blockquote><h3 id="자리올림smallcarrysmall-이용"><a class="markdownIt-Anchor" href="#자리올림smallcarrysmall-이용"></a> 자리올림<small>(carry)</small> 이용</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> ListNode.<span class="title">value</span><span class="params">()</span></span> = <span class="keyword">this</span>?.`<span class="keyword">val</span>` ?: <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addTwoNumbers</span><span class="params">(l1: <span class="type">ListNode</span>?, l2: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">var</span> (list1, list2) = l1 to l2</span><br><span class="line">        <span class="keyword">var</span> head = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> cur = head</span><br><span class="line">        <span class="keyword">var</span> carry = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> || list2 != <span class="literal">null</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> x = list1?.value() ?: <span class="number">0</span></span><br><span class="line">            <span class="keyword">val</span> y = list2?.value() ?: <span class="number">0</span></span><br><span class="line">            <span class="keyword">val</span> sum = (x + y + carry) % <span class="number">10</span></span><br><span class="line">            carry = (x + y + carry) / <span class="number">10</span></span><br><span class="line">            cur?.next = ListNode(sum)</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> (list1 != <span class="literal">null</span>) list1 = list1.next</span><br><span class="line">            <span class="keyword">if</span> (list2 != <span class="literal">null</span>) list2 = list2.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime: 240 ms, faster than 18.40% of Kotlin online submissions for Add Two Numbers.</span><br><span class="line">Memory Usage: 43.6 MB, less than 11.74% of Kotlin online submissions for Add Two Numbers.</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://june0122.github.io/2021/06/15/leetcode-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 1. Two Sum</title>
      <link>http://june0122.github.io/2021/06/13/leetcode-1/</link>
      <guid>http://june0122.github.io/2021/06/13/leetcode-1/</guid>
      <pubDate>Sun, 13 Jun 2021 11:49:45 GMT</pubDate>
      
      <description>1. Two Sum</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="leetcode-1-two-sum"><a class="markdownIt-Anchor" href="#leetcode-1-two-sum"></a> <a href="https://leetcode.com/problems/two-sum/">[LeetCode] 1. Two Sum</a></h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h3><blockquote><h3 id="brute-force"><a class="markdownIt-Anchor" href="#brute-force"></a> Brute Force</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">twoSum</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">var</span> twoNum = <span class="number">0</span> to <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until nums.size) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) twoNum = i to j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> intArrayOf(twoNum.first, twoNum.second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">232 ms36.5 MB</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">twoSum</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until nums.size) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) <span class="keyword">return</span> intArrayOf(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;No two sum solution&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">236 ms36.8 MB</span><br></pre></td></tr></table></figure><h4 id="시간-복잡도-onsup2sup"><a class="markdownIt-Anchor" href="#시간-복잡도-onsup2sup"></a> 시간 복잡도 : O(n<sup>2</sup>)</h4><h4 id="공간-복잡도-o1"><a class="markdownIt-Anchor" href="#공간-복잡도-o1"></a> 공간 복잡도 : O(1)</h4><blockquote><h3 id="two-pass-hash-table"><a class="markdownIt-Anchor" href="#two-pass-hash-table"></a> Two-pass Hash Table</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">twoSum</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> hashmap = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">        </span><br><span class="line">        nums.forEachIndexed &#123; index, value -&gt;</span><br><span class="line">            hashmap[value] = index</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        nums.forEachIndexed &#123; index, value -&gt;</span><br><span class="line">            <span class="keyword">val</span> complement = target - value</span><br><span class="line">            <span class="keyword">if</span> (hashmap.containsKey(complement) &amp;&amp; hashmap.getValue(complement) != index) &#123;</span><br><span class="line">                <span class="keyword">return</span> intArrayOf(index, hashmap.getValue(complement))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;No two sum solution&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">204 ms37.4 MB</span><br></pre></td></tr></table></figure><h4 id="시간-복잡도-on"><a class="markdownIt-Anchor" href="#시간-복잡도-on"></a> 시간 복잡도 : O(n)</h4><p>n개의 요소들을 가지고 있는 리스트를 2번 순회하지만, HashMap을 사용하여 look up time을 O(1)으로 줄였기 때문에 결과적으론 O(n)이다.</p><h4 id="공간-복잡도-on"><a class="markdownIt-Anchor" href="#공간-복잡도-on"></a> 공간 복잡도 : O(n)</h4><p>HashMap 사용으로 n개의 요소들을 저장하기 때문에 추가적인 공간이 필요하다.</p><blockquote><h3 id="one-pass-hash-table"><a class="markdownIt-Anchor" href="#one-pass-hash-table"></a> One-pass Hash Table</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">twoSum</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> hashmap = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">        </span><br><span class="line">        nums.forEachIndexed &#123; index, value -&gt;</span><br><span class="line">            <span class="keyword">val</span> complement = target - value</span><br><span class="line">            <span class="keyword">if</span> (hashmap.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> intArrayOf(hashmap.getValue(complement), index)</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap[value] = index</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;No two sum solution&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">188 ms37.9 MB</span><br></pre></td></tr></table></figure><h4 id="시간-복잡도-on-2"><a class="markdownIt-Anchor" href="#시간-복잡도-on-2"></a> 시간 복잡도 : O(n)</h4><p>n개의 원소들을 가진 리스트를 딱 한 번만 순회하고, HashMap에서의 look up time은 오직 O(1)만 소모하므로 시간 복잡도는 O(n)이다.</p><h4 id="공간-복잡도-on-2"><a class="markdownIt-Anchor" href="#공간-복잡도-on-2"></a> 공간 복잡도 : O(n)</h4><p>Two-pass Hash Table 방법과 마찬가지로 HashMap 사용으로 n개의 요소들을 저장하기 때문에 추가적인 공간이 필요하다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://june0122.github.io/2021/06/13/leetcode-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 232. Implement Queue using Stacks</title>
      <link>http://june0122.github.io/2021/06/12/leetcode-232/</link>
      <guid>http://june0122.github.io/2021/06/12/leetcode-232/</guid>
      <pubDate>Sat, 12 Jun 2021 00:33:36 GMT</pubDate>
      
      <description>232. Implement Queue using Stacks</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="leetcode-232-implement-queue-using-stacks"><a class="markdownIt-Anchor" href="#leetcode-232-implement-queue-using-stacks"></a> <a href="https://leetcode.com/problems/implement-queue-using-stacks/">[LeetCode] 232. Implement Queue using Stacks</a></h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">val</span> input = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> output = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        input.push(x)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        peek()</span><br><span class="line">        <span class="keyword">return</span> output.pop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (output.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(input.isNotEmpty()) &#123;</span><br><span class="line">                output.push(input.pop())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output.peek()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">empty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> input.isEmpty() &amp;&amp; output.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime: 168 ms, faster than 26.03% of Kotlin online submissions for Implement Queue using Stacks.</span><br><span class="line">Memory Usage: 35.4 MB, less than 100.00% of Kotlin online submissions for Implement Queue using Stacks.</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://june0122.github.io/2021/06/12/leetcode-232/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
