<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>카미유 테크 블로그</title>
    <link>http://june0122.github.io/</link>
    
    <atom:link href="http://june0122.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 04 Aug 2021 23:19:57 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[프로그래밍 용어] 멱등성(idempotent)이란?</title>
      <link>http://june0122.github.io/2021/08/05/term-idempotent/</link>
      <guid>http://june0122.github.io/2021/08/05/term-idempotent/</guid>
      <pubDate>Wed, 04 Aug 2021 22:19:57 GMT</pubDate>
      
      <description>멱등성&lt;small&gt;(idempotent)&lt;/small&gt;에 대한 개념</description>
      
      
      
      <content:encoded><![CDATA[<p>전산학이나 수학에서 사용하는 용어로 <b>연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질</b>, <b>연산을 여러 번 반복하여도 한 번만 수행된 것과 같은 성질</b>을 의미한다. 함수 <code>f(x)</code>를 예를 들면 다음과 같은 등식이 성립된다. 즉 메서드가 여러 번 실행되어도, 결과는 같으므로 <b>안전하게 사용</b>할 수 있는 성질이기도 하다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(f(x)) = f(x)</span><br></pre></td></tr></table></figure><p>등식으로만 처음 보면 감이 오지 않을 수 있는데 절대값을 구하기 위해 사용하는 <code>abs()</code> 함수가 바로 멱등성을 가지고 있다. 모든 <code>x</code>에 대해 <code>abs(abs(x)) = abs(x)</code>이기 대문이다.</p><p>수학적 정의에서 <code>x</code>가 객체의 상태를 나타내고, <code>f</code>가 해당 객체를 변경할 수 있는 연산이라는 점을 고려해보자. 예를 들어, <a href="https://docs.python.org/2/library/stdtypes.html#set">파이썬의 set</a>이 있고, 이것의 <code>discard</code> 메서드는 set에서 요소를 제거하고, 요소가 존재하지 않으면 아무 작업도 수행하지 않는다. 그러므로</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_set.discard(x)</span><br></pre></td></tr></table></figure><p>는 동일한 작업을 두 번 수행하는 것과 정확히 동일한 효과가 있다. <small>(참고로 <code>array.pop()</code>은 멱등적이지 않다)</small></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_set.discard(x)</span><br><span class="line">my_set.discard(x)</span><br></pre></td></tr></table></figure><p>멱등 연산은 작업 수행 요청이 최소 한 번 발생하도록 보장되지만 두 번 이상 발생할 수도 있는 <b>네트워크 프로토콜 설계에 자주 사용</b>된다. 작업이 멱등적이면 작업을 두 번 이상 수행해도 결과는 한 번만 수행된 것과 동일하기 때문에 문제가 없기 때문이다.</p><p>멱등은 <b>RESTful</b> 웹 서비스의 맥락에서 많이 언급된다. REST는 HTTP를 최대한 활용하여 프로그램에 웹 콘텐츠에 대한 액세스 권한을 부여하고, 일반적으로 HTTP 요청 및 응답 내에서 원격 프로시저 호출 스타일 서비스를 터널링하는 SOAP 기반 웹 서비스와 대조적으로 설정된다.</p><p>REST는 웹 애플리케이션을 <b>리소스</b><small>(예: Twitter 사용자 또는 Flickr 이미지)</small>로 구성한 다음 <code>POST</code>, <code>PUT</code>, <code>GET</code> 및 <code>DELETE</code>의 HTTP 메서드를 사용하여 해당 리소스를 생성, 업데이트, 읽기 및 삭제한다. 이중 <code>POST</code>를 제외한 나머지 HTTP 메서드를 사용하는 API<small>(<code>GET</code>, <code>PUT</code>, <code>DELETE</code>)</small>들이 멱등성이 유지되어야 한다.</p><p>멱등성은 REST에서 중요한 역할을 한다. REST 리소스 표현을 <code>GET</code>하고<small>(예: Flickr에서 jpeg 이미지 가져오기)</small> 작업이 실패하면 작업이 성공할 때까지 <code>GET</code>을 계속해서 반복할 수 있다. 웹 서비스의 경우 이미지를 몇 번 가져왔는지는 중요하지 않다. 마찬가지로 RESTful 웹 서비스를 사용하여 Twitter 계정 정보를 업데이트하는 경우 웹 서비스에서 확인을 받기 위해 필요한 만큼 새 정보를 <code>PUT</code> 할 수 있다. 천 번 <code>PUT</code> 하는 것은 한 번 <code>PUT</code> 하는 것과 같다. 마찬가지로 REST 리소스를 천 번 <code>DELETE</code>하는 것은 한 번 <code>DELETE</code>하는 것과 같다. 따라서 멱등성을 사용하면 통신 오류에 탄력적인 웹 서비스를 훨씬 쉽게 구성할 수 있다.</p><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li>Stackoverflow : <a href="https://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation">What is an idempotent operation?</a></li><li>NHN Cloud Meetup! : <a href="https://meetup.toast.com/posts/218">지속 가능한 소프트웨어를 위한 코딩 방법</a></li><li>Wikipedia : <a href="https://en.wikipedia.org/wiki/Idempotence">Idempotence</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Terminology/">Terminology</category>
      
      
      <category domain="http://june0122.github.io/tags/Terminology/">Terminology</category>
      
      <category domain="http://june0122.github.io/tags/Idempotent/">Idempotent</category>
      
      <category domain="http://june0122.github.io/tags/RESTful/">RESTful</category>
      
      
      <comments>http://june0122.github.io/2021/08/05/term-idempotent/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래밍 용어] 리터럴(literal)과 상수(constant)란?</title>
      <link>http://june0122.github.io/2021/08/04/term-literal/</link>
      <guid>http://june0122.github.io/2021/08/04/term-literal/</guid>
      <pubDate>Tue, 03 Aug 2021 19:40:58 GMT</pubDate>
      
      <description>리터럴&lt;small&gt;(literal)&lt;/small&gt;과 상수&lt;small&gt;(constant)&lt;/small&gt;에 대한 개념 비교</description>
      
      
      
      <content:encoded><![CDATA[<p>코틀린에서 &quot;<a href="https://kotlinlang.org/docs/lambdas.html#lambda-expressions-and-anonymous-functions">람다 표현식과 익명 함수</a>는 <b>함수 리터럴<small>(function literals)</small></b>이다&quot;라는 설명을 보면서 리터럴이 정확히 무엇인지 정확히 이해하고 있지 않은 것 같아 개념을 글로 정리하게 되었다.</p><p>위키백과에서 리터럴<small>(literal)</small>은 소스 코드의 <b>고정된 값</b>을 표현하는 용어라 설명한다.</p><blockquote><p>In computer science, a literal is a notation for representing a fixed value in source code.</p></blockquote><p><code>고정된 값</code>이라는 표현 때문에 우리가 흔히 사용하던 상수<small>(constant)</small>의 개념과 혼란이 왔는데, 실제로 구글에 <i>literal vs constant</i>에 대한 검색 결과가 많이 존재하는 것을 보아 이 용어들이 헷갈리는 건 나뿐만이 아니었나 보다. 위키백과에서 상수에 대해선 실행 중에 프로그램에 의해 <b>변경되어선 안되는 값</b>이라 설명한다.</p><blockquote><p>In computer programming, a constant is a value that should not be altered by the program during normal execution.</p></blockquote><p>리터럴은 고정된 값, 상수는 변경되어선 안되는 값이라니 위키백과의 설명만 봐서는 이 용어들에 대해 감을 잡기가 어려웠기에 스택오버플로우의 답변을 살펴보았다.</p><h2 id="설명-1"><a class="markdownIt-Anchor" href="#설명-1"></a> 설명 1</h2><h3 id="리터럴"><a class="markdownIt-Anchor" href="#리터럴"></a> 리터럴</h3><ul><li><code>&quot;hey&quot;</code> (a string)</li><li><code>false</code> (a boolean)</li><li><code>3.14</code> (a real number)</li><li><code>[1,2,3]</code> (a list of numbers)</li><li><code>(x) =&gt; x*x</code> (a function)</li><li><code>/^1?$|^(11+?)\1+$/</code> (a RegExp)</li></ul><h3 id="리터럴이-아닌-것"><a class="markdownIt-Anchor" href="#리터럴이-아닌-것"></a> 리터럴이 아닌 것</h3><ul><li><code>std::cout</code> (an identifier)</li><li><code>foo = 0;</code> (a statement)</li><li><code>1 + 2</code> (an expression)</li></ul><br><p>가장 많은 채택을 받은 답변이지만 뭔가 모호하다. 다른 답변들을 살펴보자.</p><h2 id="설명-2"><a class="markdownIt-Anchor" href="#설명-2"></a> 설명 2</h2><ul><li>기본적으로 상수는 값을 변경할 수 없는 변수이다.</li><li>리터럴은 고정값을 나타내는 표기법이다. 이 값은 문자열, 숫자 등이 될 수 있다.</li><li>리터럴은 변수에 할당될 수 있다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Simba&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><p><code>a</code>와 <code>name</code>은 변수이고, <code>pi</code>는 상수다. <code>10</code>, <code>&quot;Simba&quot;</code>, <code>3.14</code>는 리터럴이다.</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> y = <span class="number">2</span>; <span class="comment">// 2는 리터럴이지만, y는 아니다.</span></span><br><span class="line"><span class="keyword">int</span> z = y + <span class="number">4</span>; <span class="comment">// y랑 z는 리터럴이 아니지만 4는 리터럴이다.</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> + <span class="number">2</span>; <span class="comment">// 1 + 2 는 리터럴이 아니지만 (표현식이다), 1과 2 각각은 리터럴이다.</span></span><br></pre></td></tr></table></figure><br><p>이제 리터럴이 무엇인지 감이 올 것 같지만 좀 더 보충해보자.</p><h2 id="설명-3"><a class="markdownIt-Anchor" href="#설명-3"></a> 설명 3</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DRINKING_AGE = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">const</span> VOTING_AGE = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>위의 코드에서 <code>18</code>과 <code>21</code>은 리터럴이다. 리터럴은 <code>if(age &gt; 18)</code> 또는 <code>if(age &lt; 21)</code>과 같이 프로그램의 모든 영역에서 사용될 수 있다. 하지만 상수를 이용하면 <code>if(age &gt; VOTING_AGE)</code>와 같이 코드를 더 이해하기 쉽게 만들 수 있다.</p><p>프로그래밍을 하면서 <i>매직 넘버를 사용하지 마라</i> 와 같은 말을 들어봤을 것이다. 상수를 사용하면 프로그래머가 각 리터럴이 무엇인지, 어떠한 의미를 지녔는지를 일일이 기억하고 유추할 필요가 없어진다. 비즈니스 요구 사항에 따라 상수를 변경해야 하는 경우<small>(예를 들어, 향후 음주 연령을 20세로 낮추는 경우)</small> 프로그램에 변경 사항을 적용하는 것이 훨씬 쉬워진다. 프로그램 전체에서 리터럴을 사용했다면 변경하기도 어렵고 일부 인스턴스는 수정이 누락될 위험도 있다.</p><h2 id="결론"><a class="markdownIt-Anchor" href="#결론"></a> 결론</h2><p>스택오버플로우 등을 검색하여 리터럴과 상수의 차이점이 무엇인지 정리하였다. 이제 리터럴이 무엇인지 이해하였는데 코틀린 등의 언어에서 이야기하는 함수 리터럴의 정의는 무엇인지 알아볼 필요가 있다고 생각한다. 함수 리터럴에 대해선 아래의 글들을 참고하여 정리할 예정이다.</p><ul><li><a href="https://blog.kotlin-academy.com/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e">Kotlin Programmer Dictionary: Function Type vs Function literal vs Lambda expression vs Anonymous function</a></li><li><a href="https://medium.com/til-kotlin-ko/kotlin%EC%9D%98-extension%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80-part-3-587cc37e7337">Kotlin의 Extension은 어떻게 동작하는가 part 3</a></li></ul><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li>Wikipedia - <a href="https://en.wikipedia.org/wiki/Literal_(computer_programming)">Literal</a></li><li>MDN - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#literals">Literals</a></li><li>stackoverflow - <a href="https://stackoverflow.com/a/62239386">Confusion between constants and literals?</a></li><li>stackoverflow - <a href="https://stackoverflow.com/questions/485119/what-does-the-word-literal-mean">What does the word “literal” mean?</a></li><li>stackoverflow - <a href="https://stackoverflow.com/a/48411723">What is the difference between literals and non-literals …</a></li><li><a href="https://www.diffen.com/difference/Constant_vs_Literal">Constant vs. Literal</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Terminology/">Terminology</category>
      
      
      <category domain="http://june0122.github.io/tags/Terminology/">Terminology</category>
      
      
      <comments>http://june0122.github.io/2021/08/04/term-literal/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 1756번 : 피자 굽기</title>
      <link>http://june0122.github.io/2021/08/02/boj-1756/</link>
      <guid>http://june0122.github.io/2021/08/02/boj-1756/</guid>
      <pubDate>Mon, 02 Aug 2021 14:05:16 GMT</pubDate>
      
      <description>[이분탐색] 백준 알고리즘 1756번, 피자 굽기</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/1756">문제 보기</a></h2><h2 id="풀이"><a class="markdownIt-Anchor" href="#풀이"></a> 풀이</h2><p>이중 for문으로 문제를 접근하기엔 300,000<sup>2</sup>으로 시간 초과가 발생할 것을 예상할 수 있다. 이분탐색으로 문제를 해결하고 싶어도 주어진 배열은 정렬된 형태가 아니므로 입력값 그대로는 이분탐색을 사용할 수 없다. 이분탐색을 사용하기 위해 주어진 배열<small>(오븐의 지름값들)</small>을 내림차순으로 정렬되도록 값을 변경해준다.</p><table><thead><tr><th style="text-align:center">오븐 깊이</th><th style="text-align:center">오븐 지름</th><th style="text-align:center">통과할 수 있는 반죽의 최대 크기</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">6</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">3</td><td style="text-align:center">2</td></tr></tbody></table><p>위의 표와 같이 지름이 순서대로 <code>5 6 4 3 6 2 3</code>인 오븐을 예로 들면<small>(오븐의 최상단이 1, 최하단이 D이므로 깊이는 인덱스에 1을 더한다)</small>, 깊이 2에서 오븐의 지름이 6이라도 바로 위인 깊이 1의 오븐의 지름이 5이므로 통과할 수 있는 피자 반죽의 지름은 5보다 클 수가 없다. 오븐의 지름은 이전 깊이의 오븐의 지름보다 작거나 같아야하므로 아래와 같은 코드로 오븐의 지름을 변경한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> min = oven[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until depth) &#123;</span><br><span class="line">    min = min(min, oven[i])</span><br><span class="line">    oven[i] = min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 정렬된 배열이 있으니 이분탐색을 할 수 있다. 각 피자 반죽의 위치는 찾고자 하는 피자 반죽의 지름보다 작은 값이 처음으로 나타나는 위치에서 1을 뺀 값이다. 즉, 찾고자 하는 값보다 작은 값이 처음으로 나타나는 위치를 반환하는 upperBound 구현을 응용하여 피자 반죽의 위치를 알아낼 수 있다<small>(lowerBound는 내림차순 기준, 찾고자하는 값 이하가 처음으로 나타나는 위치)</small>.</p><p>탐색 구간의 끝점을 가장 최근 오븐에 들어간 피자 반죽의 위치로 설정하여 모든 반죽들의 위치를 탐색하면 마지막 반죽의 위치에 1을 더한 값<small>(1-based indexing이므로)</small>이 맨 위의 피자가 들어가 있는 깊이이다.</p><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"><span class="keyword">import</span> kotlin.math.min</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> en = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a: IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> b: IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    sortOvenDiameter(a)</span><br><span class="line">    println(lastIndex())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lastIndex</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    st = <span class="number">0</span></span><br><span class="line">    en = d</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        depthOfPizza(b[i])</span><br><span class="line">        <span class="keyword">if</span> (en &lt; <span class="number">0</span>) <span class="keyword">break</span></span><br><span class="line">        st = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> en + <span class="number">1</span> <span class="comment">// 1-based indexing : 오븐의 최상단이 1, 최하단이 D이므로</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">depthOfPizza</span><span class="params">(target: <span class="type">Int</span>)</span></span> &#123; <span class="comment">// 내림차순의 upperBound 사용</span></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    en--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sortOvenDiameter</span><span class="params">(a : <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> min = a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until d) &#123;</span><br><span class="line">        min = min(min, a[i])</span><br><span class="line">        a[i] = min</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    d = nextInt()</span><br><span class="line">    n = nextInt()</span><br><span class="line">    a = IntArray(d)</span><br><span class="line">    b = IntArray(n)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until d) a[i] = nextInt()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) b[i] = nextInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="정렬-순서에-따른-upperbound와-lowerbound-구현"><a class="markdownIt-Anchor" href="#정렬-순서에-따른-upperbound와-lowerbound-구현"></a> 정렬 순서에 따른 upperBound와 lowerBound 구현</h2><p><a href="https://www.acmicpc.net/problem/10816">BOJ 10816번, 숫자 카드 2</a> 기준으로 설명</p><blockquote><p>오름차순 정렬</p></blockquote><p>오름차순 정렬일 경우 <code>lowerBound</code>는 찾고자 하는 값 이상이 처음으로 나타나는 위치인 반면에, <code>upperBound</code>는 찾고자 하는 값보다 큰 값이 처음으로 나타나는 위치이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a : IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> b : IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    a.sort() <span class="comment">// 오름차순 정렬</span></span><br><span class="line">    b.forEach &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="subst">$&#123;upperBound(it) - lowerBound(it)&#125;</span> &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowerBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">upperBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    a = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        a[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">    m = nextInt()</span><br><span class="line">    b = IntArray(m)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">        b[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>내림차순 정렬</p></blockquote><p>내림차순 정렬일 경우 <code>lowerBound</code>는 찾고자 하는 값 이하가 처음으로 나타나는 위치인 반면에, <code>upperBound</code>는 찾고자 하는 값보다 작은 값이 처음으로 나타나는 위치이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a : IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> b : IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    a.sortDescending() <span class="comment">// 내림차순 정렬</span></span><br><span class="line">    b.forEach &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="subst">$&#123;upperBound(it) - lowerBound(it)&#125;</span> &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowerBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">upperBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    a = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        a[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">    m = nextInt()</span><br><span class="line">    b = IntArray(m)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">        b[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/">이분탐색</category>
      
      
      <comments>http://june0122.github.io/2021/08/02/boj-1756/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 1939번 : 중량제한</title>
      <link>http://june0122.github.io/2021/08/02/boj-1939/</link>
      <guid>http://june0122.github.io/2021/08/02/boj-1939/</guid>
      <pubDate>Mon, 02 Aug 2021 14:05:16 GMT</pubDate>
      
      <description>[이분탐색] 백준 알고리즘 1939번, 중량제한</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/1756">문제 보기</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> start = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> end = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> graph: Array&lt;ArrayList&lt;Info&gt;&gt;</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> visit: BooleanArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> factory: Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    binarySearch()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binarySearch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (start + end) / <span class="number">2</span></span><br><span class="line">        visit = BooleanArray(n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (dfs(factory.first, mid)) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">            result = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(cur: <span class="type">Int</span>, limit: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (visit[cur]) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    visit[cur] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (cur == factory.second) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (island <span class="keyword">in</span> graph[cur]) &#123;</span><br><span class="line">        <span class="keyword">val</span> (next, weight) = island.dest to island.weight</span><br><span class="line">        <span class="keyword">if</span> (weight &gt;= limit) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(next, limit))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> br = System.`<span class="keyword">in</span>`.bufferedReader()</span><br><span class="line">    <span class="keyword">val</span> firstLine = br.readLine().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    n = firstLine[<span class="number">0</span>].toInt()</span><br><span class="line">    m = firstLine[<span class="number">1</span>].toInt()</span><br><span class="line">    graph = Array(n + <span class="number">1</span>) &#123; ArrayList() &#125;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">        <span class="keyword">val</span> (a, b, c) = br.readLine().split(<span class="string">&quot; &quot;</span>).map &#123; it.toInt()&#125;</span><br><span class="line">        graph[a].add(Info(b, c))</span><br><span class="line">        graph[b].add(Info(a, c))</span><br><span class="line">        end = max(end, c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> lastLine = br.readLine().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    factory = lastLine[<span class="number">0</span>].toInt() to lastLine[<span class="number">1</span>].toInt()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span></span>(<span class="keyword">val</span> dest: <span class="built_in">Int</span>, <span class="keyword">val</span> weight: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>BFS/DFS와 이분탐색을 함께 적용해서 풀어야하는 문제이다. 아직 BFS/DFS 문제에 익숙하지 않다보니 시간도 많이 소요되고 결국 다른 사람의 코드를 봐야했다. BFS/DFS 관련 문제를 많이 풀어보고 다시 이 문제를 풀어야겠다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/BFS/">BFS</category>
      
      <category domain="http://june0122.github.io/tags/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/">이분탐색</category>
      
      <category domain="http://june0122.github.io/tags/DFS/">DFS</category>
      
      <category domain="http://june0122.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/">그래프</category>
      
      
      <comments>http://june0122.github.io/2021/08/02/boj-1939/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 10815번 : 숫자 카드</title>
      <link>http://june0122.github.io/2021/08/02/boj-10815/</link>
      <guid>http://june0122.github.io/2021/08/02/boj-10815/</guid>
      <pubDate>Mon, 02 Aug 2021 14:03:32 GMT</pubDate>
      
      <description>[이분탐색] 백준 알고리즘 10815번, 숫자 카드</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/10815">문제 보기</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>이분 탐색 구현</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a: IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> b: IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    a.sort()</span><br><span class="line">    b.forEach &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="subst">$&#123;binarySearch(it)&#125;</span> &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binarySearch</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt;= en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            a[mid] &gt; target -&gt; en = mid - <span class="number">1</span></span><br><span class="line">            a[mid] &lt; target -&gt; st = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    a = IntArray(n)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        a[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">    m = nextInt()</span><br><span class="line">    b = IntArray(m)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">        b[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>kotlin.collections의 binarySearch 사용</p></blockquote><ul><li>JVM을 기반으로 하는 코틀린에서의 컬렉션은 자바에서 제공하는 클래스들을 그대로 사용한다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a: IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> b: IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">    a.sort()</span><br><span class="line">    b.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.binarySearch(it) &lt; <span class="number">0</span>) print(<span class="string">&quot;0 &quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> print(<span class="string">&quot;1 &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    a = IntArray(n)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        a[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">    m = nextInt()</span><br><span class="line">    b = IntArray(m)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">        b[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/">이분탐색</category>
      
      
      <comments>http://june0122.github.io/2021/08/02/boj-10815/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 이분 탐색 (Binary Search)</title>
      <link>http://june0122.github.io/2021/07/29/boj-binary-search/</link>
      <guid>http://june0122.github.io/2021/07/29/boj-binary-search/</guid>
      <pubDate>Thu, 29 Jul 2021 06:55:07 GMT</pubDate>
      
      <description>[바킹독의 실전 알고리즘] 0x13강 - 이분 탐색</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="설명"><a class="markdownIt-Anchor" href="#설명"></a> 설명</h2><p><b>정렬되어 있는 배열</b>에서 특정 데이터를 찾기 위해 모든 데이터를 순차적으로 확인하는 대신 <b>탐색 범위를 절반</b>으로 줄여가며 찾는 탐색 방법</p><ul><li>선형 탐색 : <i>O(N)</i></li><li>이분 탐색 : <i>O(logN)</i></li></ul><h2 id="구현"><a class="markdownIt-Anchor" href="#구현"></a> 구현</h2><h3 id="boj-1920-수-찾기"><a class="markdownIt-Anchor" href="#boj-1920-수-찾기"></a> <a href="https://www.acmicpc.net/problem/1920">BOJ 1920, 수 찾기</a></h3><ul><li>M개의 수에 대해 <strong>선형 탐색</strong>을 한다면 시간복잡도는 <i>O(NM)</i></li><li>미리 배열 A를 정렬해둔 다음 <strong>이분 탐색</strong>을 수행하면 시간복잡도는 <i>O(NlogN + MlogN)</i><ul><li><em>NlogN</em>은 정렬에 필요한 시간복잡도, <em>MlogN</em>은 이분탐색에 필요한 시간복잡도</li></ul></li></ul><blockquote><p>이분 탐색 직접 구현</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a: IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> b: IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    a.sort()</span><br><span class="line">    b.forEach &#123;</span><br><span class="line">        println(binarySearch(it))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">binarySearch</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span> <span class="comment">// start</span></span><br><span class="line">    <span class="keyword">var</span> en = n - <span class="number">1</span> <span class="comment">// end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt;= en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            a[mid] &lt; target -&gt; st = mid + <span class="number">1</span></span><br><span class="line">            a[mid] &gt; target -&gt; en = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    a = IntArray(n)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        a[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">    m = nextInt()</span><br><span class="line">    b = IntArray(m)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">        b[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>kotlin.collections의 <code>binarySearch</code> 사용</p></blockquote><ul><li>JVM을 기반으로 하는 코틀린에서의 컬렉션은 자바에서 제공하는 클래스들을 그대로 사용한다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b.forEach &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.binarySearch(it) &gt;= <span class="number">0</span>) println(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span> println(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>contains</code> 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b.forEach &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.contains(it)) println(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span> println(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BOJ를 기준으로 <code>binarySearch</code>를 이용한 풀이는 <strong>2164ms</strong>, <code>contains</code>는 <strong>4940ms</strong> 시간이 소요되었다.</p><p>kotlin.collections의 <code>contains</code> 함수의 내부 구현은 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">contains</span><span class="params">(element: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(element) &gt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> IntArray.<span class="title">indexOf</span><span class="params">(element: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> indices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element == <span class="keyword">this</span>[index]) &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>내부적으로 <code>indexOf</code> 함수를 사용하여 모든 인덱스를 순회하는 형태로 구현되어 있으며, <i>O(N)</i> 시간복잡도를 가진다.</p><p>그에 반해 <code>binarySearch</code>의 경우 <i>O(logN)</i>의 시간복잡도를 가지므로 더 좋은 성능을 보여준다.</p><p>다음 코드는 java.util.Arrays의 <code>binarySearch</code> 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">return</span> binarySearch0(a, fromIndex, toIndex, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch0</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = fromIndex;</span><br><span class="line">    <span class="keyword">int</span> high = toIndex - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + high &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> midVal = a[mid];</span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; key) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (midVal &lt;= key) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="boj-10816-숫자-카드2"><a class="markdownIt-Anchor" href="#boj-10816-숫자-카드2"></a> <a href="https://www.acmicpc.net/problem/10816">BOJ 10816, 숫자 카드2</a></h3><ul><li>삽입하는 수가 주어질 때, 오름차순 순서가 유지되는 제일 왼쪽 인덱스와 제일 오른쪽의 인덱스의 차이가 해당 배열에서 그 수의 등장 횟수가 되는 성질을 이용<ul><li><code>start</code> ~ <code>end</code>의 범위가 <code>0</code> ~ <code>a.size</code>인 것에 유의</li><li>while의 조건문이 <code>start &lt;= end</code>가 아니라 <code>start &lt; end</code></li></ul></li></ul><blockquote><p><code>Scanner</code>를 통한 입력 받기 (시간 초과)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a : IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> b : IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    a.sort()</span><br><span class="line">    b.forEach &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="subst">$&#123;upperBound(it) - lowerBound(it)&#125;</span> &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowerBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">upperBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    a = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        a[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">    m = nextInt()</span><br><span class="line">    b = IntArray(m)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">        b[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>readLine()</code>을 통한 입력 받기 (통과)</p></blockquote><ul><li>가독성이 좋아 Scanner를 통해 입력을 받는 방식을 BOJ에서 자주 사용하지만 다른 입력 방식들에 비해 느리기 때문에 시간 초과가 발생할 경우 <code>readLine()</code>을 이용하는 방법 등을 사용한다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> a: IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    readLine()</span><br><span class="line">    a = readLine()!!.split(<span class="string">&quot; &quot;</span>).map &#123; it.toInt() &#125;.sorted().toIntArray()</span><br><span class="line">    readLine()</span><br><span class="line">    print(readLine()!!.split(<span class="string">&quot; &quot;</span>).map &#123; it.toInt() &#125;.map &#123; upperBound(it) - lowerBound(it) &#125;.joinToString(<span class="string">&quot; &quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowerBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">upperBound</span><span class="params">(target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = a.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="주의사항"><a class="markdownIt-Anchor" href="#주의사항"></a> 주의사항</h3><ol><li>이분 탐색을 하고자 한다면 주어진 배열은 정렬되어 있어야 한다.</li><li>무한 루프에 빠지지 않게 mid 값을 정해야 한다.</li></ol><h2 id="연습-문제"><a class="markdownIt-Anchor" href="#연습-문제"></a> 연습 문제</h2><h3 id="boj-18870-좌표-압축"><a class="markdownIt-Anchor" href="#boj-18870-좌표-압축"></a> <a href="https://www.acmicpc.net/problem/18870">BOJ 18870, 좌표 압축</a></h3><ul><li>중복을 제외하고 자신보다 작은 수가 몇 개 있는지를 물어보는 문제</li></ul><blockquote><p>이분 탐색 - lowerBound 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> list: List&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">    <span class="keyword">val</span> sorted = list.distinct().sorted()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> list.indices) &#123;</span><br><span class="line">        sb.append(lowerBound(sorted, list[i])).append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lowerBound</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, target: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> st = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> en = list.lastIndex</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (list[mid] &gt;= target) en = mid</span><br><span class="line">        <span class="keyword">else</span> st = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    readLine()</span><br><span class="line">    list = readLine()!!.split(<span class="string">&quot; &quot;</span>).map &#123; it.toInt() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>HashMap 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> list: List&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    <span class="keyword">val</span> sorted = list.sorted()</span><br><span class="line">    <span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">var</span> idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> sorted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(i)) map[i] = idx++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> list) &#123;</span><br><span class="line">        sb.append(map[i]).append(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(sb)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    readLine()</span><br><span class="line">    list = readLine()!!.split(<span class="string">&quot; &quot;</span>).map &#123; it.toInt() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align = 'center'><img height = '350' src = 'https://user-images.githubusercontent.com/39554623/127417010-9ed6f9f1-ee89-4e7f-ba94-af8ef79df344.png'><img height = '350' src = 'https://user-images.githubusercontent.com/39554623/127417011-3364002f-9ba4-44db-88c0-1a901ad623d1.png'></p><ul><li>문제의 예제인 좌표 [2, 4, -10, 4, -9]을 위와 같은 알고리즘으로 압축하면 [2, 3, 0, 3, 1]이 되는데 위 그림 처럼 압축된 점들도 같은 동일선 상 안에 놓이게 된다.</li><li>이렇게 범위가 매우 넓은 좌표의 경우에 좌표를 인덱싱해서 처리 할 경우 손쉽게 처리 할 수 있게 된다.</li><li><a href="https://codingdog.tistory.com/entry/%EC%A2%8C%ED%91%9C-%EC%95%95%EC%B6%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B2%94%EC%9C%84%EA%B0%80-%ED%81%B4-%EB%95%8C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B3%B5%EA%B0%84%EC%9D%84-%EC%A4%84%EC%9D%BC%EA%B9%8C%EC%9A%94">좌표 압축 알고리즘에 대한 설명</a></li></ul><h3 id="boj-2295-세-수의-합"><a class="markdownIt-Anchor" href="#boj-2295-세-수의-합"></a> <a href="https://www.acmicpc.net/problem/2295">BOJ 2295, 세 수의 합</a></h3><p><code>a[i] + a[j] + a[k] = a[l]</code>을 만족하는 <code>a[l]</code> 중에서 최댓값을 구하기</p><ol><li><i>O(N<sup>4</sup>)</i> 풀이 :  i, j, k, l에 대한 4중 for문</li><li><i>O(N<sup>3</sup>logN)</i> 풀이 : i, j, k에 대한 3중 for문을 돌리고, 배열 a 안에 <code>a[i] + a[j] + a[k]</code>가 있는지 이분 탐색</li><li><i>O(N<sup>2</sup>logN)</i> 풀이<ul><li>미리 a에서 두 원소의 합을 다 묶어놓은 배열 two 생성</li><li><code>two[m] + a[k] = a[l]</code></li><li>k, l에 대한 2중 for문을 돌리고 <code>a[l] - a[k]</code>가 배열 two 안에 있는지 이분 탐색</li><li>two의 길이는 N<sup>2</sup>인데 log(N<sup>2</sup>)은 2logN 이어서 <i>O(N<sup>2</sup>log(N<sup>2</sup>))</i> = <i>O(N<sup>2</sup> * 2logN)</i> = <i>O(N<sup>2</sup>logN)</i></li></ul></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> list = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> two = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">    </span><br><span class="line">    list.sort()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> i until n) &#123;</span><br><span class="line">            two.add(list[i] + list[j])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    two.sort()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> n - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (two.binarySearch(list[i] - list[j]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                println(list[i])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    repeat(n) &#123; list.add(nextInt()) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2개의 값을 묶은 후 어느 한쪽의 값을 이분탐색으로 찾아서 시간복잡도를 낮추는 아이디어</strong>는 이분탐색 관련 응용문제에서 핵심적으로 많이 나오므로 여러 문제들을 풀어보며 익숙해질 필요가 있다.</p><h2 id="parametric-search-small매개-변수-탐색small"><a class="markdownIt-Anchor" href="#parametric-search-small매개-변수-탐색small"></a> Parametric Search <small>(매개 변수 탐색)</small></h2><blockquote><p>조건을 만족하는 최소∙최대값을 구하는 문제<b>(최적화 문제)</b>를 <b>결정 문제</b>로 변환해 이분 탐색을 수행하는 방법</p></blockquote><p>parametric search는 꽤 어려운 난이도를 가지고 있다. 애초에 문제가 parametric search인 것을 눈치채기가 어렵고, DP나 그리디 등의 유형과 결합을 해서 나오는 경우도 빈번하다.</p><h3 id="boj-1654-세-수의-합"><a class="markdownIt-Anchor" href="#boj-1654-세-수의-합"></a> <a href="https://www.acmicpc.net/problem/1654">BOJ 1654, 세 수의 합</a></h3><ul><li>[최적화 문제] : N개를 만들 수 있는 랜선의 <strong>최대</strong> 길이</li><li>[결정 문제] : 랜선의 길이가 X일 때 랜선이 <strong>N개 이상인가 아닌가?</strong></li></ul><p>이 문제의 상황은 N개를 만들 수 있는 랜선의 최대 길이를 구하는 최적화 문제이다. 이걸 결정 문제로 바꾸면 반대로 우리가 구해야 하는 답이 인자로 들어가고, 조건의 참/거짓 여부를 판단하는 문제로 만들 수 있다.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/127440178-acf4a192-1ba7-4f08-99ab-f005e29decfc.png'></p><p>랜선의 길이가 줄어들수록 개수가 많아지므로 간단하게 그래프를 그려보면 랜선의 길이가 x축에 놓이고 개수가 y축에 놓인다. 그리고 그래프는 x가 커질수록 y가 감소하는 형태이다. 그래프에서 답은 표시한 지점으로, 개수가 N개 이상인 지점들 중에서 가장 길이가 긴 곳이다. 이 답을 기점으로 왼쪽은 개수가 N 이상이고 오른쪽은 N 미만이다. 랜선의 길이는 최소 1, 최대 2<sup>31</sup>-1인데, 우리는 여기서 이분탐색으로 답을 빠르게 찾아낼 수 있다.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/127440347-093188d8-a06c-405b-9305-322e8da02d3c.png'></p><p>이렇게 st, mid, en을 놓고 범위를 줄여가며 답을 찾는다. 최대 길이를 구해야하는 문제에서 랜선의 길이가 X일 때 조건을 만족하는지 확인하는 문제로 변환해서 풀이를 해낼 수 있다.</p><p>이 문제의 경우, 랜선의 길이를 X로 두고나면 조각의 개수를 구하는건 <i>O(N)</i>이고 랜선의 길이로 가능한 범위는 2<sup>31</sup>이어서 시간복잡도는 <i>O(log(2<sup>31</sup>N))</i> = <i>O(31N)</i></p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/127440224-353dd38a-022c-44fb-b3c4-00334f5eab30.png'></p><p>여기서 주의해야하는건, 지금처럼 이분탐색을 수행할 변수를 가지고 함수를 세웠을 때 그 함수가 감소함수거나 증가함수여야 한다. 만약 위의 그래프처럼 함수가 감소 혹은 증가함수 형태가 아니라 뒤죽박죽이면 이분탐색 자체가 불가능하다. 그래서 parametric search를 할 때에는 최적화 문제를 결정 문제로 바꿀 수 있는지 생각하고 그 결정 문제로 얻어낸 함수가 감소 혹은 증가함수인지를 따져봐야 한다. 문제에서 최소 혹은 최대 얘기가 있고 범위가 무지막지하게 크거나, 시간복잡도에서 값 하나를 로그로 어떻게 잘 떨구면 될 것 같을 때 parametric search 풀이가 가능하지는 않을까 고민을 해볼 필요가 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> arr: IntArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> st: <span class="built_in">Long</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> en = <span class="built_in">Int</span>.MAX_VALUE.toLong() <span class="comment">// 2^31 - 1</span></span><br><span class="line">    <span class="keyword">while</span> (st &lt; en) &#123;</span><br><span class="line">        <span class="keyword">val</span> mid = (st + en + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (solve(mid)) st = mid</span><br><span class="line">        <span class="keyword">else</span> en = mid - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(st)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solve</span><span class="params">(x: <span class="type">Long</span>)</span></span>: <span class="built_in">Boolean</span> &#123; <span class="comment">// 결정 문제</span></span><br><span class="line">    <span class="keyword">var</span> cur = <span class="number">0L</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until k) cur += arr[i] / x</span><br><span class="line">    <span class="keyword">return</span> cur &gt;= n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    k = nextInt()</span><br><span class="line">    n = nextInt()</span><br><span class="line">    arr = IntArray(k)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until k) &#123;</span><br><span class="line">        arr[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mid = (st + en + 1) / 2</code>로 둬야 무한 루프에 빠지지 않는다. <code>mid = (st + en) / 2</code>로 두면 st와 en이 1 차이날 때 st가 계속 값이 똑같아버릴 수 있다.</p><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><ul><li><a href="https://youtu.be/3TkaOKHxHnI">[바킹독의 실전 알고리즘] 0x13강 - BFS</a></li><li><a href="https://jungguji.github.io/2020/12/15/%EB%B0%B1%EC%A4%80-18870%EB%B2%88-%EC%A2%8C%ED%91%9C-%EC%95%95%EC%B6%95/">https://jungguji.github.io/2020/12/15/백준-18870번-좌표-압축/</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%94%ED%82%B9%EB%8F%85/">바킹독</category>
      
      <category domain="http://june0122.github.io/tags/Binary-Search/">Binary Search</category>
      
      
      <comments>http://june0122.github.io/2021/07/29/boj-binary-search/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] View Binding (뷰 바인딩)</title>
      <link>http://june0122.github.io/2021/07/24/android-docs-view-binding/</link>
      <guid>http://june0122.github.io/2021/07/24/android-docs-view-binding/</guid>
      <pubDate>Fri, 23 Jul 2021 21:48:09 GMT</pubDate>
      
      <description>&lt;b&gt;뷰 바인딩&lt;small&gt;(View Binding)&lt;/small&gt;&lt;/b&gt; 기능은 뷰와 상호작용하는 코드를 쉽게 작성할 수 있게 해준다. 모듈에서 사용 설정&lt;small&gt;(enable)&lt;/small&gt;된 뷰 바인딩은 각 XML 레이아웃 파일의 &lt;b&gt;바인딩 클래스&lt;small&gt;(binding class)&lt;/small&gt;&lt;/b&gt;를 생성한다. 바인딩 클래스의 인스턴스는 상응하는 레이아웃에 ID가 있는 모든 뷰의 직접 참조가 포함된다.</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><b>뷰 바인딩<small>(View Binding)</small></b> 기능은 뷰와 상호작용하는 코드를 쉽게 작성할 수 있게 해준다.</li><li>모듈에서 사용 설정<small>(enable)</small>된 뷰 바인딩은 각 XML 레이아웃 파일의 <b>바인딩 클래스<small>(binding class)</small></b>를 생성한다.</li><li>바인딩 클래스의 인스턴스는 상응하는 레이아웃에 ID가 있는 모든 뷰의 직접 참조가 포함된다.</li><li>대부분의 경우, 뷰 바인딩이 <code>findViewById</code>를 대체한다.</li></ul><h2 id="설정-방법"><a class="markdownIt-Anchor" href="#설정-방법"></a> 설정 방법</h2><p>뷰 바인딩은 모듈 별로 사용 설정이 된다<small>(enabled on a module by module)</small>.</p><p>모듈에서 뷰 바인딩을 사용 설정<small>(enable)</small> 하려면, module 레벨의 <code>build.gradle</code> 파일에 <code>viewBinding</code> 빌드 옵션을 아래의 예시와 같이 <code>true</code>로 변경한다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">        ...</span><br><span class="line">        viewBinding &#123;</span><br><span class="line">            enabled = <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>바인딩 클래스를 생성하는 동안 레이아웃 파일을 무시하려면 <code>tools:viewBindingIgnore=&quot;true&quot;</code> 속성을 레이아웃 파일의 루트 뷰에 추가해야 한다.</p><h2 id="사용법"><a class="markdownIt-Anchor" href="#사용법"></a> 사용법</h2><p>모듈에 뷰 바인딩이 사용 설정되면, 모듈에 포함된 각 XML 레이아웃 파일의 바인딩 클래스가 생성된다.</p><p>각 바인딩 클래스에는 루트 뷰와 ID가 있는 모든 뷰에 대한 참조를 포함한다.</p><p>생성된 바인딩 클래스의 이름은 XML 파일의 이름을 카멜 표기법으로 변환하고 끝에 'Binding’이 추가된다.</p><blockquote><p><code>result_profile.xml</code> 이름을 가진 레이아웃 파일의 예시</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/name&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span> <span class="attr">android:cropToPadding</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@drawable/rounded_button&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>생성된 바인딩 클래스의 이름은 <code>ResultProfileBinding</code>이 된다. 이 클래스에는 <code>name</code>이라는 <code>TextView</code>와 <code>button</code>이라는 <code>Button</code> 등 두 개의 필드가 있다. 레이아웃의 <code>ImageView</code>에는 ID가 없으므로 바인딩 클래스에 참조가 없다.</p><p>모든 바인딩 클래스는 <code>getRoot()</code> 메서드를 포함하고 있는데, <strong>상응하는 레이아웃 파일의 루트 뷰에 대한 직접 참조를 제공</strong>한다.</p><p>위의 예시 코드에서는 <code>ResultProfileBinding</code> 클래스의 <code>getRoot()</code> 메서드가 <code>LinearLayout</code> 루트 뷰를 반환한다.</p><h3 id="액티비티에서의-뷰-바인딩-사용법"><a class="markdownIt-Anchor" href="#액티비티에서의-뷰-바인딩-사용법"></a> 액티비티에서의 뷰 바인딩 사용법</h3><p>액티비티에 사용할 바인딩 클래스 인스턴스를 설정하려면, 액티비티의 <code>onCreate()</code> 메서드에서 다음 두 단계를 따라야 한다.</p><ol><li>생성된 바인딩 클래스에 포함된 static <code>inflate()</code> 메서드를 호출한다. 이를 통해 액티비티에서 사용할 바인딩 클래스의 인스턴스를 생성한다.</li><li><code>getRoot()</code>메서드를 호출하거나 <a href="https://kotlinlang.org/docs/properties.html#declaring-properties">Kotlin property syntax</a>를 사용하여 루트 뷰의 참조를 가져온다.</li><li>루트 뷰를 <code>setContentView()</code>에 전달<small>(pass)</small>하여 화면 상의 활성 뷰로 만든다.</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ResultProfileBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    binding = ResultProfileBinding.inflate(layoutInflater)</span><br><span class="line">    <span class="keyword">val</span> view = binding.root</span><br><span class="line">    setContentView(view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 바인딩 클래스의 인스턴스를 사용하여 뷰를 참조할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binding.name.text = viewModel.name</span><br><span class="line">binding.button.setOnClickListener &#123; viewModel.userClicked() &#125;</span><br></pre></td></tr></table></figure><h3 id="프래그먼트에서의-뷰-바인딩-사용법"><a class="markdownIt-Anchor" href="#프래그먼트에서의-뷰-바인딩-사용법"></a> 프래그먼트에서의 뷰 바인딩 사용법</h3><p>프래그먼트에서 사용할 바인딩 클래스의 인스턴스를 설정하려면, 프래그먼트의 <code>onCreateView()</code> 메서드에서 다음 단계를 따라야 한다.</p><ol><li>생성된 바인딩 클래스에 포함된 static <code>inflate()</code> 메서드를 호출한다. 그러면 프래그먼트에서 사용할 바인딩 클래스의 인스턴스가 생성된다.</li><li><code>getRoot()</code>메서드를 호출하거나 <a href="https://kotlinlang.org/docs/properties.html#declaring-properties">Kotlin property syntax</a>를 사용하여 루트 뷰의 참조를 가져온다.</li><li><code>onCreateView()</code> 메서드에서 루트 뷰를 반환하여 화면 상의 활성 뷰를 만든다.</li></ol><blockquote><p>★ 참고 : inflate() 메서드를 사용하려면 layout inflator를 전달해야 한다. 레이아웃이 이미 inflate 되었다면, 바인딩 클래스의 static bind() 메서드를 호출하면 된다. 자세한 내용은 <a id = "a1"><a href="#f1">본문의 하단</a></a>이나 <a href="https://github.com/android/architecture-components-samples/blob/master/ViewBindingSample/app/src/main/java/com/android/example/viewbindingsample/BindFragment.kt#L36-L41">뷰 바인딩 깃허브 샘플의 예시</a>에서 볼 수 있다.</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _binding: ResultProfileBinding? = <span class="literal">null</span></span><br><span class="line"><span class="comment">// This property is only valid between onCreateView and</span></span><br><span class="line"><span class="comment">// onDestroyView.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> binding <span class="keyword">get</span>() = _binding!!</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: View? &#123;</span><br><span class="line">    _binding = ResultProfileBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">val</span> view = binding.root</span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">    _binding = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 바인딩 클래스의 인스턴스를 사용하여 뷰를 참조할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binding.name.text = viewModel.name</span><br><span class="line">binding.button.setOnClickListener &#123; viewModel.userClicked() &#125;</span><br></pre></td></tr></table></figure><blockquote><p>★ 참고 : 프래그먼트는 뷰보다 오래 지속된다<small>(Fragments outlive their views)</small>. 프래그먼트의 onDestroyView() 메서드에서 바인딩 클래스 인스턴스에 대한 참조를 정리해야 한다.</p></blockquote><h3 id="다른-구성smallconfigurationsmall에-대한-힌트"><a class="markdownIt-Anchor" href="#다른-구성smallconfigurationsmall에-대한-힌트"></a> 다른 구성<small>(configuration)</small>에 대한 힌트</h3><p>여러 구성<small>(configuration)</small>에서 뷰를 선언할 때, 특정 레이아웃에 따라 다른 뷰 타입을 사용하는 것이 더 합리적이다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># in res/layout/example.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/user_bio&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"># in res/layout-land/example.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">EditText</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/user_bio&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>이러한 경우, <code>TextView</code>가 공통된 기본 클래스<small>(common base class)</small>이기 때문에 생성된 클래스가 <code>TextView</code> 타입의 <code>userBio</code> 필드를 노출할 것으로 예상할 것이다. 하지만 기술적인 한계로 인해 뷰 바인딩 코드 생성기는 이러한 결정을 내릴 수 없으며, 대신에 단순히 <code>View</code> 필드를 생성한다. 이를 위해서는 나중에 <code>binding.userBio as TextView</code>를 사용하여 필드를 캐스팅해야 한다.</p><p>이 제한 사항을 해결하기 위해, 뷰 바인딩은 <code>tools:viewBindingType</code> 속성을 지원하여 생성된 코드에서 어떤 타입을 사용할 것인지 컴파일러에게 알릴 수 있다.</p><blockquote><p><code>tools:viewBindingType</code> 속성을 사용하여 컴파일러가 필드를 <code>TextView</code>로 생성하게 하기</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># in res/layout/example.xml (unchanged)</span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/user_bio&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"># in res/layout-land/example.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">EditText</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/user_bio&quot;</span> <span class="attr">tools:viewBindingType</span>=<span class="string">&quot;TextView&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>다른 예시로, 하나는 <code>BottomNavigationView</code>를 포함하고 다른 하나는 <code>NavigationRailView</code>를 포함하는 두 개의 레이아웃이 있다고 가정해보자. 두 클래스 모두 구현의 세부 정보가 포함된 <code>NavigationBarView</code>를 확장한다. 코드가 현재 레이아웃에 어떤 하위 클래스가 있는지 정확히 알 필요가 없는 경우, <code>tools:viewBindingType</code>를 사용하여 생성된 타입을 두 레이아웃 모두에서 <code>NavigationBarView</code>로 설정할 수 있다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># in res/layout/navigation_example.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">BottomNavigationView</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/navigation&quot;</span> <span class="attr">tools:viewBindingType</span>=<span class="string">&quot;NavigationBarView&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"># in res/layout-w720/navigation_example.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">NavigationRailView</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/navigation&quot;</span> <span class="attr">tools:viewBindingType</span>=<span class="string">&quot;NavigationBarView&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>참고로 뷰 바인딩은 코드를 생성할 때 속성 값의 유효성을 검사할 수 없다. 컴파일 타임과 런타임 오류를 방지하려면 값이 다음 조건들을 충족해야 한다.</p><ul><li>값은 <code>android.view.View</code>에서 상속되는 클래스여야 한다.</li><li>값은 해당 값이 배치된 태그의 슈퍼 클래스여야 한다. 예를 들어 다음 값들은 작동하지 않는다.<ul><li><code>&lt;TextView tools:viewBindingType=&quot;ImageView&quot; /&gt;</code> : ImageView는 TextView와 관련이 없다.</li><li><code>&lt;TextView tools:viewBindingType=&quot;Button&quot; /&gt;</code> : Button은 TextView의 슈퍼 클래스가 아니다.</li></ul></li><li>최종 타입은 모든 구성에서 일관되게 해결되어야 한다.</li></ul><h2 id="findviewbyid와의-차이점"><a class="markdownIt-Anchor" href="#findviewbyid와의-차이점"></a> findViewById와의 차이점</h2><p>뷰 바인딩은 <code>findViewById</code>를 사용하는 것에 비해 중요한 장점이 있다.</p><ul><li><strong>널 안정성</strong><ul><li>뷰 바인딩운 뷰에 대한 직접 참조를 생성하므로, 유효하지 않은 view ID로 인해 null pointer exception이 발생할 위험이 없다. 또한 레이아웃의 일부 구성에서만 뷰가 있는 경우, 바인딩 클래스에서 참조를 포함하는 필드가 <code>@Nullable</code>로 표시된다.</li></ul></li><li><strong>타입 안정성</strong><ul><li>각 바인딩 클래스에 있는 필드는 XML 파일에서 참조하는 뷰와 일치하는 타입을 가진다. 즉, 클래스 변환 예외<small>(class cast exception)</small>이 발생할 위험이 없다.</li></ul></li></ul><p>이러한 차이점은 레이아웃과 코드 사이의 비호환성으로 인해 <code>findViewById</code>가 런타임에 오류가 발생하는 반면, 뷰 바인딩은 런타임이 아닌 컴파일 타임에 빌드가 실패하게 된다는 것을 의미한다.</p><p>연산 속도 면에서도 <code>findViewById</code>는 레이아웃 태그를 순회하여 일치하는 뷰를 찾아가기 때문에 연산 속도에 영향을 미치고, 단순 바인딩 코드가 길어진다.</p><h2 id="데이터-바인딩과의-비교"><a class="markdownIt-Anchor" href="#데이터-바인딩과의-비교"></a> 데이터 바인딩과의 비교</h2><p>뷰 바인딩과 데이터 바인딩은 모두 뷰를 직접 참조하는 데 사용할 수 있는 바인딩 클래스를 생성한다. 하지만 뷰 바인딩은 보다 단순한 사용 사례를 처리하기 위한 것이며 데이터 결합에 비해 다음과 같은 이점을 제공한다.</p><ul><li>더 빠른 컴파일<ul><li>뷰 바인딩은 주석 처리<small>(annotation processing)</small>이 필요하지 않으므로 컴파일 시간이 더 짧다.</li></ul></li><li>사용 편의성<ul><li>뷰 바인딩은 특별히 태그된 XML 레이아웃 파일이 필요하지 않으므로 앱에서 더 신속하게 채택될 수 있다. 모듈에서 뷰 바인딩을 사용 설정하면 모듈의 모든 레이아웃에 뷰 바인딩이 자동으로 적용된다.</li></ul></li></ul><p>반대로 뷰 바인딩에는 데이터 바인딩과 비교해서 다음과 같은 제한 사항들이 있다.</p><ul><li>뷰 바인딩은 <a href="https://developer.android.com/topic/libraries/data-binding/expressions">레이아웃 변수 또는 레이아웃 표현식</a>을 지원하지 않으므로, XML 레이아웃 파일에서 직접 동적 UI 콘텐츠를 선언하는 데 사용할 수 없다.</li><li>뷰 바인딩은 <a href="https://developer.android.com/topic/libraries/data-binding/two-way">양방향 데이터 바인딩</a>을 지원하지 않는다.</li></ul><p>위 사항을 고려할 때, 일부 사례에서는 뷰 바인딩과 데이터 바인딩을 모두 사용하는 것이 가장 좋다. 고급 기능이 필요한 레이아웃에는 데이터 바인딩을, 고급 기능이 필요 없는 레이아웃에는 뷰 바인딩을 사용할 수 있다.</p><h3 id="b-id-f1레이아웃이-이미-인플레이트된-상황에서의-뷰-바인딩b"><a class="markdownIt-Anchor" href="#b-id-f1레이아웃이-이미-인플레이트된-상황에서의-뷰-바인딩b"></a> <b id = "f1">레이아웃이 이미 인플레이트된 상황에서의 뷰 바인딩</b>  <a href="#a1"> ↩</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * View Binding example with a fragment that uses the alternate constructor for inflation and</span></span><br><span class="line"><span class="comment"> * [onViewCreated] for binding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindFragment</span> : <span class="type">Fragment</span></span>(R.layout.fragment_blank) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scoped to the lifecycle of the fragment&#x27;s view (between onCreateView and onDestroyView)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> fragmentBlankBinding: FragmentBlankBinding? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> binding = FragmentBlankBinding.bind(view)</span><br><span class="line">        fragmentBlankBinding = binding</span><br><span class="line">        binding.textViewFragment.text = getString(string.hello_from_vb_bindfragment)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Consider not storing the binding instance in a field, if not needed.</span></span><br><span class="line">        fragmentBlankBinding = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위 코드는 인플레이션을 위해 <a href="https://developer.android.com/reference/androidx/fragment/app/Fragment#Fragment(int)">Alternate constructor</a>를 사용하고 <code>onViewCreated</code>를 바인딩에 사용하는 프래그먼트의 뷰 바인딩 예시이다. 레이아웃이 이미 인플레이트 되었기에 바로 바인딩 클래스의 static <code>bind()</code> 메서드를 호출하면 된다.</li></ul><h2 id="additional-resources"><a class="markdownIt-Anchor" href="#additional-resources"></a> Additional resources</h2><h3 id="samples"><a class="markdownIt-Anchor" href="#samples"></a> Samples</h3><ul><li><a href="https://github.com/android/architecture-components-samples/tree/main/ViewBindingSample">View binding sample</a></li></ul><h3 id="blogs"><a class="markdownIt-Anchor" href="#blogs"></a> Blogs</h3><ul><li><a href="https://medium.com/androiddevelopers/use-view-binding-to-replace-findviewbyid-c83942471fc">Use view binding to replace findViewById</a></li><li><a href="https://betterprogramming.pub/why-are-kotlin-synthetics-deprecated-and-what-are-the-alternatives-5c2b087dda1c">Why Are Kotlin Synthetics Deprecated and What Are the Alternatives?</a></li></ul><h3 id="videos"><a class="markdownIt-Anchor" href="#videos"></a> Videos</h3><ul><li><a href="https://www.youtube.com/watch?v=W7uujFrljW0">Android Jetpack: Replace findViewById with view binding</a></li></ul><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li>Android Docs - View Binding : <a href="https://developer.android.com/topic/libraries/view-binding">https://developer.android.com/topic/libraries/view-binding</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Documentation/">Documentation</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Data-Binding/">Data Binding</category>
      
      <category domain="http://june0122.github.io/tags/View-Binding/">View Binding</category>
      
      <category domain="http://june0122.github.io/tags/findViewById/">findViewById</category>
      
      
      <comments>http://june0122.github.io/2021/07/24/android-docs-view-binding/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 15649번 : N과 M</title>
      <link>http://june0122.github.io/2021/07/23/boj-15649/</link>
      <guid>http://june0122.github.io/2021/07/23/boj-15649/</guid>
      <pubDate>Fri, 23 Jul 2021 12:33:37 GMT</pubDate>
      
      <description>[백트래킹] 백준 알고리즘 15649번, N과 M</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/15649">문제 보기</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> arr = IntArray(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> isUsed = BooleanArray(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    m = nextInt()</span><br><span class="line">    backTrack(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">backTrack</span><span class="params">(k : <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            print(<span class="string">&quot;<span class="subst">$&#123;arr[i]&#125;</span> &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> .. n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUsed[i].not()) &#123;</span><br><span class="line">            arr[k] = i</span><br><span class="line">            isUsed[i] = <span class="literal">true</span></span><br><span class="line">            backTrack(k+<span class="number">1</span>)</span><br><span class="line">            isUsed[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/">백트래킹</category>
      
      
      <comments>http://june0122.github.io/2021/07/23/boj-15649/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 2798번 : 블랙잭</title>
      <link>http://june0122.github.io/2021/07/23/boj-2798/</link>
      <guid>http://june0122.github.io/2021/07/23/boj-2798/</guid>
      <pubDate>Fri, 23 Jul 2021 12:33:37 GMT</pubDate>
      
      <description>[백트래킹] 백준 알고리즘 2798번, 블랙잭</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/2798">문제 보기</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> nums = IntArray(<span class="number">101</span>)</span><br><span class="line"><span class="keyword">val</span> visited = BooleanArray(<span class="number">101</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    m = nextInt()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        nums[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> arr = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    dfs(arr, <span class="number">0</span>)</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(arr: <span class="type">MutableList</span>&lt;<span class="type">Int</span>&gt;, count: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.sum() &lt;= m) result = max(result, arr.sum())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            visited[i] = <span class="literal">true</span></span><br><span class="line">            arr.add(nums[i])</span><br><span class="line">            dfs(arr, count + <span class="number">1</span>)</span><br><span class="line">            arr.removeAt(arr.size - <span class="number">1</span>)</span><br><span class="line">            visited[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>단순히 3중 for문을 이용하여 간단하게 해결할 수 있는 문제이지만 백트래킹에 익숙해지기 위해 위와 같이 풀이하였다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/">완전탐색</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/">백트래킹</category>
      
      
      <comments>http://june0122.github.io/2021/07/23/boj-2798/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 10819번 : 차이를 최대로</title>
      <link>http://june0122.github.io/2021/07/23/boj-10819/</link>
      <guid>http://june0122.github.io/2021/07/23/boj-10819/</guid>
      <pubDate>Fri, 23 Jul 2021 12:33:37 GMT</pubDate>
      
      <description>[백트래킹] 백준 알고리즘 10819번, 차이를 최대로</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/10819">문제 보기</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.abs</span><br><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> nums = IntArray(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> visited = BooleanArray(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        nums[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> arr = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    dfs(arr, <span class="number">0</span>)</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(arr: <span class="type">MutableList</span>&lt;<span class="type">Int</span>&gt;, count: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">        result = max(arr.value(), result)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            visited[i] = <span class="literal">true</span></span><br><span class="line">            arr.add(nums[i])</span><br><span class="line">            dfs(arr, count + <span class="number">1</span>)</span><br><span class="line">            arr.removeAt(arr.size - <span class="number">1</span>)</span><br><span class="line">            visited[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">value</span><span class="params">()</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span>) &#123;</span><br><span class="line">        sum += abs(<span class="keyword">this</span>[i] - <span class="keyword">this</span>[i + <span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/">백트래킹</category>
      
      
      <comments>http://june0122.github.io/2021/07/23/boj-10819/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 14889번 : 스타트와 링크</title>
      <link>http://june0122.github.io/2021/07/23/boj-14889/</link>
      <guid>http://june0122.github.io/2021/07/23/boj-14889/</guid>
      <pubDate>Fri, 23 Jul 2021 12:33:37 GMT</pubDate>
      
      <description>[백트래킹] 백준 알고리즘 14889번, 스타트와 링크</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/14889">문제 보기</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.abs</span><br><span class="line"><span class="keyword">import</span> kotlin.math.min</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> status: Array&lt;IntArray&gt;</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> visited: BooleanArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    status = Array(n) &#123; IntArray(n) &#125;</span><br><span class="line">    visited = BooleanArray(n)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">            status[i][j] = nextInt()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(index: <span class="type">Int</span>, count: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == n / <span class="number">2</span>) &#123;</span><br><span class="line">        statusGap()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> index until n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            visited[i] = <span class="literal">true</span></span><br><span class="line">            dfs(i + <span class="number">1</span>, count + <span class="number">1</span>)</span><br><span class="line">            visited[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">statusGap</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> startSum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> linkSum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] &amp;&amp; visited[j]) &#123;</span><br><span class="line">                startSum += status[i][j] + status[j][i]</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!visited[i] &amp;&amp; !visited[j]) &#123;</span><br><span class="line">                linkSum += status[i][j] + status[j][i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = min(result, abs(startSum - linkSum))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스타트 팀과 링크 팀을 구분 짓는 자료구조를 따로 선언하지 않고 BooleanArray인 <em>visited</em>의 값을 통해 구분하므로 dfs 함수의 첫 번째 인자로 <em>index</em>를 사용하였다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/">백트래킹</category>
      
      
      <comments>http://june0122.github.io/2021/07/23/boj-14889/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 2661번 : 좋은수열</title>
      <link>http://june0122.github.io/2021/07/23/boj-2661/</link>
      <guid>http://june0122.github.io/2021/07/23/boj-2661/</guid>
      <pubDate>Fri, 23 Jul 2021 12:33:37 GMT</pubDate>
      
      <description>[백트래킹] 백준 알고리즘 2661번, 좋은수열</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/2661">문제 보기</a></h2><h2 id="풀이"><a class="markdownIt-Anchor" href="#풀이"></a> 풀이</h2><p>백트래킹 문제이며 좋은 수열인지 나쁜 수열인지 검사하는 코드를 구현하는 것이 핵심이다.</p><p>문자열에서 동일한 요소의 중복은 요소의 길이가 <code>1 ~ N/2</code>의 범위에 있을 때만 발생한다.</p><p>백트래킹을 통해 수열을 늘려나가는 식이므로 맨 뒷자리를 기준으로</p><p>맨 뒤 <code>1</code>자리의 수가 그 앞의 <code>1</code>자리 수와 동일한지</p><p>맨 뒤 <code>2</code>자리의 수가 그 앞의 <code>2</code>자리 수와 동일한지</p><p>맨 뒤 <code>3</code>자리의 수가 그 앞의 <code>3</code>자리 수와 동일한지</p><p>맨 뒤 <code>4</code>자리의 수가 그 앞의 <code>4</code>자리 수와 동일한지</p><p>…</p><p>맨 뒤 <code>N/2</code>자리의 수가 그 앞의 <code>N/2</code>자리 수와 동일한지 비교하는 식으로</p><p>한 번이라도 동일한 경우가 발생한다면 그 수열은 나쁜 수열로 판단할 수 있다.</p><p>가장 첫 번째로 나오는 백트래킹 알고리즘의 결과가 결과값들 중 가장 작은 수이기 때문에 기본적인 백트래킹 문제들과 같이 만들어진 결과값들끼리 최대나 최소를 비교할 필요가 없다. 그렇기 때문에 프로세스를 종료하는 코드 혹은 플래그를 이용하는 코드가 사용이 된다.</p><p>가장 작은 수를 나타내는 수열을 구하는 것이기 때문에 첫 번째 자리는 무조건 1이 나온다. 그러므로 dfs의 첫 탐색 정점 기준을 <code>&quot;1&quot;</code>로 잡고 시작하는 것이 더 효율적인 코드이지만 쉬운 이해를 위해 <code>dfs(&quot;&quot;)</code>을 사용하였다.</p><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"><span class="keyword">import</span> kotlin.system.exitProcess</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    dfs(<span class="string">&quot;&quot;</span>) <span class="comment">// dfs(&quot;1&quot;)이 더 효율적</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length == n) &#123;</span><br><span class="line">        println(s)</span><br><span class="line">        exitProcess(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s + i).isGood()) &#123;</span><br><span class="line">            dfs(s + i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">isGood</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> len = <span class="keyword">this</span>.length / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.substring(<span class="keyword">this</span>.length - i) == <span class="keyword">this</span>.substring(<span class="keyword">this</span>.length - i * <span class="number">2</span>, <span class="keyword">this</span>.length - i))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자바에서 프로세스를 강제 종료하는 <code>System.exit(0)</code>는 코틀린에선 <code>exitProcess(0)</code>를 사용한다. 하지만 <code>exitProcess(0)</code>를 사용하면 <em>kotlin.system</em> 패키지를 import 해줘야하는 번거로움이 있기에 시간이 제한되고 긴장되는 코딩 테스트 환경에서는 아래 코드와 같이 플래그 변수를 사용하거나 자바의 <code>System.exit(0)</code>를 사용하는 것이 나을 수도 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> exit = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    dfs(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (exit) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.length == n) &#123;</span><br><span class="line">        println(s)</span><br><span class="line">        exit = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s + i).isGood()) &#123;</span><br><span class="line">            dfs(s + i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">isGood</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> len = <span class="keyword">this</span>.length / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.substring(<span class="keyword">this</span>.length - i) == <span class="keyword">this</span>.substring(<span class="keyword">this</span>.length - i * <span class="number">2</span>, <span class="keyword">this</span>.length - i))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li><a href="https://bellog.tistory.com/43">https://bellog.tistory.com/43</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/">백트래킹</category>
      
      
      <comments>http://june0122.github.io/2021/07/23/boj-2661/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 14888번 : 연산자 끼워넣기</title>
      <link>http://june0122.github.io/2021/07/23/boj-14888/</link>
      <guid>http://june0122.github.io/2021/07/23/boj-14888/</guid>
      <pubDate>Fri, 23 Jul 2021 12:33:37 GMT</pubDate>
      
      <description>[백트래킹] 백준 알고리즘 14888번, 연산자 끼워넣기</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://www.acmicpc.net/problem/14888">문제 보기</a></h2><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"><span class="keyword">import</span> kotlin.math.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> min = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> nums: IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> visit: BooleanArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> opers: MutableList&lt;String&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    nums = IntArray(n)</span><br><span class="line">    visit = BooleanArray(n - <span class="number">1</span>)</span><br><span class="line">    opers = mutableListOf()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        nums[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repeat(nextInt()) &#123; opers.add(<span class="string">&quot;+&quot;</span>) &#125;</span><br><span class="line">    repeat(nextInt()) &#123; opers.add(<span class="string">&quot;-&quot;</span>) &#125;</span><br><span class="line">    repeat(nextInt()) &#123; opers.add(<span class="string">&quot;*&quot;</span>) &#125;</span><br><span class="line">    repeat(nextInt()) &#123; opers.add(<span class="string">&quot;/&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    println(max)</span><br><span class="line">    println(min)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(comb: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (comb.length == n - <span class="number">1</span>) &#123;</span><br><span class="line">        min = min(min, comb.result())</span><br><span class="line">        max = max(max, comb.result())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visit[i]) <span class="keyword">continue</span></span><br><span class="line">        visit[i] = <span class="literal">true</span></span><br><span class="line">        dfs(comb + opers[i])</span><br><span class="line">        comb.removeRange(comb.length - <span class="number">1</span>, comb.length - <span class="number">1</span>)</span><br><span class="line">        visit[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">result</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span>) &#123;</span><br><span class="line">        temp = calc(temp, nums[i+<span class="number">1</span>], <span class="keyword">this</span>[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calc</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, c: <span class="type">Char</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> (c) &#123;</span><br><span class="line">        <span class="string">&#x27;+&#x27;</span> -&gt; a + b</span><br><span class="line">        <span class="string">&#x27;-&#x27;</span> -&gt; a - b</span><br><span class="line">        <span class="string">&#x27;*&#x27;</span> -&gt; a * b</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span> -&gt; a / b</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">메모리</th><th style="text-align:center">시간</th></tr></thead><tbody><tr><td style="text-align:center">304432 KB</td><td style="text-align:center">1548 ms</td></tr></tbody></table><blockquote></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"><span class="keyword">import</span> kotlin.math.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> min = <span class="built_in">Int</span>.MAX_VALUE</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Int</span>.MIN_VALUE</span><br><span class="line"><span class="keyword">val</span> opers = IntArray(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> nums: IntArray</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> visit: BooleanArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    n = nextInt()</span><br><span class="line">    nums = IntArray(n)</span><br><span class="line">    visit = BooleanArray(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        nums[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">        opers[i] = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(nums[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    println(max)</span><br><span class="line">    println(min)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(acc: <span class="type">Int</span>, count: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">        min = min(min, acc)</span><br><span class="line">        max = max(max, acc)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opers[i] &lt;= <span class="number">0</span>) <span class="keyword">continue</span></span><br><span class="line">        opers[i]--</span><br><span class="line">        dfs(calc(acc, nums[count], i), count + <span class="number">1</span>)</span><br><span class="line">        opers[i]++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calc</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, oper: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> (oper) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; a + b</span><br><span class="line">        <span class="number">1</span> -&gt; a - b</span><br><span class="line">        <span class="number">2</span> -&gt; a * b</span><br><span class="line">        <span class="number">3</span> -&gt; a / b</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">메모리</th><th style="text-align:center">시간</th></tr></thead><tbody><tr><td style="text-align:center">13684 KB</td><td style="text-align:center">140 ms</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/">백트래킹</category>
      
      
      <comments>http://june0122.github.io/2021/07/23/boj-14888/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[코틀린 자료구조] 트리 (Tree)</title>
      <link>http://june0122.github.io/2021/07/19/data-structure-trees/</link>
      <guid>http://june0122.github.io/2021/07/19/data-structure-trees/</guid>
      <pubDate>Mon, 19 Jul 2021 14:36:42 GMT</pubDate>
      
      <description>&lt;b&gt;트리&lt;small&gt;(tree)&lt;/small&gt;&lt;/b&gt;는 매우 중요한 자료구조로 다음과 같이 소프트웨어 개발에서 반복되는 많은 문제를 해결하는 데 사용한다.&lt;br&gt;① 계층적 관계를 표현 ② 정렬된 데이터 관리 ③ 빠른 조회 작업을 용이하게 함</description>
      
      
      
      <content:encoded><![CDATA[<p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125863597-4066759b-d019-421a-bcd4-f0383febe0d0.png'></p><p><b>트리<small>(tree)</small></b>는 매우 중요한 자료구조로 다음과 같이 소프트웨어 개발에서 반복되는 많은 문제를 해결하는 데 사용한다.</p><ul><li>계층적 관계를 표현</li><li>정렬된 데이터 관리</li><li>빠른 조회 작업을 용이하게 함</li></ul><h2 id="트리와-관련된-용어들smallterminologysmall"><a class="markdownIt-Anchor" href="#트리와-관련된-용어들smallterminologysmall"></a> 트리와 관련된 용어들<small>(Terminology)</small></h2><h3 id="노드smallnodesmall"><a class="markdownIt-Anchor" href="#노드smallnodesmall"></a> 노드<small>(Node)</small></h3><p>연결 리스트와 마찬가지로 트리도 노드로 구성된다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125863852-f54f02f7-560f-4037-8e11-db6f9ba137b7.png'></p><p>각 노드는 일부 데이터를 캡슐화하고 자식을 추적한다.</p><h3 id="부모와-자식smallparent-and-childsmall"><a class="markdownIt-Anchor" href="#부모와-자식smallparent-and-childsmall"></a> 부모와 자식<small>(Parent and child)</small></h3><p>트리는 거꾸로 뒤집힌 실제 나무처럼 위에서 시작하여 아래쪽으로 가지를 뻗어 나간다.</p><p>첫 번째 노드를 제외한 모든 노드는 <strong>부모</strong> 노드라고 하는 위의 단일 노드에 연결된다. 바로 아래에 있고 부모 노드에 연결된 노드를 <strong>자식</strong> 노드라 한다. 트리에서 모든 자식은 정확히 한 명의 부모를 가진다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125863863-bf9c778e-92b9-4b93-b44a-edf19b0a64af.png'></p><h3 id="뿌리smallrootsmall"><a class="markdownIt-Anchor" href="#뿌리smallrootsmall"></a> 뿌리<small>(Root)</small></h3><p>트리의 최상위 노드를 트리의 뿌리<small>(루트, root)</small>라고 한다. 부모가 없는 유일한 노드이기도 하다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125863874-acebca4c-f298-4ab9-b24e-10376320c968.png'></p><h3 id="잎smallleafsmall"><a class="markdownIt-Anchor" href="#잎smallleafsmall"></a> 잎<small>(Leaf)</small></h3><p>자식이 없는 노드를 리프라고 한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125863886-cfebea5d-2c3d-497c-9848-a1c709baa36c.png'></p><h2 id="구현"><a class="markdownIt-Anchor" href="#구현"></a> 구현</h2><p>트리는 노드로 구성되어 있으므로 제일 처음해야 할 작업은 TreeNode 클래스를 생성하는 것이다.</p><blockquote><p>TreeNode.kt</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> value: T) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> children: MutableList&lt;TreeNode&lt;T&gt;&gt; = mutableListOf()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 노드는 값을 담당하고 MutableList를 사용하여 모든 자식에 대한 참조를 저장한다.</p><p>다음으로 TreeNode 내부에 아래의 메서드를 추가하자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(child: <span class="type">TreeNode</span>&lt;<span class="type">T</span>&gt;)</span></span> = children.add(child)</span><br></pre></td></tr></table></figure><p>이 메서드는 노드에 자식 노드를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> hot = TreeNode(<span class="string">&quot;Hot&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> cold = TreeNode(<span class="string">&quot;Cold&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> beverages = TreeNode(<span class="string">&quot;Beverages&quot;</span>).run &#123;</span><br><span class="line">        add(hot)</span><br><span class="line">        add(cold)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>계층 구조는 트리 구조의 자연스러운 형태 중 하나이다. 위의 코드는 아래와 같은 구조를 가지고 있다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125865331-9c19532f-d417-4f64-88f0-91cd4314520f.png'></p><h2 id="traversal-algorithms"><a class="markdownIt-Anchor" href="#traversal-algorithms"></a> Traversal algorithms</h2><p>배열이나 리스트와 같은 <strong>선형 컬렉션</strong>을 반복<small>(iterating)</small>하는 것은 간단하다. 선형 컬렉션에는 명확한 시작과 끝이 있다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125865349-410b60ee-2e18-41ea-b07c-05d8f3939925.png'></p><p>트리를 반복하는 것은 조금 더 복잡하다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125865353-3a4a0fec-6f60-42d7-8165-cdee3b7d6ddb.png'></p><p>왼쪽에 있는 노드가 우선 순위를 가져야 할까? 노드의 깊이는 우선 순위와 어떤 관련이 있을까? 순회 전략은 해결하려는 문제에 따라 다르게 가져가야 한다.</p><p>서로 다른 트리와 문제에 대해 여러 전략이 존재한다. 이 모든 방법은 노드를 <strong>방문</strong>하고 노드 내부의 정보를 사용할 수 있게 해준다.</p><blockquote><p>TreeNode 클래스의 외부에 정의 추가</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Visitor&lt;T&gt; = (TreeNode&lt;T&gt;) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> value: T) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="depth-first-traversalsmalldepth-first-search-dfs-깊이-우선-탐색small"><a class="markdownIt-Anchor" href="#depth-first-traversalsmalldepth-first-search-dfs-깊이-우선-탐색small"></a> Depth-first traversal<small>(Depth-first search, DFS, 깊이 우선 탐색)</small></h3><p>깊이 우선 탐색은 루트 노드에서 시작하여 리프에 도달한 다음 백트래킹하기 전에 각 분기를 따라 가능한 멀리 트리를 탐색한다.</p><p>TreeNode 내부에 다음을 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">forEachDepthFirst</span><span class="params">(visit: <span class="type">Visitor</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    visit(<span class="keyword">this</span>)</span><br><span class="line">    children.forEach &#123; </span><br><span class="line">        it.forEachDepthFirst(visit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 간단한 코드는 재귀를 사용하여 다음 노드를 처리한다.</p><p>재귀적인 구현을 사용하지 않으려면 스택을 사용할 수 있으나 재귀를 이용한 방법이 더 간단하다.</p><blockquote><p>재귀 깊이 우선 탐색 테스트</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">makeBeverageTree</span><span class="params">()</span></span>: TreeNode&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> tree = TreeNode(<span class="string">&quot;Beverages&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> hot = TreeNode(<span class="string">&quot;hot&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> cold = TreeNode(<span class="string">&quot;cold&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> tea = TreeNode(<span class="string">&quot;tea&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> coffee = TreeNode(<span class="string">&quot;coffee&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> chocolate = TreeNode(<span class="string">&quot;cocoa&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> blackTea = TreeNode(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> greenTea = TreeNode(<span class="string">&quot;green&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> chaiTea = TreeNode(<span class="string">&quot;chai&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> soda = TreeNode(<span class="string">&quot;soda&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> milk = TreeNode(<span class="string">&quot;milk&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> gingerAle = TreeNode(<span class="string">&quot;ginger ale&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> bitterLemon = TreeNode(<span class="string">&quot;bitter lemon&quot;</span>)</span><br><span class="line">    tree.add(hot)</span><br><span class="line">    tree.add(cold)</span><br><span class="line">    hot.add(tea)</span><br><span class="line">    hot.add(coffee)</span><br><span class="line">    hot.add(chocolate)</span><br><span class="line">    cold.add(soda)</span><br><span class="line">    cold.add(milk)</span><br><span class="line">    tea.add(blackTea)</span><br><span class="line">    tea.add(greenTea)</span><br><span class="line">    tea.add(chaiTea)</span><br><span class="line">    soda.add(gingerAle)</span><br><span class="line">    soda.add(bitterLemon)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>makeBeverageTree()</code>는 아래와 같은 트리를 생성한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125865366-20b030f5-3cee-472f-b095-2d50ba7e7151.png'></p><p>트리를 생성한 다음 <code>main()</code>에서 다음과 같은 코드를 실행한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tree = makeBeverageTree()</span><br><span class="line">    tree.forEachDepthFirst &#123; println(it.value) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드의 출력 결과는 깊이 우선 탐색이 각 노드를 방문하는 순서를 보여준다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Beverages</span><br><span class="line">hot</span><br><span class="line">tea</span><br><span class="line">black</span><br><span class="line">green</span><br><span class="line">chai</span><br><span class="line">coffee</span><br><span class="line">cocoa</span><br><span class="line">cold</span><br><span class="line">soda</span><br><span class="line">ginger ale</span><br><span class="line">bitter lemon</span><br><span class="line">milk</span><br></pre></td></tr></table></figure><h3 id="level-order-traversal"><a class="markdownIt-Anchor" href="#level-order-traversal"></a> Level-order traversal</h3><p>Level-order traversal은 노드의 깊이를 기반으로 트리의 각 노드를 방문하는 방법이다. 루트에서 시작하여 하위 레벨로 이동하기 전에 같은 레벨의 모든 노드를 방문한다.</p><p>TreeNode 내부에 다음을 추가한다.</p><blockquote><p><a href="https://github.com/june0122/DataStructureKotlin/tree/master/src/queue">직접 구현한 Queue</a>를 사용할 시</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">forEachLevelOrder</span><span class="params">(visit: <span class="type">Visitor</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    visit(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">val</span> queue = StackQueue&lt;TreeNode&lt;T&gt;&gt;()</span><br><span class="line">    children.forEach &#123; queue.enqueue(it) &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> node = queue.dequeue()</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        visit(node)</span><br><span class="line">        node.children.forEach &#123; queue.enqueue(it) &#125;</span><br><span class="line">        node = queue.dequeue()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>java.util 패키지 내부의 Queue 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">forEachLevelOrder</span><span class="params">(visit: <span class="type">Visitor</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    visit(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;TreeNode&lt;T&gt;&gt; = LinkedList()</span><br><span class="line">    children.forEach &#123; queue.offer(it) &#125;</span><br><span class="line">    <span class="keyword">var</span> node = queue.poll()</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        visit(node)</span><br><span class="line">        node.children.forEach &#123; queue.offer(it) &#125;</span><br><span class="line">        node = queue.poll()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>forEachLevelOrder()</code>는 각 노드를 레벨 순으로 방문한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125865372-a74a4353-1568-422f-ac6c-9abf96f4d858.png'></p><p>노드가 올바른 레벨 순서로 방문되도록 큐를 사용하는 방법에 유의한다. 현재 노드를 방문하여 모든 자식을 큐에 넣는다. 그런 다음 비어 있을 때까지 큐를 사용하기 시작한다. 노드를 방문할 때마다 노드의 모든 자식들도 큐에 넣는다. 이렇게 하면 같은 레벨의 모든 노드를 차례로 방문할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> tree = makeBeverageTree()</span><br><span class="line">  tree.forEachLevelOrder &#123; println(it.value) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">beverages</span><br><span class="line">hot</span><br><span class="line">cold</span><br><span class="line">tea</span><br><span class="line">coffee</span><br><span class="line">cocoa</span><br><span class="line">soda</span><br><span class="line">milk</span><br><span class="line">black</span><br><span class="line">green</span><br><span class="line">chai</span><br><span class="line">ginger ale</span><br><span class="line">bitter lemon</span><br></pre></td></tr></table></figure><h3 id="검색"><a class="markdownIt-Anchor" href="#검색"></a> 검색</h3><p>노드를 반복하는 메서드를 이미 구현했으므로 검색 알고리즘을 구현하는데 오래 걸리지 않는다.</p><p>TreeNode 내부에 아래의 코드를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">search</span><span class="params">(value: <span class="type">T</span>)</span></span>: TreeNode&lt;T&gt;? &#123;</span><br><span class="line">    <span class="keyword">var</span> result: TreeNode&lt;T&gt;? = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    forEachLevelOrder &#123; </span><br><span class="line">        <span class="keyword">if</span> (it.value == value) &#123;</span><br><span class="line">            result = it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드를 테스트하기 위해 <code>main()</code>에 아래의 코드를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tree = makeBeverageTree()</span><br><span class="line">    tree.search(<span class="string">&quot;ginger ale&quot;</span>)?.let &#123;</span><br><span class="line">        println(<span class="string">&quot;Found node: <span class="subst">$&#123;it.value&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tree.search(<span class="string">&quot;WKD Blue&quot;</span>)?.let &#123;</span><br><span class="line">        println(it.value)</span><br><span class="line">    &#125; ?: println(<span class="string">&quot;Couldn&#x27;t find WKD Blue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main()</code>을 실행하면 다음과 같은 출력 결과를 볼 수 있다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Found node: ginger ale</span><br><span class="line">Couldn&#x27;t find WKD Blue</span><br></pre></td></tr></table></figure><p>위에서 level-order traversal 알고리즘을 사용했는데, 모든 노드를 방문하기 때문에 일치하는 항목이 여러 개일 경우 마지막으로 일치하는 항목이 채택된다. 이것은 사용하는 순회 방법에 따라 다른 객체를 얻을 수 있음을 의미한다.</p><h2 id="챌린지"><a class="markdownIt-Anchor" href="#챌린지"></a> 챌린지</h2><p>아래 트리의 값을 레벨에 따라 순서대로 출력하시오. 같은 레벨에 속하는 노드는 같은 줄에 출력해야 합니다.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/126172924-394314ff-9136-4639-bd29-65e1615d6edb.png'></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">17</span> <span class="number">20</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">0</span> <span class="number">2</span> <span class="number">5</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><blockquote><p>예제 트리 생성 코드</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">makeSampleTree</span><span class="params">()</span></span>: TreeNode&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> tree = TreeNode(<span class="number">15</span>)</span><br><span class="line">    <span class="keyword">val</span> one = TreeNode(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> seventeen = TreeNode(<span class="number">17</span>)</span><br><span class="line">    <span class="keyword">val</span> twenty = TreeNode(<span class="number">20</span>)</span><br><span class="line">    tree.add(one)</span><br><span class="line">    tree.add(seventeen)</span><br><span class="line">    tree.add(twenty)</span><br><span class="line">    one.add(TreeNode(<span class="number">1</span>))</span><br><span class="line">    one.add(TreeNode(<span class="number">5</span>))</span><br><span class="line">    one.add(TreeNode(<span class="number">0</span>))</span><br><span class="line">    seventeen.add(TreeNode(<span class="number">2</span>))</span><br><span class="line">    twenty.add(TreeNode(<span class="number">5</span>))</span><br><span class="line">    twenty.add(TreeNode(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>레벨 별 노드 출력 코드 (java.util 패키지 내부의 Queue 사용)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printEachLevel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;TreeNode&lt;T&gt;&gt; = LinkedList()</span><br><span class="line">    <span class="keyword">var</span> nodesLeftInCurrentLevel = <span class="number">0</span></span><br><span class="line">    queue.offer(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        nodesLeftInCurrentLevel = queue.size</span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">while</span> (nodesLeftInCurrentLevel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.poll()</span><br><span class="line">            node?.let &#123;</span><br><span class="line">                print(<span class="string">&quot;<span class="subst">$&#123;node.value&#125;</span> &quot;</span>)</span><br><span class="line">                node.children.forEach &#123; queue.offer(it) &#125;</span><br><span class="line">                nodesLeftInCurrentLevel--</span><br><span class="line">            &#125; ?: <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>레벨 별 노드 출력 코드 (<a href="https://github.com/june0122/DataStructureKotlin/tree/master/src/queue">직접 구현한 Queue</a>를 사용)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printEachLevel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">val</span> queue = StackQueue&lt;TreeNode&lt;T&gt;&gt;()</span><br><span class="line">    <span class="keyword">var</span> nodesLeftInCurrentLevel = <span class="number">0</span></span><br><span class="line">    queue.enqueue(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty.not()) &#123;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        nodesLeftInCurrentLevel = queue.count</span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">while</span> (nodesLeftInCurrentLevel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> node = queue.dequeue()</span><br><span class="line">            node?.let &#123;</span><br><span class="line">                print(<span class="string">&quot;<span class="subst">$&#123;node.value&#125;</span> &quot;</span>)</span><br><span class="line">                node.children.forEach &#123; queue.enqueue(it) &#125;</span><br><span class="line">                nodesLeftInCurrentLevel--</span><br><span class="line">            &#125; ?: <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>레벨 순서 순회를 용이하게 하기 위해 큐를 초기화하는 것으로 시작한다. 또한 새 줄을 출력하기 전에 작업해야하는 노드의 수를 추적하기 위해 <em>nodesLeftInCurrentLevel</em>을 만든다.</li><li>레벨 순서 순회는 큐가 빌 때까지 계속된다.</li><li>첫 번째 while 루프 내에서 <em>nodesLeftInCurrentLevel</em>을 큐의 현재 요소로 설정하여 시작한다.</li><li>다른 while 루프를 사용하여 <em>nodesLeftInCurrentLevel</em>의 수만큼 큐에서 요소를 빼낸다. 큐에서 빼는 모든 요소는 다음 줄로 넘어가지 않고 출력되며, 노드의 모든 자식을 큐에 넣는다.</li><li>이 시점에서 <code>println()</code>을 사용하여 새 줄을 생성한다. 다음 반복에서 <em>nodesLeftInCurrentLevel</em>은 이전 반복의 자식 수를 나타내는 <em>queue.count</em>로 업데이트된다.</li></ol><h2 id="요약"><a class="markdownIt-Anchor" href="#요약"></a> 요약</h2><ul><li>트리는 연결 리스트와 몇 가지 유사점을 공유한다. 그러나 트리의 노드는 무한히 많은 노드에 연결할 수 있는 반면 연결 리스트의 노드는 하나의 다른 노드에만 연결할 수 있다.</li><li>깊이 우선 및 레벨 순서 순회는 일반적인 유형의 트리에만 국한되지 않는다. 트리 구조에 따라 구현이 약간 다르지만 다른 유형의 트리에서도 작동할 수 있다.</li></ul><br><div style="text-align: right"> <a href="https://github.com/june0122/DataStructureKotlin/tree/master/src/tree"><b><i>Github에서 본문의 코드 확인하기 </div><br><div style="text-align: right"> <a href="https://www.raywenderlich.com/books/data-structures-algorithms-in-kotlin/v1.0"><b><i>Data Structures & Algorithms in Kotlin</i></b></a> 서적을 참고하여 작성했습니다. </div>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Data-Structure/">Data Structure</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Data-Structure/">Data Structure</category>
      
      <category domain="http://june0122.github.io/tags/Tree/">Tree</category>
      
      
      <comments>http://june0122.github.io/2021/07/19/data-structure-trees/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[코틀린 자료구조] 큐 (Queue)</title>
      <link>http://june0122.github.io/2021/07/16/data-structure-queue/</link>
      <guid>http://june0122.github.io/2021/07/16/data-structure-queue/</guid>
      <pubDate>Thu, 15 Jul 2021 21:53:06 GMT</pubDate>
      
      <description>우리는 모두 줄을 서서 기다리는 것에 익숙하다. 좋아하는 영화의 티켓을 구매하기 위해 줄을 서는 것과 같은 실생활의 예시들은 &lt;b&gt;큐&lt;small&gt;(Queue)&lt;/small&gt;&lt;/b&gt; 자료구조를 모방한다. 큐는 &lt;b&gt;FIFO&lt;small&gt;(first in, first out)&lt;/small&gt;&lt;/b&gt;의 형태로, 처음 추가된 요소가 제일 먼저 제거되는 요소가 된다. 큐는 나중에 처리할 요소의 순서를 유지해야 할 때 편리하다.</description>
      
      
      
      <content:encoded><![CDATA[<p>우리는 모두 줄을 서서 기다리는 것에 익숙하다. 좋아하는 영화의 티켓을 구매하기 위해 줄을 서는 것과 같은 실생활의 예시들은 <b>큐<small>(Queue)</small></b> 자료구조를 모방한다.</p><p>큐는 <b>FIFO<small>(first in, first out)</small></b>의 형태로, 처음 추가된 요소가 제일 먼저 제거되는 요소가 된다. 큐는 나중에 처리할 요소의 순서를 유지해야 할 때 편리하다.</p><h2 id="큐의-일반적인-연산들"><a class="markdownIt-Anchor" href="#큐의-일반적인-연산들"></a> 큐의 일반적인 연산들</h2><p>먼저 큐에 대한 인터페이스를 설정한다. base 패키지 내부에 Queue.kt라는 파일을 만들고 Queue 인터페이스를 정의하는 다음 코드를 추가한다.</p><blockquote><p>큐 인터페이스 정의 (base/Queue.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="type">T : Any</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: T?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = count == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제부터 구현하는 모든 것은 큐의 핵심 작업을 설명하는 위의 인터페이스의 규약을 따른다.</p><p>큐의 핵심 연산들은 다음과 같다.</p><ul><li><code>enqueue</code> : <b>대기열<small>(queue)</small></b>의 뒤에 요소를 삽입하고 연산이 성공하면 true를 반환한다.</li><li><code>dequeue</code> : 대기열의 맨 앞 요소를 제거하고 반환한다.</li><li><code>isEmpty</code> : <em>count</em> 속성을 사용하여 대기열이 비어있는지 확인한다.</li><li><code>peek</code> : 대기열의 맨 앞에 있는 요소를 제거하지 않고 값만 반환한다.</li></ul><p>큐는 앞쪽에서 제거하고 뒤쪽에서 삽입하는 것에만 관심이 있다. 그 사이에 내용이 무엇인지 알 필요가 없다.</p><h2 id="큐의-이해"><a class="markdownIt-Anchor" href="#큐의-이해"></a> 큐의 이해</h2><p>큐의 작동 방식을 이해하는 가장 쉬운 방법은 작동 예제를 보는 것이다. 영화 티켓을 위해 줄을 서서 기다리는 사람들을 상상해보자.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/124502496-9370b180-ddfe-11eb-8e2d-4841fcb3d2ef.png'></p><p>이 대기열에는 현재 Ray, Brian, Sam 및 Mic이 있다. Ray는 티켓을 받으면 줄에서 나간다. <code>dequeue()</code>를 호출하면 Ray가 대기열의 앞쪽에서 제거된다.</p><p><code>peek()</code>을 호출하면 Brian이 현재 맨앞에 있기 때문에 Brian이 반환된다.</p><p>이제 막 표를 사기 위해 비키가 줄에 합류한다. <code>enqueue(&quot;Vicki&quot;)</code>를 호출하면 Vicki가 대기열 뒤에 추가된다.</p><h2 id="큐의-구현-방법들"><a class="markdownIt-Anchor" href="#큐의-구현-방법들"></a> 큐의 구현 방법들</h2><p>본문에선 네 가지 방법의 큐 구현 방법들을 알아본다.</p><ol><li>배열 기반 리스트<small>(array based list)</small> 사용</li><li>이중 연결 리스트<small>(doubly linked list)</small> 사용</li><li>ring buffer 사용</li><li>두 개의 스택 사용</li></ol><h3 id="1-리스트-기반-구현"><a class="markdownIt-Anchor" href="#1-리스트-기반-구현"></a> 1. 리스트 기반 구현</h3><p>코틀린 표준 라이브러리에는 더 높은 수준의 추상화를 구축하는데 사용할 수 있는 고도로 최적화된 자료구조의 핵심 세트가 함께 제공된다. 이들 중 하나가 연속적이고<small>(contiguous)</small> 정렬된 요소들의 리스트를 저장하는 자료구조인 <strong>ArrayList</strong>이다. ArrayList를 이용해서 큐를 구현해보자.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124503376-67563000-de00-11eb-9be3-0bb2fcff0246.png'></p><p>list 패키지 내부에 ArrayListQueue.kt 파일을 생성하고 아래의 코드를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayListQueue</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">Queue</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> list = arrayListOf&lt;T&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Queue 인터페이스를 구현하는 제네릭 ArrayListQueue 클래스를 정의했다. 인터페이스 구현은 저장하는 요소에 대해 동일한 제네릭 타입인 <code>T</code>를 사용한다.</p><p>다음으로 ArrayListQueue 구현을 완료하여 Queue 인터페이스의 규약을 만족시키자.</p><h4 id="arraylist-활용"><a class="markdownIt-Anchor" href="#arraylist-활용"></a> ArrayList 활용</h4><p>ArrayListQueue 클래스에 다음 코드를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayListQueue</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">Queue</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = list.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T? = list.getOrNull(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList의 기능들을 사용하면 다음을 간단히 구현할 수 있다.</p><ol><li>리스트의 동일한 속성을 사용하여 큐의 크기를 가져온다.</li><li>큐의 맨 앞에 요소가 존재한다면 값을 반환한다.</li></ol><p>이 연산들은 모두 *O(1)*이다.</p><h4 id="enqueue"><a class="markdownIt-Anchor" href="#enqueue"></a> Enqueue</h4><p>큐의 뒤에 요소를 추가하는 것은 간단하다. ArrayList의 끝에 요소를 추가하기만 하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    list.add(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>리스트의 크기에 관계없이 요소를 큐에 추가하는 것은 <em>O(1)</em> 연산이다. 리스트 뒤에 빈 공간이 있기 때문이다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124504495-9077c000-de02-11eb-8719-55521aae5db3.png'></p><p>위의 예시에서 Mic를 추가하면 리스트에 두 개의 빈 공간이 있다.</p><p>여러 요소를 추가한 후에는 ArrayList 내부 배열이 결국 가득 차게 된다. 할당된 공간보다 더 많이 사용하려면 추가 공간을 만들기 위해 배열의 크기를 조정해야만 한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124504497-92418380-de02-11eb-8ad1-392ae7528963.png'></p><p>크기 조정<small>(resizing)</small>은 <em>O(n)</em> 연산이다. 크기를 조정하려면 리스트에서 새 메모리를 할당하고 기존의 모든 데이터를 새 리스트에 복사해야 한다. 매번 크기를 두 배로 늘리는 덕분에 자주는 발생하지 않으며, 시간 복잡도는 여전히 <a href = "https://stackoverflow.com/a/249695"><i>Amortized O(1)</i></a>으로 동작한다.</p><h4 id="dequeue"><a class="markdownIt-Anchor" href="#dequeue"></a> Dequeue</h4><p>전면에서 항목<small>(item)</small>을 제거하려면 약간 더 많은 작업이 필요하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: T? = </span><br><span class="line">    <span class="keyword">if</span> (isEmpty) <span class="literal">null</span> <span class="keyword">else</span> list.removeAt(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>큐가 비어 있으면 <code>dequeue()</code>는 단순히 null을 반환한다. 그렇지 않다면 리스트의 맨 앞에서 요소를 제거하고 반환한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124504501-94a3dd80-de02-11eb-9b82-9818df31bf7d.png'></p><p>큐의 전면에서 요소를 제거하는 연산은 <em>O(n)</em> 시간 복잡도를 가진다. 대기열에서 요소를 제거하려면 리스트 시작 부분에서 요소를 제거해야 한다. 리스트의 나머지 모든 요소를 메모리에서 이동시켜야하므로 항상 선형 시간<small>(Linear time, O(n))</small>의 연산이다.</p><h4 id="테스트"><a class="markdownIt-Anchor" href="#테스트"></a> 테스트</h4><p>디버깅을 위해 구현한 큐가 <code>toString()</code>을 재정의하도록 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = list.toString()</span><br></pre></td></tr></table></figure><p>이제 구현한 큐를 직접 사용해보도록 하자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = ArrayListQueue&lt;String&gt;().apply &#123;</span><br><span class="line">        enqueue(<span class="string">&quot;Ray&quot;</span>)</span><br><span class="line">        enqueue(<span class="string">&quot;Brian&quot;</span>)</span><br><span class="line">        enqueue(<span class="string">&quot;Eric&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    println(queue)</span><br><span class="line">    println(<span class="string">&quot;Next up: <span class="subst">$&#123;queue.peek()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Ray, Brian, Eric]</span><br><span class="line">[Brian, Eric]</span><br><span class="line">Next up: Brian</span><br></pre></td></tr></table></figure><p>이 코드는 Ray, Brian 및 Eric을 큐에 넣는다<small>(<code>enqueue</code>)</small>. 그런 다음 Ray를 제거하고<small>(<code>dequeue()</code>)</small> Brian을 들여다 보지만 제거하지는 않는다<small>(<code>peek()</code>)</small>.</p><h4 id="장점과-단점"><a class="markdownIt-Anchor" href="#장점과-단점"></a> 장점과 단점</h4><p>다음은 ArrayList 기반 큐 구현의 알고리즘 및 복잡도에 대해 요약하고 있다. 대부분의 작업은 선형 시간이 걸리는 <code>dequeue()</code>를 제외하고는 상수 시간을 가진다. 공간 복잡도는 <em>O(n)</em> 이다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124506381-7344f080-de06-11eb-963b-0c16e0146195.png'></p><p>Kotlin ArrayList를 활용하여 리스트 기반 큐를 간단하게 구현하였다. <em>O(1)</em> 추가 연산 덕분에 큐에 넣는 것이 매우 빠르다.</p><p>하지만 이 구현에는 몇 가지 단점들이 있다. 항목을 제거하면 모든 요소가 하나씩 이동하므로 큐에서 항목을 제거하는 것은 비효율적일 수 있다. 이것은 매우 큰 큐에서 차이를 만든다. 리스트가 가득 차면 크기를 조정해야 하며 사용하지 않는 공간이 있을 수 있다. 이것은 시간이 지남에 따라 메모리 사용량을 증가시킬 수 있다. 이러한 단점을 어떻게 해결할 수 있을까? 연결 리스트 기반 구현을 살펴보고 ArrayListQueue와 비교해보도록 하자.</p><h3 id="2-이중-연결-리스트smalldoubly-linked-listsmall-기반-구현"><a class="markdownIt-Anchor" href="#2-이중-연결-리스트smalldoubly-linked-listsmall-기반-구현"></a> 2. 이중 연결 리스트<small>(doubly linked list)</small> 기반 구현</h3><p>linkedlist 패키지 내부에 LinkedListQueue.kt 파일을 생성한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">Queue</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> list = DoublyLinkedList&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 구현은 <strong>ArrayListQueue</strong>와 유사하지만 <strong>ArrayList</strong> 대신 <strong>DoublyLinkedList</strong>를 생성한다.</p><p>DoublyLinkedList가 제공하지 않는 <em>count</em> 속성 아래로 Queue 인터페이스의 구현을 시작한다.</p><h4 id="enqueue-2"><a class="markdownIt-Anchor" href="#enqueue-2"></a> Enqueue</h4><p>큐의 뒤에 요소를 추가하기 위해 아래의 코드를 작성한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    list.append(element)</span><br><span class="line">    size += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124506865-80161400-de07-11eb-841b-a5acb773c7a8.png'></p><p>이중 연결 리스트는 내부에서 새 노드에 대한 꼬리 노드의 이전<small>(prev)</small> 및 다음<small>(next)</small> 참조를 업데이트하고 크기를 늘린다. 이 과정은 <em>O(1)</em> 연산이다.</p><h4 id="dequeue-2"><a class="markdownIt-Anchor" href="#dequeue-2"></a> Dequeue</h4><p>큐에서 요소를 제거하기 위해서 아래의 코드를 추가한다.</p><blockquote><p>간단한 구현</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: T? = list.pop()</span><br></pre></td></tr></table></figure><p>원서는 DoublyLinkedList에 대한 코드가 제공되지 않은 상태에서 위의 코드를 예시로 들어놓았는데, 직접 구현한 LinkedList를 기반으로 Queue를 구현한다면 <code>dequeue()</code>를 리스트에서 첫 번째 노드를 제거하는 메서드를 호출하는 것으로 간단히 구현할 수 있다.</p><blockquote><p>원서의 코드</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">  <span class="keyword">val</span> firstNode = list.first ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  size--</span><br><span class="line">  <span class="keyword">return</span> list.remove(firstNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>원서의 코드는 큐의 첫 번째 요소가 존재하는지 확인하고 존재하지 않는다면 null을 반환한다. 큐에 첫 번째 요소가 존재한다면 맨 앞에 있는 요소를 제거하고 이를 반환한다. 크기도 감소한다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124506868-81dfd780-de07-11eb-875b-2bb97909b55f.png'></p><p>리스트 맨 앞을 제거하는 것 또한 <em>O(1)</em> 연산이다. ArrayList 구현과 비교할 때 요소를 하나씩 이동할 필요가 없는 대신, 위의 이미지처럼 연결 리스트의 처음 두 노드 사이의 전<small>(prev)</small> 및 다음<small>(next)</small> 포인터를 업데이트하기만 하면 된다.</p><h4 id="peek"><a class="markdownIt-Anchor" href="#peek"></a> Peek</h4><p>ArrayList 기반 구현과 유사하게, DoublyLinkedList의 속성을 이용하여 <code>peek()</code>을 간단히 구현할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T? = list.first?.value</span><br></pre></td></tr></table></figure><h4 id="테스트-2"><a class="markdownIt-Anchor" href="#테스트-2"></a> 테스트</h4><p>디버깅을 위해 아래의 코드를 클래스에 추가하고 테스트 해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = list.toString()</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedListQueue&lt;String&gt;().apply &#123;</span><br><span class="line">    enqueue(<span class="string">&quot;Ray&quot;</span>)</span><br><span class="line">    enqueue(<span class="string">&quot;Brian&quot;</span>)</span><br><span class="line">    enqueue(<span class="string">&quot;Eric&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    println(queue)</span><br><span class="line">    println(<span class="string">&quot;Next up: <span class="subst">$&#123;queue.peek()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 테스트 코드는 ArrayListQueue 구현과 동일한 결과를 생성한다.</p><h4 id="장점과-단점-2"><a class="markdownIt-Anchor" href="#장점과-단점-2"></a> 장점과 단점</h4><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124506871-84423180-de07-11eb-8b5b-ae09b51587b4.png'></p><p>ArrayListQueue의 주요 문제점 중 하나는 항목을 대기열에서 빼는데 <i>O(n)</i>이 걸리는 것이다. 연결 리스트 구현을 통해 노드의 이전 및 다음 포인터를 업데이트하는 것만으로 시간 복잡도를 <i>O(1)</i>으로 축소시켰다.</p><p>LinkedListQueue의 주요 단점은 위의 표에서 분명하게 나타나지 않는다. <i>O(1)</i> 성능에도 불구하고 높은 오버헤드가 존재하는데, 각 요소는 이전과 다음의 참조를 위한 추가 공간이 있어야 한다<small>(공간 복잡도 증가)</small>. 또한 새 요소를 만들 때마다 상대적으로 비용이 많이 드는 동적 할당이 필요하다. 이에 비해, ArrayListQueue는 더 빠른 대량 할당을 수행한다.</p><p>할당에 대한 오버헤드를 제거하고 <i>O(1)</i>의 dequeue를 유지할 수 있을까? 큐가 고정된 크기 이상으로 커지는 것에 대해 걱정할 필요가 없는 경우 <strong>링 버퍼</strong>와 같은 다른 접근 방식을 사용할 수 있다. 예를 들어, 5명의 플레이어가 참여하는 모노폴리 게임에 링 버퍼를 기반으로 한 큐를 사용하여 다음에 올 차례를 추적할 수 있다. 다음으로 링 버퍼 구현을 살펴보자.</p><h3 id="3-링-버퍼smallring-buffersmall-기반-구현"><a class="markdownIt-Anchor" href="#3-링-버퍼smallring-buffersmall-기반-구현"></a> 3. 링 버퍼<small>(Ring Buffer)</small> 기반 구현</h3><p>원형 버퍼<small>(circular buffer)</small>라고도 불리는 링 버퍼<small>(ring buffer)</small>는 고정 크기 배열이다. 이 자료구조는 마지막에 제거할 항목이 없을 때 시작 부분으로 래핑된다.</p><p>링 버퍼를 사용하여 큐를 구현하는 방법에 대한 간단한 예를 아래의 이미지들로 살펴보자.</p><blockquote><p>링 버퍼 생성</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/124657417-72cb5900-dedd-11eb-83e7-d1347a5734db.png'></p><p>먼저 고정 크기가 4인 링 버퍼를 만든다. 링 버퍼에는 두 개의 포인터가 존재한다.</p><ol><li>읽기<small>(read)</small> 포인터 : 큐의 앞쪽을 추적</li><li>쓰기<small>(write)</small> 포인터 : 사용 가능한 다음 칸을 추적하여 이미 읽어 들인 기존 요소를 재정의할 수 있다.</li></ol><blockquote><p>대기열에 항목 추가</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/124657442-7828a380-dedd-11eb-9b9e-81cb4ceefc91.png'></p><p>대기열에 항목을 추가할 때마다 쓰기 포인터가 1씩 증가한다.</p><blockquote><p>항목 2개를 더 추가</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/124657453-7bbc2a80-dedd-11eb-9434-92854fd7844a.png'></p><p>쓰기 포인터가 두 자리 더 이동하여 읽기 포인터보다 3칸 앞서 있는 것을 확인 할 수 있다. 이는 대기열이 비어 있지 않다는 것을 의미한다.</p><blockquote><p>대기열에서 두 개의 항목을 빼기</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/124657465-7fe84800-dedd-11eb-80da-d4634f1a86d8.png'></p><p>대기열에서 항목을 빼는 것을 링 버퍼를 읽는 것과 동일하다. 읽기 포인터가 어떻게 두 번 이동했는지 주목하자.</p><blockquote><p>대기열을 채우기 위해 항목을 하나 더 추가</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/124657480-824aa200-dedd-11eb-9928-35956b11d604.png'></p><p>쓰기 포인터가 끝에 도달했으므로 시작 인덱스로 다시 랩핑된다.</p><blockquote><p>마지막으로 남은 두 개의 항목을 대기열에서 빼기</p></blockquote><p align = 'center'><img width = '400' src = 'https://user-images.githubusercontent.com/39554623/124657496-8676bf80-dedd-11eb-8b69-b5961c7d5dc8.png'></p><p>남은 두 항목도 대기열에서 빼면서 읽기 포인터도 시작 부분으로 돌아온다.</p><p>위 이미지를 통해 읽기와 쓰기 포인터가 동일한 인덱스에 있을 경우 대기열, 즉 큐가 비어 있다는 것을 알 수 있다.</p><p>링 버퍼를 통한 큐의 구현은 개념만 확인하고 구현은 생략하였다.</p><h4 id="장점과-단점-3"><a class="markdownIt-Anchor" href="#장점과-단점-3"></a> 장점과 단점</h4><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/124657508-8aa2dd00-dedd-11eb-86f7-208f48e10b6b.png'></p><p>링 버퍼 기반 큐는 연결 리스트 기반 구현과 <code>enqueue</code>와 <code>dequeue</code>의 시간 복잡도가 동일하다. 유일한 차이점은 공간 복잡도인데, 링 버퍼의 크기는 고정되어 있으므로 큐에 넣는 것 자체가 실패할 수 있는 단점이 존재한다.</p><p>지금까지 배열, 연결 리스트, 링 버퍼 기반까지 총 세 가지의 구현 방법을 보았는데 마지막으로 두 개의 스택을 사용하여 구현된 큐를 알아 볼 것이다.</p><p>이중 스택 기반 구현 큐는 메모리 상의 공간적 지역성이 연결 리스트보다 훨씬 우수하고, 링 버퍼와 같이 고정된 크기가 필요하지 않다는 장점이 있다.</p><h3 id="4-이중-스택smalldouble-stacksmall-기반-구현"><a class="markdownIt-Anchor" href="#4-이중-스택smalldouble-stacksmall-기반-구현"></a> 4. 이중 스택<small>(Double-Stack)</small> 기반 구현</h3><p>doublestack 패키지 내부에 StackQueue.kt를 추가한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackQueue</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">Queue</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> leftStack = StackImpl&lt;T&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> rightStack = StackImpl&lt;T&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>두 개의 스택을 사용하는 아이디어는 요소를 큐에 넣을 때마다 <strong>오른쪽</strong> 스택으로 이동하고, 요소를 큐에서 뺄 때는 FIFO 순서를 사용하여 요소를 검색할 수 있도록 오른쪽 스택을 반대로 뒤집어서 <strong>왼쪽</strong> 스택에 넣는다.</p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/125627123-d8f7ca3e-d598-4fda-b7e8-bf87d948cef6.png'></p><h4 id="스택-활용하기"><a class="markdownIt-Anchor" href="#스택-활용하기"></a> 스택 활용하기</h4><p>그러면 아래의 코드를 추가하여 큐의 공통 기능들을 구현해본다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = leftStack.count + rightStack.count </span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = leftStack.isEmpty &amp;&amp; rightStack.isEmpty</span><br></pre></td></tr></table></figure><p>큐가 비어 있는지 확인하려면 왼쪽과 오른쪽의 스택이 모두 비어 있는지 확인하면 된다. 큐에 있는 요소의 개수는 두 스택에 있는 요소 개수의 합이다.</p><p>이중 스택으로 구현한 큐는 위에서 설명했듯이 오른쪽 스택에서 왼쪽 스택으로 요소를 전달해야 할 때가 있다. 이는 왼쪽 스택이 비어 있을 때마다 발생한다.</p><p>다음의 헬퍼 메서드를 추가하자.</p><blockquote><p>오른쪽 스택에서 왼쪽 스택으로 요소 이동</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">transferElements</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nextElement = rightStack.pop()</span><br><span class="line">    <span class="keyword">while</span> (nextElement != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftStack.push(nextElement)</span><br><span class="line">        nextElement = rightStack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드를 통해 오른쪽 스택으로부터 요소를 꺼내어 왼쪽 스택에 넣을 수 있다. 스택은 LIFO 방식으로 작동하기 때문에 추가적인 작업 없이 역순으로 요소들을 가져올 수 있다.</p><blockquote><p><code>peek()</code></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftStack.isEmpty) &#123;</span><br><span class="line">        transferElements()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftStack.peek()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>peek()</code>은 최상위 요소를 보는 메서드이다. 만약 왼쪽 스택이 비어 있지 않다면 이 스택의 맨 위에 있는 요소가 큐의 맨 앞에 있다.</p><p>왼쪽 스택이 비어 있으면 <code>transferElements()</code>를 사용한다. 그렇게 하면 <code>leftStack.peek()</code>은 항상 올바른 요소 또는 <em>null</em>을 반환한다. <code>isEmpty()</code>는 여전히 <i>O(1)</i> 작업인 반면 <code>peek()</code>은 <i>O(n)</i>이다.</p><p>이러한 <code>peek()</code>의 구현이 비싼 비용을 요구하는 것처럼 보이지만, 큐의 각 요소는 오른쪽 스택에서 왼쪽 스택으로 한 번만 이동하면 되기 때문에 amortized <i>O(1)</i>이다. 왼쪽 스택이 비어 있을 때 <code>peek()</code> 호출은 오른쪽 요소들을 모두 왼쪽 스택으로 이동시키므로 <i>O(n)</i>이지만, 그 외 추가적인 호출에 대해선 <i>O(1)</i>이 된다.</p><h4 id="enqueue-3"><a class="markdownIt-Anchor" href="#enqueue-3"></a> Enqueue</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    rightStack.push(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>요소를 큐에 추가할 때는 오른쪽 스택이 사용된다. 스택에 요소를 넣는 <code>push()</code>는 <i>O(1)</i>이다.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125709812-534b1733-5132-4770-9b10-23b3b17392b7.png'></p><h4 id="dequeue-3"><a class="markdownIt-Anchor" href="#dequeue-3"></a> Dequeue</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftStack.isEmpty) &#123;</span><br><span class="line">        transferElements()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftStack.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>동작 원리는 다음과 같다.</p><ol><li>왼쪽 스택이 비어 있는지 확인한다.</li><li>왼쪽 스택이 비어 있으면 오른쪽 스택의 요소를 역순으로 이동시킨다.</li><li>왼쪽 스택에서 맨 위의 요소를 제거한다.</li></ol><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125709818-4e175602-0dbc-45ef-b299-999bc03ec2d2.png'></p><p>왼쪽 스택이 비어 있을 때에만 오른쪽 스택의 요소를 이동시키므로 <code>dequeue()</code>는 <code>peek()</code>처럼 amortized <i>O(1)</i> 연산이다.</p><h4 id="테스트-3"><a class="markdownIt-Anchor" href="#테스트-3"></a> 테스트</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Left stack: \n<span class="variable">$leftStack</span> \nRight stack: \n<span class="variable">$rightStack</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = StackQueue&lt;String&gt;().apply &#123;</span><br><span class="line">        enqueue(<span class="string">&quot;Ray&quot;</span>)</span><br><span class="line">        enqueue(<span class="string">&quot;Brian&quot;</span>)</span><br><span class="line">        enqueue(<span class="string">&quot;Eric&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    println(queue)</span><br><span class="line">    println(<span class="string">&quot;Next up: <span class="subst">$&#123;queue.peek()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Left stack: </span><br><span class="line">----top----</span><br><span class="line">-----------</span><br><span class="line"> </span><br><span class="line">Right stack: </span><br><span class="line">----top----</span><br><span class="line">Eric</span><br><span class="line">Brian</span><br><span class="line">Ray</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">Left stack: </span><br><span class="line">----top----</span><br><span class="line">Brian</span><br><span class="line">Eric</span><br><span class="line">-----------</span><br><span class="line"> </span><br><span class="line">Right stack: </span><br><span class="line">----top----</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">Next up: Brian</span><br></pre></td></tr></table></figure><h4 id="장점과-단점-4"><a class="markdownIt-Anchor" href="#장점과-단점-4"></a> 장점과 단점</h4><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/125711056-d0be53af-a4b3-4029-bacb-3a914e9d8115.png'></p><p>리스트 기반 구현과 비교했을 때, 두 개의 스택을 활용하면 <code>dequeue()</code>의 구현을 amortized <i>O(1)</i> 연산으로 변환할 수 있다. 또한 이중 스택 기반 구현은 완전히 동적이고 링 버퍼 기반 구현처럼 고정된 크기로 제한되지도 않는다. 마지막으로 공간적 지역성<small>(spatial locality, 메모리 상 인접 데이터의 재이용률이 높음)</small> 측면에서 연결 리스트 기반 구현을 능가하는데, 이는 리스트이 요소가 메모리 블록에서 서로 옆에 있기 때문이다. 따라서 많은 수의 요소가 한 번의 접근<small>(access)</small>으로 캐시에 로드된다.</p><blockquote><p>연속된 배열에 있는 요소들</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125709832-3a3d4f43-4b43-4c06-8319-85f9d593084e.png'></p><blockquote><p>메모리 전체에 흩어져 있는 연결 리스트의 요소들</p></blockquote><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/125709837-9a7d64d5-f7cf-45ef-825e-33b7f79b5e18.png'></p><p>연결 리스트에서 요소는 메모리 블록에 연속적으로 존재하지 않는다. 이로 인해 더 많은 캐시 미스가 발생하여 접근 시간이 늘어난다.</p><br><div style="text-align: right"> <a href="https://github.com/june0122/DataStructureKotlin/tree/master/src/queue"><b><i>Github에서 본문의 코드 확인하기 </div><br><div style="text-align: right"> <a href="https://www.raywenderlich.com/books/data-structures-algorithms-in-kotlin/v1.0"><b><i>Data Structures & Algorithms in Kotlin</i></b></a> 서적을 참고하여 작성했습니다. </div>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Data-Structure/">Data Structure</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Data-Structure/">Data Structure</category>
      
      <category domain="http://june0122.github.io/tags/Queue/">Queue</category>
      
      
      <comments>http://june0122.github.io/2021/07/16/data-structure-queue/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 레벨 2 : JadenCase 문자열 만들기</title>
      <link>http://june0122.github.io/2021/07/16/programmers-12951/</link>
      <guid>http://june0122.github.io/2021/07/16/programmers-12951/</guid>
      <pubDate>Thu, 15 Jul 2021 20:40:24 GMT</pubDate>
      
      <description>레벨 2</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/12951">문제 보기</a></h3><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>나의 풀이</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> words = s.toLowerCase().toCharArray()</span><br><span class="line"></span><br><span class="line">        words[<span class="number">0</span>] = words[<span class="number">0</span>].toUpperCase()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until words.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (words[i].isLowerCase() &amp;&amp; words[i - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                words[i] = words[i].toUpperCase()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> String(words)  <span class="comment">// words.joinToString(&quot;&quot;) 사용 가능</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>capitalize()</code></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(s: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">          <span class="keyword">return</span> s.toLowerCase().split(<span class="string">&quot; &quot;</span>).map &#123;</span><br><span class="line">                it.capitalize()</span><br><span class="line">            &#125;.joinToString(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Programmers/">Programmers</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Programmers/">Programmers</category>
      
      
      <comments>http://june0122.github.io/2021/07/16/programmers-12951/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 1688. Count of Matches in Tournament</title>
      <link>http://june0122.github.io/2021/07/16/leetcode-1688/</link>
      <guid>http://june0122.github.io/2021/07/16/leetcode-1688/</guid>
      <pubDate>Thu, 15 Jul 2021 19:06:59 GMT</pubDate>
      
      <description>1688. Count of Matches in Tournament</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://leetcode.com/problems/count-of-matches-in-tournament/">문제 보기</a></h3><h2 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">numberOfMatches</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> remains = n</span><br><span class="line">        <span class="keyword">var</span> cnt = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (remains &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remains % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt += remains / <span class="number">2</span></span><br><span class="line">                remains /= <span class="number">2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt += (remains - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">                remains = (remains - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      <category domain="http://june0122.github.io/tags/Simulation/">Simulation</category>
      
      
      <comments>http://june0122.github.io/2021/07/16/leetcode-1688/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 57. Insert Interval</title>
      <link>http://june0122.github.io/2021/07/16/leetcode-57/</link>
      <guid>http://june0122.github.io/2021/07/16/leetcode-57/</guid>
      <pubDate>Thu, 15 Jul 2021 17:48:33 GMT</pubDate>
      
      <description>57. Insert Interval</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://leetcode.com/problems/insert-interval/">문제 보기</a></h3><h2 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h2><blockquote><p><i>O(nlogn)</i> 시간 복잡도 해결법</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;, newInterval: <span class="type">IntArray</span>)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> new = intervals + newInterval</span><br><span class="line">        new.sortWith(compareBy &#123;it[<span class="number">0</span>]&#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> arr = mutableListOf&lt;IntArray&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (interval <span class="keyword">in</span> new) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr.isEmpty() || arr.last()[<span class="number">1</span>] &lt; interval[<span class="number">0</span>]) &#123;</span><br><span class="line">                arr.add(interval)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr.last()[<span class="number">1</span>] = max(arr.last()[<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arr.toTypedArray()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><i>O(n)</i> 시간 복잡도 해결법</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;, newInterval: <span class="type">IntArray</span>)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> merged = mutableListOf&lt;IntArray&gt;()</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (interval <span class="keyword">in</span> intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">1</span>] &gt;= newInterval[<span class="number">0</span>]) <span class="keyword">break</span></span><br><span class="line">            merged.add(interval)</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &lt; intervals.size &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>])&#123;</span><br><span class="line">            newInterval[<span class="number">0</span>] = min(newInterval[<span class="number">0</span>], intervals[i][<span class="number">0</span>])</span><br><span class="line">            newInterval[<span class="number">1</span>] = max(newInterval[<span class="number">1</span>], intervals[i][<span class="number">1</span>])</span><br><span class="line">            i++</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        merged.add(newInterval)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (i &lt; intervals.size)&#123;</span><br><span class="line">            merged.add(intervals[i])</span><br><span class="line">            i++</span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merged.toTypedArray()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://june0122.github.io/2021/07/16/leetcode-57/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 56. Merge Intervals</title>
      <link>http://june0122.github.io/2021/07/15/leetcode-56/</link>
      <guid>http://june0122.github.io/2021/07/15/leetcode-56/</guid>
      <pubDate>Thu, 15 Jul 2021 07:41:39 GMT</pubDate>
      
      <description>56. Merge Intervals</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://leetcode.com/problems/merge-intervals/">문제 보기</a></h3><h2 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">        intervals.sortWith(compareBy &#123; it[<span class="number">0</span>] &#125;)</span><br><span class="line">        <span class="keyword">val</span> merged = mutableListOf&lt;IntArray&gt;()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (interval <span class="keyword">in</span> intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (merged.isEmpty() || merged.last()[<span class="number">1</span>] &lt; interval[<span class="number">0</span>]) &#123;</span><br><span class="line">                merged.add(interval)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged.last()[<span class="number">1</span>] = max(merged.last()[<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merged.toTypedArray()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="복잡도-분석"><a class="markdownIt-Anchor" href="#복잡도-분석"></a> 복잡도 분석</h4><ul><li>시간 복잡도 : <i>O(nlogn)</i><ul><li>정렬로 인한 시간복잡도</li><li><code>java.util.Collections.sort()</code>의 <a href="https://docs.oracle.com/javase/6/docs/api/java/util/Collections.html#sort(java.util.List)">API 문서</a>에 정렬 알고리즘으로 개선된 합병정렬<small>(a modified mergesort)</small>을 사용하고 시간 복잡도는 <i>O(nlogn)</i>으로 명시되어 있다.</li></ul></li><li>공간 복잡도 : <i>O(n)</i></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://june0122.github.io/2021/07/15/leetcode-56/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 495. Teemo Attacking</title>
      <link>http://june0122.github.io/2021/07/15/leetcode-495/</link>
      <guid>http://june0122.github.io/2021/07/15/leetcode-495/</guid>
      <pubDate>Thu, 15 Jul 2021 05:35:23 GMT</pubDate>
      
      <description>495. Teemo Attacking</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://leetcode.com/problems/teemo-attacking/">문제 보기</a></h3><h2 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h2><blockquote><p>시간 초과 코드</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findPoisonedDuration</span><span class="params">(timeSeries: <span class="type">IntArray</span>, duration: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> poisonedTimes = mutableSetOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        </span><br><span class="line">        timeSeries.forEach &#123; t -&gt;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> t until t + duration) &#123;</span><br><span class="line">                poisonedTimes.add(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> poisonedTimes.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>easy 난이도의 문제였기에 간단히 set을 이용하여 중복을 제거하는 식으로 문제를 해결하려 하였으나 시간 초과가 발생하였다. 제약 사항을 보니 아래와 같았다. 입력값의 범위를 보고 문제 접근 방법을 고려할 수 있어야 하는데 연습이 많이 부족하다.</p><p>제약 사항</p><ul><li>1 &lt;= timeSeries.length &lt;= 10<sup>4</sup></li><li>0 &lt;= timeSeries[i], duration &lt;= 10<sup>7</sup></li><li>timeSeries is sorted in <strong>non-decreasing</strong> order.</li></ul><blockquote><p>해답</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.min</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findPoisonedDuration</span><span class="params">(timeSeries: <span class="type">IntArray</span>, duration: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = timeSeries.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span>) &#123;</span><br><span class="line">            total += min(timeSeries[i + <span class="number">1</span>] - timeSeries[i], duration)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> total + duration</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일반적으로 이러한 유형의 문제들은 <a href="https://leetcode.com/problems/insert-interval/">입력 값이 정렬되어 있을 경우</a> <i>O(N)</i>, <a href="https://leetcode.com/problems/merge-intervals/">그렇지 않을 경우</a> <i>O(nlogn)</i>의 시간 복잡도를 가진다.</p><p>두 개의 공격 사이의 간격과 duration 중 작은 값을 독에 중독된 시간에 더해나가는 식으로 값을 구할 수 있다.</p><p>두 개의 공격 사이의 간격이 duration보다 작다는 것은 중첩되는 구간이 있다는 뜻으로 다음 공격 시간과 현재 공격 시간의 차이<small>(<code>timeSeries[i + 1] - timeSeries[i]</code>)</small>만큼만 총 중독 시간에 더한다.</p><p>duration이 두 공격 사이 간격보다 클 경우는 중첩 구간이 없다는 뜻이므로 duration 값 그대로를 총 중독 시간에 더한다. 마지막 공격은 비교군에서 제외되므로 총 중독 시간에 따로 duration을 한 번만 더해준다.</p><h4 id="복잡도-분석"><a class="markdownIt-Anchor" href="#복잡도-분석"></a> 복잡도 분석</h4><ul><li>시간 복잡도 : <i>O(N)</i></li><li>공간 복잡도 : <i>O(1)</i></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://june0122.github.io/2021/07/15/leetcode-495/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
