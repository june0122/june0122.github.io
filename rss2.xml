<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>카미유 테크 블로그</title>
    <link>http://june0122.github.io/</link>
    
    <atom:link href="http://june0122.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Thu, 15 Jul 2021 08:11:25 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[LeetCode] 56. Merge Intervals</title>
      <link>http://june0122.github.io/2021/07/15/leetcode-56/</link>
      <guid>http://june0122.github.io/2021/07/15/leetcode-56/</guid>
      <pubDate>Thu, 15 Jul 2021 07:41:39 GMT</pubDate>
      
      <description>56. Merge Intervals</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://leetcode.com/problems/merge-intervals/">문제 보기</a></h3><h2 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">merge</span><span class="params">(intervals: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: Array&lt;IntArray&gt; &#123;</span><br><span class="line">        intervals.sortWith(compareBy &#123; it[<span class="number">0</span>] &#125;)</span><br><span class="line">        <span class="keyword">val</span> merged = mutableListOf&lt;IntArray&gt;()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (interval <span class="keyword">in</span> intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (merged.isEmpty() || merged.last()[<span class="number">1</span>] &lt; interval[<span class="number">0</span>]) &#123;</span><br><span class="line">                merged.add(interval)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged.last()[<span class="number">1</span>] = max(merged.last()[<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merged.toTypedArray()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="복잡도-분석"><a class="markdownIt-Anchor" href="#복잡도-분석"></a> 복잡도 분석</h4><ul><li>시간 복잡도 : <i>O(nlogn)</i><ul><li>정렬로 인한 시간복잡도</li><li><code>java.util.Collections.sort()</code>의 <a href="https://docs.oracle.com/javase/6/docs/api/java/util/Collections.html#sort(java.util.List)">API 문서</a>에 정렬 알고리즘으로 개선된 합병정렬<small>(a modified mergesort)</small>을 사용하고 시간 복잡도는 <i>O(nlogn)</i>으로 명시되어 있다.</li></ul></li><li>공간 복잡도 : <i>O(n)</i></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://june0122.github.io/2021/07/15/leetcode-56/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 495. Teemo Attacking</title>
      <link>http://june0122.github.io/2021/07/15/leetcode-495/</link>
      <guid>http://june0122.github.io/2021/07/15/leetcode-495/</guid>
      <pubDate>Thu, 15 Jul 2021 05:35:23 GMT</pubDate>
      
      <description>495. Teemo Attacking</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://leetcode.com/problems/teemo-attacking/">문제 보기</a></h3><h2 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h2><blockquote><p>시간 초과 코드</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findPoisonedDuration</span><span class="params">(timeSeries: <span class="type">IntArray</span>, duration: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> poisonedTimes = mutableSetOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        </span><br><span class="line">        timeSeries.forEach &#123; t -&gt;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> t until t + duration) &#123;</span><br><span class="line">                poisonedTimes.add(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> poisonedTimes.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>easy 난이도의 문제였기에 간단히 set을 이용하여 중복을 제거하는 식으로 문제를 해결하려 하였으나 시간 초과가 발생하였다. 제약 사항을 보니 아래와 같았다. 입력값의 범위를 보고 문제 접근 방법을 고려할 수 있어야 하는데 연습이 많이 부족하다.</p><p>제약 사항</p><ul><li>1 &lt;= timeSeries.length &lt;= 10<sup>4</sup></li><li>0 &lt;= timeSeries[i], duration &lt;= 10<sup>7</sup></li><li>timeSeries is sorted in <strong>non-decreasing</strong> order.</li></ul><blockquote><p>해답</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.min</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findPoisonedDuration</span><span class="params">(timeSeries: <span class="type">IntArray</span>, duration: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> n = timeSeries.size</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n - <span class="number">1</span>) &#123;</span><br><span class="line">            total += min(timeSeries[i + <span class="number">1</span>] - timeSeries[i], duration)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> total + duration</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일반적으로 이러한 유형의 문제들은 <a href="https://leetcode.com/problems/insert-interval/">입력 값이 정렬되어 있을 경우</a> <i>O(N)</i>, <a href="https://leetcode.com/problems/merge-intervals/">그렇지 않을 경우</a> <i>O(nlogn)</i>의 시간 복잡도를 가진다.</p><p>두 개의 공격 사이의 간격과 duration 중 작은 값을 독에 중독된 시간에 더해나가는 식으로 값을 구할 수 있다.</p><p>두 개의 공격 사이의 간격이 duration보다 작다는 것은 중첩되는 구간이 있다는 뜻으로 다음 공격 시간과 현재 공격 시간의 차이<small>(<code>timeSeries[i + 1] - timeSeries[i]</code>)</small>만큼만 총 중독 시간에 더한다.</p><p>duration이 두 공격 사이 간격보다 클 경우는 중첩 구간이 없다는 뜻이므로 duration 값 그대로를 총 중독 시간에 더한다. 마지막 공격은 비교군에서 제외되므로 총 중독 시간에 따로 duration을 한 번만 더해준다.</p><h4 id="복잡도-분석"><a class="markdownIt-Anchor" href="#복잡도-분석"></a> 복잡도 분석</h4><ul><li>시간 복잡도 : <i>O(N)</i></li><li>공간 복잡도 : <i>O(1)</i></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://june0122.github.io/2021/07/15/leetcode-495/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 레벨 2 : 가장 큰 수</title>
      <link>http://june0122.github.io/2021/07/13/programmers-42746/</link>
      <guid>http://june0122.github.io/2021/07/13/programmers-42746/</guid>
      <pubDate>Tue, 13 Jul 2021 09:59:37 GMT</pubDate>
      
      <description>[코딩테스트 고득점 Kit - 정렬] 레벨 2</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/42746">문제 보기</a></h3><p><code>정렬</code></p><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(numbers: <span class="type">IntArray</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">var</span> answer = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">var</span> tempArray = numbers.map &#123; it.toString() &#125;.toTypedArray()</span><br><span class="line">        </span><br><span class="line">        tempArray.sortWith(Comparator&lt;String&gt; &#123; a, b -&gt;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                a.length == b.length -&gt; b.compareTo(a)</span><br><span class="line">                <span class="keyword">else</span> -&gt; (b + a).compareTo(a + b)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (tempArray[<span class="number">0</span>] == <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">            answer = <span class="string">&quot;0&quot;</span></span><br><span class="line">            <span class="keyword">return</span> answer</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tempArray.forEach &#123;</span><br><span class="line">            answer += it</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Programmers/">Programmers</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Programmers/">Programmers</category>
      
      <category domain="http://june0122.github.io/tags/%EC%A0%95%EB%A0%AC/">정렬</category>
      
      
      <comments>http://june0122.github.io/2021/07/13/programmers-42746/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 레벨 2 : 전화번호 목록</title>
      <link>http://june0122.github.io/2021/07/12/programmers-42577/</link>
      <guid>http://june0122.github.io/2021/07/12/programmers-42577/</guid>
      <pubDate>Mon, 12 Jul 2021 06:54:19 GMT</pubDate>
      
      <description>[코딩테스트 고득점 Kit - 해시] 레벨 2</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/42577">문제 보기</a></h3><p><code>해시</code></p><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="java"><a class="markdownIt-Anchor" href="#java"></a> java</h3><blockquote><p>정확성 테스트 통과, 효율성 테스트 실패 코드</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solution</span><span class="params">(String[] phone_book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> answer = <span class="keyword">true</span>;</span><br><span class="line">        Arrays.sort(phone_book, Comparator.comparing(String::length));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; phone_book.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; phone_book.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phone_book[i].equals(phone_book[j].substring(<span class="number">0</span>, phone_book[i].length()))) &#123;</span><br><span class="line">                    answer = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Hash 사용</p></blockquote><p><strong>해시</strong>를 사용해야 효율성 통과를 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solution</span><span class="params">(String[] phone_book)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(phone_book, Collections.reverseOrder());</span><br><span class="line">        HashMap&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : phone_book) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.get(s) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                hashMap.put(s.substring(<span class="number">0</span>, i), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solution</span><span class="params">(String[] phone_book)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : phone_book) hashMap.put(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : phone_book) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hashMap.containsKey(s.substring(<span class="number">0</span>, i))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(phone_book: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> hashMap = HashMap&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    phone_book.forEach &#123; hashMap[it] = <span class="number">0</span> &#125;</span><br><span class="line">    phone_book.forEach &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until it.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.containsKey(it.substring(<span class="number">0</span>, i))) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Programmers/">Programmers</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Programmers/">Programmers</category>
      
      <category domain="http://june0122.github.io/tags/%ED%95%B4%EC%8B%9C/">해시</category>
      
      <category domain="http://june0122.github.io/tags/Java/">Java</category>
      
      
      <comments>http://june0122.github.io/2021/07/12/programmers-42577/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 레벨 2 : 행렬 테두리 회전하기</title>
      <link>http://june0122.github.io/2021/07/11/programmers-77485/</link>
      <guid>http://june0122.github.io/2021/07/11/programmers-77485/</guid>
      <pubDate>Sun, 11 Jul 2021 12:08:10 GMT</pubDate>
      
      <description>[2021 Dev-Matching: 웹 백엔드 개발자(상반기)] 레벨 2</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/77485">문제 보기</a></h3><p><code>2021 Dev-Matching: 웹 백엔드 개발자(상반기)</code>, <code>완전 탐색</code></p><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>연결 리스트 이용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(rows: <span class="type">Int</span>, columns: <span class="type">Int</span>, queries: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">if</span> (queries.size == <span class="number">1</span>) <span class="keyword">return</span> intArrayOf(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> answer = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> board = Array(rows) &#123; i -&gt; IntArray(columns) &#123; j -&gt; (i * columns) + j + <span class="number">1</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">        queries.forEach &#123;</span><br><span class="line">            <span class="keyword">val</span> list = LinkedList&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">            <span class="keyword">val</span> values = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">val</span> (row1, col1) = it[<span class="number">0</span>] - <span class="number">1</span> to it[<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> (row2, col2) = it[<span class="number">2</span>] - <span class="number">1</span> to it[<span class="number">3</span>] - <span class="number">1</span></span><br><span class="line">            <span class="keyword">var</span> (tempRow, tempCol) = row1 to col1</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (tempCol &lt; col2) &#123;</span><br><span class="line">                list.add(tempRow to tempCol)</span><br><span class="line">                values.add(board[tempRow][tempCol])</span><br><span class="line">                tempCol += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (tempRow &lt; row2) &#123;</span><br><span class="line">                list.add(tempRow to tempCol)</span><br><span class="line">                values.add(board[tempRow][tempCol])</span><br><span class="line">                tempRow += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (tempCol &gt; col1) &#123;</span><br><span class="line">                list.add(tempRow to tempCol)</span><br><span class="line">                values.add(board[tempRow][tempCol])</span><br><span class="line">                tempCol -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (tempRow &gt; row1) &#123;</span><br><span class="line">                list.add(tempRow to tempCol)</span><br><span class="line">                values.add(board[tempRow][tempCol])</span><br><span class="line">                tempRow -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.add(list.removeAt(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> cnt = <span class="number">0</span></span><br><span class="line">            list.forEach &#123; pos -&gt;</span><br><span class="line">                board[pos.first][pos.second] = values[cnt]</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            answer.add(values.min()!!)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer.toIntArray()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>첫 시도에는 연결 리스트를 이용하는 방법으로 풀이하였지만 코드의 복잡도만 올라가는데다 효율성도 그리 좋지 못하여 아래와 같이 배열만을 이용하는 방법으로 풀이하였다.</p><blockquote><p>배열만 이용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.min</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(rows: <span class="type">Int</span>, columns: <span class="type">Int</span>, queries: <span class="type">Array</span>&lt;<span class="type">IntArray</span>&gt;)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">var</span> answer = intArrayOf()</span><br><span class="line">        <span class="keyword">val</span> board = Array(rows) &#123; i -&gt; IntArray(columns) &#123; j -&gt; (columns * i) + j + <span class="number">1</span> &#125; &#125;</span><br><span class="line">        </span><br><span class="line">        queries.forEach &#123;</span><br><span class="line">            <span class="keyword">val</span> (r1, c1) = it[<span class="number">0</span>] - <span class="number">1</span> to it[<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> (r2, c2) = it[<span class="number">2</span>] - <span class="number">1</span> to it[<span class="number">3</span>] - <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> a1 = IntArray(c2 - c1) &#123; i -&gt; board[r1][c1 + i] &#125;</span><br><span class="line">            <span class="keyword">val</span> a2 = IntArray(r2 - r1) &#123; i -&gt; board[r1 + i][c2] &#125;</span><br><span class="line">            <span class="keyword">val</span> a3 = IntArray(c2 - c1) &#123; i -&gt; board[r2][c1 + <span class="number">1</span> + i] &#125;</span><br><span class="line">            <span class="keyword">val</span> a4 = IntArray(r2 - r1) &#123; i -&gt; board[r1 + <span class="number">1</span> + i][c1] &#125;</span><br><span class="line">            <span class="keyword">var</span> min = rows * columns</span><br><span class="line">            </span><br><span class="line">            a1.forEachIndexed &#123; i, v -&gt;</span><br><span class="line">                board[r1][c1 + i + <span class="number">1</span>] = v</span><br><span class="line">                min = min(min, v)</span><br><span class="line">            &#125;</span><br><span class="line">            a2.forEachIndexed &#123; i, v -&gt;</span><br><span class="line">                board[r1 + i + <span class="number">1</span>][c2] = v</span><br><span class="line">                min = min(min, v)</span><br><span class="line">            &#125;</span><br><span class="line">            a3.forEachIndexed &#123; i, v -&gt;</span><br><span class="line">                board[r2][c1 + i] = v</span><br><span class="line">                min = min(min, v)</span><br><span class="line">            &#125;</span><br><span class="line">            a4.forEachIndexed &#123; i, v -&gt;</span><br><span class="line">                board[r1 + i][c1] = v</span><br><span class="line">                min = min(min, v)</span><br><span class="line">            &#125;</span><br><span class="line">            answer += min</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Programmers/">Programmers</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Programmers/">Programmers</category>
      
      <category domain="http://june0122.github.io/tags/%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89/">완전 탐색</category>
      
      
      <comments>http://june0122.github.io/2021/07/11/programmers-77485/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[코틀린 자료구조] 스택 (Stack)</title>
      <link>http://june0122.github.io/2021/07/05/data-structure-stack/</link>
      <guid>http://june0122.github.io/2021/07/05/data-structure-stack/</guid>
      <pubDate>Mon, 05 Jul 2021 13:25:08 GMT</pubDate>
      
      <description>&lt;b&gt;Stack&lt;small&gt;(스택)&lt;/small&gt;&lt;/b&gt;은 한 쪽에서만 요소의 추가나 제거가 가능한 자료구조이다. Computer science에선 스택은 LIFO&lt;small&gt;(last-in first-out)&lt;/small&gt; 자료구조라고도 한다. 마지막에 들어간&lt;small&gt;(push)&lt;/small&gt; 요소들은 가장 먼저 나온다&lt;small&gt;(pop)&lt;/small&gt;.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="스택의-연산들"><a class="markdownIt-Anchor" href="#스택의-연산들"></a> 스택의 연산들</h2><p>스택에는 오직 두 개의 필수적인 연산들이 존재한다.</p><ul><li><code>push</code> : 스택 맨 위에 요소를 추가</li><li><code>pop</code> : 스택 맨 위의 요소를 제거</li></ul><p>즉, 스택은 한 쪽에서만 요소의 추가나 제거가 가능한 자료구조이다. Computer science에선 스택은 LIFO<small>(last-in first-out)</small> 자료구조라고도 한다. 마지막에 들어간<small>(push)</small> 요소들은 가장 먼저 나온다<small>(pop)</small>.</p><blockquote><p>stack 패키지 내부에 Stack 인터페이스 선언 (stack/Stack.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="type">T : Any</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(element: <span class="type">T</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: T?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">※ 위의 Stack 인터페이스는 Vector 클래스를 상속받고 본문에서 필요로 하지 않는 메서드들을 제공하는 Kotlin과 Java의 Stack 클래스와 다르다.  </span><br></pre></td></tr></table></figure><p>스택은 다음과 같은 프로그래밍 분야에서 눈에 띄게 사용된다.</p><ul><li>안드로이드는 <strong>fragment stack</strong>을 사용하여 Activity의 안팎으로 fragment들을 push 및 pop을 한다.</li><li>메모리 할당은 아키텍처 수준에서 스택을 사용한다. <strong>지역 변수의 메모리</strong>도 스택을 사용하여 관리된다.</li><li>미로에서 길을 찾는 것과 같은 <strong>Search and conquer 알고리즘</strong>은 스택을 사용하여 백트래킹을 용이하게 한다.</li></ul><h2 id="구현"><a class="markdownIt-Anchor" href="#구현"></a> 구현</h2><p>다양한 방식으로 Stack 인터페이스를 구현할 수 있는데 올바른 storage type을 선택하는 것이 중요하다. <strong>ArrayList</strong>는 마지막 인덱스를 매개변수로 사용하여 <code>add</code> 및 <code>removeAt</code>을 통해 한쪽 끝에서 O(1)<small>(상수 시간)</small> 삽입 및 삭제를 제공하므로 확실한 선택이다. 이 두 연산을 사용하면 스택의 LIFO 특성이 쉽게 구현된다.</p><blockquote><p>StackImpl 클래스에 <code>toString</code> 재정의 (StackImpl.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackImpl</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">Stack</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> storage = arrayListOf&lt;T&gt;()  </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = buildString &#123;</span><br><span class="line">      appendLine(<span class="string">&quot;----top----&quot;</span>)</span><br><span class="line">      storage.asReversed().forEach &#123;</span><br><span class="line">        appendLine(<span class="string">&quot;<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      appendLine(<span class="string">&quot;-----------&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>데이터에 대해 ArrayList 유형의 private property를 정의하고 디버그 목적으로 해당 내용을 표시하기 위해 <code>toString</code> 메서드를 재정의한다. <small>(이 코드를 사용하면 아직 push 및 pop 연산을 구현하지 않았기에 오류가 발생한다.)</small></p><h3 id="push-및-pop-연산"><a class="markdownIt-Anchor" href="#push-및-pop-연산"></a> push 및 pop 연산</h3><blockquote><p><code>push</code> 및 <code>pop</code> 추가 (StackImpl.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(element: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    storage.add(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">if</span> (storage.size == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> storage.removeAt(storage.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>push</code> 메서드에서 ArrayList의 <code>add</code> 메서드를 이용해서 매개변수로 전달된 값을 ArrayList의 끝에 추가한다<small>(append)</small>. <code>pop</code> 메서드는 ArrayList가 비어 있으면 null을 반환하고 그렇지 않다면 마지막에 삽입한 요소를 제거하고 반환한다.</p><p>아래의 코드를 통해 직접 구현한 스택이 올바르게 작동하는지 확인한다.</p><blockquote><p>테스트용 코드 작성 (Main.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = StackImpl&lt;<span class="built_in">Int</span>&gt;().apply &#123;</span><br><span class="line">        push(<span class="number">1</span>)</span><br><span class="line">        push(<span class="number">2</span>)</span><br><span class="line">        push(<span class="number">3</span>)</span><br><span class="line">        push(<span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    print(stack)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> poppedElement = stack.pop()</span><br><span class="line">    <span class="keyword">if</span> (poppedElement != <span class="literal">null</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Popped: <span class="variable">$poppedElement</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    print(stack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">----top----</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">-----------</span><br><span class="line">Popped: 4</span><br><span class="line">----top----</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">-----------</span><br></pre></td></tr></table></figure><p><code>push</code> 및 <code>pop</code>은 둘 다 O(1) 시간 복잡도를 가진다.</p><h3 id="유용한-추가-연산들"><a class="markdownIt-Anchor" href="#유용한-추가-연산들"></a> 유용한 추가 연산들</h3><p>스택을 더 쉽게 사용할 수 있는 몇 가지 유용한 연산들을 추가한다.</p><blockquote><p>Stack 인터페이스에 <code>peek</code> 추가 (stack/Stack.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="type">T : Any</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = count == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>peek</code>의 개념은 내용을 변경하지 않고 스택의 맨 위 요소를 보는 것이다. <em>count</em> 속성은 스택의 요소 수를 반환하며 <em>isEmpty</em> 속성을 구현하는데 사용된다.</p><blockquote><p><code>peek</code> 구현하기 (StackImpl.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">return</span> storage.lastOrNull()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = storage.size</span><br></pre></td></tr></table></figure><p><code>peek</code>을 구현함으로써 <code>pop</code>의 구현을 더 깔끔한 코드로 변경할 수 있다.</p><blockquote><p><code>pop</code> 코드를 더 깔끔하게 수정</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> storage.removeAt(storage.size - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="스택과-kotlin-collection-interfaces"><a class="markdownIt-Anchor" href="#스택과-kotlin-collection-interfaces"></a> 스택과 Kotlin Collection Interfaces</h3><p>스택에 Kotlin Collection 인터페이스를 채택할 수 있을지 궁금할 수 있다. 스택의 목적은 데이터에 액세스하는 방법의 수를 제한하는 것인데, <strong>Iterable</strong>과 같은 인터페이스를 채택하면 iterator를 통해 모든 요소들을 노출함으로써 당초의 목표와 어긋나게 된다.</p><p>액세스 순서가 보장되도록 기존의 List를 가져와 스택으로 변환하는 것을 원할 수 있다. 물론 배열의 요소들을 순회하고 각 요소들을 <code>push</code> 할 수 있다. 하지만 이러한 요소를 Stack 구현에 직접적으로 추가하는 <a href="https://github.com/june0122/Effective-Java/blob/b24a45bbf5e320971bf2dfafe5bcbd38feeb9039/item%2001.md"><b>정적 팩토리 메서드<small>(static factory method)</small></b></a>를 작성할 수 있다.</p><blockquote><p>정적 팩토리 메서드 사용하기 (StackImpl.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">create</span><span class="params">(items: <span class="type">Iterable</span>&lt;<span class="type">T</span>&gt;)</span></span>: Stack&lt;T&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> stack = StackImpl&lt;T&gt;()</span><br><span class="line">      <span class="keyword">for</span> (item <span class="keyword">in</span> items) &#123;</span><br><span class="line">        stack.push(item)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> stack</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>테스트용 코드 (Main.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> stack = StackImpl.create(list)</span><br><span class="line">    print(stack)</span><br><span class="line">    println(<span class="string">&quot;Popped: <span class="subst">$&#123;stack.pop()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">----top----</span><br><span class="line">D</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">A</span><br><span class="line">-----------</span><br><span class="line">Popped: D</span><br></pre></td></tr></table></figure><p>이 코드는 문자열 스택을 생성하고 최상위 요소인 &quot;D&quot;를 pop 한다.</p><p>한 단계 더 나아가 <code>listOf()</code> 및 기타 표준 라이브러리 collection factory 함수와 유사한 요소를 나열하여 스택을 초기화할 수 있다. 이를 Stack.kt의 Stack을 구현한 클래스 외부에 추가한다.</p><blockquote><p>스택 초기화 함수 추가 (Stack.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">stackOf</span><span class="params">(<span class="keyword">vararg</span> elements: <span class="type">T</span>)</span></span>: Stack&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> StackImpl.create(elements.asList())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>테스트용 코드 (Main.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = stackOf(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line">    print(stack)</span><br><span class="line">    println(<span class="string">&quot;Popped: <span class="subst">$&#123;stack.pop()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">----top----</span><br><span class="line">4.0</span><br><span class="line">3.0</span><br><span class="line">2.0</span><br><span class="line">1.0</span><br><span class="line">-----------</span><br><span class="line">Popped: 4.0</span><br></pre></td></tr></table></figure><p>이렇게 하면 Double의 스택이 생성되고 최상위 값인 4.0이 표시된다. 코틀린 컴파일러의 타입 추론 기능 덕분에 <code>stackOf</code> 함수 호출의 제네릭 타입 인자를 지정하지 않아도 된다.</p><p>스택은 트리와 그래프를 검색하는 문제에 매우 중요하다. 미로를 통해 길을 찾는다고 상상할 때, 왼쪽, 오른쪽 또는 직진을 결정해야 하는 지점에 올 때마다 가능한 모든 결정들을 스택에 넣을 수 있다. <small>(When you hit a dead end, backtrack by popping from the stack and continuing until you escape or hit another dead end.)</small></p><h2 id="스택의-활용"><a class="markdownIt-Anchor" href="#스택의-활용"></a> 스택의 활용</h2><h3 id="linkedlist-뒤집기"><a class="markdownIt-Anchor" href="#linkedlist-뒤집기"></a> LinkedList 뒤집기</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> LinkedList<span class="type">&lt;T&gt;</span>.<span class="title">printInReverse</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = StackImpl&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (node <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        stack.push(node)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> node = stack.pop()</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        println(node)</span><br><span class="line">        node = stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="괄호-확인"><a class="markdownIt-Anchor" href="#괄호-확인"></a> 괄호 확인</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">h((e))llo(world)() // balanced parentheses</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">(hello world // unbalanced parentheses</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">checkParentheses</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stack = StackImpl&lt;<span class="built_in">Char</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (char <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">when</span> (char) &#123;</span><br><span class="line">            <span class="string">&#x27;(&#x27;</span> -&gt; stack.push(char)</span><br><span class="line">            <span class="string">&#x27;)&#x27;</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                <span class="keyword">else</span> stack.pop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스택은 괄호 관련 코딩 테스트 문제에 자주 등장하므로 사용 방법을 숙지할 필요가 있다.</p><ul><li><a href="https://programmers.co.kr/learn/courses/30/lessons/60058">프로그래머스 레벨 2 - 괄호 변환</a></li><li><a href="https://programmers.co.kr/learn/courses/30/lessons/76502">프로그래머스 레벨 2 - 괄호 회전하기</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Data-Structure/">Data Structure</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Data-Structure/">Data Structure</category>
      
      <category domain="http://june0122.github.io/tags/Stack/">Stack</category>
      
      
      <comments>http://june0122.github.io/2021/07/05/data-structure-stack/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] BFS (Breadth First Search)</title>
      <link>http://june0122.github.io/2021/07/01/boj-bfs/</link>
      <guid>http://june0122.github.io/2021/07/01/boj-bfs/</guid>
      <pubDate>Thu, 01 Jul 2021 14:23:18 GMT</pubDate>
      
      <description>[바킹독의 실전 알고리즘] 0x09강 - BFS</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="설명"><a class="markdownIt-Anchor" href="#설명"></a> 설명</h2><blockquote><h3 id="다차원-배열에서-각-칸을-방문할-때-너비를-우선으로-방문하는-알고리즘"><a class="markdownIt-Anchor" href="#다차원-배열에서-각-칸을-방문할-때-너비를-우선으로-방문하는-알고리즘"></a> 다차원 배열에서 각 칸을 방문할 때 너비를 우선으로 방문하는 알고리즘</h3></blockquote><ol><li>시작하는 칸을 큐에 넣고 방문했다는 표시를 남김</li><li>큐에서 원소를 꺼내어 그 칸에 상하좌우로 인접한 칸에 대해 <code>3번</code>을 진행</li><li>해당 칸을 이전에 방문했다면 아무것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 큐에 삽입</li><li>큐가 빌 때까지 <code>2번</code>을 반복</li></ol><p>모든 칸이 큐에 1번씩 들어가므로 시간복잡도는 칸이 N개일 때 O(N)</p><h4 id="bfs-구현-시-자주하는-실수"><a class="markdownIt-Anchor" href="#bfs-구현-시-자주하는-실수"></a> BFS 구현 시 자주하는 실수</h4><ol><li>시작점을 큐에 넣긴하는데 정작 방문했다는 표시를 남기지 않은 채로 진행하는 경우</li><li>큐에 넣을 때 해당 칸에 방문했다는 표시를 남기지 않고 큐에서 빼낼 때 남기는 경우</li><li>nx, ny가 배열 바깥으로 벗어났는지에 대한 루틴을 아예 빼먹었거나, 아니면 이상하게 구현을 한 상황</li></ol><h2 id="예시-및-응용"><a class="markdownIt-Anchor" href="#예시-및-응용"></a> 예시 및 응용</h2><h3 id="예시-flood-fill"><a class="markdownIt-Anchor" href="#예시-flood-fill"></a> 예시 : Flood Fill</h3><blockquote><p><a href="https://www.acmicpc.net/problem/1926">BOJ 1926, 그림</a></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> (n, m) = Pair(nextInt(), nextInt())</span><br><span class="line">    <span class="keyword">val</span> (dx, dy) = intArrayOf(<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>) to intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>) <span class="comment">// 상하좌우 네 방향을 의미</span></span><br><span class="line">    <span class="keyword">val</span> paper = Array(n) &#123; IntArray(m) &#125;</span><br><span class="line">    <span class="keyword">val</span> visitMap = Array(n) &#123; BooleanArray(m) &#125; <span class="comment">// 해당 칸을 방문했는지 여부를 저장</span></span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span> <span class="comment">// 그림의 최댓값</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span> <span class="comment">// 그림의 개수</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> paper.indices) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> paper[i].indices) &#123;</span><br><span class="line">            paper[i][j] = nextInt()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> paper.indices) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> paper[i].indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (paper[i][j] == <span class="number">0</span> || visitMap[i][j]) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> queue: Queue&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; = LinkedList()</span><br><span class="line">            <span class="keyword">var</span> area = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            visitMap[i][j] = <span class="literal">true</span></span><br><span class="line">            queue.offer(i to j)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">                area += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> cur = queue.poll()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (dir <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123; <span class="comment">// 상하좌우 칸을 탐색</span></span><br><span class="line">                    <span class="keyword">val</span> nx = cur.first + dx[dir]</span><br><span class="line">                    <span class="keyword">val</span> ny = cur.second + dy[dir] <span class="comment">// nx, ny에 dir에서 정한 방향의 인접한 칸의 좌표가 들어감</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span> <span class="comment">// 범위 밖일 경우 넘어감</span></span><br><span class="line">                    <span class="keyword">if</span> (visitMap[nx][ny]|| paper[nx][ny] != <span class="number">1</span>) <span class="keyword">continue</span> <span class="comment">// 이미 방문한 칸이거나 색칠된 칸이 아닐 경우</span></span><br><span class="line"></span><br><span class="line">                    visitMap[nx][ny] = <span class="literal">true</span> <span class="comment">// (nx, ny)를 방문했다고 명시</span></span><br><span class="line">                    queue.offer(nx to ny)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max = max(max, area)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$num</span>\n<span class="variable">$max</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="응용-1-거리-측정"><a class="markdownIt-Anchor" href="#응용-1-거리-측정"></a> 응용 1 : 거리 측정</h3><blockquote><p><a href="https://www.acmicpc.net/problem/2178">BOJ 2178번, 미로 탐색</a></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> (n, m) = nextInt() to nextInt()</span><br><span class="line">    <span class="keyword">val</span> (dx, dy) = intArrayOf(<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>) to intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> maze = Array(n) &#123; IntArray(m) &#125;</span><br><span class="line">    <span class="keyword">val</span> dist = Array(n) &#123; IntArray(m) &#123; -<span class="number">1</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123; <span class="comment">// 각각의 수들은 &#x27;붙어서&#x27; 입력으로 주어진다.</span></span><br><span class="line">        <span class="keyword">val</span> line = next()</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            maze[i][j] = line[j] - <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; = LinkedList()</span><br><span class="line">    queue.offer(<span class="number">0</span> to <span class="number">0</span>)</span><br><span class="line">    dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> (curX, curY) = queue.poll()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (dir <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> nx = curX + dx[dir]</span><br><span class="line">            <span class="keyword">val</span> ny = curY + dy[dir]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (dist[nx][ny] &gt;= <span class="number">0</span> || maze[nx][ny] != <span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            dist[nx][ny] = dist[curX][curY] + <span class="number">1</span></span><br><span class="line">            queue.offer(nx to ny)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(dist[n - <span class="number">1</span>][m - <span class="number">1</span>] + <span class="number">1</span>) <span class="comment">// 지나는 칸 수를 출력이므로 + 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="응용-2-시작점이-여러-개일-때"><a class="markdownIt-Anchor" href="#응용-2-시작점이-여러-개일-때"></a> 응용 2 : 시작점이 여러 개일 때</h3><blockquote><p><a href="https://www.acmicpc.net/problem/7576">BOJ 7576번, 토마토</a></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">var</span> date = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> (m, n) = nextInt() to nextInt()</span><br><span class="line">    <span class="keyword">val</span> (dx, dy) = intArrayOf(<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>) to intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> box = Array(n) &#123; IntArray(m) &#125;</span><br><span class="line">    <span class="keyword">val</span> vis = Array(n) &#123; BooleanArray(m) &#123; <span class="literal">false</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            box[i][j] = nextInt()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; = LinkedList()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (box[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                queue.offer(i to j)</span><br><span class="line">                vis[i][j] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> temp = mutableListOf&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (rottenNum <span class="keyword">in</span> <span class="number">0</span> until queue.size) &#123;</span><br><span class="line">            <span class="keyword">val</span> (curX, curY) = queue.poll()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (dir <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> (nx, ny) = curX + dx[dir] to curY + dy[dir]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> (box[nx][ny] == <span class="number">1</span> || box[nx][ny] == -<span class="number">1</span> || vis[nx][ny]) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                vis[nx][ny] = <span class="literal">true</span></span><br><span class="line">                box[nx][ny] = <span class="number">1</span></span><br><span class="line">                temp.add(nx to ny)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.forEach &#123;</span><br><span class="line">            queue.offer(it)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.clear()</span><br><span class="line"></span><br><span class="line">        date += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (box[i][j] == <span class="number">0</span>) date = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(date - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">var</span> date = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> (m, n) = nextInt() to nextInt()</span><br><span class="line">    <span class="keyword">val</span> (dx, dy) = intArrayOf(<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>) to intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> box = Array(n) &#123; IntArray(m) &#125;</span><br><span class="line">    <span class="keyword">val</span> dist = Array(n) &#123; IntArray(m) &#125; <span class="comment">// 익은 토마토가 들어있거나 토마토가 없는 칸은 값이 0</span></span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; = LinkedList()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            box[i][j] = nextInt()</span><br><span class="line">            <span class="keyword">when</span> (box[i][j]) &#123;</span><br><span class="line">                <span class="number">1</span> -&gt; queue.offer(i to j) <span class="comment">// 익은 토마토, 즉 거리가 0인 칸을 큐에 넣음</span></span><br><span class="line">                <span class="number">0</span> -&gt; dist[i][j] = -<span class="number">1</span> <span class="comment">// 익지 않은 토마토의 dist값을 -1로 설정</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> (curX, curY) = queue.poll()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (dir <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> (nx, ny) = curX + dx[dir] to curY + dy[dir]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (dist[nx][ny] &gt;= <span class="number">0</span>) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            dist[nx][ny] = dist[curX][curY] + <span class="number">1</span></span><br><span class="line">            queue.offer(nx to ny)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i][j] == -<span class="number">1</span>) &#123; <span class="comment">// 익지 않은 토마토가 있다면 -1 출력</span></span><br><span class="line">                print(-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            date = max(date, dist[i][j])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(date)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="응용-3-시작점이-두-종류일-때"><a class="markdownIt-Anchor" href="#응용-3-시작점이-두-종류일-때"></a> 응용 3 : 시작점이 두 종류일 때</h3><blockquote><p><a href="https://www.acmicpc.net/problem/4179">BOJ 4179번, 불!</a></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> (row, col) = nextInt() to nextInt()</span><br><span class="line">    <span class="keyword">val</span> (dx, dy) = intArrayOf(<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>) to intArrayOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> maze = Array(row) &#123; CharArray(col) &#125;</span><br><span class="line">    <span class="keyword">val</span> fireDist = Array(row) &#123; IntArray(col) &#123; -<span class="number">1</span> &#125; &#125; <span class="comment">// 불의 전파 시간</span></span><br><span class="line">    <span class="keyword">val</span> jihoonDist = Array(row) &#123; IntArray(col) &#123; -<span class="number">1</span> &#125; &#125; <span class="comment">// 지훈이의 이동 시간</span></span><br><span class="line">    <span class="keyword">val</span> fireQueue: Queue&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; = LinkedList()</span><br><span class="line">    <span class="keyword">val</span> jihoonQueue: Queue&lt;Pair&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;&gt; = LinkedList()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until row) &#123;</span><br><span class="line">        <span class="keyword">val</span> line = next()</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until col) &#123;</span><br><span class="line">            maze[i][j] = line[j]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (maze[i][j] == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">                fireQueue.offer(i to j)</span><br><span class="line">                fireDist[i][j] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maze[i][j] == <span class="string">&#x27;J&#x27;</span>) &#123;</span><br><span class="line">                jihoonQueue.offer(i to j)</span><br><span class="line">                jihoonDist[i][j] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 불에 대한 BFS</span></span><br><span class="line">    <span class="keyword">while</span> (fireQueue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> (curX, curY) = fireQueue.poll()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (dir <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> (nx, ny) = curX + dx[dir] to curY + dy[dir]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= row || ny &lt; <span class="number">0</span> || ny &gt;= col) <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (fireDist[nx][ny] &gt;= <span class="number">0</span> || maze[nx][ny] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            fireDist[nx][ny] = fireDist[curX][curY] + <span class="number">1</span></span><br><span class="line">            fireQueue.offer(nx to ny)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 지훈이에 대한 BFS</span></span><br><span class="line">    <span class="keyword">while</span> (jihoonQueue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> (curX, curY) = jihoonQueue.poll()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (dir <span class="keyword">in</span> <span class="number">0</span> until <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> (nx, ny) = curX + dx[dir] to curY + dy[dir]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 범위를 벗어난 것은 탈출에 성공했다는 의미. 큐에 거리 순으로 들어가므로 최초에 탈출한 시간을 출력하면 됨.</span></span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= row || ny &lt; <span class="number">0</span> || ny &gt;= col) &#123;</span><br><span class="line">                println(jihoonDist[curX][curY] + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (jihoonDist[nx][ny] &gt;= <span class="number">0</span> || maze[nx][ny] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (fireDist[nx][ny] != -<span class="number">1</span> &amp;&amp; fireDist[nx][ny] &lt;= jihoonDist[curX][curY] + <span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">// 불의 전파 시간을 조건에 추가. 지훈이 도착한 시간과 동시에, 혹은 더 빨리 불이 도착하는 자리로는 갈 수 없음.</span></span><br><span class="line"></span><br><span class="line">            jihoonDist[nx][ny] = jihoonDist[curX][curY] + <span class="number">1</span></span><br><span class="line">            jihoonQueue.offer(nx to ny)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;IMPOSSIBLE&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>fireDist[nx][ny] != -1</code> 조건이 필요한 이유를 설명해주는 input 케이스</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br><span class="line">###F</span><br><span class="line">.J#.</span><br><span class="line">###.</span><br></pre></td></tr></table></figure><blockquote><p>continue를 사용하지 않고 조건을 만족할 떄 로직을 실행</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (jihoonDist[nx][ny] == -<span class="number">1</span> &amp;&amp; maze[nx][ny] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fireDist[nx][ny] == -<span class="number">1</span> || fireDist[nx][ny] &gt; jihoonDist[curX][curY] + <span class="number">1</span>) &#123;</span><br><span class="line">        jihoonDist[nx][ny] = jihoonDist[curX][curY] + <span class="number">1</span></span><br><span class="line">        jihoonQueue.offer(nx to ny)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>maze 초기화 시 forEachIndeded 사용하는 방법</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until row) &#123;</span><br><span class="line">        next().forEachIndexed &#123; j, char -&gt;</span><br><span class="line">            maze[i][j] = char</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>이렇게 시작점이 두 종류인 문제를 해결할 수 있게 되었다. 하지만 시작점이 두 종류인 문제에 관해서 생각해야 할 점이 추가로 존재한다. 본 문제는 지훈이의 이동은 불의 전파에 영향을 받지만 불의 전파는 지훈이의 이동에 영향을 받지 않아서 불만 먼저 전파를 쭉 시키는게 가능했다. 그러나 시작점이 A, B 두 종류가 있고, A의 전파에 B가 영향을 주고 B의 전파에도 A가 영향을 준다고 가정해본다면 어느 하나를 먼저 끝까지 전파시키는게 불가능하다. (예를 들어, 불과 소방수 내지는 불과 물이 전파되는 문제여서 둘이 만나면 뭔가 상호작용이 발생하는 케이스)</p><p>위의 케이스를 다루는 문제가 바로 <a href="https://www.acmicpc.net/problem/18809">BOJ 18809번, Gaaaaaaaaaarden</a> 문제이다. 아쉽게도 이 문제는 <strong>백트래킹 기법</strong>을 추가로 알고 있어야 해결이 가능하기 때문에 당장 풀어볼 수는 없지만, 두 종류의 BFS에서 BFS를 돌 때 어느 하나가 독립적이지 않고 서로에게 영향을 준다면 위의 방법으로는 해결할 수 없다는 것을 꼭 이해해야 한다. 그런 상황에서는 시간 순으로 A와 B를 동시에 진행시켜야 한다.</p><h3 id="응용-4-1차원에서의-bfs"><a class="markdownIt-Anchor" href="#응용-4-1차원에서의-bfs"></a> 응용 4 : 1차원에서의 BFS</h3><blockquote><p><a href="https://www.acmicpc.net/problem/1697">BOJ 1697번, 숨바꼭질</a></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> (n, k) = nextInt() to nextInt()</span><br><span class="line">    <span class="keyword">val</span> line = Array(<span class="number">100001</span>) &#123; -<span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;<span class="built_in">Int</span>&gt; = LinkedList()</span><br><span class="line"></span><br><span class="line">    line[n] = <span class="number">0</span></span><br><span class="line">    queue.offer(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> current = queue.poll()</span><br><span class="line">        <span class="keyword">val</span> dx = intArrayOf(<span class="number">1</span>, -<span class="number">1</span>, current)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (dir <span class="keyword">in</span> dx.indices) &#123;</span><br><span class="line">            <span class="keyword">val</span> next = current + dx[dir]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next &lt; <span class="number">0</span> || next &gt; <span class="number">100000</span>) <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (line[next] != -<span class="number">1</span>) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            line[next] = line[current] + <span class="number">1</span></span><br><span class="line">            queue.offer(next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(line[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><p><a href="https://youtu.be/ftOmGdm95XI">[바킹독의 실전 알고리즘] 0x09강 - BFS</a></p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%94%ED%82%B9%EB%8F%85/">바킹독</category>
      
      <category domain="http://june0122.github.io/tags/BFS/">BFS</category>
      
      
      <comments>http://june0122.github.io/2021/07/01/boj-bfs/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BOJ] 다이나믹 프로그래밍 (Dynamic Programming, DP)</title>
      <link>http://june0122.github.io/2021/06/30/boj-dynamic-programming/</link>
      <guid>http://june0122.github.io/2021/06/30/boj-dynamic-programming/</guid>
      <pubDate>Tue, 29 Jun 2021 16:23:11 GMT</pubDate>
      
      <description>[바킹독의 실전 알고리즘] 0x10강 - 다이나믹 프로그래밍</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>여러 개의 하위 문제를 먼저 푼 후 그 결과를 쌓아올려 주어진 문제를 해결하는 알고리즘</p></blockquote><h3 id="dp를-푸는-과정"><a class="markdownIt-Anchor" href="#dp를-푸는-과정"></a> DP를 푸는 과정</h3><ol><li>테이블 정의하기</li><li>점화식 찾기</li><li>초기값 정하기</li></ol><h2 id="연습-문제"><a class="markdownIt-Anchor" href="#연습-문제"></a> 연습 문제</h2><h3 id="boj-1463-1로-만들기"><a class="markdownIt-Anchor" href="#boj-1463-1로-만들기"></a> <a href="https://www.acmicpc.net/problem/1463">BOJ 1463 : 1로 만들기</a></h3><blockquote><p>DP</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nextInt()</span><br><span class="line">    <span class="keyword">val</span> d = IntArray(n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">        d[i] = d[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) d[i] = min(d[i], d[i / <span class="number">2</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) d[i] = min(d[i], d[i / <span class="number">3</span>] + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(d[n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>BFS</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nextInt()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> queue: Queue&lt;<span class="built_in">Int</span>&gt; = LinkedList()</span><br><span class="line">    <span class="keyword">val</span> dist = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> dx = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    queue.offer(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.isNotEmpty()) &#123;</span><br><span class="line">        <span class="keyword">val</span> cur = queue.poll()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (dir <span class="keyword">in</span> dx.indices) &#123;</span><br><span class="line">            <span class="keyword">val</span> next = <span class="keyword">when</span> (dir) &#123;</span><br><span class="line">                <span class="number">0</span> -&gt; cur + dx[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">else</span> -&gt; cur * dx[dir]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next &gt; n) <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (dist[next] != <span class="number">0</span>) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            dist[next] = dist[cur] + <span class="number">1</span></span><br><span class="line">            queue.offer(next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(dist[n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="boj-9095-1-2-3-더하기"><a class="markdownIt-Anchor" href="#boj-9095-1-2-3-더하기"></a> <a href="https://www.acmicpc.net/problem/9095">BOJ 9095 : 1, 2, 3 더하기</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> t = nextInt()</span><br><span class="line">    <span class="keyword">val</span> d = IntArray(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    d[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    d[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> until <span class="number">11</span>) &#123;</span><br><span class="line">        d[i] = d[i - <span class="number">1</span>] + d[i - <span class="number">2</span>] + d[i - <span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repeat(t) &#123; println(d[nextInt()]) &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="boj-2579-계단-오르기"><a class="markdownIt-Anchor" href="#boj-2579-계단-오르기"></a> <a href="https://www.acmicpc.net/problem/2579">BOJ 2579 : 계단 오르기</a></h3><blockquote><p>2차원 배열 이용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nextInt()</span><br><span class="line">    <span class="keyword">val</span> s = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> d = Array(n + <span class="number">1</span>) &#123; IntArray(<span class="number">3</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.n) s[i] = nextInt()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        println(s[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@with</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>][<span class="number">1</span>] = s[<span class="number">1</span>]</span><br><span class="line">    d[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">    d[<span class="number">2</span>][<span class="number">1</span>] = s[<span class="number">2</span>]</span><br><span class="line">    d[<span class="number">2</span>][<span class="number">2</span>] = s[<span class="number">1</span>] + s[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3.</span>.n) &#123;</span><br><span class="line">        d[i][<span class="number">1</span>] = max(d[i - <span class="number">2</span>][<span class="number">1</span>], d[i - <span class="number">2</span>][<span class="number">2</span>]) + s[i]</span><br><span class="line">        d[i][<span class="number">2</span>] = d[i - <span class="number">1</span>][<span class="number">1</span>] + s[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(max(d[n][<span class="number">1</span>], d[n][<span class="number">2</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>D[i][j]</code> = 현재까지 <code>j</code>개의 계단을 연속해서 밟고 <code>i</code>번째 계단까지 올라섰을 때 점수 합의 최댓값, 단 <code>i</code>번째 계단은 반드시 밟아야 함</p><p>이렇게 2차원 배열을 선언한 이유는 지금까지 몇 개의 계단을 밟았는지에 대한 정보가 추가로 있어야 점화식을 세울 때 계단을 오르는 규칙을 고려할 수 있기 때문이다. 그리고 i번째 계단은 반드시 밟아야 한다는 조건이 있어야 점화식을 이끌어낼 수 있다. 이 2차원 배열에서 <code>j</code>는 어떤 값을 가지냐 보면 <code>i</code>번째 계단을 반드시 밟아야 한다는 조건이 있어서 <code>j = 1</code> 혹은 <code>2</code>이다. 연속된 세 개의 계단을 모두 밟아서는 안된다는 조건으로 인해 <code>j</code>가 <code>3</code> 이상일 수는 없다.</p><blockquote><p>1차원 배열 이용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.max</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nextInt()</span><br><span class="line">    <span class="keyword">val</span> s = IntArray(<span class="number">300</span>)</span><br><span class="line">    <span class="keyword">val</span> d = IntArray(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) s[i] = nextInt()</span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>] = s[<span class="number">0</span>]</span><br><span class="line">    d[<span class="number">1</span>] = max(s[<span class="number">0</span>] + s[<span class="number">1</span>], s[<span class="number">1</span>])</span><br><span class="line">    d[<span class="number">2</span>] = max(s[<span class="number">0</span>] + s[<span class="number">2</span>], s[<span class="number">1</span>] + s[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3</span> until n) &#123;</span><br><span class="line">        d[i] = max(d[i - <span class="number">2</span>] + s[i], d[i - <span class="number">3</span>] + s[i - <span class="number">1</span>] + s[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(d[n - <span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="boj-1149-rgb거리"><a class="markdownIt-Anchor" href="#boj-1149-rgb거리"></a> <a href="https://www.acmicpc.net/problem/1149">BOJ 1149 : RGB거리</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> kotlin.math.min</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">RGB</span></span>(<span class="keyword">var</span> red: <span class="built_in">Int</span>, <span class="keyword">var</span> green: <span class="built_in">Int</span>, <span class="keyword">var</span> blue: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nextInt()</span><br><span class="line">    <span class="keyword">val</span> colors = Array(n + <span class="number">1</span>) &#123; RGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> d = Array(n + <span class="number">1</span>) &#123; IntArray(<span class="number">3</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        colors[i].red = nextInt()</span><br><span class="line">        colors[i].green = nextInt()</span><br><span class="line">        colors[i].blue = nextInt()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = colors[<span class="number">0</span>].red</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">1</span>] = colors[<span class="number">0</span>].green</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">2</span>] = colors[<span class="number">0</span>].blue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until n) &#123;</span><br><span class="line">        d[i][<span class="number">0</span>] = min(d[i-<span class="number">1</span>][<span class="number">1</span>], d[i-<span class="number">1</span>][<span class="number">2</span>]) + colors[i].red</span><br><span class="line">        d[i][<span class="number">1</span>] = min(d[i-<span class="number">1</span>][<span class="number">0</span>], d[i-<span class="number">1</span>][<span class="number">2</span>]) + colors[i].green</span><br><span class="line">        d[i][<span class="number">2</span>] = min(d[i-<span class="number">1</span>][<span class="number">0</span>], d[i-<span class="number">1</span>][<span class="number">1</span>]) + colors[i].blue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(minOf(d[n - <span class="number">1</span>][<span class="number">0</span>], d[n - <span class="number">1</span>][<span class="number">1</span>], d[n - <span class="number">1</span>][<span class="number">2</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="boj-11726-2n-타일링"><a class="markdownIt-Anchor" href="#boj-11726-2n-타일링"></a> <a href="https://www.acmicpc.net/problem/11726">BOJ 11726 : 2×n 타일링</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nextInt()</span><br><span class="line">    <span class="keyword">val</span> d = IntArray(n + <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> mod = <span class="number">10007</span></span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    d[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3.</span>.n) d[i] = (d[i - <span class="number">1</span>] + d[i - <span class="number">2</span>]) % mod</span><br><span class="line"></span><br><span class="line">    println(d[n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="boj-11659-구간-합-구하기-4"><a class="markdownIt-Anchor" href="#boj-11659-구간-합-구하기-4"></a> <a href="https://www.acmicpc.net/problem/11659">BOJ 11659 : 구간 합 구하기 4</a></h3><blockquote><p>Prefix Sum 기법</p></blockquote><p>Prefix Sum은 시작 위치부터 현재 위치까지의 원소 합을 저장하는 배열이다.</p><p>부분 합(partial sum) 또는 누적 합(cumulative sum)이라고도 한다.</p><table><thead><tr><th style="text-align:center">Number</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:center">Prefix sum</td><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">10</td><td style="text-align:center">15</td></tr></tbody></table><p>Prefix sum은 누적 합을 미리 구하는 전처리 과정을 통해 구간 합(range sum)을 빠르게 구할 때 사용된다.</p><ul><li>prefix sum : <code>0 ~ b</code> 까지의 누적합 (반드시 첫번 째 원소를 포함하는 구간)</li><li>range sum : <code>a ~ b</code> 까지의 구간 합</li></ul><h4 id="시간-복잡도"><a class="markdownIt-Anchor" href="#시간-복잡도"></a> 시간 복잡도</h4><ul><li>전처리 단계<ul><li>1차원 : O(n)</li><li>2차원 : O(n*m)</li></ul></li><li>계산 : O(1)</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> (n, m) = nextInt() to nextInt()</span><br><span class="line">    <span class="keyword">val</span> d = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> a = IntArray(n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">        a[i] = nextInt()</span><br><span class="line">        d[i] = d[i - <span class="number">1</span>] + a[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repeat(m) &#123;</span><br><span class="line">        <span class="keyword">val</span> (i, j) = nextInt() to nextInt()</span><br><span class="line">        println(d[j] - d[i - <span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// O(n^2)</span><br><span class="line">D[i] = A[i] + A[2] + … + A[i]</span><br><span class="line"></span><br><span class="line">// O(n)</span><br><span class="line">D[i] = D[i-1] + A[i]</span><br><span class="line"></span><br><span class="line">// O(1)</span><br><span class="line">A[i] + A[i+1] + … + A[j]</span><br><span class="line">= (A[1] + A[2] + … + A[j]) - (A[1] + A[2] + … + A[i-1])</span><br><span class="line">= D[j] - D[i-1] </span><br></pre></td></tr></table></figure><h2 id="경로-추적"><a class="markdownIt-Anchor" href="#경로-추적"></a> 경로 추적</h2><h3 id="boj-12852-1로-만들기-2"><a class="markdownIt-Anchor" href="#boj-12852-1로-만들기-2"></a> <a href="https://www.acmicpc.net/problem/12852">BOJ 12852 : 1로 만들기 2</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = with(Scanner(System.`<span class="keyword">in</span>`)) &#123;</span><br><span class="line">    <span class="keyword">val</span> n = nextInt()</span><br><span class="line">    <span class="keyword">val</span> d = IntArray(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> pre = IntArray(n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">2.</span>.n) &#123;</span><br><span class="line">        d[i] = d[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        pre[i] = i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; d[i] &gt; d[i / <span class="number">2</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">            d[i] = d[i / <span class="number">2</span>] + <span class="number">1</span></span><br><span class="line">            pre[i] = i / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; d[i] &gt; d[i / <span class="number">3</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">            d[i] = d[i / <span class="number">3</span>] + <span class="number">1</span></span><br><span class="line">            pre[i] = i / <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(d[n])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cur = n</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        print(<span class="string">&quot;<span class="variable">$cur</span> &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">1</span>) <span class="keyword">break</span></span><br><span class="line">        cur = pre[cur]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위 문제를 BFS로 경로 복원 문제 풀이도 가능하다.</li></ul><h2 id="참고"><a class="markdownIt-Anchor" href="#참고"></a> 참고</h2><ul><li>바킹독의 실전 알고리즘 - <a href="https://www.youtube.com/watch?v=5leTtB3PQu0">https://www.youtube.com/watch?v=5leTtB3PQu0</a></li><li>Prefix sum - <a href="https://gamedevlog.tistory.com/68">https://gamedevlog.tistory.com/68</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/BOJ/">BOJ</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/BOJ/">BOJ</category>
      
      <category domain="http://june0122.github.io/tags/DP/">DP</category>
      
      <category domain="http://june0122.github.io/tags/%EB%B0%94%ED%82%B9%EB%8F%85/">바킹독</category>
      
      
      <comments>http://june0122.github.io/2021/06/30/boj-dynamic-programming/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[코틀린 자료구조] 연결 리스트 (Linked List)</title>
      <link>http://june0122.github.io/2021/06/27/data-structure-linked-list/</link>
      <guid>http://june0122.github.io/2021/06/27/data-structure-linked-list/</guid>
      <pubDate>Sun, 27 Jun 2021 12:51:57 GMT</pubDate>
      
      <description>&lt;b&gt;Linked list&lt;/b&gt;는 선형, 단방향 시퀀스로 배열된 값의 모음이다. linked list는 Kotlin Array, ArrayList와 같은 연속적인 저장소 옵션들&lt;small&gt;(contiguous storage options)&lt;/small&gt;에 비해 몇 가지 이론적인 장점이 있다.</description>
      
      
      
      <content:encoded><![CDATA[<p><b>Linked List<small>(연결 리스트)</small></b>는 선형, 단방향 시퀀스로 배열된 값의 모음이다. linked list는 <em>Kotlin Array, ArrayList</em>와 같은 연속적인 저장소 옵션들<small>(contiguous storage options)</small>에 비해 몇 가지 이론적인 장점이 있다.</p><ol><li>리스트의 앞부분에서 <strong>상수 시간</strong> 삽입 및 제거 수행</li><li>안정적인 성능</li></ol><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/122393576-f87b7900-cfaf-11eb-9b60-ac29477387db.png'></p><p>다이어그램이 보여주듯, linked list는 노드들의 체인이다. 노드는 두 가지의 책임을 가지고 있다.</p><ol><li>값을 가지고 있어야한다.</li><li>다음 노드에 대한 참조를 가지고 있어야 한다. 다음 노드에 대한 참조가 없다면 <em>null</em>을 통해 리스트의 끝을 나타낸다.</li></ol><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/122393617-06c99500-cfb0-11eb-959a-18b6ea1d2fc8.png'></p><h2 id="node"><a class="markdownIt-Anchor" href="#node"></a> Node</h2><blockquote><p>Node.kt</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">var</span> value: T, <span class="keyword">var</span> next: Node&lt;T&gt;? = <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="string">&quot;<span class="variable">$value</span> -&gt; <span class="subst">$&#123;next.toString()&#125;</span>&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="string">&quot;<span class="variable">$value</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 노드 생성 및 연결하기</span></span><br><span class="line">    <span class="keyword">val</span> node1 = Node(value = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> node2 = Node(value = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> node3 = Node(value = <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    node1.next = node2</span><br><span class="line">    node2.next = node3</span><br><span class="line">    </span><br><span class="line">    println(node1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure><p>이런 방법으로 리스트를 작성하는 것은 실용적이지 못하다. 이러한 문제를 해결시켜주는 일반적인 방법은 Node 객체들을 관리하는 <strong>LinkedList</strong>를 사용하는 것이다.</p><h2 id="linkedlist"><a class="markdownIt-Anchor" href="#linkedlist"></a> LinkedList</h2><blockquote><p>LinkedList.kt</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> head: Node&lt;T&gt;? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> tail: Node&lt;T&gt;? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> size = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="string">&quot;Empty list&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.toString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linked list에는 첫 번째와 마지막 노드를 각각 참조하는 <strong>head</strong>와 <strong>tail</strong>의 개념이 있다.</p><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/122397634-1c40be00-cfb4-11eb-8ed1-2db54feb2e5f.png'></p><p>또한 <em>size</em> 속성<small>(property)</small>에서 linked list의 크기를 추적할 수 있다.</p><h2 id="리스트에-값들을-추가하기"><a class="markdownIt-Anchor" href="#리스트에-값들을-추가하기"></a> 리스트에 값들을 추가하기</h2><p>다음으로, Node 객체를 관리하기 위한 인터페이스를 작성한다. 먼저 값 추가를 처리한다. Linked list에 값을 추가하는 방법에는 세 가지가 있으며, 각각 고유한 성능 특징을 지니고 있다.</p><ol><li><strong>push</strong> : 리스트의 맨 앞에 값을 추가</li><li><strong>append</strong> : 리스트의 끝에 값을 추가</li><li><strong>insert</strong> : 리스트의 특정 노드 뒤에 값을 추가</li></ol><p>이들 각각을 차례로 구현하고 성능 특징을 분석해본다.</p><h3 id="push-연산"><a class="markdownIt-Anchor" href="#push-연산"></a> push 연산</h3><p>리스트의 맨 앞에 값을 추가하는 것은 <strong>push</strong> 연산으로 알려져 있다. 또한 <strong>head-first insertion</strong>이라고도 한다. push 연산의 코드는 매우 간단하다.</p><blockquote><p><code>push(…)</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    head = Node(value = value, next = head)</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">null</span>) &#123;</span><br><span class="line">        tail = head</span><br><span class="line">    &#125;</span><br><span class="line">    size += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>빈 리스트에 값을 push할 경우, 새로운 노드는 리스트의 head와 tail이 된다. 리스트에 새로운 노드가 추가되었기 때문에 <em>size</em>의 값도 증가시켜준다.</p><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// push 예시</span></span><br><span class="line">    <span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    println(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure><p>이대로도 괜찮지만 더욱 멋지게 개선할 수 있다. <b><a href="https://ko.wikipedia.org/wiki/%ED%94%8C%EB%A3%A8%EC%96%B8%ED%8A%B8_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">Fluent interface</a></b> 패턴을 사용하여 여러 push 호출을 연결할 수 있다. <code>push()</code>로 돌아가서 <code>LinkedList&lt;T&gt;</code>를 반환 타입으로 추가한다. 그런 다음 마지막 줄에 <code>return this</code>를 추가하여 방금 요소를 push한 목록을 반환한다.</p><blockquote><p>Fluent interface pattern <code>push(…)</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(value: <span class="type">T</span>)</span></span>: LinkedList&lt;T&gt; &#123;</span><br><span class="line">    head = Node(value = value, next = head)</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">null</span>) &#123;</span><br><span class="line">        tail = head</span><br><span class="line">    &#125;</span><br><span class="line">    size += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// fluent interface push 예시</span></span><br><span class="line">    <span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>).push(<span class="number">2</span>).push(<span class="number">1</span>)</span><br><span class="line">    println(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fluent interface 패턴을 통해 복수의 요소들을 리스트의 시작 부분에 쉽게 추가할 수 있게 되었다.</p><h3 id="append-연산"><a class="markdownIt-Anchor" href="#append-연산"></a> append 연산</h3><p>append 연산은 리스트의 끝에 값을 추가하며, <strong>tail-end insertion</strong>이라고도 한다.</p><blockquote><p><code>append(…)</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">append</span><span class="params">(value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ➀</span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        push(value)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ➁</span></span><br><span class="line">    tail?.next = Node(value = value)</span><br><span class="line">    <span class="comment">// ➂</span></span><br><span class="line">    tail = tail?.next</span><br><span class="line">    size += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>이전과 마찬가지로 리스트가 비어있으면 head와 tail을 모두 새 노드로 업데이트해야한다. 빈 리스트에 추가하는 것은 기능적으로 <em>push</em>와 동일하므로 <em>push</em>를 호출하여 작업을 수행한다.</li><li>다른 모든 경우에는 현재 tail 노드 뒤에 새 노드를 만든다. if 문에서 리스트가 비어있는 경우<small>(<code>isEmpty()</code>)</small>를 이미 처리 했으므로 tail은 여기서 null이 되지 않는다.</li><li><strong>tail-end insertion</strong>이므로 새 노드도 리스트의 tail이 된다.</li></ol><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    list.append(<span class="number">1</span>)</span><br><span class="line">    list.append(<span class="number">2</span>)</span><br><span class="line">    list.append(<span class="number">3</span>)</span><br><span class="line">    println(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>append도 물론 Fluent interface 패턴을 적용시킬 수 있다!</p><blockquote><blockquote><p>Fluent interface pattern <code>append(…)</code> (<em>LinkedList.kt</em>)</p></blockquote></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">append</span><span class="params">(value: <span class="type">T</span>)</span></span>: LinkedList&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        push(value)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    tail?.next = Node(value = value)</span><br><span class="line">    tail = tail?.next</span><br><span class="line">    size += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="insert-연산"><a class="markdownIt-Anchor" href="#insert-연산"></a> insert 연산</h3><p><strong>insert</strong> 연산은 리스트의 지정된 위치에 값을 삽입하며 두 단계가 필요하다.</p><ol><li>리스트에서 지정된 노드를 찾는다.</li><li>지정된 노드의 뒤에 새로운 노드를 삽입한다.</li></ol><p>먼저 값을 삽일할 노드를 찾는 코드를 구현하자.</p><blockquote><p><code>nodeAt(…)</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">nodeAt</span><span class="params">(index: <span class="type">Int</span>)</span></span>: Node&lt;T&gt;? &#123;</span><br><span class="line">    <span class="comment">// ➀</span></span><br><span class="line">    <span class="keyword">var</span> currentNode = head</span><br><span class="line">    <span class="keyword">var</span> currentIndex = <span class="number">0</span></span><br><span class="line">    <span class="comment">// ➁</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode != <span class="literal">null</span> &amp;&amp; currentIndex &lt; index) &#123;</span><br><span class="line">        currentNode = currentNode.next</span><br><span class="line">        currentIndex += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nodeAt()</code>은 주어진 인덱스를 기반으로 리스트에서 노드 검색을 시도한다. head 노드에서만 리스트의 노드에 접근할 수 있으므로 반복 순회<small>(iterative traversals)</small>를 수행해야 한다.</p><ol><li>head에 대한 새 참조를 만들고 현재 순회 수를 추적한다.</li><li>while 루프를 사용하여 원하는 인덱스에 도달할 때까지 리스트 참조를 다음으로 이동시킨다. 빈 리스트 또는 범위를 벗어난 인덱스는 null을 반환한다.</li></ol><p>이제 새로운 노드를 삽입해보자.</p><blockquote><p><code>insert(…)</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(value: <span class="type">T</span>, afterNode: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;)</span></span>: Node&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">if</span> (tail == afterNode) &#123;</span><br><span class="line">        append(value)</span><br><span class="line">        <span class="keyword">return</span> tail!!</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">val</span> newNode = Node(value = value, next = afterNode.next)</span><br><span class="line">    <span class="comment">// ③</span></span><br><span class="line">    afterNode.next = newNode</span><br><span class="line">    size += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> newNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>수행한 작업은 다음과 같다.</p><ol><li>이 메서드가 tail 노드와 함께 호출되는 경우, 기능적으로 동일한 <em>append</em> 메서드를 호출할 수 있다. 이것은 tail의 업데이트를 처리한다.</li><li>그렇지 않으면, 새 노드를 만들고 <em>next</em> 속성을 리스트의 다음 노드에 연결한다.</li><li>지정된 노드의 <em>next</em> 값을 다시 할당하여 방금 만든 새 노드에 연결한다.</li></ol><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    println(<span class="string">&quot;Before inserting: <span class="variable">$list</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> middleNode = list.nodeAt(<span class="number">1</span>)!!</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">        middleNode = list.insert(-<span class="number">1</span> * i, middleNode)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;After inserting: <span class="variable">$list</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before inserting: 1 -&gt; 2 -&gt; 3</span><br><span class="line">After inserting: 1 -&gt; 2 -&gt; -1 -&gt; -2 -&gt; -3 -&gt; 3</span><br></pre></td></tr></table></figure><h3 id="성능-분석"><a class="markdownIt-Anchor" href="#성능-분석"></a> 성능 분석</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">push</th><th style="text-align:center">append</th><th style="text-align:center">insert</th><th style="text-align:center">nodeAt</th></tr></thead><tbody><tr><td style="text-align:center">행동</td><td style="text-align:center">head에 삽입</td><td style="text-align:center">tail에 삽입</td><td style="text-align:center">노드 뒤에 삽입</td><td style="text-align:center">주어진 인덱스의 노드를 반환</td></tr><tr><td style="text-align:center">시간 복잡도</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(i), i는 주어진 인덱스</td></tr></tbody></table><h2 id="리스트에서-값들을-제거하기"><a class="markdownIt-Anchor" href="#리스트에서-값들을-제거하기"></a> 리스트에서 값들을 제거하기</h2><p>노드의 제거에는 3가지 대표적인 연산들이 있다.</p><ol><li><strong>pop</strong> : 리스트 앞부분의 값을 제거</li><li><strong>removeLast</strong> : 리스트 끝에 있는 값을 제거</li><li><strong>removeAfter</strong> : 리스트의 어느 곳의 값이든 제거</li></ol><h3 id="pop-연산"><a class="markdownIt-Anchor" href="#pop-연산"></a> pop 연산</h3><blockquote><p><code>pop()</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty()) size -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> result = head?.value</span><br><span class="line">    head = head?.next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) tail = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pop()</code>은 리스트에서 제거된 값을 반환한다. 리스트가 비어있을 수 있으므로 이 값은</p><p>head를 다음 노드로 이동시켜 리스트의 첫 번째 노드를 효과적으로 제거할 수 있다. 더 이상 연결된 참조가 없기 때문에 가비지 컬렉터는 메서드가 완료되면 메모리에서 이전 노드를 제거한다. 리스트가 비어 있으면 tail도 null로 설정한다.</p><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    println(<span class="string">&quot;Before popping list: <span class="variable">$list</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> poppedValue = list.pop()</span><br><span class="line">    println(<span class="string">&quot;After popping list: <span class="variable">$list</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Popped value: <span class="variable">$poppedValue</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before popping list: 1 -&gt; 2 -&gt; 3</span><br><span class="line">After popping list: 2 -&gt; 3</span><br><span class="line">Popped value: 1</span><br></pre></td></tr></table></figure><h3 id="removelast-연산"><a class="markdownIt-Anchor" href="#removelast-연산"></a> removeLast 연산</h3><p>리스트의 마지막 노드를 제거하는 것은 다소 번거로운 작업이다.</p><p>tail 노드에 대한 참조가 있더라도 그 앞에 노드에 대한 참조가 없으면 잘라낼 수 없다. 따라서 마지막 노드 이전의 노드를 찾으려면 전체 리스트를 탐색해야한다.</p><blockquote><p><code>removeLast()</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeLast</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">val</span> head = head ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span> pop()</span><br><span class="line">    <span class="comment">// ③</span></span><br><span class="line">    size -= <span class="number">1</span></span><br><span class="line">    <span class="comment">// ④</span></span><br><span class="line">    <span class="keyword">var</span> prev = head</span><br><span class="line">    <span class="keyword">var</span> current = head</span><br><span class="line">    <span class="keyword">var</span> next = current.next</span><br><span class="line">    <span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">        prev = current</span><br><span class="line">        current = next</span><br><span class="line">        next = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⑤</span></span><br><span class="line">    prev.next = <span class="literal">null</span></span><br><span class="line">    tail = prev</span><br><span class="line">    <span class="keyword">return</span> current.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>head가 null이면 제거할 항목이 없으므로 null을 반환한다.</li><li>목록이 하나의 노드로만 구성된 경우 <em>removeLast</em>는 기능적으로 <em>pop</em>과 동일하다. <em>pop</em>은 head 및 tail의 참조를 업데이트하는 것을 처리하므로 이 작업을 <em>pop</em> 함수에 위임할 수 있다.</li><li>이 시점에서 노드를 제거 할 것임을 알고 있으므로 그에 따라 목록의 크기를 업데이트한다.</li><li>current.next가 null이 될 때까지 다음 노드를 계속 검색한다. 이것은 current가 목록의 마지막 노드임을 나타낸다.</li><li>current가 마지막 노드이므로 prev.next 참조를 사용하여 연결을 끊는다. tail의 참조도 업데이트해야 한다.</li></ol><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    println(<span class="string">&quot;Before removing last node: <span class="variable">$list</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> removedValue = list.removeLast()</span><br><span class="line">    println(<span class="string">&quot;After removing last node: <span class="variable">$list</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Removed value: <span class="variable">$removedValue</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before removing last node: 1 -&gt; 2 -&gt; 3</span><br><span class="line">After removing last node: 1 -&gt; 2</span><br><span class="line">Removed value: 3</span><br></pre></td></tr></table></figure><p><code>removeLast()</code>를 사용하려면 리스트를 순회해야 한다. 이것은 비교적 비용이 많이 드는 <em>O(n)</em> 연산을 하게 된다.</p><h3 id="remove-연산"><a class="markdownIt-Anchor" href="#remove-연산"></a> remove 연산</h3><p>remove 연산은 리스트의 특정 지점에서 노드를 제거하는 것이다. 이것은 <code>insert()</code>와 매우 유사하다. 먼저 제거하려는 노드의 바로 앞 노드를 찾은 다음 연결을 해제<small>(unlink)</small>해야 한다.</p><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/122572442-b40fdc00-d088-11eb-9132-9ac1d7a295f0.png'></p><blockquote><p><code>removeAfter()</code> (<em>LinkedList.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">removeAfter</span><span class="params">(node: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;)</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">val</span> result = node.next?.value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.next == tail) tail = node</span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>) size -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    node.next = node.next?.next</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tail 참조를 업데이트해야 하므로 제거된 노드가 tail 노드인 경우 특별한 주의가 필요하다.</p><blockquote><p>테스트 (<em>Main.kt</em>)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before removing at particular index: <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br><span class="line">After removing at index <span class="number">1</span>: <span class="number">1</span> -&gt; <span class="number">3</span></span><br><span class="line">Removed value: <span class="number">2</span></span><br></pre></td></tr></table></figure><p><code>insert()</code>와 유사하게 이 작업의 시간 복잡도는 *O(1)*이지만 미리 특정 노드에 대한 참조가 있어야 한다.</p><h3 id="성능-분석-2"><a class="markdownIt-Anchor" href="#성능-분석-2"></a> 성능 분석</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">pop</th><th style="text-align:center">removeLast</th><th style="text-align:center">removeAfter</th></tr></thead><tbody><tr><td style="text-align:center">행동</td><td style="text-align:center">head를 제거</td><td style="text-align:center">tail을 제거</td><td style="text-align:center">바로 다음 노드를 제거</td></tr><tr><td style="text-align:center">시간 복잡도</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td></tr></tbody></table><p>지금까지 대부분의 프로그래머가 공감할 수 있는 linked list에 대한 인터페이스를 정의했다. 하지만 Kotlin semantic을 더욱 돋보이게 하려면 수행해야 할 작업이 존재한다. 본문의 다음 절반에서는 Kotlin의 관용적<small>(idomatic)</small>인 부분을 활용하여 더 나은 인터페이스를 만드는데 초점을 맞출 것이다.</p><h2 id="kotlin-collection-interfaces"><a class="markdownIt-Anchor" href="#kotlin-collection-interfaces"></a> Kotlin collection interfaces</h2><p>Kotlin 표준 라이브러리에는 특정 유형에 대해 예상되는 사항을 정의하는데 도움이 되는 인터페이스 모음이 있다. 이러한 각 인터페이스는 특성과 성능에 대한 특정한 보증을 제공한다. 이러한 인터페이스 모음 중 4개를 컬렉션 인터페이스라고 한다.</p><p>다음은 각 인터페이스가 나타내는 작은 예시들이다.</p><ol><li>Iterable : iterable 타입은 <em>Iterator</em>를 통해 요소들에 대한 순차적 접근을 제공한다.</li><li>Collection : 컬렉션 타입은 추가 기능을 제공하는 iterable 타입으로, 컬렉션이 특정 요소 또는 요소들의 컬렉션을 포함하고 있는지 확인할 수 있게 해준다.</li><li>MutableIterable : 주어진 컬렉션에서 항목들을 제거할 수 있는 MutableIterator를 제공한다.</li><li>MutableCollection : 단순 컬렉션과 달리, MutableCollection 인터페이스는 컬렉션을 변경하는 메서드를 제공한다. 예를 들어, 요소를 <em>추가</em> 및 <em>제거</em>할 수 있으며 전체 <em>컬렉션을 지울 수도</em> 있다.</li></ol><p>Linked list는 컬렉션 인터페이스의 계층 4에 도달 할 수 있습니다. Linked list는 연결된 노드들이므로<small>(chain of nodes)</small> Iterable 인터페이스를 채택하는 것이 합리적이다. 이미 요소 추가 및 제거를 구현 했으므로 MutableCollection 인터페이스로 이동할 수 있다는 것이 매우 분명하다.</p><br><div style="text-align: right"> <a href="https://www.raywenderlich.com/books/data-structures-algorithms-in-kotlin/v1.0"><b><i>Data Structures & Algorithms in Kotlin</i></b></a> 서적을 참고하여 작성했습니다. </div>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Data-Structure/">Data Structure</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Data-Structure/">Data Structure</category>
      
      <category domain="http://june0122.github.io/tags/Linked-List/">Linked List</category>
      
      
      <comments>http://june0122.github.io/2021/06/27/data-structure-linked-list/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 레벨 2 : 카펫</title>
      <link>http://june0122.github.io/2021/06/26/programmers-42842/</link>
      <guid>http://june0122.github.io/2021/06/26/programmers-42842/</guid>
      <pubDate>Sat, 26 Jun 2021 11:28:54 GMT</pubDate>
      
      <description>[코딩테스트 고득점 Kit - 완전탐색] 레벨 2</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/42842">문제 보기</a></h3><p><code>완전탐색</code></p><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>첫 시도</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(brown: <span class="type">Int</span>, yellow: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> total = brown + yellow</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">3</span> .. (total / <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">3</span> .. (total / <span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= j &amp;&amp; i * j == total &amp;&amp; checkBrown(i to j, brown)) <span class="keyword">return</span> intArrayOf(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> intArrayOf()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">checkBrown</span><span class="params">(pair: <span class="type">Pair</span>&lt;<span class="type">Int</span>, <span class="built_in">Int</span>&gt;, brown: <span class="type">Int</span>)</span></span> = (pair.first * <span class="number">2</span>) + (pair.second * <span class="number">2</span>) - <span class="number">4</span> == brown</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>(가로 * 2) + (세로 * 2) - 4 = brown</code></p><p>테두리의 갈색 격자의 개수는 가로와 세로를 각각 2를 곱해주고 모서리 부분에서 중복되는 4만큼을 빼서 구할 수 있는 것을 이용하였다.</p><p>이렇게 하면 간단하게 구현할 수 있지만 시간 복잡도적인 측면에서 효율적이진 못한 코드라 개선이 필요해보인다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">테스트 <span class="number">1</span> 〉통과 (<span class="number">0.</span>71ms, <span class="number">54.</span>8MB)</span><br><span class="line">테스트 <span class="number">2</span> 〉통과 (<span class="number">1.</span>04ms, <span class="number">55.</span>1MB)</span><br><span class="line">테스트 <span class="number">3</span> 〉통과 (<span class="number">229.</span>05ms, <span class="number">54.</span>4MB)</span><br><span class="line">테스트 <span class="number">4</span> 〉통과 (<span class="number">30.</span>27ms, <span class="number">55.</span>2MB)</span><br><span class="line">테스트 <span class="number">5</span> 〉통과 (<span class="number">28.</span>67ms, <span class="number">54.</span>5MB)</span><br><span class="line">테스트 <span class="number">6</span> 〉통과 (<span class="number">152.</span>95ms, <span class="number">54.</span>7MB)</span><br><span class="line">테스트 <span class="number">7</span> 〉통과 (<span class="number">688.</span>13ms, <span class="number">54.</span>2MB)</span><br><span class="line">테스트 <span class="number">8</span> 〉통과 (<span class="number">239.</span>40ms, <span class="number">54.</span>4MB)</span><br><span class="line">테스트 <span class="number">9</span> 〉통과 (<span class="number">379.</span>53ms, 55MB)</span><br><span class="line">테스트 <span class="number">10</span> 〉통과 (<span class="number">400.</span>44ms, <span class="number">55.</span>5MB)</span><br><span class="line">테스트 <span class="number">11</span> 〉통과 (<span class="number">0.</span>65ms, <span class="number">55.</span>4MB)</span><br><span class="line">테스트 <span class="number">12</span> 〉통과 (<span class="number">0.</span>66ms, <span class="number">55.</span>8MB)</span><br><span class="line">테스트 <span class="number">13</span> 〉통과 (<span class="number">1.</span>30ms, 55MB)</span><br></pre></td></tr></table></figure><blockquote><p>근의 공식 활용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(brown: <span class="type">Int</span>, yellow: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> D = ((brown + <span class="number">4</span>) / <span class="number">2</span>).toDouble().pow(<span class="number">2.0</span>) - <span class="number">4</span> * (brown + yellow)</span><br><span class="line">        <span class="keyword">val</span> width = ((brown + <span class="number">4</span>) / <span class="number">2</span> + sqrt(D)) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">val</span> height = ((brown + <span class="number">4</span>) / <span class="number">2</span> - sqrt(D)) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> intArrayOf(width.toInt(), height.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>먼저 문제의 지문에서 아래 두 개의 식을 구할 수 있다.</li></ol><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/123511666-9a404b80-d6bd-11eb-99c8-20393430d471.png'></p><ol start="2"><li>그 다음 계산의 편의성을 위해 아래와 같이 <code>A</code>와 <code>B</code>로 치환시킨다.</li></ol><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/123511670-a0cec300-d6bd-11eb-8ba7-03f931e5403b.png'></p><ol start="3"><li>치환한 값을 대입시키면 아래와 같은 이차 방정식을 구할 수 있다.</li></ol><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/123511672-a75d3a80-d6bd-11eb-9968-1bd1a87322b9.png'></p><ol start="4"><li>근의 공식을 이용하면 가로와 세로의 크기를 구할 수 있다. 근의 공식은 다음과 같다.</li></ol><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/123511675-ad531b80-d6bd-11eb-835d-335a687c8714.png'></p><ol start="5"><li>가로가 세로보다 크거나 같으므로 가로인 <code>w</code>에 sqrt(D)를 더하고 세로인 <code>h</code>에서는 빼면 값을 구할 수 있다.</li></ol><p align = 'center'><img width = '250' src = 'https://user-images.githubusercontent.com/39554623/123511680-b348fc80-d6bd-11eb-9c14-4cc2bb606850.png'></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">테스트 <span class="number">1</span> 〉통과 (<span class="number">0.</span>05ms, <span class="number">55.</span>3MB)</span><br><span class="line">테스트 <span class="number">2</span> 〉통과 (<span class="number">0.</span>04ms, <span class="number">55.</span>4MB)</span><br><span class="line">테스트 <span class="number">3</span> 〉통과 (<span class="number">0.</span>04ms, <span class="number">54.</span>6MB)</span><br><span class="line">테스트 <span class="number">4</span> 〉통과 (<span class="number">0.</span>05ms, 55MB)</span><br><span class="line">테스트 <span class="number">5</span> 〉통과 (<span class="number">0.</span>05ms, <span class="number">55.</span>1MB)</span><br><span class="line">테스트 <span class="number">6</span> 〉통과 (<span class="number">0.</span>07ms, <span class="number">54.</span>9MB)</span><br><span class="line">테스트 <span class="number">7</span> 〉통과 (<span class="number">0.</span>06ms, <span class="number">54.</span>6MB)</span><br><span class="line">테스트 <span class="number">8</span> 〉통과 (<span class="number">0.</span>04ms, <span class="number">54.</span>8MB)</span><br><span class="line">테스트 <span class="number">9</span> 〉통과 (<span class="number">0.</span>06ms, <span class="number">54.</span>6MB)</span><br><span class="line">테스트 <span class="number">10</span> 〉통과 (<span class="number">0.</span>05ms, <span class="number">55.</span>3MB)</span><br><span class="line">테스트 <span class="number">11</span> 〉통과 (<span class="number">0.</span>04ms, <span class="number">54.</span>7MB)</span><br><span class="line">테스트 <span class="number">12</span> 〉통과 (<span class="number">0.</span>05ms, 55MB)</span><br><span class="line">테스트 <span class="number">13</span> 〉통과 (<span class="number">0.</span>04ms, <span class="number">54.</span>5MB)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Programmers/">Programmers</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Programmers/">Programmers</category>
      
      <category domain="http://june0122.github.io/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/">완전탐색</category>
      
      
      <comments>http://june0122.github.io/2021/06/26/programmers-42842/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 레벨 2 : H-Index</title>
      <link>http://june0122.github.io/2021/06/25/programmers-42747/</link>
      <guid>http://june0122.github.io/2021/06/25/programmers-42747/</guid>
      <pubDate>Fri, 25 Jun 2021 04:46:25 GMT</pubDate>
      
      <description>[코딩테스트 고득점 Kit - 정렬] 레벨 2</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/42747">문제 보기</a></h3><p><code>정렬</code></p><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>나의 풀이</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(citations: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> h = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> citedList = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> uncitedList = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">        citations.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &lt;= citations.size) &#123;</span><br><span class="line">            citations.forEach &#123;</span><br><span class="line">                <span class="keyword">if</span> (it &gt;= count) citedList.add(it)</span><br><span class="line">                <span class="keyword">else</span> uncitedList.add(it)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (citedList.size &gt;= count &amp;&amp; uncitedList.size &lt;= count) h = count</span><br><span class="line">            &#125;</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            citedList.clear()</span><br><span class="line">            uncitedList.clear()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>다른 사람의 풀이</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.min</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(citations: <span class="type">IntArray</span>)</span></span> = citations.sortedDescending().mapIndexed &#123; idx, item -&gt; min(idx + <span class="number">1</span>, item) &#125;.max()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Programmers/">Programmers</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Programmers/">Programmers</category>
      
      <category domain="http://june0122.github.io/tags/%EC%A0%95%EB%A0%AC/">정렬</category>
      
      
      <comments>http://june0122.github.io/2021/06/25/programmers-42747/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] 레벨 2 : 튜플</title>
      <link>http://june0122.github.io/2021/06/25/programmers-64065/</link>
      <guid>http://june0122.github.io/2021/06/25/programmers-64065/</guid>
      <pubDate>Fri, 25 Jun 2021 04:39:51 GMT</pubDate>
      
      <description>[2019 카카오 개발자 겨울 인턴십] 레벨 2</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제-보기"><a class="markdownIt-Anchor" href="#문제-보기"></a> <a href="https://programmers.co.kr/learn/courses/30/lessons/64065">문제 보기</a></h3><h2 id="소스"><a class="markdownIt-Anchor" href="#소스"></a> 소스</h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> kotlin</h3><blockquote><p>나의 풀이</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(s: <span class="type">String</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">set</span> = mutableSetOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">val</span> elements = s.replace(<span class="string">&quot;&#123;&#123;&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#125;&#125;&quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;&#125;,&#123;&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> arr = elements.map &#123; it.split(<span class="string">&quot;,&quot;</span>) &#125;.sortedBy &#123; it.size &#125;</span><br><span class="line"></span><br><span class="line">        arr.forEach &#123;</span><br><span class="line">            it.forEach &#123; </span><br><span class="line">                <span class="keyword">set</span>.add(it.toInt())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">set</span>.toIntArray()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>fold(…)</code> 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">solution</span><span class="params">(s: <span class="type">String</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">return</span> s.split(<span class="string">&quot;&#125;,&#123;&quot;</span>)</span><br><span class="line">            .map &#123; it.replace(<span class="string">&quot;[^0-9,]&quot;</span>.toRegex(), <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;,&quot;</span>).map &#123; it.toInt() &#125; &#125;</span><br><span class="line">            .sortedBy &#123; it.size &#125;</span><br><span class="line">            .fold(setOf&lt;<span class="built_in">Int</span>&gt;()) &#123; acc, list -&gt; acc.union(list) &#125;</span><br><span class="line">            .toIntArray()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/Programmers/">Programmers</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/Programmers/">Programmers</category>
      
      <category domain="http://june0122.github.io/tags/%EC%A0%95%EB%A0%AC/">정렬</category>
      
      
      <comments>http://june0122.github.io/2021/06/25/programmers-64065/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 2. Add Two Numbers</title>
      <link>http://june0122.github.io/2021/06/15/leetcode-2/</link>
      <guid>http://june0122.github.io/2021/06/15/leetcode-2/</guid>
      <pubDate>Tue, 15 Jun 2021 04:59:28 GMT</pubDate>
      
      <description>2. Add Two Numbers</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="leetcode-2-add-two-numbers"><a class="markdownIt-Anchor" href="#leetcode-2-add-two-numbers"></a> <a href="https://leetcode.com/problems/add-two-numbers/">[LeetCode] 2. Add Two Numbers</a></h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h3><blockquote><h3 id="자리올림smallcarrysmall-이용"><a class="markdownIt-Anchor" href="#자리올림smallcarrysmall-이용"></a> 자리올림<small>(carry)</small> 이용</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> ListNode.<span class="title">value</span><span class="params">()</span></span> = <span class="keyword">this</span>?.`<span class="keyword">val</span>` ?: <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addTwoNumbers</span><span class="params">(l1: <span class="type">ListNode</span>?, l2: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">        <span class="keyword">var</span> (list1, list2) = l1 to l2</span><br><span class="line">        <span class="keyword">var</span> head = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> cur = head</span><br><span class="line">        <span class="keyword">var</span> carry = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> || list2 != <span class="literal">null</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> x = list1?.value() ?: <span class="number">0</span></span><br><span class="line">            <span class="keyword">val</span> y = list2?.value() ?: <span class="number">0</span></span><br><span class="line">            <span class="keyword">val</span> sum = (x + y + carry) % <span class="number">10</span></span><br><span class="line">            carry = (x + y + carry) / <span class="number">10</span></span><br><span class="line">            cur?.next = ListNode(sum)</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> (list1 != <span class="literal">null</span>) list1 = list1.next</span><br><span class="line">            <span class="keyword">if</span> (list2 != <span class="literal">null</span>) list2 = list2.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime: 240 ms, faster than 18.40% of Kotlin online submissions for Add Two Numbers.</span><br><span class="line">Memory Usage: 43.6 MB, less than 11.74% of Kotlin online submissions for Add Two Numbers.</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://june0122.github.io/2021/06/15/leetcode-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 1. Two Sum</title>
      <link>http://june0122.github.io/2021/06/13/leetcode-1/</link>
      <guid>http://june0122.github.io/2021/06/13/leetcode-1/</guid>
      <pubDate>Sun, 13 Jun 2021 11:49:45 GMT</pubDate>
      
      <description>1. Two Sum</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="leetcode-1-two-sum"><a class="markdownIt-Anchor" href="#leetcode-1-two-sum"></a> <a href="https://leetcode.com/problems/two-sum/">[LeetCode] 1. Two Sum</a></h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h3><blockquote><h3 id="brute-force"><a class="markdownIt-Anchor" href="#brute-force"></a> Brute Force</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">twoSum</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">var</span> twoNum = <span class="number">0</span> to <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until nums.size) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) twoNum = i to j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> intArrayOf(twoNum.first, twoNum.second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">232 ms36.5 MB</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">twoSum</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until nums.size) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) <span class="keyword">return</span> intArrayOf(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;No two sum solution&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">236 ms36.8 MB</span><br></pre></td></tr></table></figure><h4 id="시간-복잡도-onsup2sup"><a class="markdownIt-Anchor" href="#시간-복잡도-onsup2sup"></a> 시간 복잡도 : O(n<sup>2</sup>)</h4><h4 id="공간-복잡도-o1"><a class="markdownIt-Anchor" href="#공간-복잡도-o1"></a> 공간 복잡도 : O(1)</h4><blockquote><h3 id="two-pass-hash-table"><a class="markdownIt-Anchor" href="#two-pass-hash-table"></a> Two-pass Hash Table</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">twoSum</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> hashmap = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">        </span><br><span class="line">        nums.forEachIndexed &#123; index, value -&gt;</span><br><span class="line">            hashmap[value] = index</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        nums.forEachIndexed &#123; index, value -&gt;</span><br><span class="line">            <span class="keyword">val</span> complement = target - value</span><br><span class="line">            <span class="keyword">if</span> (hashmap.containsKey(complement) &amp;&amp; hashmap.getValue(complement) != index) &#123;</span><br><span class="line">                <span class="keyword">return</span> intArrayOf(index, hashmap.getValue(complement))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;No two sum solution&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">204 ms37.4 MB</span><br></pre></td></tr></table></figure><h4 id="시간-복잡도-on"><a class="markdownIt-Anchor" href="#시간-복잡도-on"></a> 시간 복잡도 : O(n)</h4><p>n개의 요소들을 가지고 있는 리스트를 2번 순회하지만, HashMap을 사용하여 look up time을 O(1)으로 줄였기 때문에 결과적으론 O(n)이다.</p><h4 id="공간-복잡도-on"><a class="markdownIt-Anchor" href="#공간-복잡도-on"></a> 공간 복잡도 : O(n)</h4><p>HashMap 사용으로 n개의 요소들을 저장하기 때문에 추가적인 공간이 필요하다.</p><blockquote><h3 id="one-pass-hash-table"><a class="markdownIt-Anchor" href="#one-pass-hash-table"></a> One-pass Hash Table</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">twoSum</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">        <span class="keyword">val</span> hashmap = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">        </span><br><span class="line">        nums.forEachIndexed &#123; index, value -&gt;</span><br><span class="line">            <span class="keyword">val</span> complement = target - value</span><br><span class="line">            <span class="keyword">if</span> (hashmap.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> intArrayOf(hashmap.getValue(complement), index)</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap[value] = index</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;No two sum solution&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">188 ms37.9 MB</span><br></pre></td></tr></table></figure><h4 id="시간-복잡도-on-2"><a class="markdownIt-Anchor" href="#시간-복잡도-on-2"></a> 시간 복잡도 : O(n)</h4><p>n개의 원소들을 가진 리스트를 딱 한 번만 순회하고, HashMap에서의 look up time은 오직 O(1)만 소모하므로 시간 복잡도는 O(n)이다.</p><h4 id="공간-복잡도-on-2"><a class="markdownIt-Anchor" href="#공간-복잡도-on-2"></a> 공간 복잡도 : O(n)</h4><p>Two-pass Hash Table 방법과 마찬가지로 HashMap 사용으로 n개의 요소들을 저장하기 때문에 추가적인 공간이 필요하다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://june0122.github.io/2021/06/13/leetcode-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 232. Implement Queue using Stacks</title>
      <link>http://june0122.github.io/2021/06/12/leetcode-232/</link>
      <guid>http://june0122.github.io/2021/06/12/leetcode-232/</guid>
      <pubDate>Sat, 12 Jun 2021 00:33:36 GMT</pubDate>
      
      <description>232. Implement Queue using Stacks</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="leetcode-232-implement-queue-using-stacks"><a class="markdownIt-Anchor" href="#leetcode-232-implement-queue-using-stacks"></a> <a href="https://leetcode.com/problems/implement-queue-using-stacks/">[LeetCode] 232. Implement Queue using Stacks</a></h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">val</span> input = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> output = Stack&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        input.push(x)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        peek()</span><br><span class="line">        <span class="keyword">return</span> output.pop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (output.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(input.isNotEmpty()) &#123;</span><br><span class="line">                output.push(input.pop())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output.peek()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">empty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> input.isEmpty() &amp;&amp; output.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime: 168 ms, faster than 26.03% of Kotlin online submissions for Implement Queue using Stacks.</span><br><span class="line">Memory Usage: 35.4 MB, less than 100.00% of Kotlin online submissions for Implement Queue using Stacks.</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://june0122.github.io/2021/06/12/leetcode-232/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] 225. Implement Stack using Queues</title>
      <link>http://june0122.github.io/2021/06/12/leetcode-225/</link>
      <guid>http://june0122.github.io/2021/06/12/leetcode-225/</guid>
      <pubDate>Sat, 12 Jun 2021 00:33:36 GMT</pubDate>
      
      <description>225. Implement Stack using Queues</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="leetcode-225-implement-stack-using-queues"><a class="markdownIt-Anchor" href="#leetcode-225-implement-stack-using-queues"></a> <a href="https://leetcode.com/problems/implement-stack-using-queues/">[LeetCode] 225. Implement Stack using Queues</a></h2><h3 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> Kotlin</h3><blockquote><p>Queue 1개 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">val</span> q1: Queue&lt;<span class="built_in">Int</span>&gt; = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> size = q1.size</span><br><span class="line">        q1.offer(x)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until size) &#123;</span><br><span class="line">            q1.offer(q1.poll())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.poll()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">top</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.peek()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">empty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Queue 2개 사용</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">val</span> q1: Queue&lt;<span class="built_in">Int</span>&gt; = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">val</span> q2: Queue&lt;<span class="built_in">Int</span>&gt; = LinkedList&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">push</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        q1.add(x);</span><br><span class="line">        <span class="keyword">while</span> (!q2.isEmpty())</span><br><span class="line">            q1.add(q2.poll());</span><br><span class="line">        <span class="keyword">while</span> (!q1.isEmpty())</span><br><span class="line">            q2.add(q1.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">pop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q2.poll()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">top</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q2.peek()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">empty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty() &amp;&amp; q2.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/categories/Algorithm/LeetCode/">LeetCode</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Algorithm/">Algorithm</category>
      
      <category domain="http://june0122.github.io/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://june0122.github.io/2021/06/12/leetcode-225/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Kotlin] Coroutine - 코루틴의 내부 구현</title>
      <link>http://june0122.github.io/2021/06/09/coroutines-under-the-hood/</link>
      <guid>http://june0122.github.io/2021/06/09/coroutines-under-the-hood/</guid>
      <pubDate>Wed, 09 Jun 2021 08:48:07 GMT</pubDate>
      
      <description>코루틴은 디컴파일되면 일반 코드일 뿐이다. &lt;b&gt;Continuation Passing Style&lt;small&gt;(CPS, 연속 전달 방식)&lt;/b&gt; 이라는 형태로 동작하며, 결과를 호출자에게 직접 반환하는 대신 &lt;b&gt;Continuation&lt;/b&gt;으로 결과를 전달한다. &lt;b&gt;Continuation&lt;/b&gt;이라는 객체가 있고, 매 번 함수를 호출할 때마다 &lt;b&gt;continuation&lt;/b&gt;을 넘겨준다. &lt;b&gt;continuation&lt;/b&gt;은 Callback 인터페이스 같은 것으로, 재개를 해주는 인터페이스를 가진 객체인 것이다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="코루틴은-jvm에서-내부적으로-어떻게-동작하는-것일까"><a class="markdownIt-Anchor" href="#코루틴은-jvm에서-내부적으로-어떻게-동작하는-것일까"></a> 코루틴은 JVM에서 내부적으로 어떻게 동작하는 것일까?</h2><p>아래의 내용은 <a href="https://www.youtube.com/watch?v=YrrUCSi72E8&amp;t=110s">KotlinConf 2017 - Deep Dive into Coroutines on JVM by Roman Elizarov</a> 영상의 내용들이다.</p><h4 id="there-is-no-magic"><a class="markdownIt-Anchor" href="#there-is-no-magic"></a> There is no magic</h4><p>코루틴은 디컴파일되면 일반 코드일 뿐이다. <strong>Continuation Passing Style<small>(CPS, 연속 전달 방식)</small></strong> 이라는 형태의 코드로 전환한다.</p><blockquote><h3 id="a-toy-problem"><a class="markdownIt-Anchor" href="#a-toy-problem"></a> A toy problem</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> token = requestToken()</span><br><span class="line">    <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">    processPost(post)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>서버에서 토큰을 가져와서 게시물을 포스트한 다음, 포스트 완료처리를 하는 세 가지 연산을 코루틴으로 만들면 JVM 혹은 바이트코드에서 내부적으로 어떤 형태로 동작하는 것일까?</p><p>이것이 Continuation Passing Style로 내부적으로 컴파일할 때 아래와 같이 바뀐다.</p><blockquote><h3 id="continuation-passing-style"><a class="markdownIt-Anchor" href="#continuation-passing-style"></a> Continuation Passing Style</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">    requestToken &#123; token -&gt;</span><br><span class="line">        <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">        processPost(post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Continuation Passing Style은 결과를 호출자에게 직접 반환하는 대신 <strong>Callback</strong>같은 것 <sup>continuation</sup>으로 결과를 전달하는 것을 의미한다.</p><blockquote><h3 id="kotlin-suspending-functions"><a class="markdownIt-Anchor" href="#kotlin-suspending-functions"></a> Kotlin suspending functions</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">createPost</span><span class="params">(token: <span class="type">Token</span>, item: <span class="type">Item</span>)</span></span>: Post &#123; … &#125;</span><br></pre></td></tr></table></figure><p><code>createPost(…)</code>라는 suspend 함수를 하나를 만들었을 때, 코루틴에서는 일시 중단이 되었다가 재개가 되는데 어떻게 이것이 가능한 것인지 알아보자.</p><blockquote><h3 id="kotlin-suspending-functions-2"><a class="markdownIt-Anchor" href="#kotlin-suspending-functions-2"></a> Kotlin suspending functions</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// suspend fun createPost(token: Token, item: Item): Post &#123; … &#125;</span></span><br><span class="line">     ↓</span><br><span class="line"><span class="comment">// Java/JVM </span></span><br><span class="line"><span class="function">Object <span class="title">createPost</span><span class="params">(Token token, Item item, Continuation&lt;Post&gt; cont)</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure><p>내부적으로는 JVM에 들어갈 때 바이트코드로 컴파일되면서 같은 <code>createPost(…)</code>인데 <strong>Continuation</strong>이 생성되어 Continuation Passing Style로 변환된다.</p><p>호출했던 함수의 끝에 매개변수가 하나 추가되서 <strong>Continuation</strong>이라는 객체를 넘겨주는 것으로 변환되는 것이다.</p><blockquote><h3 id="labels"><a class="markdownIt-Anchor" href="#labels"></a> Labels</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    suspen <span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// LABEL 0</span></span><br><span class="line">↛       <span class="keyword">val</span> token = requestToken()</span><br><span class="line">    <span class="comment">// LABEL 1</span></span><br><span class="line">↛       <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">    <span class="comment">// LABEL 2</span></span><br><span class="line">        processPost(post)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>먼저 Labael이라는 작업을 하게 되는데 코루틴에서 순차적으로 작성했던 코드들이 <code>suspend</code> 함수가 되면 컴파일할 때 Label이 찍히게 된다.</p><p>이 함수가 재개되어야 하는데, 재개될 때 필요한 <strong>Suspention Point</strong><small>(중단 지점과 재개 지점)</small>가 요구된다. 그래서 이 지점들을 Label로 찍어놓는 것이다. 이런 작업을 코틀린 컴파일러가 내부적으로 하게 된다.</p><p>대략적으로 아래와 같은 형태가 되는데, 작성했던 함수가 내부적으론 <code>switch-case</code>문처럼 바뀌어 case문이 3개가 생성되고 세 번을 실행하는 것을 알 수 있다. 함수를 실행할 때 0번이든, 1번이든, 2번이든 함수를 재개할 수 있는 지점이 생긴 것이다. 그리고 이 함수를 호출한 지점은 중단점이 될 수도 있는 것이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">    switch (label) &#123;</span><br><span class="line">        case <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">val</span> token = requestToken()</span><br><span class="line">        case <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">val</span> post = createPost(token, item)</span><br><span class="line">        case <span class="number">2</span>:</span><br><span class="line">            processPost(post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Label들이 다 완성되고 나면 Continuation Passing Style로 변환을 하게 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>, cont: <span class="type">Continuation</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sm = <span class="keyword">object</span> : CoroutineImpl &#123; … &#125;</span><br><span class="line">    switch (sm.label) &#123;</span><br><span class="line">        case <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">val</span> token = requestToken(sm)</span><br><span class="line">        case <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">val</span> post = createPost(token, item, sm)</span><br><span class="line">        case <span class="number">2</span>:</span><br><span class="line">            processPost(post)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Continuation</strong>이라는 객체가 있고, 매 번 함수를 호출할 때마다 <strong>continuation</strong>을 넘겨준다. <strong>continuation</strong>은 Callback 인터페이스 같은 것으로, 재개를 해주는 인터페이스를 가진 객체인 것이다.</p><p>위의 코드에서 <code>sm</code>이라고 하는 것은 <strong>state machine</strong>을 의미하는데, 각각의 함수가 호출될 때 상태<small>(지금까지 했던 연산의 결과)</small>를 같이 넘겨줘야 한다. 이 <strong>state machine</strong>의 정체는 결국 <strong>Continuation</strong>이고, <strong>Continuation</strong>이 어떠한 정보값을 가진 형태로 Passing이 되면서 코루틴이 내부적으로 동작하게 되는 것이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">postItem</span><span class="params">(item: <span class="type">Item</span>, cont: <span class="type">Continuation</span>)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> sm = cont <span class="keyword">as</span>? ThisSM ?: <span class="keyword">object</span> : ThisSM &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(…)</span></span> &#123;</span><br><span class="line">            postItem(<span class="literal">null</span>, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (sm.label) &#123;</span><br><span class="line">        case <span class="number">0</span>:</span><br><span class="line">            sm.item = item</span><br><span class="line">            sm.label = <span class="number">1</span></span><br><span class="line">            requestToken(sm)</span><br><span class="line">        case <span class="number">1</span>:</span><br><span class="line">            createPost(token, item, sm)</span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각각의 suspend function이 Continuation<small>(위 코드에선 <code>sm</code>)</small>을 마지막 매개변수로 가져가게 된다.</p><ul><li>만약 <code>requestToken(sm)</code>이 완료되었다면 <code>sm</code><small>(continuation)</small>에다가 <code>resume()</code>을 호출하게 된다.</li><li>다시 <code>createPost(token, item, sm)</code>가 호출되고 이것이 완료되었을 때도 <code>sm</code><small>(continuation)</small>에다가 <code>resume()</code>을 호출하는 형태가 반복되는 것이다.</li></ul><p>그렇다면 <code>resume()</code>은 정체가 무엇일까? 위의 코드에서 <code>resume()</code>은 결국 자기 자신을 불러주는 것이다. <small>(<code>postItem(…)</code> 내부에서 <code>postItem(…)</code>을 다시 호출하고 있음)</small></p><ul><li>예시로, suspend function인 <code>requestToken(sm)</code>의 연산이 끝났을 때 <code>resume()</code>을 통해 다시 <code>postItem(…)</code>이 호출되는데, 그때 Label 값을 하나 올려서 다른 케이스가 호출되도록 하는 것이다. 이렇게 되면 내부적으로는 마치 suspend function이 호출되고 다음 번 케이스, 그리고 또다시 다음 번 케이스로 넘어가는 형태가 되는 것이다.</li></ul><h2 id="decomplie된-코드-살펴보기"><a class="markdownIt-Anchor" href="#decomplie된-코드-살펴보기"></a> Decomplie된 코드 살펴보기</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> userData = fetchUserData()</span><br><span class="line">        <span class="keyword">val</span> userCache = cacheUserData(userData)</span><br><span class="line">        updateTextView(userCache)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchUserData</span><span class="params">()</span></span> = <span class="string">&quot;user_name&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">cacheUserData</span><span class="params">(user: <span class="type">String</span>)</span></span> = user</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">updateTextView</span><span class="params">(user: <span class="type">String</span>)</span></span> = user</span><br></pre></td></tr></table></figure><p>위의 코드를 코틀린의 바이트코드로 만든 다음, Decompile하여 Java 코드로 만들어보자.</p><p align = 'center'><img width = '500' src = 'https://user-images.githubusercontent.com/39554623/120593066-e3fc9400-c479-11eb-9f3d-3ad7738018d3.png'></p><blockquote><p>Decomplie된 코드</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Example_nomagic_01Kt</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">      BuildersKt.launch$default((CoroutineScope)GlobalScope.INSTANCE, (CoroutineContext)<span class="literal">null</span>, (CoroutineStart)<span class="literal">null</span>, (Function2)(new Function2((Continuation)<span class="literal">null</span>) &#123;</span><br><span class="line">         int label;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Nullable</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object $result) &#123;</span><br><span class="line">            Object var10000;</span><br><span class="line">            label17: &#123;</span><br><span class="line">               Object var4 = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">               switch(<span class="keyword">this</span>.label) &#123;</span><br><span class="line">               case <span class="number">0</span>:</span><br><span class="line">                  ResultKt.throwOnFailure($result);</span><br><span class="line">                  <span class="keyword">this</span>.label = <span class="number">1</span>;</span><br><span class="line">                  var10000 = Example_nomagic_01Kt.fetchUserData(<span class="keyword">this</span>);</span><br><span class="line">                  <span class="keyword">if</span> (var10000 == var4) &#123;</span><br><span class="line">                     <span class="keyword">return</span> var4;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">               case <span class="number">1</span>:</span><br><span class="line">                  ResultKt.throwOnFailure($result);</span><br><span class="line">                  var10000 = $result;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">               case <span class="number">2</span>:</span><br><span class="line">                  ResultKt.throwOnFailure($result);</span><br><span class="line">                  var10000 = $result;</span><br><span class="line">                  <span class="keyword">break</span> label17;</span><br><span class="line">               default:</span><br><span class="line">                  <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               String userData = (String)var10000;</span><br><span class="line">               <span class="keyword">this</span>.label = <span class="number">2</span>;</span><br><span class="line">               var10000 = Example_nomagic_01Kt.cacheUserData(userData, <span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">if</span> (var10000 == var4) &#123;</span><br><span class="line">                  <span class="keyword">return</span> var4;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String userCache = (String)var10000;</span><br><span class="line">            Example_nomagic_01Kt.updateTextView(userCache);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@NotNull</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> Continuation create(<span class="meta">@Nullable</span> Object value, <span class="meta">@NotNull</span> Continuation completion) &#123;</span><br><span class="line">            Intrinsics.checkNotNullParameter(completion, <span class="string">&quot;completion&quot;</span>);</span><br><span class="line">            Function2 var3 = new &lt;anonymous <span class="keyword">constructor</span>&gt;(completion);</span><br><span class="line">            <span class="keyword">return</span> var3;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> Object invoke(Object var1, Object var2) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((&lt;undefinedtype&gt;)<span class="keyword">this</span>.create(var1, (Continuation)var2)).invokeSuspend(<span class="built_in">Unit</span>.INSTANCE);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;), <span class="number">3</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> static void main(String[] var0) &#123;</span><br><span class="line">      main();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> Object fetchUserData(<span class="meta">@NotNull</span> Continuation $completion) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;user_name&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> Object cacheUserData(<span class="meta">@NotNull</span> String user, <span class="meta">@NotNull</span> Continuation $completion) &#123;</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> String updateTextView(<span class="meta">@NotNull</span> String user) &#123;</span><br><span class="line">      Intrinsics.checkNotNullParameter(user, <span class="string">&quot;user&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>코드의 <em>64번째 라인</em>을 보면 <code>fetchUserData(…)</code>와 <code>cacheUserData(…)</code>와 같이 suspend function이었던 함수들이 일반 함수로 변경되고 마지막 매개변수로 Continuation이 들어간 것을 확인할 수 있다.</p></li><li><p>일시 중단과 재개를 위해서 suspention point를 label로 표시해두는 <strong>Labeling</strong> 작업이 Decompile되어 <em>11번째 라인</em>과 같이 <code>switch-case</code>문이 생성된 것을 확인할 수 있다.</p><ul><li>케이스가 3개 생성되었는데 첫 번째 케이스에서 <code>fetchUserData(…)</code>를 호출하면서 <strong>Continuation</strong> 객체가 넘어가는 것을 확인할 수 있다.</li><li>위의 자료에서 설명했던 부분과는 다른 부분이 존재하지만, 요지는 <code>switch-case</code> 형태로 Decompile되면서 다시 재개될 수 있는 형태로 만들어지고 <strong>Continuation</strong> 객체가 전달되고 있는 것을 확인할 수 있다는 것이다.</li><li>아래 이미지처럼 <em>15번째 라인</em>과 <em>34번째 라인</em>에서 함수의 마지막 매개변수로 Continuation 객체가 <code>this</code>로 전달되고 있다.</li></ul></li></ol><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/120595224-004e0000-c47d-11eb-8e2c-3f965f4c09ed.png'></p><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/120595278-10fe7600-c47d-11eb-8ffc-cbcb1437b475.png'></p><h2 id="cps-simulation-해보기"><a class="markdownIt-Anchor" href="#cps-simulation-해보기"></a> CPS simulation 해보기</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">↛       <span class="keyword">val</span> userData = fetchUserData()</span><br><span class="line">↛       <span class="keyword">val</span> userCache = cacheUserData(userData)</span><br><span class="line">        updateTextView(userCache)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;[in] main&quot;</span>)</span><br><span class="line">    myCoroutine(MyContinuation())</span><br><span class="line">    println(<span class="string">&quot;\n[out] main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myCoroutine</span><span class="params">(cont: <span class="type">MyContinuation</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span>(cont.label) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;\nmyCoroutine(), label: <span class="subst">$&#123;cont.label&#125;</span>&quot;</span>)</span><br><span class="line">            cont.label = <span class="number">1</span></span><br><span class="line">            fetchUserData(cont)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">1</span> -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;\nmyCoroutine(), label: <span class="subst">$&#123;cont.label&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> userData = cont.result</span><br><span class="line">            cont.label = <span class="number">2</span></span><br><span class="line">            cacheUserData(userData, cont)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">2</span> -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;\nmyCoroutine(), label: <span class="subst">$&#123;cont.label&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> userCache = cont.result</span><br><span class="line">            updateTextView(userCache)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fetchUserData</span><span class="params">(cont: <span class="type">MyContinuation</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;fetchUserData(), called&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result = <span class="string">&quot;[서버에서 받은 사용자 정보]&quot;</span></span><br><span class="line">    println(<span class="string">&quot;fetchUserData(), 작업완료: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    cont.resumeWith(Result.success(result))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cacheUserData</span><span class="params">(user: <span class="type">String</span>, cont: <span class="type">MyContinuation</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;cacheUserData(), called&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result = <span class="string">&quot;[캐쉬함 <span class="variable">$user</span>]&quot;</span></span><br><span class="line">    println(<span class="string">&quot;cacheUserData(), 작업완료: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    cont.resumeWith(Result.success(result))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">updateTextView</span><span class="params">(user: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;updateTextView(), called&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;updateTextView(), 작업완료: [텍스트 뷰에 출력 <span class="variable">$user</span>]&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContinuation</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = EmptyCoroutineContext)</span><br><span class="line">    : Continuation&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> label = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result.getOrThrow()</span><br><span class="line">        println(<span class="string">&quot;Continuation.resumeWith()&quot;</span>)</span><br><span class="line">        myCoroutine(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[in] main</span><br><span class="line"></span><br><span class="line">myCoroutine(), label: 0</span><br><span class="line">fetchUserData(), called</span><br><span class="line">fetchUserData(), 작업완료: [서버에서 받은 사용자 정보]</span><br><span class="line">Continuation.resumeWith()</span><br><span class="line"></span><br><span class="line">myCoroutine(), label: 1</span><br><span class="line">cacheUserData(), called</span><br><span class="line">cacheUserData(), 작업완료: [캐쉬함 [서버에서 받은 사용자 정보]]</span><br><span class="line">Continuation.resumeWith()</span><br><span class="line"></span><br><span class="line">myCoroutine(), label: 2</span><br><span class="line">updateTextView(), called</span><br><span class="line">updateTextView(), 작업완료: [텍스트 뷰에 출력 [캐쉬함 [서버에서 받은 사용자 정보]]]</span><br><span class="line"></span><br><span class="line">[out] main</span><br></pre></td></tr></table></figure><h2 id="정리"><a class="markdownIt-Anchor" href="#정리"></a> 정리</h2><ul><li>There is no magic<ul><li>CPS<small>Continuation Passing Style</small> == Callbacks</li><li>CPS Transformation</li></ul></li><li>Decompile<ul><li>Labels</li><li>Callback</li></ul></li><li>CPS simulation<ul><li>debugging</li></ul></li></ul><h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2><ul><li><a href="https://youtu.be/DOXyH1RtMC0">새차원, 코틀틴 코루틴</a></li><li><a href="https://www.youtube.com/watch?v=YrrUCSi72E8&amp;t=110s">KotlinConf 2017 - Deep Dive into Coroutines on JVM by Roman Elizarov</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/categories/Kotlin/Coroutine/">Coroutine</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Coroutine/">Coroutine</category>
      
      
      <comments>http://june0122.github.io/2021/06/09/coroutines-under-the-hood/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] CustomView &amp; Touch Event</title>
      <link>http://june0122.github.io/2021/06/07/android-bnr-30/</link>
      <guid>http://june0122.github.io/2021/06/07/android-bnr-30/</guid>
      <pubDate>Sun, 06 Jun 2021 17:09:18 GMT</pubDate>
      
      <description>안드로이드는 뛰어난 기능의 표준 뷰와 위젯을 많이 제공한다. 그러나 때로는 앱 특유의 비주얼을 보여주는 &lt;b&gt;커스텀&lt;small&gt;(custom)&lt;/small&gt; 뷰&lt;/b&gt;가 필요하다. 커스텀 뷰를 생성하려면 다음의 세 단계를 거친다.&lt;br&gt;&amp;emsp;➀ 슈퍼 클래스를 선택한다. 단순 커스텀 뷰에선 &lt;b&gt;View&lt;/b&gt;, 복합 커스텀 뷰에선 &lt;b&gt;FrameLayout&lt;/b&gt;과 같이 적합한 레이아웃 클래스를 선택한다.&lt;br&gt;&amp;emsp;➁ 1번에서 선택한 슈퍼 클래스의 서브 클래스를 만들고, 해당 슈퍼 클래스의 생성자를 오버라이드한다.&lt;br&gt;&amp;emsp;➂ 슈퍼 클래스의 주요 함수들을 오버라이드해 커스터마이징한다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="커스텀-뷰-생성하기"><a class="markdownIt-Anchor" href="#커스텀-뷰-생성하기"></a> 커스텀 뷰 생성하기</h2><p>안드로이드는 뛰어난 기능의 표준 뷰와 위젯을 많이 제공한다. 그러나 때로는 앱 특유의 비주얼을 보여주는 커스텀<small>(custom)</small> 뷰가 필요하다.</p><p>커스텀 뷰에는 여러 종류가 있지만 크게 두 가지 유형으로 분류할 수 있다.</p><ul><li><b>단순<small>(simple)</small></b> : 단순 뷰는 내부적으로 복잡할 수 있지만, 자식 뷰가 없어서 구조가 간단하다. 대부분 커스텀 렌더링을 수행한다.</li><li><b>복합<small>(composite)</small></b> : 복합 뷰는 서로 다른 뷰 객체들로 구성된다. 일반적으로 복합 뷰는 자식 뷰들을 관리하지만, 자신은 커스텀 렌더링을 하지 않는다. 대신에 렌더링은 각 자식 뷰에게 위임한다.</li></ul><p>커스텀 뷰를 생성하려면 다음의 세 단계를 거친다.</p><ol><li>슈퍼 클래스를 선택한다. 단순 커스텀 뷰에서 View는 비어 있는 캔버스와 같아서 가장 많이 사용된다. 복합 커스텀 뷰에서는 FrameLayout과 같이 적합한 레이아웃 클래스를 선택한다.</li><li>1번에서 선택한 슈퍼 클래스의 서브 클래스를 만들고, 해당 슈퍼 클래스의 생성자를 오버라이드한다.</li><li>슈퍼 클래스의 주요 함수들을 오버라이드해 커스터마이징한다.</li></ol><h3 id="boxdrawingview-생성하기"><a class="markdownIt-Anchor" href="#boxdrawingview-생성하기"></a> BoxDrawingView 생성하기</h3><p><strong>BoxDrawingView</strong>는 단순 뷰이면서 <b>View</b>의 직계 서브 클래스가 된다.</p><p>BoxDrawingView라는 이름의 새로운 클래스를 생성하고 <strong>View</strong>를 슈퍼 클래스로 지정한다. 그리고 BoxDrawingView.kt에서 아래 코드와 같이 생성사를 추가한다. 이 생성자는 Context 객체 및 null이 가능하면서 기본값이 null인 <strong>AttributeSet</strong> 객체를 인자로 받는다.</p><blockquote><p>BoxDrawingView의 초기 구현 (BoxDrawingView.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxDrawingView</span></span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>) : View(context, attrs) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이처럼 <strong>AttributeSet</strong>에 기본값을 지정하면, 실제로는 <strong>두 개의 생성자가 제공</strong>된다. 우리 뷰의 인스턴스가 <em>➀ 코드</em> 또는 <em>➁ 레이아웃 XML 파일</em>로부터 생성될 수 있어야 하기 때문이다. 레이아웃 파일로부터 인스턴스가 생성되어 초기화되는 뷰는 XML에 지정된 속성들을 포함하는 <strong>AttributeSet</strong>의 인스턴스를 인자로 받는다.</p><p>그다음으로 BoxDrawingView를 사용하도록 <em>res/layout/activity_drag_and_drawing.xml</em> 레이아웃 파일을 변경한다.</p><blockquote><p>BoxDrawingView를 레이아웃에 추가하기 (res/layout/activity_drag_and_drawing.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.june0122.draganddraw.BoxDrawingView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>여기서는 레이아웃 인플레이터가 찾을 수 있게 BoxDrawingView 클래스가 속한 패키지의 전체 경로를 지정해야 한다. 인플레이터는 View 인스턴스를 생성하는 데 필요한 레이아웃 파일을 찾는다. 이때 요소로 지정된 클래스 이름에 전체 패키지 경로가 지정되지 않으면 인플레이터가 android.view와 android.widget 패키지에서 해당 이름의 클래스를 찾는다. 따라서 해당 클래스가 다른 곳에 있다면 레이아웃 인플레이터는 그것을 찾지 못하고 앱은 실행이 중단된다. 그러므로 <strong>android.view와 android.widget 패키지 외부에 있는 커스텀 클래스나 이외의 다른 클래스들에서는 반드시 전체 패키지 경로가 포함된 클래스 이름을 지정해야 한다.</strong></p><h2 id="터치-이벤트-처리하기"><a class="markdownIt-Anchor" href="#터치-이벤트-처리하기"></a> 터치 이벤트 처리하기</h2><p>터치 이벤트를 리스닝할 때는 다음의 <strong>View</strong> 함수를 사용해서 터치 이벤트 리스너를 설정한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnTouchListener</span><span class="params">(l: <span class="type">View</span>.<span class="type">OnTouchListener</span>)</span></span></span><br></pre></td></tr></table></figure><p>이 함수는 <code>setOnClickListener(View.OnClickListener)</code>와 같은 방법으로 작동한다. 즉, 함수의 인자로 <code>View.OnClickListener</code>를 구현한 리스너 객체<small>(여기서는 View의 서브 클래스인 BoxDrawingView 인스턴스)</small>를 전달하면 터치 이벤트가 발생할 때마다 이 객체에 구현된 <code>onTouchEvent(…)</code> 함수가 호출된다.</p><p>따라서 BoxDrawingView에서는 다음 View 함수를 오버라이드하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(evenet: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure><p>이 함수는 <strong>MotionEvent</strong> 인스턴스를 인자로 받는다. <strong>MotionEvent</strong>는 터치 이벤트를 나타내는 클래스이며, 화면을 터치한 위치와 <b>액션<small>(action)</small></b>을 포함한다. 액션은 다음과 같이 이벤트 발생 단계를 나타낸다.</p><table><thead><tr><th style="text-align:center">액션 상수</th><th style="text-align:center">의미</th></tr></thead><tbody><tr><td style="text-align:center">ACTION_DOWN</td><td style="text-align:center">사용자가 화면을 손가락으로 터치함</td></tr><tr><td style="text-align:center">ACTION_MOVE</td><td style="text-align:center">사용자가 화면 위에서 손가락을 움직임</td></tr><tr><td style="text-align:center">ACTION_UP</td><td style="text-align:center">사용자가 화면에서 손가락을 뗌</td></tr><tr><td style="text-align:center">ACTION_CANCEL</td><td style="text-align:center">부모 뷰가 터치 이벤트를 가로챔</td></tr></tbody></table><p><code>onTouchEvent(MotionEvent)</code>의 구현 코드에서는 <strong>MotionEvent</strong> 객체의 다음 함수를 호출해 액션의 값을 확인할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAction</span><span class="params">()</span></span>: <span class="built_in">Int</span></span><br></pre></td></tr></table></figure><p>BoxDrawingView.kt에 아래 코드를 추가하자. 여기서는 이벤트가 제대로 처리되는지 로그캣에서 확인하기 위해 로그 태그 상수와 네 개의 각 액션에 대해 로그 메시지를 출력하는 <code>onTouchEvent(MotionEvent)</code>의 구현 코드도 추가한다.</p><blockquote><p>BoxDrawingView 구현하기 (BoxDrawingView.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;BoxDrawingView&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxDrawingView</span></span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>) : View(context, attrs) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> current = PointF(event.x, event.y)</span><br><span class="line">        <span class="keyword">var</span> action = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">when</span> (event.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_DOWN&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_MOVE&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_UP -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_UP&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_CANCEL -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_CANCEL&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;<span class="variable">$action</span> at x=<span class="subst">$&#123;current.x&#125;</span>, y=<span class="subst">$&#123;current.y&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 터치된 위치를 나타내는 X와 Y 좌표를 <strong>PointF</strong> 객체에 넣는다. 이 장의 나머지 코드에서 두 값을 같이 사용해야 하기 때문이다. <strong>PointF</strong>는 이런 역할을 하는 <strong>안드로이드의 컨테이너 클래스</strong>다.</p><p><em>Logcat</em> 창의 검색 상자에 <strong>I/BoxDrawingView</strong>를 입력하고 앱을 실행하여 화면을 터치하고 끌어보는 등 상호 작용을 하면 BoxDrawingView가 받는 모든 터치 액션의 X, Y 좌표가 로그에 실시간으로 출력된다.</p><blockquote><p>앱 화면과 상호 작용을 했을 때 로그에 나타나는 X, Y 좌표값들</p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/120932086-619cfa00-c72f-11eb-812b-f8d462797b5e.png'></p><h3 id="모션-이벤트-추적하기"><a class="markdownIt-Anchor" href="#모션-이벤트-추적하기"></a> 모션 이벤트 추적하기</h3><p>BoxDrawingView에서는 좌표만 로깅하는 게 아니라 화면에 박스들도 그릴 것이다. 이렇게 하려면 몇 가지 해결할 것이 있다.</p><p>우선 박스를 정의하기 위해 시작 지점<small>(손가락이 처음 놓인 곳)</small>과 현재 지점<small>(손가락이 현재 있는 곳)</small>이 반드시 필요하다.</p><p>그다음에 박스를 정의하려면 하나 이상의 MotionEvent로부터 발생하는 데이터를 추적해야하며, 이 데이터를 Box 객체에 저장해야 한다.</p><p>하나의 박스를 정의하는 데이터를 나타내는 <strong>Box</strong> 클래스를 생성해 아래의 코드를 추가한다.</p><blockquote><p>Box 클래스 추가하기 (Box.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span>(<span class="keyword">val</span> start: PointF) &#123;</span><br><span class="line">    <span class="keyword">var</span> end: PointF = start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> left: <span class="built_in">Float</span></span><br><span class="line">        <span class="keyword">get</span>() = min(start.x, end.x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> right: <span class="built_in">Float</span></span><br><span class="line">        <span class="keyword">get</span>() = max(start.x, end.x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> top: <span class="built_in">Float</span></span><br><span class="line">        <span class="keyword">get</span>() = min(start.y, end.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> bottom: <span class="built_in">Float</span></span><br><span class="line">        <span class="keyword">get</span>() = max(start.y, end.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용자가 BoxDrawingView를 터치하면 새로운 Box 객체가 생성되어 기존 박스 List에 추가되도록 하자.</p><p>사용자가 그리는 상태 정보를 추적하기 위해 BoxDrawingView 클래스에 새로운 Box 객체를 사용하는 코드를 추가한다.</p><blockquote><p>Box 객체를 사용하는 코드 추가하기 (BoxDrawingView.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxDrawingView</span></span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>) : View(context, attrs) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currentBox: Box? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> boxen = mutableListOf&lt;Box&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> current = PointF(event.x, event.y)</span><br><span class="line">        <span class="keyword">var</span> action = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">when</span> (event.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_DOWN&quot;</span></span><br><span class="line">                <span class="comment">// 그리기 상태를 재설정한다</span></span><br><span class="line">                currentBox = Box(current).also &#123; boxen.add(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_MOVE&quot;</span></span><br><span class="line">                updateCurrentBox(current)</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_UP -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_UP&quot;</span></span><br><span class="line">                updateCurrentBox(current)</span><br><span class="line">                currentBox = <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_CANCEL -&gt; &#123;</span><br><span class="line">                action = <span class="string">&quot;ACTION_CANCEL&quot;</span></span><br><span class="line">                currentBox = <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;<span class="variable">$action</span> at x=<span class="subst">$&#123;current.x&#125;</span>, y=<span class="subst">$&#123;current.y&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateCurrentBox</span><span class="params">(current: <span class="type">PointF</span>)</span></span> &#123;</span><br><span class="line">        currentBox?.let &#123;</span><br><span class="line">            it.end = current</span><br><span class="line">            invalidate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 <em>ACTION_DOWN</em> 모션 이벤트를 받을 때마다 <em>currentBox</em> 속성을 새로운 Box 객체로 설정한다. 이 객체는 이벤트가 발생한 위치를 시작 지점으로 가지며 박스 List에 저장된다<small>(본문의 뒤에서 그리기를 구현할 때 BoxDrawingView에서 이 박스 List에 저장된 모든 Box를 화면에 그린다)</small>.</p><p>사용자의 손가락이 화면을 이동하거나 화면에서 떨어지면 <em>currentBox.end</em>를 변경한다. 그리고 터치가 취소되거나 사용자의 손가락이 화면에서 떨어지면 그리기를 끝내기 위해 <em>currentBox</em>를 null로 변경한다. 즉, Box 객체는 List에 안전하게 저장되지만, 모션 이벤트에 관해서는 더 이상 변경이 생기지 않는다.</p><p><code>updateCurrentBox()</code> 함수에서 <code>invalidate()</code>를 호출한다. <code>invalidate()</code> 함수를 호출하면 뷰가 <b>무효<small>(invalid)</small></b>라는 것을 안드로이드에게 알려주므로 안드로이드 시스템이 해당 뷰의 변경 사항을 반영해서 다시 그려준다. 여기서는 사용자가 손가락을 움직여서 새로운 박스를 생성하거나 박스 크기를 조정할 때마다 <code>invalidate()</code> 함수를 호출해 BoxDrawingView를 다시 그리게 한다. 이렇게 하면 사용자가 손가락을 끌어서 박스를 생성하는 동안 어떤 모습인지 볼 수 있다.</p><p>참고로 앱이 시작되면 앱의 모든 뷰가 <strong>무효</strong> 상태가 되어 뷰들이 화면에 어떤 것도 그릴 수 없게 된다. 이런 상황을 해결하기 위해 안드로이드는 최상위 수준 <strong>View</strong>의 <code>draw()</code> 함수를 호출함으로써 부모 뷰가 자신을 그리게 되고, 이것의 자식 뷰들 또한 자신들을 그리게 된다. 뷰 계층을 따라 내려가면서 자식 뷰들의 또 다른 자식 뷰들도 자신들을 그리게 되는 식이다. 결국 뷰 계층의 모든 뷰가 자신을 그리게 되면 최상위 수준 <strong>View</strong>는 더 이상 무효 상태가 되지 않는다.</p><p>다음으로 박스를 화면에 그려보자.</p><h2 id="ondrawcanvas-내부에서-렌더링하기"><a class="markdownIt-Anchor" href="#ondrawcanvas-내부에서-렌더링하기"></a> <code>onDraw(Canvas)</code> 내부에서 렌더링하기</h2><p>뷰가 화면에 그려지게 하려면 다음 View 함수를 오버라이드해야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span></span><br></pre></td></tr></table></figure><p><code>onTouchEvent(MotionEvent)</code>의 <em>ACTION_MOVE</em>에 대한 응답에서 호출한 <code>invalidate()</code> 함수는 BoxDrawingView를 다시 무효 상태로 만든다. 그럼으로써 BoxDrawingView는 자신을 다시 그리게 되고 이때 <code>onDraw(Canvas)</code>가 다시 호출된다.</p><p>이제는 <strong>Canvas</strong> 매개변수에 대해 알아보자. <strong>Canvas</strong>와 <strong>Paint</strong> 모두 안드로이드의 주요 그리기 클래스다.</p><ul><li><strong>Canvas</strong> 클래스는 모든 그리기 함수를 갖고 있다. 우리가 호출하는 Canvas의 함수들은 그리는 위치와 선, 원, 단어, 사각형 등의 형태를 결정한다.</li><li><strong>Paint</strong> 클래스는 이런 함수들이 어떻게 수행되는지를 결정한다. 즉, 우리가 호출하는 Paint의 함수들은 도형이 채워져야 하는지, 어떤 폰트의 텍스트를 그리는지, 어떤 색의 선인지와 같은 특성을 지정한다.</li></ul><p>BoxDrawingView 인스턴스가 초기화될 때 두 개의 Paint 객체를 생성하도록 BoxDrawingView.kt를 변경한다.</p><blockquote><p>Paint 객체 생성하기 (BoxDrawingView.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxDrawingView</span></span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>) : View(context, attrs) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currentBox: Box? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> boxen = mutableListOf&lt;Box&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> boxPaint = Paint().apply &#123;</span><br><span class="line">        color = <span class="number">0x22ff0000</span>.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> backgroundPaint = Paint().apply &#123;</span><br><span class="line">        color = <span class="number">0xfff8efe0</span>.toInt()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제는 화면에 박스를 그릴 수 있다.</p><blockquote><p><code>onDraw(Canvas)</code> 오버라이드 하기 (BoxDrawingView.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxDrawingView</span></span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>) : View(context, attrs) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 배경을 채운다</span></span><br><span class="line">        canvas.drawPaint(backgroundPaint)</span><br><span class="line">        </span><br><span class="line">        boxen.forEach &#123; box -&gt; </span><br><span class="line">            canvas.drawRect(box.left, box.top, box.right, box.bottom, boxPaint)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>황백색 배경의 Paint를 사용해서 박스의 배경인 캔버스를 채운다. 그다음에 박스 List에 저장된 각 Box 객체에 대해 박스의 두 점을 조사해 직사각형의 왼쪽, 오른쪽, 위, 아래의 꼭지점 위치를 결정한다. 왼쪽과 위의 값은 X와 Y의 최솟값이, 아래쪽과 오른쪽은 최댓값이 된다.</p><p>이 값들을 산출한 후 <code>Canvas.drawRect(…)</code>를 호출해 화면에 빨간색의 사각형을 그린다.</p><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/120933267-48e31300-c734-11eb-909a-f00498e631cc.gif'></p><h2 id="궁금증-해소-️-gesturedetector"><a class="markdownIt-Anchor" href="#궁금증-해소-️-gesturedetector"></a> 궁금증 해소 💁🏻‍♂️ : GestureDetector</h2><p>터치 이벤트를 처리하는 또 다른 방법으로 <strong>GestureDetector</strong> 객체가 있다. GestureDetector는 특정 이벤트가 발생하면 알려주는 리스너를 갖고 있다. 예를 들어, <code>GestureDetector.OnGestureListener</code>는 화면을 길게 누르거나 밀거나 스크롤하는 등의 이벤트를 리스닝하는 함수들을 갖고 있다. 그리고 두 번 두드림 이벤트를 리스닝하는 <code>GestureDetector.OnDoubleTapListener</code>도 있다. 대부분은 View의 <code>onTouch(…)</code>나 <code>onTouchEvent(…)</code> 함수를 오버라이드해서 사용하는 다양한 이벤트 처리가 필요하지 않다. 따라서 이러한 함수 대신 GestureDetector를 사용하는 것도 아주 좋은 방법이다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/CustomView/">CustomView</category>
      
      <category domain="http://june0122.github.io/tags/TouchEvent/">TouchEvent</category>
      
      
      <comments>http://june0122.github.io/2021/06/07/android-bnr-30/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Android] 단위 테스트와 오디오 재생</title>
      <link>http://june0122.github.io/2021/06/06/android-bnr-20/</link>
      <guid>http://june0122.github.io/2021/06/06/android-bnr-20/</guid>
      <pubDate>Sun, 06 Jun 2021 05:28:37 GMT</pubDate>
      
      <description>&lt;b&gt;단위 테스트&lt;small&gt;(unit testing)&lt;/small&gt;&lt;/b&gt;는 하나의 컴포넌트&lt;small&gt;(주로 클래스)&lt;/small&gt; 자체를 테스트하는 것이므로 작성할 수 있는 가장 작은 종류의 테스트다. 그리고 테스트를 실행하고자 전체 앱이나 장치를 사용할 필요가 없으며, 테스트를 여러 번 실행해도 충분할 만큼 빠르게 실행된다. 따라서 하나의 컴포넌트르 테스트할 때 장치 테스트로 실행하는 경우는 거의 없다. 단위 테스트는 안드로이드 런타임이 아닌 &lt;b&gt;로컬 컴퓨터의 JVM&lt;small&gt;(Java Virtual Machine)&lt;/small&gt;에서 실행되므로 빠르게 이루어진다.&lt;/b&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>MVVM 아키텍처가 매력적인 이유 중 하나는 <b>단위 테스트<small>(unit testing)</small></b>가 쉽기 때문이다. 단위 테스트는 앱의 각 단위가 제대로 작동하는지 검사하는 작은 프로그램들을 작성하는 것이다.</p><p>본문에서는 단위 테스트 및 안드로이드 오디오 API를 쉽게 사용하도록 해주는 도구인 <strong>SoundPool</strong> 클래스를 사용한다. <strong>SoundPool</strong> 클래스는 많은 음원 파일을 메모리로 로드할 수 있으며, 재생하려는 음원의 최대 개수를 언제든 제어할 수 있다. 따라서 사용자가 앱의 모든 버튼을 동시에 마구잡이로 누르더라도 앱의 실행이나 장치에는 영향을 주지 않는다.</p><h2 id="soundpool-생성하기"><a class="markdownIt-Anchor" href="#soundpool-생성하기"></a> SoundPool 생성하기</h2><p>먼저 BeatBox 클래스 내부에 음원 재생 기능을 추가한다. 우선 SoundPool 객체를 생성하는 코드를 작성하자.</p><blockquote><p>SoundPool 생성하기 (BeatBox.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;BeatBox&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SOUNDS_FOLDER = <span class="string">&quot;sample_sounds&quot;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> MAX_SOUNDS = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatBox</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> assets: AssetManager) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sounds: List&lt;Sound&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> soundPool = SoundPool.Builder()</span><br><span class="line">        .setMaxStreams(MAX_SOUNDS)</span><br><span class="line">        .build()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        sounds = loadSounds()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SoundPool 인스턴스를 생성할 때는 SoundPool.Builder 클래스의 <code>build()</code> 함수를 사용한다. 따라서 여기서는 <strong>SoundPool.Builder</strong> 인스턴스를 생성한 후 <code>build()</code>를 호출한다.</p><p><code>setMaxStreams(Int)</code> 함수에서는 현재 시점에 재생할 음원의 최대 개수를 인자로 전달하여 지정할 수 있다. 코드에서는 5를 전달하는데, 따라서 다섯 개의 음원이 재생 중일 때 여섯 번째 음원을 재생하려고 하면 SoundPool이 가장 오래된 음원의 재생을 중단한다.</p><p>또한, <code>setAudioAttributes(AudioAttributes)</code>를 사용하면 오디오 스티름의 다른 속성들을 지정할 수 있다. 자세한 내용은 <a href="https://developer.android.com/reference/android/media/AudioAttributes">안드로이드 문서</a>에서!</p><h2 id="에셋-사용하기"><a class="markdownIt-Anchor" href="#에셋-사용하기"></a> 에셋 사용하기</h2><p>현재 음원 파일들은 앱의 애셋으로 저장되어 잇는데, 이 파일들을 사용해서 오디오를 재생하기에 앞서 애셋의 작동 원리를 알아보자.</p><p>Sound 객체는 애셋 파일 경로를 갖고 있다. 그런데 애셋 파일 경로의 파일을 열 때는 File 클래스를 사용할 수 없고 반드시 <strong>AssetManager</strong>를 사용해야 한다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> assetPath = sound.assetPath</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> assetManager = context.assets</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> soundData = assetManager.<span class="keyword">open</span>(assetPath)</span><br></pre></td></tr></table></figure><p>이렇게 하면 코틀린의 다른 <strong>InputStream</strong>을 사용할 때처럼 표준 <strong>InputStream</strong>이 반환된다.</p><p>경우에 따라서는 <strong>InputStream</strong> 대신 <strong>FileDescriptor</strong>가 필요할 수 있다. <strong>SoundPool</strong>을 사용할 때가 그렇다. 이때는 <code>AssetManager.openFd(String)</code>을 호출하면 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> assetPath = sound.assetPath</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> assetManager = context.assets</span><br><span class="line"></span><br><span class="line"><span class="comment">// AssetFileDescriptor는 FileDescriptor와 다르다</span></span><br><span class="line"><span class="keyword">val</span> assetFileDescriptor = assetManager.openFd(assetPath)</span><br><span class="line"></span><br><span class="line"><span class="comment">// … 그러나 필요하다면 다음과 같이 쉽게 보통의 FileDescriptor를 얻을 수 있다</span></span><br><span class="line"><span class="keyword">val</span> fileDescriptor = assetFileDescriptor.fileDescriptor</span><br></pre></td></tr></table></figure><h2 id="음원-로드하기"><a class="markdownIt-Anchor" href="#음원-로드하기"></a> 음원 로드하기</h2><p>SoundPool에 음원을 로드하는 것이 다음으로 할 일이다. 오디오를 재생하는 다른 방법과 달리 SoundPool을 사용하면 응답이 빠르다. 따라서 음원 재생을 요청하면 즉시 재생이 시작된다.</p><p>단, 재생에 앞서 SoundPool로 음원을 로드해야 한다. 이때 로드할 각 음원은 자신의 정수 ID를 갖는다. 이 ID를 유지하기 위한 <em>soundId</em> 속성을 Sound 클래스에 추가한다.</p><blockquote><p><em>soundId</em> 속성 추가하기 (Sound.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sound</span></span>(<span class="keyword">val</span> assetPath: String, <span class="keyword">var</span> soundId: <span class="built_in">Int</span>? = <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> name = assetPath.split(<span class="string">&quot;/&quot;</span>).last().removeSuffix(WAV)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 <em>soundId</em> 속성을 null이 가능한 Int? 타입으로 지정하였다. <em>soundId</em>에 null 값을 지정하여 Sound의 ID 값이 없음을 알려줄 수 있기 때문이다.</p><p>다음으로는 음원을 로드한다. SoundPool에 Sound 인스턴스를 로드하기 위해 BeatBox 클래스에 <code>load(Sound)</code> 함수를 추가한다.</p><blockquote><p>SoundPool에 음원 로드하기 (BeatBox.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatBox</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> assets: AssetManager) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadSounds</span><span class="params">()</span></span>: List&lt;Sound&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">(sound: <span class="type">Sound</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> afd: AssetFileDescriptor = assets.openFd(sound.assetPath)</span><br><span class="line">        <span class="keyword">val</span> soundId = soundPool.load(afd, <span class="number">1</span>)</span><br><span class="line">        sound.soundId = soundId</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 <code>soundPool.load(AssetFileDescriptor, Int)</code> 함수를 호출해 나중에 재생할 음원 파일을 SoundPool에 로드한다. 이 함수에서는 정수 ID를 반환하는데, 음원을 유지하고 다시 재생<small>(또는 언로드)</small>하기 위해서다. 그리고 이 값을 앞에서 정의했던 <em>soundId</em> 속성에 저장한다.</p><p><code>openFd(String)</code>에서는 IOException을 발생시킬 수 있으므로 <code>load(Sound)</code>도 IOException을 발생시킬 수 있다. 따라서 <code>load(Sound)</code>가 호출될 때는 항상 IOException을 처리해야 한다.</p><p>다음으로 <code>load(Sound)</code>를 호출해 모든 음원을 로드하는 코드를 <code>BeatBox.loadSounds()</code> 함수 내부에 추가한다.</p><blockquote><p>모든 음원을 로드하기 (BeatBox.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadSounds</span><span class="params">()</span></span>: List&lt;Sound&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">val</span> sounds = mutableListOf&lt;Sound&gt;()</span><br><span class="line">    soundNames.forEach &#123; fileName -&gt;</span><br><span class="line">        <span class="keyword">val</span> assetPath = <span class="string">&quot;<span class="variable">$SOUNDS_FOLDER</span>/<span class="variable">$fileName</span>&quot;</span></span><br><span class="line">        <span class="keyword">val</span> sound = Sound(assetPath)</span><br><span class="line">        <span class="comment">//  sounds.add(sound)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            load(sound)</span><br><span class="line">            sounds.add(sound)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ioe: IOException) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Could not load sound <span class="variable">$fileName</span>&quot;</span>, ioe)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sounds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeatBox 앱을 실행해 에러 없이 모든 음원이 로드되는지 확인해본다. 만일 정상적으로 로드되지 않으면 로그캣 창에 붉은색의 예외 메시지가 나타난다<small>(아직 음원은 재생되지 않으며 화면에도 아무 변화가 없다)</small>.</p><h2 id="음원-재생하기"><a class="markdownIt-Anchor" href="#음원-재생하기"></a> 음원 재생하기</h2><p>BeatBox 앱에서 음원 재생이 되어야 하니 음원을 재생하는 <code>play(Sound)</code> 함수를 BeatBox 클래스에 추가한다.</p><blockquote><p>음원 재생하기 (BeatBox.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatBox</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> assets: AssetManager) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        sounds = loadSounds()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">play</span><span class="params">(sound: <span class="type">Sound</span>)</span></span> &#123;</span><br><span class="line">        sound.soundId?.let &#123; </span><br><span class="line">            soundPool.play(it, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1.0f</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>play(Sound)</code> 함수는 음원을 재생하기 전에 해당 음원의 <em>soundId</em>가 null이 아닌지 확인한다. 만일 음원 로드에 실패하면 null이 될 수 있다.</p><p>일단 null 값이 아니라고 확인되면 <code>SoundPool.play(Int, Float, Float, Int, Int, Float)</code>를 호출해 음원을 재생한다. 매개 변수들의 내역은 다음과 같다. 음원 ID, 왼쪽 볼륨<small>(0.0 ~ 1.0)</small>, 오른쪽 볼륨, 스트림 우선순위<small>(0이면 최저 우선순위)</small>, 반복 재생 여부<small>(0이면 반복 안함, -1이면 무한 반복, 그 외의 숫자는 반복 횟수)</small>, 재생률<small>(1이면 녹음된 속도 그대로, 2는 두 배 빠르게 재생, 0.5는 절반 느리게 재생)</small>이다.</p><p>이제는 음원 재생을 <strong>SoundViewModel</strong>에 통합할 준비가 되었다. 그 전에 테스트에 실패하도록 단위 테스트를 작성한 후 문제점을 해결하자!</p><h2 id="테스트-라이브러리-의존성-추가하기"><a class="markdownIt-Anchor" href="#테스트-라이브러리-의존성-추가하기"></a> 테스트 라이브러리 의존성 추가하기</h2><p>테스트 코드를 작성하기 전에 테스팅 도구인 <strong>Mockito</strong>와 <strong>Hamcrest</strong>를 추가한다.</p><p><strong>Mockito</strong>는 간단한 <b>모의 객체<small>(mock object)</small></b>를 쉽게 생성해주는 프레임워크다. 모의 객체는 테스트를 독립적으로 할 수 있게 도와주므로, 잘못해서 동시에 다른 객체를 테스트하지 않게 해준다.</p><p><strong>Hamcrest</strong>는 <strong>matcher</strong> 라이브러리다. Matcher는 코드에 ‘일치(match)’ 조건을 쉽게 만들어주고, 만일 코드가 우리 바람과 일치하지 않으면 실패로 처리하는 도구다.</p><p><strong>Hamcrest는 JUnit 라이브러리에 자동으로 포함</strong>되며, JUnit은 새로운 안드로이드 스튜디오 프로젝트를 생성할 때 의존성에 자동으로 포함된다. 따라서 테스트 빌드에 Mockito 의존성만 추가하면 된다.</p><blockquote><p>Mockito 의존성 추가하기 (app/build.gradle)</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    testImplementation <span class="string">&#x27;junit:junit:4.13.2&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.mockito:mockito-core:3.3.3&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.mockito:mockito-inline:3.3.3&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>testImplementation</em>은 이 라이브러리 의존성이 이 앱의 테스트 빌드에만 포함됨을 의미한다. 따라서 디버그나 릴리즈 빌드로 생성된 APK에는 포함되지 않는다.</p><p>mockito-core는 모의 객체를 생성하고 구성하는 데 사용하는 모든 함수를 포함한다. mockito-inlin은 Mockito를 코틀린에서 쉽게 사용하도록 해주는 의존성이다.</p><p>기본적으로 모든 코틀린 클래스는 <strong>final</strong>이다. 즉, 클래스에 open 키워드를 지정하지 않으면 상속받는 서브 클래스를 만들 수 없으며, 함수에 open 키워드를 지정하지 않으면 서브 클래스에서 오버라이드할 수 없다. 그런데 Mockito에서 모의 객체의 클래스를 생성할 때는 클래스 상속을 해야 한다. 이때 mockito-inline 의존성을 지정하면 Mockito가 <strong>final</strong> 클래스와 함수들의 모의 객체를 생성한다. 따라서 <strong>코틀린 클래스 소스 코드를 변경하지 않고 모의 객체를 생성할 수 있다.</strong></p><h2 id="테스트-클래스-생성하기"><a class="markdownIt-Anchor" href="#테스트-클래스-생성하기"></a> 테스트 클래스 생성하기</h2><p>단위 테스트를 작성하는 가장 편리한 방법은 <b>테스트 프레임워크<small>(testing framwork)</small></b>를 사용하는 것이다. 테스트 프레임워크를 사용하면 안드로이드 스튜디오에서 테스트 코드를 더 쉽게 작성하고 실행할 수 있으며 결과 출력도 볼 수 있다.</p><p>안드로이드의 테스트 프레임워크로는 JUnit이 사용되며, 안드로이드 스튜디오와 잘 통합되어 있다. 가장 먼저 할 일은 JUnit 테스트 클래스를 생성하는 것이다.</p><p>SoundViewModel.kt를 열어 SoundViewModel 클래스를 클릭한 후 안드로이드 스튜디오 메인 메뉴의 <code>Navigate -&gt; Test</code>를 선택한다. 그러면 안드로이드 스튜디오가 SoundViewModel 클래스와 관련된 테스트 클래스로 이동시켜준다. 그러나 여기처럼 테스트 클래스가 없으면 아래와 같이 팝업으로 새로운 테스트 클래스 생성 옵션을 제공한다.</p><blockquote><p>테스트 클래스 생성 팝업</p></blockquote><p align = 'center'><img width = '600' src = 'https://user-images.githubusercontent.com/39554623/120896740-c38d2f00-c65d-11eb-931a-5023aa8f56b9.png'></p><p>'Create New Test…'를 선택하면 대화상자<small>(좌)</small>가 나타난다. 아래와 같이 테스트 라이브러리를 JUnit4로 선택하고 SetUp/@Before를 체크한 후 다른 필드는 그대로 두고 OK 버튼을 누른다.</p><p>그러면 생성하는 테스트 클래스의 종류를 선택하는 대화상자<small>(우)</small> 나타난다.</p><blockquote><p>새로운 테스트 클래스 생성하기<small>(좌)</small>, 테스트 클래스의 종류 선택하기<small>(우)</small></p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/120896968-e66c1300-c65e-11eb-81a5-f1f28ce87cea.png'></p><h4 id="장치-테스트smallinstrumentation-testsmall"><a class="markdownIt-Anchor" href="#장치-테스트smallinstrumentation-testsmall"></a> 장치 테스트<small>(instrumentation test)</small></h4><p>androidTest 폴더에 있는 테스트를 <b>장치 테스트<small>(instrumentation test)</small></b>라고 한다. 장치 테스트는 안드로이드 장치나 에뮬레이터에서 실행된다. 앱이 배포된 후 APK가 실행될 시스템 프레임워크와 API를 대상으로 앱 전체를 테스트할 수 있다는 것이 장치 테스트의 장점이다. 그러나 장치 테스트는 <strong>해당 안드로이드 운영체제에서 실행되어서 설정과 실행에 시간이 더 걸린다는 단점</strong>이 있다.</p><h4 id="단위-테스트smallunit-testsmall"><a class="markdownIt-Anchor" href="#단위-테스트smallunit-testsmall"></a> 단위 테스트<small>(unit test)</small></h4><p>이와는 달리 test 폴더에 있는 테스트는 <b>단위 테스트<small>(unit test)</small></b>라고 한다. 단위 테스트는 안드로이드 런타임이 아닌 <strong>로컬 컴퓨터의 JVM<small>(Java Virtual Machine)</small>에서 실행되므로 빠르게 이루어진다.</strong></p><p>안드로이드에서는 '단위 테스트’라는 용어가 폭넓게 사용된다. 즉, 하나의 클래스나 단위 기능을 별개로 검사함을 의미하며, 로컬 컴퓨터에서 실행되는 단위 테스트들은 test 폴더에 포함된다. 또한, 앱의 여러 클래스나 기능이 함께 작동하는 것을 테스트하는 <b>통합 테스트<small>(integreation test)</small></b>를 의미하기도 한다. 통합 테스트는 <a id = "a1"><a href="#f1">궁금증 해소: 통합 테스트</a></a>에서 자세히 알아보자.</p><p>본문의 나머지 부분에서는 test 폴더에 있으면서 JVM에서 실행되는 각 타입의 테스트를 <strong>JVM 테스트</strong>라 하고, 하나의 클래스나 단위 기능을 검사하는 테스트만 <strong>단위 테스트</strong>라고 칭한다.</p><p>단위 테스트는 하나의 컴포넌트<small>(주로 클래스)</small> 자체를 테스트하는 것이므로 작성할 수 있는 가장 작은 종류의 테스트다. 그리고 테스트를 실행하고자 전체 앱이나 장치를 사용할 필요가 없으며, 테스트를 여러 번 실행해도 충분할 만큼 빠르게 실행된다. 따라서 하나의 컴포넌트르 테스트할 때 장치 테스트로 실행하는 경우는 거의 없다. 이 점을 염두에 두고 위의 이미지의 우측 대화상자와 같이 androidTest 폴더가 아닌 test 폴더를 선택하고 OK 버튼을 누른다. 그러면 안드로이드 스튜디오가 SoundViewModelTest.kt를 생성하고 편집기 창에 열어준다.</p><blockquote><p>Project 뷰로 보면 app/src 패키지 밑에 test와 androidTest 패키지가 생성되어 있다</p></blockquote><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/120897965-c8ed7800-c663-11eb-9970-a02fd282a3aa.png'></p><h2 id="테스트-설정하기"><a class="markdownIt-Anchor" href="#테스트-설정하기"></a> 테스트 설정하기</h2><p>자동 생성된 SoundViewModelTest 클래스는 <code>setUp()</code> 함수만 갖고 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModelTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트 클래스에서 특정 클래스를 테스트하는 데 필요한 작업은 대부분 같다. 즉, 테스트할 클래스의 인스턴스와 이 인스턴스가 필요로 하는 다른 객체들도 생성한다. 이에 따라 JUnit에서는 <code>@Before</code>라는 애노테이션을 제공한다. <code>@Before</code>가 지정된 함수 내부의 코드는 각 테스트가 실행되기 전에 한번만 실행되며, JUnit 테스트 클래스는 <code>@Before</code>가 지정된 <code>setUp()</code>이라는 이름의 함수를 갖는다.</p><h3 id="테스트-대상-설정하기"><a class="markdownIt-Anchor" href="#테스트-대상-설정하기"></a> 테스트 대상 설정하기</h3><p><code>setUp()</code> 함수 내부에서는 테스트할 SoundViewModel의 인스턴스와 Sound의 인스턴스를 생성해야 한다. SoundViewModel이 음원 제목을 보여주는 방법을 알려면 Sound 인스턴스를 필요로 하기 때문이다.</p><p>SoundViewModel과 Sound의 인스턴스를 생성하자.</p><blockquote><p>테스트 대상인 SoundViewModel 인스턴스 생성하기 (SSoundViewModelTest.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModelTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sound: Sound</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> subject: SoundViewModel</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sound = Sound(<span class="string">&quot;assetPath&quot;</span>)</span><br><span class="line">        subject = SoundViewModel()</span><br><span class="line">        subject.sound = sound</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지금까지는 <strong>SoundViewModel</strong> 인스턴스를 참조하는 속성 이름을 <em>soundViewModel</em>로 사용했는데, 여기서는 <em>subject</em>라고 했다. 테스트의 대상이 되는 객체이므로 <em><strong>subject</strong></em> 라고 하는 것이 오히려 알기 쉽고, 테스트 함수를 다른 클래스로 옮기더라도 속성 이름을 변경할 필요가 없기 때문이다.</p><h2 id="테스트-작성하기"><a class="markdownIt-Anchor" href="#테스트-작성하기"></a> 테스트 작성하기</h2><p><code>setUp()</code> 함수가 작성되었으니 이제는 테스트를 작성해본다. <code>@Test</code> 애노테이션이 지정된 테스트 클래스의 함수를 테스트라고 한다.</p><p>우선 SoundViewModel의 <em>title</em> 속성값이 Sound의 <em>name</em> 속성값과 일치하는지 검사하는 테스트 함수를 작성하자.</p><blockquote><p><em>title</em> 속성 테스트하기 (SoundViewModelTest.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert.*</span><br><span class="line"><span class="keyword">import</span> org.hamcrest.core.Is.`<span class="keyword">is</span>`</span><br><span class="line"><span class="keyword">import</span> org.hamcrest.MatcherAssert</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModelTest</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">exposesSoundNameAsTitle</span><span class="params">()</span></span> &#123;</span><br><span class="line">        MatcherAssert.assertThat(subject.title, `<span class="keyword">is</span>`(sound.name))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><small>(<code>assertThat(…)</code> 함수와 <code>is(…)</code> 함수는 위의 코드 대로 import해야 한다.)</small></p><p>이 테스트에서는 <code>assertThat(…)</code> 함수와 <code>is(…)</code> 함수를 같이 사용하며, '테스트 대상의 <em>title</em> 속성값이 Sound의 <em>name</em> 속성값과 같아야 함’을 나타낸다. 따라서 두 속성값이 다르면 테스트는 실패한다.</p><p>프로젝트 도구 창의 <strong>‘app/java/com.june0122.beatbox <small>(test)</small>’</strong> 밑에 있는 <strong>SoundViewModelTest</strong>에서 오른쪽 마우스 버튼을 클릭한 후 Run 'SoundViewModelTest’를 선택하면 단위 테스트가 실행되고 안드로이드 스튜디오에서 아래와 같은 실행 결과를 보여준다.</p><blockquote><p>테스트과 통과됨</p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/120898950-36030c80-c668-11eb-84e4-df1d2bedaad5.png'></p><p>여기서는 한 개의 테스트가 실행되어 통과되었음을 보여준다<small>(Tests passed: 1)</small>. 만일 테스트가 실패하면 이에 관한 자세한 내용도 보여준다.</p><h3 id="객체의-상호작용-테스트하기"><a class="markdownIt-Anchor" href="#객체의-상호작용-테스트하기"></a> 객체의 상호작용 테스트하기</h3><p>다음으로 SoundViewModel과 <code>BeatBox.play(Sound)</code> 함수가 잘 연동되는지 검사하는 테스트를 생성한다.</p><p>이때는 주로 연동을 테스트하는 함수를 테스트 클래스에 작성한다. 우선 <code>onButtonClicked()</code>를 호출하는 테스트 함수를 작성한다<small>(<code>onButtonClicked()</code> 함수는 잠시 후에 SoundViewModel에 추가한다)</small>.</p><blockquote><p><code>onButtonClicked()</code>를 호출하는 테스트 함수 작성하기 (SoundViewModelTest.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModelTest</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">exposesSoundNameAsTitle</span><span class="params">()</span></span> &#123;</span><br><span class="line">        MatcherAssert.assertThat(subject.title, `<span class="keyword">is</span>`(sound.name))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">callsBeatBoxPlayOnButtonClicked</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject.onButtonClicked()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 <code>onButtonClicked()</code> 함수는 아직 작성되지 않았기에 붉은색의 에러로 표시된다. 이 함수를 클릭한 후 <code>Alt+Enter [Option+Return]</code> 키를 누르고 Create member function 'SoundViewModel.onButtonClicked’를 선택하면 이 함수가 SoundViewModel.kt에 자동 생성된다. 반드시 TODO를 주석으로 처리해주자!</p><blockquote><p>자동 생성된 <code>onButtonClicked()</code> (SoundViewModel.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModel</span> : <span class="type">BaseObservable</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onButtonClicked</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// TODO(&quot;Not yet implemented&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지금은 <code>onButtonClicked()</code> 함수를 비어 있는 상태로 두고 SoundViewModelTest 클래스를 다시 본다.</p><p>테스트 함수인 <code>callsBeatBoxPlayOnButtonClicked()</code>에서는 SoundViewModel의 <code>onButtonClicked()</code> 함수를 호출한다. 그러나 이 함수에서 <code>BeatBox.play(Sound)</code>를 호출하는 것을 검사해야 한다. 이것을 구현하기 위해 맨 먼저 할 일은 SoundViewModel에 BeatBox 객체를 제공하는 것이다.</p><p>이때 테스트 함수에서 BeatBox 인스턴스를 생성하고 SoundViewModel 생성자에 전달할 수 있다. 그러나 단위 테스트에서 이렇게하면 문제가 생긴다. 만일 BeatBox에서 문제가 생기면 이것을 사용하는 SoundViewModel도 덩달아 문제가 생겨서 SoundViewModel의 단위 테스트가 실패할 수 있기 때문이다. 이것은 우리가 원하는 바가 아니다. <strong>SoundViewModel의 단위 테스트는 SoundViewModel에 국한된 문제가 있을 때만 실패해야 한다.</strong></p><p>다시 말해서 SoundViewModel 자체의 작동과 다른 클래스와의 상호 작용은 별개로 테스트해야 한다. 이것이 단위 테스트에서 중요한 사항이다.</p><p>이런 문제를 해결하고자 BeatBox에 모의 객체<small>(mock object)</small>를 사용한다. 이때 모의 객체는 BeatBox의 서브 클래스가 되며, BeatBox와 같은 함수들을 갖는다. 단, 모든 함수가 아무 일도 하지 않으므로 BeatBox에서는 문제가 생기지 않는다. 따라서 SoundViewModel의 테스트에서는 BeatBox의 작동과는 무관하게 SoundViewModel이 BeatBox를 사용하는 것이 맞는지 검사할 수 있다.</p><p>Mockito를 사용해서 모의 객체를 생성할 때는 <strong>static</strong> 함수인 <code>mock(Class)</code>를 호출하며, 이때 모의 객체를 사용할 클래스를 인자로 전달한다. BeatBox의 모의 객체를 생성하고 이 객체의 참조를 갖는 속성을 SoundViewModelTest에 추가한다.</p><blockquote><p>BeatBox의 모의 객체 생성하기 (SoundViewModelTest.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.mockito.Mockito.mock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModelTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> beatBox: BeatBox</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sound: Sound</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> subject: SoundViewModel</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        beatBox = mock(BeatBox::<span class="keyword">class</span>.java)</span><br><span class="line">        sound = Sound(<span class="string">&quot;assetPath&quot;</span>)</span><br><span class="line">        subject = SoundViewModel()</span><br><span class="line">        subject.sound = sound</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mock(Class)</code> 함수는 클래스 참조처럼 import되며, BeatBox의 모의 객체를 자동으로 생성한다.</p><p>BeatBox의 모의 객체가 준비되었으니 이제는 <code>play(Sound)</code> 함수가 호출되는지 검사하는 테스트 작성을 마무리한다. 모든 Mockito 모의 객체는 자신의 함수들이 호출된 기록은 물론이고, 각 호출에 전달된 매개변수 내역을 유지한다. 그리고 Mockito의 <code>verify(Object)</code> 함수를 사용하면 기대한 대로 모의 객체 함수들이 호출되었는지 확인할 수 있다.</p><p>SoundViewModel에 연결된 Sound 객체를 사용해서 <code>onButtonClicked()</code>가 <code>BeatBox.play(Sound)</code>를 호출하는지 확인하기 위해 <code>verify(Object)</code>를 호출한다<small>(Sound는 문제가 될 함수가 없는 데이터 객체이므로 모의 객체를 생성할 필요가 없다)</small>.</p><blockquote><p><code>BeatBox.play(Sound)</code>가 호출되는지 검사하기 (SoundViewModelTest.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModelTest</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">callsBeatBoxPlayOnButtonClicked</span><span class="params">()</span></span> &#123;</span><br><span class="line">        subject.onButtonClicked()</span><br><span class="line">        </span><br><span class="line">        verify(beatBox).play(sound) <span class="comment">// verify(Object) 호출</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 <b>플루언트 인터페이스<small>(fluent interface)</small></b>를 사용한다<small>(플루언트 인터페이슨느 코드를 알기 쉽게 해주며, 일반적으로 함수의 연쇄 호출 형태로 구현된다)</small>. 즉, <code>verify(beatBox)</code>에서 BeatBox 객체를 반환하므로 연속해서 이 객체의 <code>play(sound)</code> 함수를 호출할 수 있다. <code>verify(beatBox).play(sound)</code>는 다음과 같다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">verify(beatBox)</span><br><span class="line">beatBox.play(sound)</span><br></pre></td></tr></table></figure><p>여기서 <code>verify(beatBox)</code>는 'beatBox의 함수가 호출되었는지 검사하려고 함’이라는 의미이며, 그다음 함수 호출인 <code>play(sound)</code>는 ’<code>play(sound)</code> 함수가 이처럼 호출되었는지 검사하라’는 의미로 생각할 수 있다. 결국 <code>verify(beatBox).play(sound)</code>는 sound를 인자로 받는 beatBox의 <code>play(sound)</code> 함수가 호출되었는지 확인하라는 의미다.</p><p>물론, 지금은 이런 일이 생기지 않는다. <code>SoundViewModel.onButtonClicked()</code> 함수의 실행 코드가 아직 없어서 <code>beatBox.play(sound)</code>가 호출되지 않았기 때문이다. 또한, SoundViewModel은 beatBox 참조를 갖고 있지 않아서 beatBox의 어떤 함수도 호출할 수 없다. 따라서 테스트는 실패한다. 현재는 테스트를 먼저 작성했으니 이렇게 되는 것이 정상이다. 처음부터 테스트가 실패하지 않는다면 어떤 것도 테스트할 필요가 없다.</p><p>테스트를 실행해 아래와 같이 테스트가 실패하는 것을 확인해보자.</p><blockquote><p>테스트 실패 내역 출력</p></blockquote><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/120899745-2d143a00-c66c-11eb-8646-3dd24a79692c.png'></p><p>출력 메시지는 다음과 같다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Wanted but not invoked:</span><br><span class="line">beatBox.play(</span><br><span class="line">    com.june0122.beatbox.Sound@1af146</span><br><span class="line">);</span><br><span class="line">-&gt; at com.june0122.beatbox.BeatBox.play(BeatBox.kt:26)</span><br><span class="line">Actually, there were zero interactions with this mock.</span><br></pre></td></tr></table></figure><p><code>beatBox.play(sound)</code>의 호출을 기대했지만 호출되지 않았다.</p><p><code>assertThat(…)</code>과 마찬가지로 <code>verify(Object)</code>은 내부적으로 어서션<small>(<a href="https://ko.wikipedia.org/wiki/%ED%91%9C%EB%AA%85">assertion</a>)</small>을 생성한다. 그리고 어서션에 어긋나면 테스트를 실패로 처리하고, 로그에 그 이유를 설명하는 출력을 남긴다. 그리고 어서션에 어긋나면 테스트를 실패로 처리하고, 로그에 그 이유를 설명하는 출력을 남긴다.</p><p>이제는 테스트의 결함을 수정할 때가 되었다. 우선 SoundViewModel의 생성자에서 BeatBox 인스턴스를 받도록 속성을 추가한다<small>(여기서 기본 생성자에 선언된 beatBox는 매개변수이면서 속성으로도 생성된다)</small>.</p><blockquote><p>BeatBox를 SoundViewModel에 제공하기 (SoundViewModel.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> beatBox: BeatBox) : BaseObservable() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 변경하면 SoundHolder 클래스와 SoundViewModelTest 클래스에서 에러가 발생한다.</p><ul><li>SoundHolder에서 SoundViewModel 인스턴스를 생성할 때 <em>beatBox</em> 객체를 생성자에 전달하도록 변경</li><li>BeatBox의 모의 객체를 SoundViewModel 생성자에 전달</li></ul><blockquote><p>SoundHolder의 에러 수정 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SoundHolder</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> binding: ListItemSoundBinding) : RecyclerView.ViewHolder(binding.root) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        binding.viewModel = SoundViewModel(beatBox)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(sound: <span class="type">Sound</span>)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>테스트에 BeatBox 모의 객체 제공 (SoundViewModelTest.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModelTest</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        beatBox = mock(BeatBox::<span class="keyword">class</span>.java)</span><br><span class="line">        sound = Sound(<span class="string">&quot;assetPath&quot;</span>)</span><br><span class="line">        subject = SoundViewModel(beatBox)</span><br><span class="line">        subject.sound = sound</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음으로 테스트에서 기대하는 것을 수행하도록 <code>onButtonClicked()</code>를 구현한다.</p><blockquote><p><code>onButtonClicked()</code> 구현하기 (SoundViewModel.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoundViewModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> beatBox: BeatBox) : BaseObservable() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onButtonClicked</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sound?.let &#123; </span><br><span class="line">            beatBox.play(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>테스트를 다시 실행하면 이번에는 테스트과 통과되었음을 Run 도구 창에서 확인할 수 있다.</p><p align = 'center'><img width = '800' src = 'https://user-images.githubusercontent.com/39554623/120900145-32728400-c66e-11eb-8b37-dc3dde85c26e.png'></p><h2 id="데이터-바인딩-콜백"><a class="markdownIt-Anchor" href="#데이터-바인딩-콜백"></a> 데이터 바인딩 콜백</h2><p>이제는 버튼들이 제대로 작동하는지 테스트하는 것만 남았다. 따라서 <code>onButtonClicked()</code>를 버튼과 연결해야 한다.</p><p>사용자 인터페이스인 레이아웃에 데이터를 넣을 때 데이터 바인딩을 사용할 수 있듯이, 클릭 리스너를 연결할 때도 람다식으로 데이터 바인딩을 할 수 있다.</p><p>버튼 클릭을 <code>SoundViewModel.onButtonClicked()</code>에 연결하기 위해 데이터 바인딩으로 호출되는 콜백 표현식을 추가한다.</p><blockquote><p>버튼을 코드와 연결하기 (list_item_sound.xml)</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;120dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; viewModel.onButtonClicked()&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@&#123;viewModel.title&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:text</span>=<span class="string">&quot;Sound name&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>이제는 BeatBox 앱을 실행하고 음원 제목을 보여주는 버튼을 누르면 음원이 재생되어야 한다. 테스트를 실행한 뒤에는 <b>실행 구성<small>(run configuration)</small></b>이 변경되므로 실행 구성 드롭다운을 클릭해 <strong>app</strong>으로 변경한다.</p><blockquote><p>실행 구성을 변경하기</p></blockquote><p align = 'center'><img width = '300' src = 'https://user-images.githubusercontent.com/39554623/120900296-115e6300-c66f-11eb-8ba7-b0301e31984f.png'></p><h2 id="음원-내리기"><a class="markdownIt-Anchor" href="#음원-내리기"></a> 음원 내리기</h2><p>음원 재생이 잘 작동하지만 아직 마무리해야 할 것이 있다. 음원 재생이 끝나면 <code>SoundPool.release()</code>를 호출해 SoundPool을 클린업<small>(리소스 해제)</small>해야 한다. 이 일을 하는 <code>BeatBox.release()</code> 함수를 추가한다.</p><blockquote><p>SoundPool 클린업하기 (BeatBox.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeatBox</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> assets: AssetManager) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">play</span><span class="params">(sound: <span class="type">Sound</span>)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">        soundPool.release()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadSounds</span><span class="params">()</span></span>: List&lt;Sound&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그다음에 <code>BeatBox.release()</code> 함수를 호출하는 <code>onDestroy()</code> 함수를 MainActivity에 추가한다. 액티비티가 소멸하면 SoundPool도 클린업해야 하기 때문이다.</p><blockquote><p><code>onDestroy()</code> 함수 추가하기 (MainActivity.kt)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> beatBox: BeatBox</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        beatBox.release()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeatBox 앱을 다시 실행해 <code>release()</code> 함수가 제대로 작동하는지 확인해보자. 대부분 짧은 소리만 나지만, 조금 긴 소리의 음원이 재생되는 동안에 장치를 회전하거나 백 버튼을 누르면 재생이 중단된다.</p><h2 id="b-id-f1궁금증-해소-️-통합-테스트b"><a class="markdownIt-Anchor" href="#b-id-f1궁금증-해소-️-통합-테스트b"></a> <b id = "f1">궁금증 해소 💁🏻‍♂️ : 통합 테스트</b>  <a href="#a1"> ↩</a></h2><p>앞의 <strong>SoundViewModelTest</strong>는 단위 테스트였지만, <b>통합 테스트<small>(integration test)</small></b>를 생성할 수도 있다. 통합 테스트가 무엇일까?</p><p>단위 테스트에서는 테스트 항목이 개별 클래스이지만, 통합 테스트는 여러 클래스나 컴포넌트가 함께 작동하는 앱의 일부가 테스트 대상이다. 단위 테스트와 통합 테스트 모두 중요하지만, 서로 다른 목적을 갖는다.</p><ul><li>단위 테스트에서는 각 단위 클래스가 올바르게 작동하는지, 기대한 대로 다른 단위와 제대로 상호 작용하는지 확인한다.</li><li>반면에 통합 테스트에서는 개별적으로 테스트된 단위들과 기능이 올바르게 통합되어 작동하는지 검사한다.</li></ul><p>통합 테스트는 데이터베이스 사용과 같은 UI가 아닌 부분을 검사하기 위해 작성한다. 그런데 안드로이드에서는 UI와 상호 작용하면서 기대한 대로 잘 되는지 검사하기 때문에 UI 수준에서 앱을 테스트하고자 이러한 테스트를 작성하는 경우가 많다. 따라서 대개는 화면별로 통합 테스트를 작성한다. 예를 들어, MainActivity 화면이 나타날 때 첫 번째 버튼의 제목이 <em>sample_sounds</em>의 첫 번째 파일 이름<small>(예를 들어, MainActivity)</small> 화면이 나타날 때 첫 번째 버튼의 제목이 <em>sample_sounds</em>의 첫 번째 파일 이름<small>(예를 들어, 65_cjipie)</small>을 보여주는지 테스트할 수 있다.</p><p>UI 수준의 통합 테스트는 액티비티나 프래그먼트와 같은 프레임워크 클래스가 필요하며, JVM 단위 테스트에서 사용할 수 없는 시스템 서비스, 파일 시스템 등도 필요할 수 있다. 이런 이유로 안드로이드에서는 통합 테스트는 주로 장치 테스트로 구현된다.</p><p>통합 테스트는 기대한 대로 앱이 <strong>작동</strong>하면 통과된다. <strong>구현</strong>될 때 통과되는 것이 아니다. 버튼 ID의 이름을 변경해도 앱의 작동에는 영향을 주지 않는다. 그런데 <code>findViewById(R.id.button)</code>을 호출해 해당 버튼이 올바른 텍스트를 보여주는지 확인하는 것은 통합 테스트로 작성할 수 있다. 이때 안드로이드에서는 <code>findViewById(R.id.button)</code> 대신 UI 테스트 프레임워크를 사용해서 통합 테스트를 작성한다. 이렇게 하면 기대하는 텍스트를 갖는 버튼이 화면에 있는지 쉽게 확인할 수 있다.</p><p><strong>Espresso는 안드로이드 앱을 테스트하는 구글의 UI 테스트 프레임워크</strong>다. 안드로이드 스튜디오의 프로젝트 도구 창에서 Gradle Scripts 밑의 build.gradle (Module: BeatBox.app) 파일을 보면 다음과 같이 기본적으로 라이브러리 의존성에 추가되어 있다<small>(맨 끝의 버전 번호는 변경될 수 있다)</small>.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.3.0&#x27;</span></span><br></pre></td></tr></table></figure><p>이처럼 Espresso가 의존성에 포함되면 통합 테스트를 하기 위해 시작될 액티비티에 관한 어서션을 만들 수 있다. 여기서는 첫 번째 <em>sample_sounds</em> 테스트 파일 이름을 사용하는 뷰<small>(버튼)</small>가 화면에 있어야 한다는 어서션을 만드는 방법을 보여준다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(AnbdroidJUnit4::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivityTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Rule</span></span><br><span class="line">    <span class="keyword">val</span> activityRule = ActivityTestRule(MainActivity::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">showsFirstFileName</span><span class="params">()</span></span> &#123;</span><br><span class="line">        onView(withText(<span class="string">&quot;65_cjipie&quot;</span>))</span><br><span class="line">                .check(matches(isDisplayed()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서는 두 개의 애노테이션이 코드를 실행한다. <code>@RunWith(AnbdroidJUnit4::class)</code>는 MainActivityTest가 안드로이드 장치 테스트이며, 액티비티 및 다른 안드로이드 런타임 도구와 함께 작동함을 나타낸다. 그다음에 있는 activityRule의 <code>@get:Rule</code>은 각 테스트를 실행하기 전에 MainActivity의 인스턴스를 시작시켜야 함을 JUnit에게 알린다.</p><p>테스트가 설정되었으니 이제는 테스트할 MainActivity에 관한 어서션을 만들 수 있다. <code>showsFirstFileName()</code>의 <code>onView(withText(&quot;65_cjipie&quot;))</code>에서는 테스트를 수행하기 위해 *“65_cjipie”*라는 텍스트를 갖는 뷰<small>(버튼)</small>을 찾는다. 그다음에 <code>check(matches(isDisplayed()))</code>를 호출해 해당 뷰가 화면에 보이는지 확인한다. 만일 그런 텍스트를 갖는 뷰가 없다면 <code>check(…)</code>는 실패한다. <code>check(…)</code> 함수는 뷰에 관한 <code>assertThat(…)</code> 형태의 어서션을 만드는 Espresso의 방법이다.</p><p>버튼처럼 뷰를 클릭해야 할 때는 클릭한 결과를 검사하는 어서션을 만들면 된다. 이때도 다음과 같이 Espresso를 사용할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onView(withText(<span class="string">&quot;65_cjipie&quot;</span>))</span><br><span class="line">        .perform(click())</span><br></pre></td></tr></table></figure><p>이처럼 뷰와 상호 작용할 때는 Espresso가 테스트를 멈추고 기다리며, UI의 변경이 끝났을 때를 감지한다. 그런데 Espresso를 더 오래 기다리게 할 때는 <strong>IdlingResource</strong>의 서브 클래스를 사용해 Espresso에게 앱의 작업이 아직 끝나지 않았음을 알린다.</p><p>Espresso로 UI를 테스트하는 방법에 관한 자세한 정보는 <a href="https://developer.android.com/training/testing/espresso?hl=ko">Espresso 문서</a>를 참고하자.</p><p>다시 말하지만 <strong>통합 테스트와 단위 테스트는 그 목적이 다르다.</strong> 대부분의 사람은 단위 테스트를 먼저 시작한다. 앱의 개별적인 부분들의 작동을 정의하고 검사하는데 도움이 되기 때문이다. 통합 테스트는 그런 개별적인 부분들에 의존해 여러 부분이 하나로 함께 잘 작동하는지 검사한다. 두 테스트는 각각 앱의 건강에 관한 서로 다른 중요한 관점을 제공하므로 테스트를 같이 하는 것이 가장 좋다.</p><h2 id="궁금증-해소-️-모의-객체와-테스트"><a class="markdownIt-Anchor" href="#궁금증-해소-️-모의-객체와-테스트"></a> 궁금증 해소 💁🏻‍♂️ : 모의 객체와 테스트</h2><p>통합 테스트에서는 모의 객체가 단위 테스트 때와는 다른 역할을 담당한다. 모의 객체는 다른 컴포넌트를 테스트와 관계없는 것처럼 만들어서 테스트할 컴포넌트를 격리하기 위해 존재한다. 단위 테스트는 클래스 단위로 테스트한다. 그런데 각 클래스는 다른 클래스들에 대해 의존성을 가질 수 있으므로 테스트 클래스들은 서로 다른 모의 객체들을 가지며, 모의 객체가 어떻게 작동하는가는 중요하지 않다. 따라서 간단한 모의 객체를 쉽게 생성해주는 모의 프레임워크<small>(예를 들어, Mockito)</small>가 단위 테스트에는 안성맞춤이다.</p><p>이와는 달리 통합 테스트는 앱 전체를 한 덩어리로 테스트한다. 따라서 앱의 각 부분을 격리하는 대신에 앱이 상호 작용하는 외부의 것과 격리하기 위한 모의 객체를 사용한다. 예를 들어, 모의 데이터와 응답을 반호나하는 웹 서비스를 제공하는 경우다. BeatBox 앱에서는 특정 음원 파일이 재생되었음을 알려주는 모의 SoundPool을 제공할 수 있을 것이다. 모의 객체는 점점 더 많아지고 여러 테스트에서 공유되며 모의 행동을 구현하므로, 통합 테스트에서는 자동화된 모의 프레임워크를 사용하지 말고 모의 객체를 직접 작성하는 것이 좋다.</p><p>어떤 경우든 다음 규칙이 적용된다. 즉, 테스트 중인 컴포넌트의 경계에 있는 개체들을 모의 객체로 만든다. 이렇게 하면 테스트하려는 범위에만 집중할 수 있다. 또한, 테스트 컴포넌트 외의 다른 컴포넌트와는 무관하게 테스트 컴포넌트에 문제가 있을 때만 테스트가 실패하므로 정확하게 테스트할 수 있다.</p>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Android/">Android</category>
      
      <category domain="http://june0122.github.io/categories/Android/Guide/">Guide</category>
      
      
      <category domain="http://june0122.github.io/tags/Android/">Android</category>
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/MVVM/">MVVM</category>
      
      <category domain="http://june0122.github.io/tags/Unit-Test/">Unit Test</category>
      
      <category domain="http://june0122.github.io/tags/Mockito/">Mockito</category>
      
      <category domain="http://june0122.github.io/tags/Espresso/">Espresso</category>
      
      <category domain="http://june0122.github.io/tags/SoundPool/">SoundPool</category>
      
      
      <comments>http://june0122.github.io/2021/06/06/android-bnr-20/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Kotlin] Coroutine - Cancellation and Timeouts</title>
      <link>http://june0122.github.io/2021/06/03/coroutines-cancellation-timeouts/</link>
      <guid>http://june0122.github.io/2021/06/03/coroutines-cancellation-timeouts/</guid>
      <pubDate>Thu, 03 Jun 2021 09:15:50 GMT</pubDate>
      
      <description>코루틴이 취소되기 위해서 협조적인 방식을 취하는데 크게 2가지 방법이 있다. 첫 번째, &lt;b&gt;주기적으로 suspend function을 호출하기&lt;/b&gt; &lt;small&gt;(suspend 되었다가 다시 재개될 때 cancel 되었는지를 확인해서 Exception을 던져주는 방식)&lt;/small&gt;. 두 번째, &lt;b&gt;명시적으로 취소 상태를 확인하기&lt;/b&gt; &lt;small&gt;(isActive 상태를 확인하여 false일 때 해당 코루틴을 종료시키는 방식)&lt;/small&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><h3 id="1-b-id-f1cancelling-coroutine-executionb"><a class="markdownIt-Anchor" href="#1-b-id-f1cancelling-coroutine-executionb"></a> ① <b id = "f1">Cancelling coroutine execution</b>  <a href="#a1"> ↩</a></h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancel() <span class="comment">// cancels the job </span></span><br><span class="line">    job.join() <span class="comment">// waits for job&#x27;s completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">job: I&#x27;m sleeping 0 ... [main]</span><br><span class="line">job: I&#x27;m sleeping 1 ... [main]</span><br><span class="line">job: I&#x27;m sleeping 2 ... [main]</span><br><span class="line">main: I&#x27;m tired of waiting! [main]</span><br><span class="line">main: Now I can quit. [main]</span><br></pre></td></tr></table></figure><p>코루틴을 실행할 떄 launch를 해서 반환된 Job 객체에서 <code>cancel()</code>을 호출할 수 있고, 이를 통해 코루틴 실행을 취소시킬 수 있다.</p><blockquote><h3 id="2-cancellation-is-cooperative"><a class="markdownIt-Anchor" href="#2-cancellation-is-cooperative"></a> ② Cancellation is cooperative</h3></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123; <span class="comment">// computation loop, just wastes CPU</span></span><br><span class="line">            <span class="comment">// print a message twice a second</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">job: I&#x27;m sleeping 0 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 1 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 2 ... [DefaultDispatcher-worker-1]</span><br><span class="line">main: I&#x27;m tired of waiting! [main]</span><br><span class="line">job: I&#x27;m sleeping 3 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 4 ... [DefaultDispatcher-worker-1]</span><br><span class="line">main: Now I can quit. [main]</span><br></pre></td></tr></table></figure><p>코드의 의도는 코루틴이 3번정도 실행되고 취소되는 것을 기대했을 것이다. 하지만 <code>main: I'm tired of waiting!</code>이 호출된 뒤 코루틴의 실행은 취소되지 않고 5번의 횟수를 채운 뒤 종료된다.</p><p>왜 이런 것일까? 이는 코루틴 자체가 취소되는데 협조적 <sup>cooperative</sup>이지 않았기 때문이다. 코루틴 내부에 suspend function이 존재하지 않는 것과 달리, <a id = "a1"><a href="#f1">첫 번째 예제</a></a>에서는 코루틴 내부에 <code>delay()</code>라는 suspend function이 존재하므로 취소가 가능했다.</p><p>다시 말해, 첫 번째 예제에서는 suspend function이 있었는데 두 번째 예제에서는 단순 연산만 있고 suspend function의 호출이 코루틴 내부에 없기 때문에 취소가 불가능하다는 것이다. 그럼 첫 번째 예제와 같이 두 번째 예제에도 suspend function을 호출하여 취소에 협조적인 코루틴을 만들어보자. 과연 원하는 실행 결과가 나올까?</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                delay(<span class="number">1L</span>) <span class="comment">// suspend function을 추가</span></span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>)</span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">job: I&#x27;m sleeping 0 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 1 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 2 ... [DefaultDispatcher-worker-1]</span><br><span class="line">main: I&#x27;m tired of waiting! [main]</span><br><span class="line">main: Now I can quit. [main]</span><br></pre></td></tr></table></figure><p>실행을 해보면 의도했던대로 0, 1, 2 까지만 출력이되고 종료가 된 것을 확인할 수 있다.</p><p>suspend function으로써 이런 상황에 <code>delay()</code>가 아닌 더 적합한 함수가 있다. 바로 <code>yield()</code> 이다. <code>yield()</code>를 이용하면 <code>delay(1L)</code>을 이용하지 않고도 취소를 확인할 수 있다. 결과는 위와 동일하다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                yield() <span class="comment">// delay 대신 yield 사용</span></span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>)</span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>어떻게 해서 cancel이 일어나게 되었을까?</p><p>코루틴 가이드에 따르면 <code>Job.cancel</code>을 하게 되면 코루틴 내부에서 suspend가 되었다가 다시 재개<small>(resume)</small>되는 시점에 suspend function<small>(여기서는 <code>yield()</code>)</small>이 CancellationException을 던진다고 설명되어 있다. Exception을 체크하기 위해 코루틴 내부에서 <code>try-catch</code> 문을 사용해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123; <span class="comment">// computation loop, just wastes CPU</span></span><br><span class="line">                <span class="comment">// print a message twice a second</span></span><br><span class="line">                <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                    yield()</span><br><span class="line">                    kotlin.io.println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                    nextPrintTime += <span class="number">500L</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            kotlin.io.println(<span class="string">&quot;Exception [<span class="variable">$e</span>]&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    kotlin.io.println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    kotlin.io.println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">job: I&#x27;m sleeping 0 ...</span><br><span class="line">job: I&#x27;m sleeping 1 ...</span><br><span class="line">job: I&#x27;m sleeping 2 ...</span><br><span class="line">main: I&#x27;m tired of waiting!</span><br><span class="line">Exception [kotlinx.coroutines.JobCancellationException: StandaloneCoroutine was cancelled; job=StandaloneCoroutine&#123;Cancelling&#125;@54c334f5]</span><br><span class="line">main: Now I can quit.</span><br></pre></td></tr></table></figure><p>결과를 확인해보면 3번 출력한 뒤 Exception이 출력되었고 그 내용이 <em>kotlinx.coroutines.JobCancellationException</em>이라는 것을 확인할 수 있다. 즉 <code>Job.cancel</code>이 동작하는 방법은 코루틴 내부에서 강제로 Exception을 발생시켜 코루틴이 종료되게 하는 것이다.</p><p><strong>Coroutine cancellation is cooperative. A coroutine code has to cooperate to be cancellable.</strong> 코루틴 문서의 협조적이어야 한다는 말은 코루틴 스스로가 cancel을 체크<small>(CancellationException을 체크)</small>해야한다는 뜻이며 suspend function을 하나라도 실행하지 않으면 코루틴은 종료되지 않는다는 것이다<small>(자신의 로직이 완료되어 리턴이 되지 않는 한에서)</small>.</p><blockquote><h3 id="3-making-computation-code-cancellable"><a class="markdownIt-Anchor" href="#3-making-computation-code-cancellable"></a> ③ Making computation code cancellable</h3></blockquote><p>코루틴이 취소되기 위해서 협조적인 방식을 취하는데 크게 2가지 방법이 있다.</p><ol><li><strong>주기적으로 suspend function을 호출하기</strong> <small>(suspend 되었다가 다시 재개될 때 cancel 되었는지를 확인해서 Exception을 던져주는 방식)</small></li><li><strong>명시적으로 취소 상태를 확인하기</strong> <small>(<code>isActive</code>라는 상태를 확인하여 false일 때 해당 코루틴을 종료시키는 방식)</small></li></ol><p>2번 예제에서 첫 번째 방법을 알아보았고, 이번 3번 예제에서 두 번째 방법을 알아본다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (isActive) &#123; <span class="comment">// cancellable computation loop</span></span><br><span class="line">            <span class="comment">// print a message twice a second</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">job: I&#x27;m sleeping 0 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 1 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 2 ... [DefaultDispatcher-worker-1]</span><br><span class="line">main: I&#x27;m tired of waiting! [main]</span><br><span class="line">main: Now I can quit. [main]</span><br></pre></td></tr></table></figure><p>while문을 통해 isActive의 상태를 확인하는 것으로 코루틴이 취소된 것을 확인할 수 있다. <code>isActive</code>가 실제로 잘 동작하였는지 로그를 통해 확인해보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        kotlin.io.println(<span class="string">&quot;isActive <span class="variable">$isActive</span> ...&quot;</span>) <span class="comment">// while문에 들어가기 전의 isActive 확인</span></span><br><span class="line">        <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        kotlin.io.println(<span class="string">&quot;isActive <span class="variable">$isActive</span> ...&quot;</span>) <span class="comment">// while문에서 나온 뒤의 isActive 확인</span></span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>)</span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin()</span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isActive true ...</span><br><span class="line">job: I&#x27;m sleeping 0 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 1 ... [DefaultDispatcher-worker-1]</span><br><span class="line">job: I&#x27;m sleeping 2 ... [DefaultDispatcher-worker-1]</span><br><span class="line">main: I&#x27;m tired of waiting! [main]</span><br><span class="line">isActive false ...</span><br><span class="line">main: Now I can quit. [main]</span><br></pre></td></tr></table></figure><p>출력 결과에서 while문에 들어가기 전과 후에 <code>isActive</code>의 상태값이 변경되는 것을 확인할 수 있다. 이러한 상태값을 통해 코루틴 스스로가 종료할 수 있다.</p><p>상태값을 통해 코루틴을 종료시키는 방식은 Exception이 발생하지 않으므로 코루틴 내부를 2번 예제와 같이 코루틴 내부를 <code>try-catch</code>문으로 감싸 예외를 확인해보면 Exception이 발생하지 않는 것을 확인할 수 있다.</p><p><code>isActive</code>는 <strong>확장 프로퍼티</strong>로 내부 구현은 코루틴의 Job이 실제로 종료되었는지를 체크하는 것이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Suppress(<span class="meta-string">&quot;EXTENSION_SHADOWED_BY_MEMBER&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> CoroutineScope.isActive: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = coroutineContext[Job]?.isActive ?: <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="4-closing-resources-with-finally-small코루틴을-종료할-때-리소스를-해제하는-방법small"><a class="markdownIt-Anchor" href="#4-closing-resources-with-finally-small코루틴을-종료할-때-리소스를-해제하는-방법small"></a> ④ Closing resources with finally <small>(코루틴을 종료할 때 리소스를 해제하는 방법)</small></h3></blockquote><p>코루틴에서 네트워크나 DB 등을 사용하다가 갑자기 코루틴이 cancel 되었을 때 코드 상에서 리소스를 해제해줘야 하는 위치를 알아보자.</p><p>아래의 코루틴은 <code>delay()</code>를 포함하여 취소하기에 협조적인 형태로 구현되어 있기에 <code>job.cancel</code>을 하면 취소가 될 것이다. 일시 중단이 되었다가 재개되면서 Exception을 던지면 <code>finally</code> 블록에서 리소스를 해제하면 된다.</p><p><strong>즉, suspend function으로 취소를 체크할 때 리소스 해제 지역은 <code>finally</code> 블록이다.</strong></p><p><code>try &#123;...&#125; finally &#123;...&#125;</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 리소스 해제 위치</span></span><br><span class="line">            println(<span class="string">&quot;job: I&#x27;m running finally&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">job: I&#x27;m sleeping 0 ... [main]</span><br><span class="line">job: I&#x27;m sleeping 1 ... [main]</span><br><span class="line">job: I&#x27;m sleeping 2 ... [main]</span><br><span class="line">main: I&#x27;m tired of waiting! [main]</span><br><span class="line">job: I&#x27;m running finally [main]</span><br><span class="line">main: Now I can quit. [main]</span><br></pre></td></tr></table></figure><blockquote><h3 id="5-run-non-cancellable-block"><a class="markdownIt-Anchor" href="#5-run-non-cancellable-block"></a> ⑤ Run non-cancellable block</h3></blockquote><p>5번 예제는 <strong>rare한 케이스</strong>이다.</p><p>이미 cancel된 코루틴 내부에서 suspend function을 호출해야하는 경우, 즉 <code>finally</code> 블록 안에서 다시 코루틴을 실행하려면 어떻게 해야할까?</p><p>이런 경우에는 <code>withContext</code> 함수에 <code>NonCancellable</code>이라는 CoroutineContext를 넘겨서 <code>withContext(NonCancellable) &#123; ... &#125;</code>에서 해당 코드를 래핑할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            withContext(NonCancellable) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m running finally&quot;</span>)</span><br><span class="line">                delay(<span class="number">1000L</span>)</span><br><span class="line">                println(<span class="string">&quot;job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">job: I&#x27;m sleeping 0 ... [main]</span><br><span class="line">job: I&#x27;m sleeping 1 ... [main]</span><br><span class="line">job: I&#x27;m sleeping 2 ... [main]</span><br><span class="line">main: I&#x27;m tired of waiting! [main]</span><br><span class="line">job: I&#x27;m running finally [main]</span><br><span class="line">job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable [main]</span><br><span class="line">main: Now I can quit. [main]</span><br></pre></td></tr></table></figure><blockquote><h3 id="6-timeout"><a class="markdownIt-Anchor" href="#6-timeout"></a> ⑥ Timeout</h3></blockquote><p>이전 예제들에서는 코루틴 스스로가 내부에서 cancel을 체크하는 2가지 방법을 알아보았다. 그런데 그외에도 다른 방법이 있는데 바로 <strong>Timeout</strong>이다.</p><p><strong>Timeout</strong>은 launch된 코루틴의 Job을 가지고 cancel하는 것이 아니라, 코루틴을 실행할 때 일정 시간이 지나면 취소되도록 미리 Timeout을 지정하는 방식이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    withTimeout(<span class="number">1300L</span>) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m sleeping 0 ... [main]</span><br><span class="line">I&#x27;m sleeping 1 ... [main]</span><br><span class="line">I&#x27;m sleeping 2 ... [main]</span><br><span class="line">Exception in thread &quot;main&quot; kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms</span><br><span class="line">at kotlinx.coroutines.TimeoutKt.TimeoutCancellationException(Timeout.kt:186)</span><br><span class="line">at kotlinx.coroutines.TimeoutCoroutine.run(Timeout.kt:156)</span><br><span class="line">at kotlinx.coroutines.EventLoopImplBase$DelayedRunnableTask.run(EventLoop.common.kt:497)</span><br><span class="line">at kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:274)</span><br><span class="line">at kotlinx.coroutines.DefaultExecutor.run(DefaultExecutor.kt:69)</span><br><span class="line">at java.base/java.lang.Thread.run(Thread.java:834)</span><br></pre></td></tr></table></figure><p>lauch를 통해 실행시킨 것이 아닌, runBlocking 내부 main에서 실행했기 때문에 CancellationException 발생하여 종료되는 것이다. 이런 경우를 해결하기 위해 <code>withTimeoutOrNull(Long)</code>을 사용한다.</p><p><code>withTimeout(Long)</code>이 아닌 <code>withTimeoutOrNull(Long)</code>을 사용하면 Exception이 발생했을 때 결과값이 <code>null</code>이 된다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> result = withTimeoutOrNull(<span class="number">1300L</span>) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">&quot;Done&quot;</span> <span class="comment">// will get cancelled before it produces this result</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Result is <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m sleeping 0 ... [main]</span><br><span class="line">I&#x27;m sleeping 1 ... [main]</span><br><span class="line">I&#x27;m sleeping 2 ... [main]</span><br><span class="line">Result is null [main]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://june0122.github.io/categories/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/categories/Kotlin/Coroutine/">Coroutine</category>
      
      
      <category domain="http://june0122.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="http://june0122.github.io/tags/Coroutine/">Coroutine</category>
      
      
      <comments>http://june0122.github.io/2021/06/03/coroutines-cancellation-timeouts/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
