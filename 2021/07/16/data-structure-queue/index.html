<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>[코틀린 자료구조] 큐 (Queue) - 카미유 테크 블로그</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="카미유 테크 블로그"><meta name="msapplication-TileImage" content="/img/logo.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="카미유 테크 블로그"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="우리는 모두 줄을 서서 기다리는 것에 익숙하다. 좋아하는 영화의 티켓을 구매하기 위해 줄을 서는 것과 같은 실생활의 예시들은 큐(Queue) 자료구조를 모방한다. 큐는 FIFO(first in, first out)의 형태로, 처음 추가된 요소가 제일 먼저 제거되는 요소가 된다. 큐는 나중에 처리할 요소의 순서를 유지해야 할 때 편리하다."><meta property="og:type" content="blog"><meta property="og:title" content="[코틀린 자료구조] 큐 (Queue)"><meta property="og:url" content="http://june0122.github.io/2021/07/16/data-structure-queue/"><meta property="og:site_name" content="카미유 테크 블로그"><meta property="og:description" content="우리는 모두 줄을 서서 기다리는 것에 익숙하다. 좋아하는 영화의 티켓을 구매하기 위해 줄을 서는 것과 같은 실생활의 예시들은 큐(Queue) 자료구조를 모방한다. 큐는 FIFO(first in, first out)의 형태로, 처음 추가된 요소가 제일 먼저 제거되는 요소가 된다. 큐는 나중에 처리할 요소의 순서를 유지해야 할 때 편리하다."><meta property="og:locale" content="ko_KR"><meta property="og:image" content="http://june0122.github.io/thumbnail/data_structure.png"><meta property="article:published_time" content="2021-07-15T21:53:06.261Z"><meta property="article:modified_time" content="2021-07-15T21:59:48.546Z"><meta property="article:author" content="KAMIYU"><meta property="article:tag" content="Kotlin"><meta property="article:tag" content="Data Structure"><meta property="article:tag" content="Queue"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/thumbnail/data_structure.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://june0122.github.io/2021/07/16/data-structure-queue/"},"headline":"[코틀린 자료구조] 큐 (Queue)","image":["http://june0122.github.io/thumbnail/data_structure.png"],"datePublished":"2021-07-15T21:53:06.261Z","dateModified":"2021-07-15T21:59:48.546Z","author":{"@type":"Person","name":"KAMIYU"},"publisher":{"@type":"Organization","name":"카미유 테크 블로그","logo":{"@type":"ImageObject","url":"http://june0122.github.io/img/logo.svg"}},"description":"우리는 모두 줄을 서서 기다리는 것에 익숙하다. 좋아하는 영화의 티켓을 구매하기 위해 줄을 서는 것과 같은 실생활의 예시들은 큐(Queue) 자료구조를 모방한다. 큐는 FIFO(first in, first out)의 형태로, 처음 추가된 요소가 제일 먼저 제거되는 요소가 된다. 큐는 나중에 처리할 요소의 순서를 유지해야 할 때 편리하다."}</script><link rel="canonical" href="http://june0122.github.io/2021/07/16/data-structure-queue/"><link rel="icon" href="/img/logo.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/rss2.xml" title="카미유 테크 블로그" type="application/rss+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="카미유 테크 블로그" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/june0122"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-07-15T21:53:06.261Z" title="2021. 7. 16. 오전 6:53:06">2021-07-16</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-07-15T21:59:48.546Z" title="2021. 7. 16. 오전 6:59:48">2021-07-16</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Data-Structure/">Data Structure</a></span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>회 방문</span></div></div><h1 class="title is-3 is-size-4-mobile">[코틀린 자료구조] 큐 (Queue)</h1><div class="content"><p>우리는 모두 줄을 서서 기다리는 것에 익숙하다. 좋아하는 영화의 티켓을 구매하기 위해 줄을 서는 것과 같은 실생활의 예시들은 <b>큐<small>(Queue)</small></b> 자료구조를 모방한다.</p>
<p>큐는 <b>FIFO<small>(first in, first out)</small></b>의 형태로, 처음 추가된 요소가 제일 먼저 제거되는 요소가 된다. 큐는 나중에 처리할 요소의 순서를 유지해야 할 때 편리하다.</p>
<h2 id="큐의-일반적인-연산들"><a class="markdownIt-Anchor" href="#큐의-일반적인-연산들"></a> 큐의 일반적인 연산들</h2>
<p>먼저 큐에 대한 인터페이스를 설정한다. base 패키지 내부에 Queue.kt라는 파일을 만들고 Queue 인터페이스를 정의하는 다음 코드를 추가한다.</p>
<blockquote>
<p>큐 인터페이스 정의 (base/Queue.kt)</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="type">T : Any</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: T?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = count == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제부터 구현하는 모든 것은 큐의 핵심 작업을 설명하는 위의 인터페이스의 규약을 따른다.</p>
<p>큐의 핵심 연산들은 다음과 같다.</p>
<ul>
<li><code>enqueue</code> : <b>대기열<small>(queue)</small></b>의 뒤에 요소를 삽입하고 연산이 성공하면 true를 반환한다.</li>
<li><code>dequeue</code> : 대기열의 맨 앞 요소를 제거하고 반환한다.</li>
<li><code>isEmpty</code> : <em>count</em> 속성을 사용하여 대기열이 비어있는지 확인한다.</li>
<li><code>peek</code> : 대기열의 맨 앞에 있는 요소를 제거하지 않고 값만 반환한다.</li>
</ul>
<p>큐는 앞쪽에서 제거하고 뒤쪽에서 삽입하는 것에만 관심이 있다. 그 사이에 내용이 무엇인지 알 필요가 없다.</p>
<h2 id="큐의-이해"><a class="markdownIt-Anchor" href="#큐의-이해"></a> 큐의 이해</h2>
<p>큐의 작동 방식을 이해하는 가장 쉬운 방법은 작동 예제를 보는 것이다. 영화 티켓을 위해 줄을 서서 기다리는 사람들을 상상해보자.</p>
<p align="center">
<img width="600" src="https://user-images.githubusercontent.com/39554623/124502496-9370b180-ddfe-11eb-8e2d-4841fcb3d2ef.png">
</p>
<p>이 대기열에는 현재 Ray, Brian, Sam 및 Mic이 있다. Ray는 티켓을 받으면 줄에서 나간다. <code>dequeue()</code>를 호출하면 Ray가 대기열의 앞쪽에서 제거된다.</p>
<p><code>peek()</code>을 호출하면 Brian이 현재 맨앞에 있기 때문에 Brian이 반환된다.</p>
<p>이제 막 표를 사기 위해 비키가 줄에 합류한다. <code>enqueue(&quot;Vicki&quot;)</code>를 호출하면 Vicki가 대기열 뒤에 추가된다.</p>
<h2 id="큐의-구현-방법들"><a class="markdownIt-Anchor" href="#큐의-구현-방법들"></a> 큐의 구현 방법들</h2>
<p>본문에선 네 가지 방법의 큐 구현 방법들을 알아본다.</p>
<ol>
<li>배열 기반 리스트<small>(array based list)</small> 사용</li>
<li>이중 연결 리스트<small>(doubly linked list)</small> 사용</li>
<li>ring buffer 사용</li>
<li>두 개의 스택 사용</li>
</ol>
<h3 id="1-리스트-기반-구현"><a class="markdownIt-Anchor" href="#1-리스트-기반-구현"></a> 1. 리스트 기반 구현</h3>
<p>코틀린 표준 라이브러리에는 더 높은 수준의 추상화를 구축하는데 사용할 수 있는 고도로 최적화된 자료구조의 핵심 세트가 함께 제공된다. 이들 중 하나가 연속적이고<small>(contiguous)</small> 정렬된 요소들의 리스트를 저장하는 자료구조인 <strong>ArrayList</strong>이다. ArrayList를 이용해서 큐를 구현해보자.</p>
<p align="center">
<img width="500" src="https://user-images.githubusercontent.com/39554623/124503376-67563000-de00-11eb-9be3-0bb2fcff0246.png">
</p>
<p>list 패키지 내부에 ArrayListQueue.kt 파일을 생성하고 아래의 코드를 추가한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayListQueue</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">Queue</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> list = arrayListOf&lt;T&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Queue 인터페이스를 구현하는 제네릭 ArrayListQueue 클래스를 정의했다. 인터페이스 구현은 저장하는 요소에 대해 동일한 제네릭 타입인 <code>T</code>를 사용한다.</p>
<p>다음으로 ArrayListQueue 구현을 완료하여 Queue 인터페이스의 규약을 만족시키자.</p>
<h4 id="arraylist-활용"><a class="markdownIt-Anchor" href="#arraylist-활용"></a> ArrayList 활용</h4>
<p>ArrayListQueue 클래스에 다음 코드를 추가한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayListQueue</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">Queue</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = list.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T? = list.getOrNull(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList의 기능들을 사용하면 다음을 간단히 구현할 수 있다.</p>
<ol>
<li>리스트의 동일한 속성을 사용하여 큐의 크기를 가져온다.</li>
<li>큐의 맨 앞에 요소가 존재한다면 값을 반환한다.</li>
</ol>
<p>이 연산들은 모두 *O(1)*이다.</p>
<h4 id="enqueue"><a class="markdownIt-Anchor" href="#enqueue"></a> Enqueue</h4>
<p>큐의 뒤에 요소를 추가하는 것은 간단하다. ArrayList의 끝에 요소를 추가하기만 하면 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    list.add(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>리스트의 크기에 관계없이 요소를 큐에 추가하는 것은 <em>O(1)</em> 연산이다. 리스트 뒤에 빈 공간이 있기 때문이다.</p>
<p align="center">
<img width="500" src="https://user-images.githubusercontent.com/39554623/124504495-9077c000-de02-11eb-8719-55521aae5db3.png">
</p>
<p>위의 예시에서 Mic를 추가하면 리스트에 두 개의 빈 공간이 있다.</p>
<p>여러 요소를 추가한 후에는 ArrayList 내부 배열이 결국 가득 차게 된다. 할당된 공간보다 더 많이 사용하려면 추가 공간을 만들기 위해 배열의 크기를 조정해야만 한다.</p>
<p align="center">
<img width="500" src="https://user-images.githubusercontent.com/39554623/124504497-92418380-de02-11eb-8ad1-392ae7528963.png">
</p>
<p>크기 조정<small>(resizing)</small>은 <em>O(n)</em> 연산이다. 크기를 조정하려면 리스트에서 새 메모리를 할당하고 기존의 모든 데이터를 새 리스트에 복사해야 한다. 매번 크기를 두 배로 늘리는 덕분에 자주는 발생하지 않으며, 시간 복잡도는 여전히 <a href="https://stackoverflow.com/a/249695" rel="external nofollow noopener noreferrer" target="_blank"><i>Amortized O(1)</i></a>으로 동작한다.</p>
<h4 id="dequeue"><a class="markdownIt-Anchor" href="#dequeue"></a> Dequeue</h4>
<p>전면에서 항목<small>(item)</small>을 제거하려면 약간 더 많은 작업이 필요하다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: T? = </span><br><span class="line">    <span class="keyword">if</span> (isEmpty) <span class="literal">null</span> <span class="keyword">else</span> list.removeAt(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>큐가 비어 있으면 <code>dequeue()</code>는 단순히 null을 반환한다. 그렇지 않다면 리스트의 맨 앞에서 요소를 제거하고 반환한다.</p>
<p align="center">
<img width="500" src="https://user-images.githubusercontent.com/39554623/124504501-94a3dd80-de02-11eb-9b82-9818df31bf7d.png">
</p>
<p>큐의 전면에서 요소를 제거하는 연산은 <em>O(n)</em> 시간 복잡도를 가진다. 대기열에서 요소를 제거하려면 리스트 시작 부분에서 요소를 제거해야 한다. 리스트의 나머지 모든 요소를 메모리에서 이동시켜야하므로 항상 선형 시간<small>(Linear time, O(n))</small>의 연산이다.</p>
<h4 id="테스트"><a class="markdownIt-Anchor" href="#테스트"></a> 테스트</h4>
<p>디버깅을 위해 구현한 큐가 <code>toString()</code>을 재정의하도록 한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = list.toString()</span><br></pre></td></tr></table></figure>
<p>이제 구현한 큐를 직접 사용해보도록 하자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = ArrayListQueue&lt;String&gt;().apply &#123;</span><br><span class="line">        enqueue(<span class="string">&quot;Ray&quot;</span>)</span><br><span class="line">        enqueue(<span class="string">&quot;Brian&quot;</span>)</span><br><span class="line">        enqueue(<span class="string">&quot;Eric&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    println(queue)</span><br><span class="line">    println(<span class="string">&quot;Next up: <span class="subst">$&#123;queue.peek()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Ray, Brian, Eric]</span><br><span class="line">[Brian, Eric]</span><br><span class="line">Next up: Brian</span><br></pre></td></tr></table></figure>
<p>이 코드는 Ray, Brian 및 Eric을 큐에 넣는다<small>(<code>enqueue</code>)</small>. 그런 다음 Ray를 제거하고<small>(<code>dequeue()</code>)</small> Brian을 들여다 보지만 제거하지는 않는다<small>(<code>peek()</code>)</small>.</p>
<h4 id="장점과-단점"><a class="markdownIt-Anchor" href="#장점과-단점"></a> 장점과 단점</h4>
<p>다음은 ArrayList 기반 큐 구현의 알고리즘 및 복잡도에 대해 요약하고 있다. 대부분의 작업은 선형 시간이 걸리는 <code>dequeue()</code>를 제외하고는 상수 시간을 가진다. 공간 복잡도는 <em>O(n)</em> 이다.</p>
<p align="center">
<img width="500" src="https://user-images.githubusercontent.com/39554623/124506381-7344f080-de06-11eb-963b-0c16e0146195.png">
</p>
<p>Kotlin ArrayList를 활용하여 리스트 기반 큐를 간단하게 구현하였다. <em>O(1)</em> 추가 연산 덕분에 큐에 넣는 것이 매우 빠르다.</p>
<p>하지만 이 구현에는 몇 가지 단점들이 있다. 항목을 제거하면 모든 요소가 하나씩 이동하므로 큐에서 항목을 제거하는 것은 비효율적일 수 있다. 이것은 매우 큰 큐에서 차이를 만든다. 리스트가 가득 차면 크기를 조정해야 하며 사용하지 않는 공간이 있을 수 있다. 이것은 시간이 지남에 따라 메모리 사용량을 증가시킬 수 있다. 이러한 단점을 어떻게 해결할 수 있을까? 연결 리스트 기반 구현을 살펴보고 ArrayListQueue와 비교해보도록 하자.</p>
<h3 id="2-이중-연결-리스트smalldoubly-linked-listsmall-기반-구현"><a class="markdownIt-Anchor" href="#2-이중-연결-리스트smalldoubly-linked-listsmall-기반-구현"></a> 2. 이중 연결 리스트<small>(doubly linked list)</small> 기반 구현</h3>
<p>linkedlist 패키지 내부에 LinkedListQueue.kt 파일을 생성한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">Queue</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> list = DoublyLinkedList&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">get</span>() = size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 구현은 <strong>ArrayListQueue</strong>와 유사하지만 <strong>ArrayList</strong> 대신 <strong>DoublyLinkedList</strong>를 생성한다.</p>
<p>DoublyLinkedList가 제공하지 않는 <em>count</em> 속성 아래로 Queue 인터페이스의 구현을 시작한다.</p>
<h4 id="enqueue-2"><a class="markdownIt-Anchor" href="#enqueue-2"></a> Enqueue</h4>
<p>큐의 뒤에 요소를 추가하기 위해 아래의 코드를 작성한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    list.append(element)</span><br><span class="line">    size += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p align="center">
<img width="500" src="https://user-images.githubusercontent.com/39554623/124506865-80161400-de07-11eb-841b-a5acb773c7a8.png">
</p>
<p>이중 연결 리스트는 내부에서 새 노드에 대한 꼬리 노드의 이전<small>(prev)</small> 및 다음<small>(next)</small> 참조를 업데이트하고 크기를 늘린다. 이 과정은 <em>O(1)</em> 연산이다.</p>
<h4 id="dequeue-2"><a class="markdownIt-Anchor" href="#dequeue-2"></a> Dequeue</h4>
<p>큐에서 요소를 제거하기 위해서 아래의 코드를 추가한다.</p>
<blockquote>
<p>간단한 구현</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: T? = list.pop()</span><br></pre></td></tr></table></figure>
<p>원서는 DoublyLinkedList에 대한 코드가 제공되지 않은 상태에서 위의 코드를 예시로 들어놓았는데, 직접 구현한 LinkedList를 기반으로 Queue를 구현한다면 <code>dequeue()</code>를 리스트에서 첫 번째 노드를 제거하는 메서드를 호출하는 것으로 간단히 구현할 수 있다.</p>
<blockquote>
<p>원서의 코드</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">  <span class="keyword">val</span> firstNode = list.first ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  size--</span><br><span class="line">  <span class="keyword">return</span> list.remove(firstNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>원서의 코드는 큐의 첫 번째 요소가 존재하는지 확인하고 존재하지 않는다면 null을 반환한다. 큐에 첫 번째 요소가 존재한다면 맨 앞에 있는 요소를 제거하고 이를 반환한다. 크기도 감소한다.</p>
<p align="center">
<img width="500" src="https://user-images.githubusercontent.com/39554623/124506868-81dfd780-de07-11eb-875b-2bb97909b55f.png">
</p>
<p>리스트 맨 앞을 제거하는 것 또한 <em>O(1)</em> 연산이다. ArrayList 구현과 비교할 때 요소를 하나씩 이동할 필요가 없는 대신, 위의 이미지처럼 연결 리스트의 처음 두 노드 사이의 전<small>(prev)</small> 및 다음<small>(next)</small> 포인터를 업데이트하기만 하면 된다.</p>
<h4 id="peek"><a class="markdownIt-Anchor" href="#peek"></a> Peek</h4>
<p>ArrayList 기반 구현과 유사하게, DoublyLinkedList의 속성을 이용하여 <code>peek()</code>을 간단히 구현할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T? = list.first?.value</span><br></pre></td></tr></table></figure>
<h4 id="테스트-2"><a class="markdownIt-Anchor" href="#테스트-2"></a> 테스트</h4>
<p>디버깅을 위해 아래의 코드를 클래스에 추가하고 테스트 해보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = list.toString()</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = LinkedListQueue&lt;String&gt;().apply &#123;</span><br><span class="line">    enqueue(<span class="string">&quot;Ray&quot;</span>)</span><br><span class="line">    enqueue(<span class="string">&quot;Brian&quot;</span>)</span><br><span class="line">    enqueue(<span class="string">&quot;Eric&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    println(queue)</span><br><span class="line">    println(<span class="string">&quot;Next up: <span class="subst">$&#123;queue.peek()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 테스트 코드는 ArrayListQueue 구현과 동일한 결과를 생성한다.</p>
<h4 id="장점과-단점-2"><a class="markdownIt-Anchor" href="#장점과-단점-2"></a> 장점과 단점</h4>
<p align="center">
<img width="500" src="https://user-images.githubusercontent.com/39554623/124506871-84423180-de07-11eb-8b5b-ae09b51587b4.png">
</p>
<p>ArrayListQueue의 주요 문제점 중 하나는 항목을 대기열에서 빼는데 <i>O(n)</i>이 걸리는 것이다. 연결 리스트 구현을 통해 노드의 이전 및 다음 포인터를 업데이트하는 것만으로 시간 복잡도를 <i>O(1)</i>으로 축소시켰다.</p>
<p>LinkedListQueue의 주요 단점은 위의 표에서 분명하게 나타나지 않는다. <i>O(1)</i> 성능에도 불구하고 높은 오버헤드가 존재하는데, 각 요소는 이전과 다음의 참조를 위한 추가 공간이 있어야 한다<small>(공간 복잡도 증가)</small>. 또한 새 요소를 만들 때마다 상대적으로 비용이 많이 드는 동적 할당이 필요하다. 이에 비해, ArrayListQueue는 더 빠른 대량 할당을 수행한다.</p>
<p>할당에 대한 오버헤드를 제거하고 <i>O(1)</i>의 dequeue를 유지할 수 있을까? 큐가 고정된 크기 이상으로 커지는 것에 대해 걱정할 필요가 없는 경우 <strong>링 버퍼</strong>와 같은 다른 접근 방식을 사용할 수 있다. 예를 들어, 5명의 플레이어가 참여하는 모노폴리 게임에 링 버퍼를 기반으로 한 큐를 사용하여 다음에 올 차례를 추적할 수 있다. 다음으로 링 버퍼 구현을 살펴보자.</p>
<h3 id="3-링-버퍼smallring-buffersmall-기반-구현"><a class="markdownIt-Anchor" href="#3-링-버퍼smallring-buffersmall-기반-구현"></a> 3. 링 버퍼<small>(Ring Buffer)</small> 기반 구현</h3>
<p>원형 버퍼<small>(circular buffer)</small>라고도 불리는 링 버퍼<small>(ring buffer)</small>는 고정 크기 배열이다. 이 자료구조는 마지막에 제거할 항목이 없을 때 시작 부분으로 래핑된다.</p>
<p>링 버퍼를 사용하여 큐를 구현하는 방법에 대한 간단한 예를 아래의 이미지들로 살펴보자.</p>
<blockquote>
<p>링 버퍼 생성</p>
</blockquote>
<p align="center">
<img width="400" src="https://user-images.githubusercontent.com/39554623/124657417-72cb5900-dedd-11eb-83e7-d1347a5734db.png">
</p>
<p>먼저 고정 크기가 4인 링 버퍼를 만든다. 링 버퍼에는 두 개의 포인터가 존재한다.</p>
<ol>
<li>읽기<small>(read)</small> 포인터 : 큐의 앞쪽을 추적</li>
<li>쓰기<small>(write)</small> 포인터 : 사용 가능한 다음 칸을 추적하여 이미 읽어 들인 기존 요소를 재정의할 수 있다.</li>
</ol>
<blockquote>
<p>대기열에 항목 추가</p>
</blockquote>
<p align="center">
<img width="400" src="https://user-images.githubusercontent.com/39554623/124657442-7828a380-dedd-11eb-9b9e-81cb4ceefc91.png">
</p>
<p>대기열에 항목을 추가할 때마다 쓰기 포인터가 1씩 증가한다.</p>
<blockquote>
<p>항목 2개를 더 추가</p>
</blockquote>
<p align="center">
<img width="400" src="https://user-images.githubusercontent.com/39554623/124657453-7bbc2a80-dedd-11eb-9434-92854fd7844a.png">
</p>
<p>쓰기 포인터가 두 자리 더 이동하여 읽기 포인터보다 3칸 앞서 있는 것을 확인 할 수 있다. 이는 대기열이 비어 있지 않다는 것을 의미한다.</p>
<blockquote>
<p>대기열에서 두 개의 항목을 빼기</p>
</blockquote>
<p align="center">
<img width="400" src="https://user-images.githubusercontent.com/39554623/124657465-7fe84800-dedd-11eb-80da-d4634f1a86d8.png">
</p>
<p>대기열에서 항목을 빼는 것을 링 버퍼를 읽는 것과 동일하다. 읽기 포인터가 어떻게 두 번 이동했는지 주목하자.</p>
<blockquote>
<p>대기열을 채우기 위해 항목을 하나 더 추가</p>
</blockquote>
<p align="center">
<img width="400" src="https://user-images.githubusercontent.com/39554623/124657480-824aa200-dedd-11eb-9928-35956b11d604.png">
</p>
<p>쓰기 포인터가 끝에 도달했으므로 시작 인덱스로 다시 랩핑된다.</p>
<blockquote>
<p>마지막으로 남은 두 개의 항목을 대기열에서 빼기</p>
</blockquote>
<p align="center">
<img width="400" src="https://user-images.githubusercontent.com/39554623/124657496-8676bf80-dedd-11eb-8b69-b5961c7d5dc8.png">
</p>
<p>남은 두 항목도 대기열에서 빼면서 읽기 포인터도 시작 부분으로 돌아온다.</p>
<p>위 이미지를 통해 읽기와 쓰기 포인터가 동일한 인덱스에 있을 경우 대기열, 즉 큐가 비어 있다는 것을 알 수 있다.</p>
<p>링 버퍼를 통한 큐의 구현은 개념만 확인하고 구현은 생략하였다.</p>
<h4 id="장점과-단점-3"><a class="markdownIt-Anchor" href="#장점과-단점-3"></a> 장점과 단점</h4>
<p align="center">
<img width="500" src="https://user-images.githubusercontent.com/39554623/124657508-8aa2dd00-dedd-11eb-86f7-208f48e10b6b.png">
</p>
<p>링 버퍼 기반 큐는 연결 리스트 기반 구현과 <code>enqueue</code>와 <code>dequeue</code>의 시간 복잡도가 동일하다. 유일한 차이점은 공간 복잡도인데, 링 버퍼의 크기는 고정되어 있으므로 큐에 넣는 것 자체가 실패할 수 있는 단점이 존재한다.</p>
<p>지금까지 배열, 연결 리스트, 링 버퍼 기반까지 총 세 가지의 구현 방법을 보았는데 마지막으로 두 개의 스택을 사용하여 구현된 큐를 알아 볼 것이다.</p>
<p>이중 스택 기반 구현 큐는 메모리 상의 공간적 지역성이 연결 리스트보다 훨씬 우수하고, 링 버퍼와 같이 고정된 크기가 필요하지 않다는 장점이 있다.</p>
<h3 id="4-이중-스택smalldouble-stacksmall-기반-구현"><a class="markdownIt-Anchor" href="#4-이중-스택smalldouble-stacksmall-기반-구현"></a> 4. 이중 스택<small>(Double-Stack)</small> 기반 구현</h3>
<p>doublestack 패키지 내부에 StackQueue.kt를 추가한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackQueue</span>&lt;<span class="type">T : Any</span>&gt; : <span class="type">Queue</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> leftStack = StackImpl&lt;T&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> rightStack = StackImpl&lt;T&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>두 개의 스택을 사용하는 아이디어는 요소를 큐에 넣을 때마다 <strong>오른쪽</strong> 스택으로 이동하고, 요소를 큐에서 뺄 때는 FIFO 순서를 사용하여 요소를 검색할 수 있도록 오른쪽 스택을 반대로 뒤집어서 <strong>왼쪽</strong> 스택에 넣는다.</p>
<p align="center">
<img width="600" src="https://user-images.githubusercontent.com/39554623/125627123-d8f7ca3e-d598-4fda-b7e8-bf87d948cef6.png">
</p>
<h4 id="스택-활용하기"><a class="markdownIt-Anchor" href="#스택-활용하기"></a> 스택 활용하기</h4>
<p>그러면 아래의 코드를 추가하여 큐의 공통 기능들을 구현해본다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = leftStack.count + rightStack.count </span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> isEmpty: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = leftStack.isEmpty &amp;&amp; rightStack.isEmpty</span><br></pre></td></tr></table></figure>
<p>큐가 비어 있는지 확인하려면 왼쪽과 오른쪽의 스택이 모두 비어 있는지 확인하면 된다. 큐에 있는 요소의 개수는 두 스택에 있는 요소 개수의 합이다.</p>
<p>이중 스택으로 구현한 큐는 위에서 설명했듯이 오른쪽 스택에서 왼쪽 스택으로 요소를 전달해야 할 때가 있다. 이는 왼쪽 스택이 비어 있을 때마다 발생한다.</p>
<p>다음의 헬퍼 메서드를 추가하자.</p>
<blockquote>
<p>오른쪽 스택에서 왼쪽 스택으로 요소 이동</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">transferElements</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nextElement = rightStack.pop()</span><br><span class="line">    <span class="keyword">while</span> (nextElement != <span class="literal">null</span>) &#123;</span><br><span class="line">        leftStack.push(nextElement)</span><br><span class="line">        nextElement = rightStack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드를 통해 오른쪽 스택으로부터 요소를 꺼내어 왼쪽 스택에 넣을 수 있다. 스택은 LIFO 방식으로 작동하기 때문에 추가적인 작업 없이 역순으로 요소들을 가져올 수 있다.</p>
<blockquote>
<p><code>peek()</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">peek</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftStack.isEmpty) &#123;</span><br><span class="line">        transferElements()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftStack.peek()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>peek()</code>은 최상위 요소를 보는 메서드이다. 만약 왼쪽 스택이 비어 있지 않다면 이 스택의 맨 위에 있는 요소가 큐의 맨 앞에 있다.</p>
<p>왼쪽 스택이 비어 있으면 <code>transferElements()</code>를 사용한다. 그렇게 하면 <code>leftStack.peek()</code>은 항상 올바른 요소 또는 <em>null</em>을 반환한다. <code>isEmpty()</code>는 여전히 <i>O(1)</i> 작업인 반면 <code>peek()</code>은 <i>O(n)</i>이다.</p>
<p>이러한 <code>peek()</code>의 구현이 비싼 비용을 요구하는 것처럼 보이지만, 큐의 각 요소는 오른쪽 스택에서 왼쪽 스택으로 한 번만 이동하면 되기 때문에 amortized <i>O(1)</i>이다. 왼쪽 스택이 비어 있을 때 <code>peek()</code> 호출은 오른쪽 요소들을 모두 왼쪽 스택으로 이동시키므로 <i>O(n)</i>이지만, 그 외 추가적인 호출에 대해선 <i>O(1)</i>이 된다.</p>
<h4 id="enqueue-3"><a class="markdownIt-Anchor" href="#enqueue-3"></a> Enqueue</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    rightStack.push(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>요소를 큐에 추가할 때는 오른쪽 스택이 사용된다. 스택에 요소를 넣는 <code>push()</code>는 <i>O(1)</i>이다.</p>
<p align="center">
<img width="500" src="https://user-images.githubusercontent.com/39554623/125709812-534b1733-5132-4770-9b10-23b3b17392b7.png">
</p>
<h4 id="dequeue-3"><a class="markdownIt-Anchor" href="#dequeue-3"></a> Dequeue</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftStack.isEmpty) &#123;</span><br><span class="line">        transferElements()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftStack.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>동작 원리는 다음과 같다.</p>
<ol>
<li>왼쪽 스택이 비어 있는지 확인한다.</li>
<li>왼쪽 스택이 비어 있으면 오른쪽 스택의 요소를 역순으로 이동시킨다.</li>
<li>왼쪽 스택에서 맨 위의 요소를 제거한다.</li>
</ol>
<p align="center">
<img width="500" src="https://user-images.githubusercontent.com/39554623/125709818-4e175602-0dbc-45ef-b299-999bc03ec2d2.png">
</p>
<p>왼쪽 스택이 비어 있을 때에만 오른쪽 스택의 요소를 이동시키므로 <code>dequeue()</code>는 <code>peek()</code>처럼 amortized <i>O(1)</i> 연산이다.</p>
<h4 id="테스트-3"><a class="markdownIt-Anchor" href="#테스트-3"></a> 테스트</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Left stack: \n<span class="variable">$leftStack</span> \nRight stack: \n<span class="variable">$rightStack</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> queue = StackQueue&lt;String&gt;().apply &#123;</span><br><span class="line">        enqueue(<span class="string">&quot;Ray&quot;</span>)</span><br><span class="line">        enqueue(<span class="string">&quot;Brian&quot;</span>)</span><br><span class="line">        enqueue(<span class="string">&quot;Eric&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    println(queue)</span><br><span class="line">    println(<span class="string">&quot;Next up: <span class="subst">$&#123;queue.peek()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Left stack: </span><br><span class="line">----top----</span><br><span class="line">-----------</span><br><span class="line"> </span><br><span class="line">Right stack: </span><br><span class="line">----top----</span><br><span class="line">Eric</span><br><span class="line">Brian</span><br><span class="line">Ray</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">Left stack: </span><br><span class="line">----top----</span><br><span class="line">Brian</span><br><span class="line">Eric</span><br><span class="line">-----------</span><br><span class="line"> </span><br><span class="line">Right stack: </span><br><span class="line">----top----</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">Next up: Brian</span><br></pre></td></tr></table></figure>
<h4 id="장점과-단점-4"><a class="markdownIt-Anchor" href="#장점과-단점-4"></a> 장점과 단점</h4>
<p align="center">
<img width="600" src="https://user-images.githubusercontent.com/39554623/125711056-d0be53af-a4b3-4029-bacb-3a914e9d8115.png">
</p>
<p>리스트 기반 구현과 비교했을 때, 두 개의 스택을 활용하면 <code>dequeue()</code>의 구현을 amortized <i>O(1)</i> 연산으로 변환할 수 있다. 또한 이중 스택 기반 구현은 완전히 동적이고 링 버퍼 기반 구현처럼 고정된 크기로 제한되지도 않는다. 마지막으로 공간적 지역성<small>(spatial locality, 메모리 상 인접 데이터의 재이용률이 높음)</small> 측면에서 연결 리스트 기반 구현을 능가하는데, 이는 리스트이 요소가 메모리 블록에서 서로 옆에 있기 때문이다. 따라서 많은 수의 요소가 한 번의 접근<small>(access)</small>으로 캐시에 로드된다.</p>
<blockquote>
<p>연속된 배열에 있는 요소들</p>
</blockquote>
<p align="center">
<img width="500" src="https://user-images.githubusercontent.com/39554623/125709832-3a3d4f43-4b43-4c06-8319-85f9d593084e.png">
</p>
<blockquote>
<p>메모리 전체에 흩어져 있는 연결 리스트의 요소들</p>
</blockquote>
<p align="center">
<img width="500" src="https://user-images.githubusercontent.com/39554623/125709837-9a7d64d5-f7cf-45ef-825e-33b7f79b5e18.png">
</p>
<p>연결 리스트에서 요소는 메모리 블록에 연속적으로 존재하지 않는다. 이로 인해 더 많은 캐시 미스가 발생하여 접근 시간이 늘어난다.</p>
<br>
<div style="text-align: right"> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/june0122/DataStructureKotlin/tree/master/src/queue"><b><i>Github에서 본문의 코드 확인하기 </i></b></a></div>
<br>
<div style="text-align: right"> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.raywenderlich.com/books/data-structures-algorithms-in-kotlin/v1.0"><b><i>Data Structures & Algorithms in Kotlin</i></b></a> 서적을 참고하여 작성했습니다. </div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Kotlin/">Kotlin</a><a class="link-muted mr-2" rel="tag" href="/tags/Data-Structure/">Data Structure</a><a class="link-muted mr-2" rel="tag" href="/tags/Queue/">Queue</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=6095b3ecf472720011a9aa6c&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/07/19/data-structure-trees/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">[코틀린 자료구조] 트리 (Tree)</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/07/16/programmers-12951/"><span class="level-item">[프로그래머스] 레벨 2 : JadenCase 문자열 만들기</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">댓글</h3><script src="https://utteranc.es/client.js" repo="june0122/blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://user-images.githubusercontent.com/39554623/117553944-71251680-b08f-11eb-99bc-0f317fb22422.gif" alt="KAMIYU"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">KAMIYU</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">68</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">60</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/june0122" target="_blank" rel="external nofollow noopener noreferrer">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/june0122"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Naver" href="https://blog.naver.com/june0122"><i class="fas fa-feather-alt"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">32</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/BOJ/"><span class="level-start"><span class="level-item">BOJ</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Codility/"><span class="level-start"><span class="level-item">Codility</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/Algorithm/Programmers/"><span class="level-start"><span class="level-item">Programmers</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Android/Compose/"><span class="level-start"><span class="level-item">Compose</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Android/Documentation/"><span class="level-start"><span class="level-item">Documentation</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Android/Guide/"><span class="level-start"><span class="level-item">Guide</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/Android/Memo/"><span class="level-start"><span class="level-item">Memo</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Data-Structure/"><span class="level-start"><span class="level-item">Data Structure</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/"><span class="level-start"><span class="level-item">Design Pattern</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Kotlin/Coroutine/"><span class="level-start"><span class="level-item">Coroutine</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Terminology/"><span class="level-start"><span class="level-item">Terminology</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><figure class="media-left"><a class="image" href="/2021/08/27/design-pattern-factory-method/"><img src="/thumbnail/design_pattern.png" alt="[디자인 패턴] 팩토리 메서드 패턴(Factory Method Pattern)"></a></figure><div class="media-content"><p class="date"><time datetime="2021-08-27T12:54:38.150Z">2021-08-27</time></p><p class="title"><a href="/2021/08/27/design-pattern-factory-method/">[디자인 패턴] 팩토리 메서드 패턴(Factory Method Pattern)</a></p><p class="categories"><a href="/categories/Design-Pattern/">Design Pattern</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/08/26/android-compose-architectural-layering/"><img src="/thumbnail/android.png" alt="[Android] Jetpack Compose 기초 - 아키텍처 레이어링"></a></figure><div class="media-content"><p class="date"><time datetime="2021-08-26T12:39:53.886Z">2021-08-26</time></p><p class="title"><a href="/2021/08/26/android-compose-architectural-layering/">[Android] Jetpack Compose 기초 - 아키텍처 레이어링</a></p><p class="categories"><a href="/categories/Android/">Android</a> / <a href="/categories/Android/Compose/">Compose</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/08/23/android-compose-lifecycle/"><img src="/thumbnail/android.png" alt="[Android] Jetpack Compose 기초 - 수명 주기"></a></figure><div class="media-content"><p class="date"><time datetime="2021-08-23T12:40:47.221Z">2021-08-23</time></p><p class="title"><a href="/2021/08/23/android-compose-lifecycle/">[Android] Jetpack Compose 기초 - 수명 주기</a></p><p class="categories"><a href="/categories/Android/">Android</a> / <a href="/categories/Android/Compose/">Compose</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/08/23/android-compose-managing-state/"><img src="/thumbnail/android.png" alt="[Android] Jetpack Compose 기초 - 상태 관리"></a></figure><div class="media-content"><p class="date"><time datetime="2021-08-23T12:37:19.636Z">2021-08-23</time></p><p class="title"><a href="/2021/08/23/android-compose-managing-state/">[Android] Jetpack Compose 기초 - 상태 관리</a></p><p class="categories"><a href="/categories/Android/">Android</a> / <a href="/categories/Android/Compose/">Compose</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/08/22/design-pattern-singleton/"><img src="/thumbnail/design_pattern.png" alt="[디자인 패턴] 싱글턴 패턴(Singleton Pattern)"></a></figure><div class="media-content"><p class="date"><time datetime="2021-08-22T11:18:12.832Z">2021-08-22</time></p><p class="title"><a href="/2021/08/22/design-pattern-singleton/">[디자인 패턴] 싱글턴 패턴(Singleton Pattern)</a></p><p class="categories"><a href="/categories/Design-Pattern/">Design Pattern</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">8월 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">7월 2021</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">6월 2021</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">5월 2021</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Action-Bar/"><span class="tag">Action Bar</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Algorithm/"><span class="tag">Algorithm</span><span class="tag">32</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">23</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App-Bar/"><span class="tag">App Bar</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AppCompat/"><span class="tag">AppCompat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BFS/"><span class="tag">BFS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BOJ/"><span class="tag">BOJ</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Binary-Search/"><span class="tag">Binary Search</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bitmap/"><span class="tag">Bitmap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Codility/"><span class="tag">Codility</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Compose/"><span class="tag">Compose</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Content-Provider/"><span class="tag">Content Provider</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Coroutine/"><span class="tag">Coroutine</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CustomView/"><span class="tag">CustomView</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DFS/"><span class="tag">DFS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DP/"><span class="tag">DP</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Data-Binding/"><span class="tag">Data Binding</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Data-Structure/"><span class="tag">Data Structure</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Database/"><span class="tag">Database</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Design-Pattern/"><span class="tag">Design Pattern</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dialog/"><span class="tag">Dialog</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DiffUtil/"><span class="tag">DiffUtil</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Espresso/"><span class="tag">Espresso</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Executors/"><span class="tag">Executors</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/File-Provider/"><span class="tag">File Provider</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Fragment/"><span class="tag">Fragment</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Google-I-O-2021/"><span class="tag">Google I/O 2021</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Idempotent/"><span class="tag">Idempotent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Intent/"><span class="tag">Intent</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Jetpack/"><span class="tag">Jetpack</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kotlin/"><span class="tag">Kotlin</span><span class="tag">64</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LeetCode/"><span class="tag">LeetCode</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linked-List/"><span class="tag">Linked List</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MVVM/"><span class="tag">MVVM</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Menu/"><span class="tag">Menu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mockito/"><span class="tag">Mockito</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Programmers/"><span class="tag">Programmers</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Queue/"><span class="tag">Queue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RESTful/"><span class="tag">RESTful</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RecyclerView/"><span class="tag">RecyclerView</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Room/"><span class="tag">Room</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Simulation/"><span class="tag">Simulation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SoundPool/"><span class="tag">SoundPool</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Stack/"><span class="tag">Stack</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Terminology/"><span class="tag">Terminology</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Toolbar/"><span class="tag">Toolbar</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TouchEvent/"><span class="tag">TouchEvent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tree/"><span class="tag">Tree</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Unit-Test/"><span class="tag">Unit Test</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/View-Binding/"><span class="tag">View Binding</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/findViewById/"><span class="tag">findViewById</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"><span class="tag">그래프</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%B0%94%ED%82%B9%EB%8F%85/"><span class="tag">바킹독</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/"><span class="tag">백트래킹</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89/"><span class="tag">완전 탐색</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"><span class="tag">완전탐색</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/"><span class="tag">이분탐색</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%A0%95%EB%A0%AC/"><span class="tag">정렬</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%ED%95%B4%EC%8B%9C/"><span class="tag">해시</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="카미유 테크 블로그" height="28"></a><p class="is-size-7"><span>&copy; 2021 KAMIYU</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a><br><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv">0</span>명의 사용자가 방문 함</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Download on GitHub" href="https://github.com/june0122"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>