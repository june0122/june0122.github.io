{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"[Android] View, Inflate, Listener","text":"안드로이드 지원 라이브러리에서 제트팩으로 기존의 안드로이드 지원(support) 라이브러리들은 그 수가 많고 독립적인 개발 및 버전 관리 때문에 어려움이 많았다. 따라서 안드로이드 10부터는 모든 지원 라이브러리를 androidx라는 네임스페이스 namespace 를 갖는, 몇 개의 더 큰 라이브러리로 통합하게 되었다. 그렇고 이렇게 통합된 라이브러리를 Jetpack이라고 한다. 뷰 계층 구조(view hierarchy) 뷰(View) 뷰는 UI를 만드는데 사용되는 구성 요소 장치 화면에 보이는 모든 것이 뷰 사용자가 화면을 보며 상호 작용하는 뷰 -&gt; 위젯 widget 위젯(Widget) 안드로이드 SDK에는 많은 위젯이 포함되어 원하는 UI(화면에 보이는 모습과 앱과의 상호작용)을 구성 가능 모든 위젯은 View 클래스의 인스턴스이거나 View의 서브 클래스 TextView나 Button 중 하나의 인스턴스 뷰그룹(ViewGrop) View의 일종 다른 뷰를 포함하고 배치해 화면에 보여주지만 그 자신은 화면에 나타나지 않음 레이아웃도 뷰그룹, 뷰그룹의 서브 클래스에는 ConstraintLayout이나 FrameLayout 등이 있음 ConstraintLayout이 뷰그룹이며, 유일한 자식이 TextView 위젯인 레이아웃 activity_main.xmlxml123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 레이아웃 XML에서 뷰 객체로 xml 파일 내에 정의된 XML 요소들이 어떻게 View 객체가 될까? GeoQuiz 프로젝트를 생성하면 MainActivity라는 이름의 Activity 서브 클래스가 자동으로 생성된다. MainActivity 클래스 파일은 app/java 디렉터리의 com.june0122.geoquiz 패키지 아래에 있다. 안드로이드는 원래 자바 코드만 지원했기 때문에 현재 소스 코드 파일이 있는 디렉터리의 이름은 java다. 코틀린 소스 파일도 java 디렉터리에 저장된다. 물론 koltin이라는 이름의 새 디렉터리를 생성해 이 디렉터리에 코틀린 소스 파일들을 따로 저장할 수 있지만 해당 소스 파일들이 프로젝트에 포함되도록 kotlin 디렉터리에 있다는 것을 안드로이드 스튜디오에 알려줘야 한다. 하지만 사용 언어마다 소스 파일을 별개의 디렉터리에 두는 것은 그리 유용하지 않으므로 코틀린 소스 파일도 java 디렉터리에 두는 것이 좋다. (괜히 상호 호환성이 큰 장점이 아니다!) AppCompatActivity 란? 12345678910class MainActivity : AppCompatActivity() { private lateinit var trueButton: Button private lateinit var falseButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) }} AppCompatActivity는 안드로이드 Activity 클래스의 서브 클래스 과거 안드로이드 버전과의 호환성을 지원하기 위해 제공 'AppCompat’은 'application compatibility’의 단축어 Jetpack의 AppCompat 라이브러리는 안드로이드 버전이 달라도 일관된 UI를 유지하는 데 핵심이 되는 클래스와 리소스들을 포함한다. AppCompat의 각 하위 패키지들 12345androidx.appcompat.appandroidx.appcompat.content.resandroidx.appcompat.graphics.drawableandroidx.appcompat.viewandroidx.appcompat.widget app/build.gradle 파일에 추가되어있는 AppCompat 라이브러리 의존성 12345dependencies { ... implementation 'androidx.appcompat:appcompat:1.2.0' ...} Activity 함수 onCreate(Bundle?) 액티비티 서브 클래스의 인스턴스가 생성될 때 자동으로 호출됨 이때 이 함수에서는 액티비티가 UI를 화면에 보여주고 처리할 수 있도록 다음 함수를 호출함 Activity.setContentView(layoutResID: Int) 이 함수는 레이아웃을 인플레이트 inflate 해 화면에 나타낸다. 인플레이트 : 뷰 계층 구조를 따라 객체로 생성하는 것 레이아웃이 인플레이트되면 레이아웃 파일에 있는 각 위젯이 자신의 속성에 정의된 대로 인스턴스로 생성됨 이 함수를 호출할 때는 인플레이트될 레이아웃의 리소스 ID(resource ID)를 인자로 전달 리소스와 리소스 ID 레이아웃은 리소스(resource) 이다. 리소스는 애플리케이션의 일부이며, 코드가 아닌 이미지 파일이나 오디오 파일 및 XML 파일 같은 것들이다. 프로젝트의 리소스들은 app/res 디렉터리 아래의 서브 디렉터리에 존재한다. 코드에서는 리소스의 리소스 ID를 지정해야 사용 가능하며 모든 리소스 ID는 앱을 빌드할 때마다 안드로이드 빌드 도구가 R.class에 자동으로 생성한다(안드로이드 스튜디오 3.6 이전 버전에서는 소스 코드 파일인 R.java를 임시로 생성했지만, 3.7 이상 버전에서는 이 파일을 생성하지 않고 R.class만 생성). 레이아웃은 하나의 리소스 ID가 생성되고, 문자열은 각각에 대해 하나의 리소스 ID가 생성된다.하지만 레이아웃에 포함된 각 위젯에서는 코드에서 참조해 사용할 필요가 있는 것에만 리소스 ID가 필요하므로 직접 지정한 것만 생성된다. (GeoQuiz 레이아웃의 리소스 ID인 R.layout.activity_main에서 activity_main은 R 클래스의 내부 클래스인 layout 안에 정수형 상수로 정의되어 있다. 문자열도 리소스 ID를 가지며, R 클래스의 내부 클래스인 string 안에 정수형 상수로 정의되어 있다. 따라서 strings.xml 파일에 기본으로 정의도니 앱 이름의 문자열은 R.string.app_name으로 참조할 수 있다.) 123456&lt;Button android:id=&quot;@+id/true_button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginRight=&quot;10dp&quot; android:text=&quot;@string/true_button&quot; /&gt; XML 파일에서 버튼의 android:id 속성값에는 +가 있지만, android:text 속성값에는 없다는 것에 주목 android:id 속성은 ID를 생성하고, android:text 속성은 문자열을 참조만 하기 때문이다. 위젯을 코드와 연결하기 코트 연결의 두 단계 인플레이트된 View 객체들의 참조를 얻는다. 이 객체들에 리스너를 설정해 사용자 액션에 응답한다. 위젯의 참조 얻기 버튼들이 리소스 ID를 가지면 MainActivity에서 사용할 수 있다. 12345678910111213class MainActivity : AppCompatActivity() { private lateinit var trueButton: Button private lateinit var falseButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) trueButton = findViewById(R.id.true_button) falseButton = findViewById(R.id.false_button) }} 위의 코드에 있듯이, 액티비티에서는 Activity.findViewById(Int)를 호출해 View 객체로 인플레이트된 위젯의 참조를 얻는다. 이 함수는 위젯의 리소스 ID를 인자로 받아서 해당 위젯(여기서는 Button)의 객체를 반환한다(이때 View 타입을 Button 타입으로 반환해준다). 리스너 설정하기 안드로이드 애플리케이션은 이벤트 기반(event-driven) 으로 구동된다. 이벤트에 응답하기 위해 생성하는 객체를 리스너 listener 라고 하며, 리스너는 해당 이벤트의 리스너 인터페이스 listener interface 를 구현한다. 안드로이드 SDK에는 다양한 이벤트의 리스너 인터페이스가 존재하여 따로 만들 필요가 없다. 버튼이 눌러졌는지에 대한 이벤트를 리스닝하기 위해서, 아래 예제 코드의 리스너는 View.OnClickListener 인터페이스를 구현한다. 12345678910override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) trueButton = findViewById(R.id.true_button) falseButton = findViewById(R.id.false_button) trueButton.setOnClickListener { view: View -&gt; // 버튼 클릭의 응답을 여기서 처리 } trueButton의 리스너는 OnClickListener 인터페이스를 구현하는 익명 클래스의 인스턴스이며 중괄호 {} 안에 정의한다. 그리고 setOnClickListener 함수로 등록한다. 안드로이드 프레임워크에는 onClick(View) 메서드만 갖는 인터페이스인 View.OnClickListener가 정의되어 있다. 이처럼 단일 추상 메서드 Single Abstract Method, SAM 를 갖는 자바 인터페이스를 SAM이라고 하며, 주로 익명의 내부 클래스를 사용해서 구현한다. 코틀린에서는 자바와 호환성을 유지하기 위해 특별한 형태로 SAM을 지원한다. 즉, 함수 리터럴 또는 람다식으로 SAM을 작성하면 이것을 해당 인터페이스의 구현 객체로 변환한다(코틀린에선 함수 리터럴이나 람다식으로 익명 함수 정의 가능). 이와 같은 내부 처리를 SAM 변환 SAM conversion 이라고 한다. 위의 예제는 람다식을 이용하여 OnClickListener 인터페이스를 구현한 것이다. View.OnClickListener 인터페이스 문서 12345678910111213package android.view;/** * Interface definition for a callback to be invoked when a view is clicked. */public interface OnClickListener { /** * Called when a view has been clicked. * * @param v The view that was clicked. */ void onClick(View v);} 12345trueButton.setOnClickListener(object : View.OnClickListener { override fun onClick(v: View?) { TODO(&quot;Not yet implemented&quot;) }}) trueButton이라는 뷰 객체에 setOnClickListener라는 메소드가 있는데, 이 메소드는 View.OnClickListener 인터페이스 객체를 받는 메소드이다. 인터페이스를 객체로 넘길 때, 구현체 부분이 있어야 하므로 익명 객체의 구현체를 만들어서 같이 넘기게 된다. 안드로이드 앱 빌드 절차 빌드를 하는 동안 안드로이드 도구가 리소스와 코드 그리고 AndroidManifest.xml 파일(애플리케이션에 관한 메타데이터를 포함)을 가지고 하나의 .apk 파일로 만든다. 그리고 이 파일은 실제 장치나 에뮬레이터에서 실행될 수 있게 디버그 키가 부여된다(.apk를 구글 플레이 스토어에서 배포하려면 구글에서 릴리즈 키를 받아 앱에 포함시켜야 한다). 안드로이드 스튜디오에서는 프로젝트의 빌드와 관리에 필요한 모든 것을 그래들(Gradle) 자동화 빌드 도구를 사용해 처리하므로 신경 쓰지 않아도 된다. 그런데 레이아웃 파일인 activity_main의 내용은 어떻게 애플리케이션의 View 객체로 변환될까? 빌드 절차의 일부로 aapt2 Android Asset Packaging Tool 2가 레이아웃 파일의 리소스들을 좀 더 압축된 형태로 컴파일한다. 그리고 이렇게 컴파일된 리소스들이 .apk 파일로 통합된다. 그 다음에 MainActivity의 onCreate(Bundle?) 메서드에서 setContentView(…) 메서드가 호출되면, MainActivity는 LayoutInflater 클래스를 사용해서 레이아웃 파일에 정의된 각 View의 인스턴스를 생성한다. activity_main.xml을 인플레이트(XML 요소를 뷰 객체로 생성)하기 뷰 클래스를 XML로 정의하는 대신에 액티비티에서 코틀린이나 자바 코드로 생성할 수도 있다. 하지만 이것은 그리 좋은 방법이 아니다. 뷰 클래스를 XML로 정의하면 프레젠테이션(사용자 인터페이스) 계층을 애플리케이션 로직과 분리할 수 있기 때문이다. MVC 패턴","link":"/2021/05/08/android-bnr-01/"},{"title":"[Android] Model-View-Controller","text":"데이터 클래스(data class) 1data class Question(@StringRes val texResId: Int, val answer: Boolean) @StringRes 애노테이션은 없어도 되지만, 다음 두 가지 이유로 지정하는 것이 좋다. 생성자에서 유효한 문자열 리소스 ID를 제공하는지를 컴파일 시점에서 Lint(안드로이드 스튜디오에 내장된 코드 검사기)가 검사한다. 따라서 유효하지 않은 리소스 ID가 생성자에 사용되어 런타임 시에 앱이 중단되는 것을 방지해준다. 애노테이션을 지정함으로써 다른 개발자가 쉽게 코드를 알 수 있다. texResId의 타입이 String이 아니고 Int인 이유는 texResId 변수는 질문 문자열 리소스의 리소스 ID(항상 Int 타입)를 갖기 때문이다. Question과 같은 클래스처럼 주로 데이터를 갖는 클래스가 많이 있으며, 그중에는 업무에 관련된 것도 있고 프로그램에서 필요해서 생성한 것도 있다. 이런 클래스들은 비즈니스 로직을 처리하는 함수보다는 주로 데이터를 저장하는 속성을 갖는다. 따라서 클래스 인스턴스끼리 각 속성의 값을 비교하거나(equals() 함수) 인스턴스를 컬렉션(HashMap 등)에 저장할 때 사용할 키 값(해시 코드)을 생성하는(hashCode() 함수) 기능이나 속성값을 문자열로 쉽게 출력하는(toString 함수) 기능이 공통으로 필요하다. 이런 이유로 코틀린에서는 데이터 클래스(data class)라는 개념을 추가하였다. 즉, 클래스를 정의할 때 data 키워드를 지정하면 이 클래스를 데이터 클래스로 간주하며, 방금 설명했던 기능들을 처리해주는 함수들을 해당 클레스에 맞게 코틀린 컴파일러가 자동으로 생성해준다. GeoQuiz의 객체 다이어그램 모델-뷰-컨트롤러와 안드로이드 위 그림의 객체들은 세 부분, 즉 모델(Model), 컨트롤러(Controller), 뷰(View)로 분리됨에 주목하자. 안드로이드 API는 모델-뷰-컨트롤러(MVC)라는 아키텍처에 맞추어 설계되었다. 애플리케이션의 어떤 객체든 모델 객체 또는 뷰 객체 또는 컨트롤러 객체가 되어야 한다는 것이 MVC의 주요 관점이다. 모델 객체 (Model Object) 모델 객체는 애플리케이션의 '데이터’와 '비즈니스 로직’을 갖는다. 모델 클래스는 앱과 관계가 있는 것들을 모델링한다. ex) 사용자, 상품, 서버에 저장된 사진 등 모델 객체는 UI를 모른다. 데이터를 보존하고 관리하는 것이 유일한 목적이다. 애플리케이션의 모든 모델 객체들은 모델 계층(model layer) 을 구성한다. GeoQuiz의 모델 계층은 Question 클래스로 구성된다. 뷰 객체 (View Object) 뷰 객체는 자신을 화면에 그리는 방법과 터치와 같은 사용자의 입력에 응답하는 방법이다. 쉽게 말해, 화면에서 볼 수 있는 것이라면 그것은 뷰 객체다. 안드로이드는 구성 가능한 뷰 클래스를 풍부하게 제공하지만, 직접 커스텀 클래스를 생성할 수도 있다. 애플리케이션의 뷰 객체들은 뷰 계층(view layer) 을 구성한다. GeoQuiz의 뷰 계층은 res/layout/activity_main.xml 요소들로부터 인플레이트되는 위젯들로 구성된다. 컨트롤러 객체 (Controller Object) 컨트롤러 객체는 뷰와 모델 객체를 결속하여 '애플리케이션 로직’을 포함한다. 컨트롤러 객체는 뷰 객체에 의해 촉발되는 다양한 이벤트에 응답하고 모델 객체 및 뷰 계층과 주고받는 데이터의 흐름을 관리한다. 안드로이드에서 컨트롤러는 일반적으로 Activity나 Fragment의 서브 클래스이다. GeoQuiz의 컨트롤러 계층은 MainActivity만으로 구성되어 있다. 사용자 입력의 MVC 처리 흐름 MVC 사용하기 애플리케이션 기능이 많아지면 너무 복잡해져 이해하기 어려울 수 있다. 따라서 코드를 클래스로 분리하면 설계에 도움이 되고 전체를 이해하기도 쉬워진다. 개별적인 변수와 함수 대신 클래스 관점으로 생각할 수 있기 때문이다. 이와 유사하게 클래스들을 모델과 뷰 그리고 컨트롤러 계층으로 분리하면 애플리케이션을 설계하고 이해하는 데 도움이 된다. 개별적인 클래스 대신 계층의 관점으로 생각할 수 있기 때문이다. MVC는 클래스를 재사용하기 쉽도록 해준다. 여러 일을 혼자서 처리하는 클래스보다는 제한된 책임을 갖는 클래스를 재사용하는 것이 더 쉽기 때문이다. MVC는 큰 앱은 물론 작고 같단한 앱에도 잘 적용되지만, 더 크고 복잡한 앱에서는 컨트롤러 계층이 훨씬 커지거나 복잡해질 수 있다. 대게는 액티비티나 다른 컨트롤러들을 가볍게(thin) 유지하려고 한다. 가벼운 액티비티는 가능한 한 비즈니스 로직을 적게 포함하기 때문이다. 그리고 앱의 컨트롤러를 가볍게 만드는 데 MVC가 더 이상 적합하지 않을 때는 MVVM(모델-뷰-뷰모델) 아키텍처가 그 대안이 될 수 있다. tools 네임스페이스 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot;&gt; // 레이아웃의 루트 태그에 tools 네임스페이스 추가 &lt;TextView android:id=&quot;@+id/question_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:padding=&quot;24dp&quot; tools:text=&quot;@string/question_australia&quot; /&gt; // tools 네임스페이스로 지정 ... 이 네임스페이스를 사용하면 TextView 위젯의 속성을 오버라이드해 레이아웃 디자인에 해당 문자열 리소스를 보여줄 수 있다. TextView에 tools:text 속성을 추가하면, 안드로이드 스튜디오가 tools:text 속성을 알 수 있게 레이아웃의 루트 태그에 tools 네임스페이스를 추가해야 한다. tools 네임스페이스 속성들은 앱이 장치에서 실행되어 위젯들이 화면에 나타날 때는 무시된다. android:text로 지정된 값은 런타임 시에 나타나고, tools:text로 지정된 값은 디자인 시에 보기 위해 사용된다. 화면 픽셀 밀도 안드로이드는 밀도에 독립적인 크기 단위를 제공한다. 따라서 서로 다른 화면 밀도에서 일정한 크기를 갖도록 그 단위를 사용하면 된다. 그리고 안드로이드가 그 단위를 런타임 시에 픽셀로 변환하므로 신경 쓸 필요도 없다. px: pixel(픽셀) 의 줄임말이다. 화면 밀도와는 무관하게 1픽셀은 화면의 1픽셀과 일치한다. 픽셀은 장치의 화면 밀도에 적합하게 조정되지 않으므로 사용을 권장하지 않는다, dp: density-independent pixel(밀도 독립적 필셀) 의 줄임말이다. 마진과 패딩 등의 크기를 픽셀 값으로 지정하지 않을 때 사용한다. 1dp는 항상 장치 화면의 1/160인치이며, 화면 밀도와 무관하게 일정한 크기를 갖는다. 따라서 장치의 화면이 고밀도일 때는 더 많은 수의 화면 픽셀을 채우기 위해 dp를 사용한다. sp: scale-independent pixel(크기 독립적 픽셀) 의 줄임말이다. sp는 사용자의 폰트 크기 선택도 고려한 dp다. 주로 화면에 나타나는 텍스트의 크기를 설정하기 위해 사용한다. pt, mm, in: 포인트(1/72인치), 밀리미터, 인치로 크기를 지정할 수 있는 크기 단위이다. 그런데 모든 장치에 잘 맞도록 구성되지 않아 사용을 권장하지 않는다. 실무에서는 dp와 sp를 사용하며, 안드로이드는 이 값들을 런타임 시에 픽셀로 변환한다.","link":"/2021/05/08/android-bnr-02/"},{"title":"[Android] Fragment와 FragmentManager","text":"UI 유연성의 필요 UI 유연성이라하면 사용자나 장치가 요구하는 것에 따라 런타임 시에 액티비티의 뷰를 구성하거나 변경할 수 있는 능력이다. 그런데 액티비티는 이런 유연성을 제공하도록 설계되지 않았다. 액티비티의 뷰들은 런타임 시에 변경되며, 이 뷰들을 제어하는 코드는 액티비티 내부에 있어야 한다. 따라서 액티비티는 사용하는 특정 화면과 강하게 결합되어 있다. 프래그먼트 개요 하나 이상의 프래그먼트(fragment) 로 앱의 UI를 관리하면 유연성이 좋아진다. 프래그먼트는 액티비티의 작업 수행을 대행할 수 있는 컨트롤러 객체다. 여기서 작업이란 UI 관리를 말하며, UI는 화면 전체 또는 일부분이 될 수 있다. UI를 관리하는 프래그먼트를 UI 프래그먼트라 한다. UI 프래그먼트는 레이아웃 파일로부터 인플레이트 inflate되는 자신의 뷰를 하나 갖는다. 프래그먼트 뷰는 사용자가 보면서 상호 작용하기를 원하는 UI 요소들을 포함한다. 액티비티의 뷰는 자신의 UI를 갖는 대신 프래그먼트를 넣을 컨테이너를 가지며, 이 컨테이너에는 인플레이트된 프래그먼트의 뷰가 추가된다. 이 장에서는 액티비티가 하나의 프래그먼트만 포함하지만, 액티비티는 여러 개의 다른 프래그먼트 뷰를 수용하는 다수의 컨테이너를 가질 수 있다. UI 프래그먼트를 사용하면 앱의 UI를 조립 가능한 요소로 분리할 수 있어서 유용하며, 탭 인터페이스를 비롯한 여러 가지를 쉽게 만들 수 있다. 새로운 안드로이드 Jetpack API 중에서도 내비게이션 컨트롤러와 같이 프래그먼트를 잘 활용하는 API가 있다. 따라서 프래그먼트를 사용하면 Jetpack API를 같이 사용할 때도 유용하다. 프래그먼트를 이용한 앱 개발 시작 예시로 사용되는 앱의 화면은 CrimeFragment라는 UI 프래그먼트가 관리하며, CrimeFragment의 인스턴스는 MainActivity라는 액티비티가 호스팅한다. 액티비티는 자신의 뷰 계층 구조에 프래그먼트와 그 뷰를 포함하는 곳을 제공하는데, 이것을 호스팅이라고 생각하면 된다. 프래그먼트는 화면에 보이는 뷰를 자체적으로 가질 수 없으며, 액티비티의 뷰 계층에 추가될 때만 화면에 자신의 뷰가 보인다. CrimeFragment를 호스팅하는 MainActivity 액티비티로만 이루어진 앱에서 액티비티들이 했던, UI를 생성하고 관리하며 모델 객체들과 상호 작용하는 일을 CrimeFragment가 한다는 것을 아래의 다이어그램에서 알 수 있다. 프래그먼트를 사용하는 앱의 객체 다이어그램 FragmentManager에 UI 프래그먼트 추가하기 Fragment 클래스가 허니콤 honeycomb 버전에 추가되면서 FragmentManager를 호출하는 코드를 포함하도록 Activity 클래스가 변경되었다. FragmentManager는 프래그먼트 리스트와 프래그먼트 트랜잭션의 백 스택 back stack을 처리한다. FragmentManager는 프래그먼트의 뷰를 액티비티의 뷰 계층에 추가하고 프래그먼트의 생명주기를 주도하는 책임을 갖는다. 프래그먼트 트랜잭션 FragmentManager에 프래그먼트를 관리하도록 넘겨주는 코드를 MainActivity.kt에 추가한다. CrimeFragment 추가하기 코드 1 (MainActivity.kt) 1234567891011121314151617class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val currentFragment = supportFragmentManager.findFragmentById(R.id.fragment_container) if (currentFragment == null) { val fragment = CrimeFragment() supportFragmentManager .beginTransaction() .add(R.id.fragment_container, fragment) .commit() } }} 액티비티에 프래그먼트를 추가하기 위해 액티비티의 FragmentManager를 호출했다. 이때 Jetpack 라이브러리와 AppCompatActivity 클래스를 사용하고 있으므로 supportFragmentMananger 속성을 사용해서 액티비티의 프래그먼트 매니저를 참조할 수 있다. supportFragmentMananger의 이름 앞 'support’는 v4 지원 라이브러리로부터 유래된 것이다. 그러나 지금은 v4 지원 라이브러리가 Jetpack 내부에 androidx 라이브러리로 포함되었다. 프래그먼트 트랜잭션 fragment transaction 을 생성하고 커밋 1234supportFragmentManager .beginTransaction() .add(R.id.fragment_container, fragment) .commit() 프래그먼트 트랜잭션은 프래그먼트 리스트에 프래그먼트를 추가 add, 삭제 remove, 첨부 attach, 분리 detach, 변경 replace하는데 사용된다. 프래그먼트 트랜잭션을 사용하면 여러 개의 오퍼레이션 (트랜잭션으로 실행되는 각 함수 코드)을 묶어서 수행할 수 있다. 예를 들어, 다수의 프래그먼트를 동시에 서로 다른 컨테이너에 추가하는 경우다. 프래그먼트로 런타임 시에 화면을 구성 또는 변경하는 방법의 핵심이 바로 프래그먼트 트랜잭션이다. FragmentManager는 프래그먼트 트랜잭션의 백 스택을 유지 관리한다. 따라서 프래그먼트 트랜잭션이 다수의 오퍼레이션을 포함한다면 해당 트랜잭션이 백 스택에서 제거될 때 이 오퍼레이션들이 역으로 실행된다. 그러므로 다수의 프래그먼트 오퍼레이션들을 하나의 트랜잭션으로 묶으면 UI 상태를 더욱 잘 제어할 수 있다. FragmentManager.beginTransaction 함수는 FragmentTranscation의 인스턴스를 생성해 반환한다. FragmentTransaction 클래스는 플루언트 인터페이스 fluent interface를 사용한다. (플루언트 인터페이스는 코드를 이해하기 쉽게 해주는 객체지향 기법이며, 일반적으로 함수의 연쇄 호출 형태로 구현된다.) 즉, FragmentTransaction을 구성하는 함수들이 Unit 대신 FragmentTransaction 객체를 반환하기 때문에 이 함수들을 연쇄 호출할 수 있다 (코틀린의 Unit은 하나의 인스턴스만 생성되는 싱글톤 객체이며 자바의 void와 같이 함수의 반환 값이 없음을 나타내는 데 사용된다). 따라서 위의 코드는 '새로운 프래그먼트 트랜잭션 인스턴스를 생성하고 이 인스턴스에 add() 오퍼레이션을 포함시킨 후 커밋해라’라는 의미다. add(...) 함수는 컨테이너 뷰 ID와 새로 생성된 CrimeFragment 인스턴스를 매개변수로 갖는다. 여기서 컨테이너 뷰 ID는 activity_main.xml에 정의했던 FrameLayout의 리소스 ID다. 컨테이너 뷰 ID는 다음 두 가지 목적으로 사용된다. 액티비티 뷰의 어느 위치에 프래그먼트 뷰가 나타나야 하는지를 FragmentManager에 알려준다. FragmentManager의 리스트에서 프래그먼트를 고유하게 식별하는 데 사용된다. FragmentManager로부터 CrimeFragment를 가져오려면 다음의 코드 첫째 줄처럼 컨테이너 뷰 ID로 요청한다. 123456789val currentFragment = supportFragmentManager.findFragmentById(R.id.fragment_container)if (currentFragment == null) { val fragment = CrimeFragment() supportFragmentManager .beginTransaction() .add(R.id.fragment_container, fragment) .commit() FragmentManager가 FrameLayout의 리소스 ID를 사용해서 CrimeFragment를 식별한다는 것이 이상하게 보일지 모른다. 그러나 컨테이너 뷰의 리소스 ID로 UI 프래그먼트를 식별하는 것이 FragmentManager가 작동하는 방법이다. 만일 하나의 액티비티에 여러 개의 프래그먼트를 추가한다면, 각 프래그먼트에 대해 별도의 리소스 ID를 갖는 컨테이너 뷰를 생성하기 때문이다. 이제 코드 1 ↩이 어떻게 작동하는지 자세히 살펴보자. 우선 R.id.fragment_container의 컨테이너 뷰 ID와 연관된 프래그먼트를 FragmentManager에 요청한다. 만일 이 프래그먼트가 리스트에 이미 있다면, FragmentManager가 그것을 반환한다. 그런데 요청한 프래그먼트가 어째서 이미 프래그먼트 리스트에 있는 것일까? 여러 이유로 액티비티가 소멸되었다가 다시 생성될 때를 대비해서 리스트에 보존하기 대문이다. 즉, 장치가 회전되거나 안드로이드 운영체제의 메모리 회수로 MainActivity가 소멸되었다가 다시 생성되면 MainActivity.onCreate(Bundle?)이 다시 호출된다. 따라서 액티비티가 소멸될 때는 이 액티비티의 FragmentManager 인스턴스가 해당 액티비티의 프래그먼트 리스트를 보존한다. 그리고 해당 액티비티가 다시 생성되면 새로운 FragmentManager 인스턴스가 그 리스트를 가져와서 리스트에 있는 프래그먼트를 다시 생성해 이전 상태로 복원한다. 이와는 달리 지정된 컨테이너 뷰 ID의 프래그먼트가 리스트에 없다면, fragment 변수는 null이 된다. 이때는 새로운 CrimeFragment와 새로운 프래그먼트 트랜잭션(프래그먼트를 리스트에 추가하는)을 생성한다. 이렇게 MainActivity가 CrimeFragment를 호스팅하게 되었다. FragmentManager와 프래그먼트 생명주기 프래그먼트 생명주기는 액티비티 생명주기와 유사하다. 즉 중단 (stopped) 상태, 일시 중지 (paused) 상태, 실행 재개 (resumed) 상태를 가지며, 상태가 전환될 대 필요한 일을 처리하기 위해 오버라이드할 수 있는 함수들도 갖는다. 이 함수들은 액티비티 생명주기 함수들과 대응된다. 프래그먼트 생명주기 다이어그램 액티비티와 프래그먼트의 생명주기 함수가 대응된다는 점이 중요하다. 프래그먼트는 액티비티를 대신해 작동하므로 프래그먼트의 상태는 액티비티의 상태를 반영해야한다. 따라서 프래그먼트는 액티비티의 작업을 처리하기 위해 액티비티와 일치하는 생명주기 함수가 필요하다. 프래그먼트 생명주기와 액티비티 생명주기가 다른 점은 프래그먼트 생명주기 함수는 안드로이드 운영체제가 아닌 호스팅 액티비티의 FragmentManager가 호출한다는 점이다. 프래그먼트는 액티비티가 내부적으로 처리해서 안드로이드 운영체제는 액티비티가 사용하는 프래그먼트에 관해서는 아무것도 모른다. onAttach(Context?), onCreate(Bundle?), onCreateView(...), onViewCreated(...) 함수들은 프래그먼트를 FragmentManager애 추가할 때 호출된다. onActivityCreated(Bundle?) 함수는 호스팅 액티비티의 onCreate(Bundle?) 함수가 실행된 후 호출된다. 앱에서는 MainActivity.onCreate(Bundle?)에서 CrimeFragment를 추가하는데, onActivityCreated(Bundle?) 함수는 프래그먼트가 추가된 후에 호출된다. 액티비티가 이미 실행 중일 때 프래그먼트를 추가하면 어떻게 될까? 이때 FragmentManager는 해당 프래그먼트가 호스팅 액티비티의 상태를 따라잡는데 필요한 프래그먼트 생명주기 함수를 몇 개이든 차례대로 즉시 호출한다. 예를 들어, 이미 실행 중인 액티비티에 프래그먼트가 추가되면 이 프래그먼트는 onAttach(Context?), onCreate(Bundle?), onActivityCreated(Bundle?), onStart(), onResume()의 순서로 이 함수들의 호출을 연속해서 받게 된다. 일단 프래그먼트의 상태가 액티비티의 상태를 따라잡으면 이후부터는 호스팅 액티비티의 FragmentManager가 액티비티 상태와 동조된 프래그먼트 상태를 유지한다. 즉, 안드로이드 운영체제로부터 액티비티 생명주기 함수들이 호출되면 이것과 부합되는 프래그먼트 생명주기 함수들을 호출해준다. 프래그먼트를 사용하는 애플리케이션 아키텍쳐 프래그먼트는 주요 컴포넌트를 재사용하게끔 캡슐화한다. 여기서 주요 컴포넌트는 앱의 전체 화면에 나타난다. 만일 한번에 너무 많은 프래그먼트를 화면에 넣는다면, 프래그먼트 트랜잭션 때문에 코드가 지저분하게 된다. 따라서 작은 컴퍼넌트들을 재사용할 때는 프래그먼트 대신 커스텀 뷰 (View의 서브 클래스 또는 View의 서브 클래스의 서브 클래스)로 추출하는 것이 좋은 방법이다. 일반적으로 한 화면에는 최대 두 개 또는 세 개 정도의 프래그먼트를 사용하는 것이 좋다.","link":"/2021/05/21/android-bnr-08/"},{"title":"[Android] Do not concatenate text displayed with setText","text":"문제 개요 TextView의 내용을 setText() 메서드를 이용해 설정할 때 Do not concatenate text displayed with setText. Use resource string with placeholders. 라는 경고문을 자주 볼 수 있다. 대략 setText로 표시된 텍스트를 +로 연결해서 사용하지 말고 리소스 문자열을 placeholder와 함께 사용하라는 내용인데 어떻게 해결할 수 있을까? 해결 답은 문자열 서식 지정에 있다. 아래의 코드와 같이 문자열 리소스에서 원하는 자리에 들어갈 값을 서식 인수 format argument를 추가하여 지정하는 것이다. 1&lt;string name=&quot;welcome_messages&quot;&gt;Hello, %1$s! You have %2$d new messages.&lt;/string&gt; 위의 예시는 문자열에 두 개의 서식 인수가 존재하는데 %1$s에는 문자열이, %2$d에는 10진수 값이 들어간다. 여기서 주의해야 할 부분은 서식 인수의 syntax인데 아래와 같은 형태이다. %[인자의 인덱스$]서식 지정자 인자의 인덱스 argument index는 문자열 리소스에서 서식 인수의 인덱스를 선택할 수 있게 해준다. 첫 번째 인자는 1$, 두 번째는 2$, 세 번째는 3$와 같은 식이다. 서식 지정자 format specifier는 데이터 타입을 지정하는 것인데, C언어 등에서 흔히 사용하는 %d, %s와 같은 서식 지정자와 동일한 개념이다. 문자열 리소스에서 서식 인수를 지정했다면 getString(int, Object...)을 통해 아래의 코드와 같이 매개변수의 첫 번째 인자로 해당 문자열 리소스를 전달하고 차례로 서식 인수들에 들어갈 값을 전달하면 된다. 1var text = getString(R.string.welcome_messages, username, mailCount) 결과적으로 +로 연결된 텍스트가 아닌 문자열 서식 지정을 이용하여 getString(int, Object...)의 값을 setText()에 넣어주면 된다. 1testTextView.text = getString(R.string.welcome_messages, username, mailCount) References Android Developers 가이드 | 문자열 서식 지정 Android Developers 가이드 | getString StackOverflow | Android TextView : “Do not concatenate text displayed with setText”","link":"/2021/05/18/android-memo-text-concatenatation/"},{"title":"[Codility] BinaryGap","text":"Lesson 1 - Iterations : BinaryGap kotlin 이진수 변환 직접 구현 1234567891011121314151617181920212223242526272829303132import kotlin.math.maxfun solution(N: Int): Int { var answer = 0 var temp = &quot;&quot; var quotient = N var remainder: Int while (quotient &gt;= 1) { remainder = quotient % 2 quotient /= 2 temp += remainder.toString() } val binary = temp.reversed() val oneIndexList = mutableListOf&lt;Int&gt;() binary.forEachIndexed { index, c -&gt; if (c == '1') { oneIndexList.add(index) } } var gap: Int for (i in 0 until oneIndexList.size - 1) { gap = oneIndexList[i+1] - oneIndexList[i] - 1 answer = max(gap, answer) } return answer} 이진수 변환을 직접 구현 이진수 문자열에서 1이 위치한 인덱스들을 값으로 가지는 리스트 생성 1이 위치한 인접한 인덱스끼리 빼고, 추가적으로 1을 더 빼면 gap의 크기가 나옴 Int.toString(radix: Int) 사용하여 이진수 변환 1234567891011fun solution(N: Int): Int { val binary = N.toString(2) val zeroList = binary.split(&quot;1&quot;).toMutableList() if (binary.last() != '1') { zeroList.removeAt(zeroList.size - 1) } return zeroList.map { it.length }.max() ?: 0} Int.toString(radix: Int) 사용하여 이진수 변환을 매우 간단하게 할 수 있다. 1을 구분자 delimniter로 이진수 문자열을 split 하여 연결된 0들을 값으로 가진 리스트를 생성 만약 이진수의 끝자리가 1이 아닐 경우엔 마지막 연결된 0들은 gap으로 인정되지 않으므로 리스트에서 삭제한다. Iterable&lt;T&gt;.map(transform: (T) -&gt; R)을 통해 리스트 원소의 길이를 기준으로 리스트를 생성한 후 가장 큰 값을 max()를 이용해 리턴한다. 대부분의 코딩 사이트는 kotlin 1.4를 지원하지 않는데 1.4 기준으로는 아래처럼 사용해야하거나 사용할 수 있다. removeAt(zeroList.size - 1) -&gt; zeroList.removeLast() max() -&gt; maxOrNull()","link":"/2021/05/19/codility-binary-gap/"},{"title":"[Codility] CyclicRotation","text":"Lesson 2 - Arrays : CyclicRotation 소스 kotlin 배열 인덱스 활용 12345678910fun solution(A: IntArray, K: Int): IntArray { val rotatedArray = IntArray(A.size) for (i in A.indices) { val index = (i + K) % A.size rotatedArray[index] = A[i] } return rotatedArray} Dequeue 덱 활용 1234567891011121314import java.util.*fun solution(A: IntArray, K: Int): IntArray { val dequeue = ArrayDeque&lt;Int&gt;() val rotation = when(A.size) { 0 -&gt; 0 else -&gt; K % A.size } dequeue.addAll(A.toList()) repeat(rotation) { dequeue.addFirst(dequeue.removeLast()) } return dequeue.toIntArray()} IntArray A의 크기가 0인 경우 java.lang.ArithmeticException: / by zero이 발생하므로 A가 0인 경우 회전하지 않도록 값을 0으로 설정해줘야 한다.","link":"/2021/05/21/codility-cyclic-rotation/"},{"title":"[Android] 액티비티 생명주기","text":"액티비티 상태와 생명주기 콜백 Activity의 모든 인스턴스는 생명주기를 갖는다. 그리고 생명주기 동안에 액티비티는 네 가지 상태, 즉 실행 재개(resumed), 일시 중지(paused), 중단(stopped), 존재하지 않음(non-existent)으로 상호 전환된다. 또한, 각 전환이 발생할 때 액티비티에 상태 변경을 알려주는 Activity 함수들이 있으며, 이 함수들은 안드로이드가 자동 호출한다. 액티비티 상태 다이어그램 액티비티 상태 상태 메모리에 있음? 사용자에게 보임? 포그라운드에서 실행? 존재하지 않음 아니오 아니오 아니오 중단 예 아니오 아니오 일시 중지 예 예(부분적)* 아니오 실행 재개 예 예 예 * 당시 상황에 따라 일시 중지된 액티비티의 전체 또는 일부가 사용자에게 보일 수 있다 ↩ ‘존재하지 않음’ 상태 액티비티가 아직 론칭되지 않았거나 소멸되었음(예를 들어, 사용자가 백 버튼을 눌러서)을 나타낸다. 이 때문에 때로는 이 상태를 ‘소멸(destroyed)’ 상태라고도 한다. 이때 액티비티 인스턴스는 메모리에 존재하지 않으며, 사용자가 보거나 상호 작용하기 위한 뷰도 없다. ‘중단’ 상태 액티비티 인스턴스가 메모리에 있지만, 이것의 뷰는 화면에서 볼 수 없다는 것을 나타낸다. 액티비티가 처음 시작될 때 거쳐가는 상태이며, 액티비티 인스턴스의 뷰가 화면에서 완전히 가려졌을 때 언제든 다시 진입하는 상태다. 예를 들어, 전체 화면을 사용하는 다른 액티비티를 사용자가 시작하거나 홈 버튼을 누를 때 등이다. ‘일시 중지’ 상태 액티비티가 포그라운드(foreground)에서 작동하지는 않지만, 액티비티 인스턴스의 뷰 전체 또는 일부를 화면에서 볼 수 있음을 나타낸다. 예를 들어, 이 액티비티 위에 새로운 대화상자나 투명 액티비티가 사용자에 의해 시작된다면 이 액티비티는 일부만 화면에 보이게 된다. 만일 사용자가 다중 창 모드(분활 화면 모드)로 두 개의 액티비티를 같이 보고 있다면 액티비티 전체가 화면에 보일 수 있지만, 포그라운드에 존재하지 않을 수도 있다. ‘실행 재개’ 상태 액티비티가 메모리에 있으면서 화면에서 전체를 볼 수 있고 포그라운드에 있음을 나타낸다. 사용자가 현재 상호 작용하고 있는 액티비티가 바로 이 상태다. ‘실행 재개’ 상태는 장치의 전체 시스템에 걸쳐 하나의 액티비티만 될 수 있다. 즉, 한 액티비티가 ‘실행 재개’ 상태가 되면 직전에 실행 중이던 액티비티는 다른 상태로 바뀐다는 의미다. 상단의 액티비티 상태 다이어그램 이미지에 있는 함수들을 사용해 액티비티 생명주기의 전환 시점에 필요한 일을 처리할 수 있다. 이 함수들을 생명주기 콜백(lifecycle callback) 이라고 한다. 이미 생명주기 콜백 함수 중 하나인 onCreate(Bundle?)을 알고 있을 것이다. 액티비티 인스턴스가 생성되고 화면에 나타나기 전에 안드로이드 운영체제가 이 함수를 호출한다. UI를 준비하기 위해 액티비티에서는 다음과 같이 onCreate(Bundle?) 함수를 오버라이드(override)한다. 위젯을 인플레이트해 뷰 객체로 생성한 후 화면에 보여준다. (setContentView(Int)를 호출) 인플레이트된 위젯의 객체 참조를 얻는다. 사용자와의 상호 작용을 처리하기 위해 위젯에 리스너를 설정한다. 외부의 모델 데이터를 연결한다. 액티비티 생명주기 로깅하기 로그 메세지 만들기 안드로이드에서 android.util.Log 클래스는 공유되는 시스템 수준의 로그에 로그 메시지를 전달한다. Log 클래스는 메시지를 로깅하기 위한 함수들을 갖고 있다. 메시지의 내용은 물론, 메시지의 중요도를 나타내는 레벨(level)도 제어할 수 있다. 안드로이드는 다섯 개의 로그 레벨을 지원 로그 레벨과 함수 로그 레벨 함수 용도 ERROR Log.e(…) 에러 WARNING Log.w(…) 경고 INFO Log.i(…) 정보성 메시지 DEBUG Log.d(…) 디버깅 출력이며 필터링할 수 있다. VERBOSE Log.v(…) 개발 전용 각 로깅 함수는 두 개의 시그니처(signature)를 갖는다. 하나는 태그 문자열과 메시지 문자열로 된 두 개의 인자를 받고 일반적으로 태그 문자열에는 클래스 이름을 값으로 갖는 TAG 상수를 지정한다. 이렇게 하면 메시지의 근원을 알기 쉽다. 다른 하나는 이 두 인자에 Throwable 인스턴스를 추가로 받는다. Throwable 인스턴스는 앱이 발생시킬 수 있는 특정 예외에 관한 정보를 쉽게 로깅할 수 있게 한다. TAG 상수 추가하기 (MainActivity.kt) 1234567import ...private const val TAG = &quot;MainActivity&quot;class MainActivity : AppCompatActivity() { ...} 참고로, 이처럼 .kt 파일 내부에서 클래스 바깥쪽에 선언한 변수를 코틀린에서는 최상위 수준 속성이라고 한다. 최상위 수준 속성은 다음 두 가지 상황에 사용할 수 있다. 특정 클래스의 인스턴스를 생성하지 않고 바로 사용할 수 있으므로 애플리케이션이 실행되는 동안 속성값을 계속 보존해야 할 때다. 애플리케이션 전체에서 사용하는 상수를 정의할 때 유용하다. 안드로이드에서 로깅하는 방법 123456789// DEBUG 로그 레벨로 메시지를 로깅한다Log.d(TAG, &quot;Current question index: $currentIndex&quot;)try { val question = questionBank[currentIndex]} catch (ex: ArrayIndexOutOfBoundsException) { // 스택에 저장된 예외의 기록과 함께 ERROR 로그 레벨로 메시지를 로깅한다 Log.e(TAG, &quot;Index was out of bounds&quot;, ex)} 생명주기 함수를 추가로 오버라이드하기(MainActivity.kt) 12345678910111213141516171819202122232425262728293031323334353637class MainActivity : AppCompatActivity() { ... override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) Log.d(TAG, &quot;onCreate(Bundle?) called&quot;) setContentView(R.layout.activity_main) ... } override fun onStart() { super.onStart() Log.d(TAG, &quot;onStart() called&quot;) } override fun onResume() { super.onResume() Log.d(TAG, &quot;onResume() called&quot;) } override fun onPause() { super.onPause() Log.d(TAG, &quot;onPause() called&quot;) } override fun onStop() { super.onStop() Log.d(TAG, &quot;onStop() called&quot;) } override fun onDestroy() { super.onDestroy() Log.d(TAG, &quot;onDestroy() called&quot;) } ...} Log.d(…)를 호출해 메시지를 로깅하기 전에 오버라이드되는 슈퍼 클래스 함수를 호출한다는 점에 유의하자. 오버라이드하는 각 콜백 함수에서는 오버라이드되는 슈퍼 클래스 함수를 호출하는 코드가 맨 앞에 있어야 한다. 각 함수에 override 키워드가 있는 이유는 오버라이드하는 함수가 슈퍼 클래스에 있는지 컴파일러에게 확인하라고 요청하기 위해서다. 액티비티 생명주기가 사용자 액션에 어떻게 응답하는지 살펴보기 GeoQuiz 앱이 설치 및 실행될 때는 생명주기 함수 onCreate(Bundle?), onStart(), onResume()가 차례대로 호출되고 MainActivity 인스턴스가 생성된다. 즉, MainActivity 인스턴스가 ‘실행 재개’ 상태가 된다(메모리에 로드되고, 사용자에게 보이며, 포그라운드에서 작동함). 앱 설치 및 실행 시, onCreate(Bundle?), onStart(), onResume()가 차례대로 호출된다. 일시적으로 액티비티 떠나기 홈 버튼을 누르면 MainActivity는 onPause(), onStop() 호출을 받지만, onDestroy()는 호출되지 않는다. 그러면 MainActivity는 어떤 상태일까? 홈 버튼을 누르면 onPause(), onStop()가 호출된다. 장치의 홈 버튼을 누르면 안드로이드 운영체제에 '나는 다른 작업을 하려고 한다. 그런데 현재의 액티비티 화면에서 볼일이 다 끝나지 않았으므로 다시 돌아올 수 있다.'라고 알리는 셈이 된다. 따라서 안드로이드 운영체제는 현재 액티비티를 일시 중지했다가 중단시킨다. 즉, GeoQuiz 앱에서 홈 버튼을 누른 후에는 MainActivity의 인스턴스가 ‘중단’ 상태가 된다(메모리에는 있지만 사용자에게는 보이지 않으며, 포그라운드에서 실행되지 않는다). 그러나 사용자가 나중에 GeoQuiz 앱으로 돌아오면 안드로이드 운영체제는 재빨리 MainActivity 인스턴스를 다시 시작한다. 다시 앱을 키면 onRestart(), onStart(), onResume()이 차례로 호출된다. 오버뷰 화면(overview screen)에서의 동작은? 아래의 이미지와 같이 오버뷰 화면의 각 카드는 이전에 사용자가 사용했던 앱을 나타낸다. 오버뷰 화면은 ‘최근 앱 화면’ 또는 '태스크 매니저’라고도 한다. 여기서는 개발자 문서에서 얘기하는 '오버뷰 화면’이라고 칭한다. 오버뷰 화면에서 태스크 클릭 시에는 onRestart(), onStart(), onResume()이 호출 오버뷰 화면에서 GeoQuiz 태스크를 클릭하면 MainActivity가 화면에 나타난다. 이때 로그캣 창의 메시지를 보면 onRestart(), onStart(), onResume()이 호출되었음을 알 수 있다. 하지만 onCreate(…)는 호출되지 않았는데 홈 버튼을 누른 후에 MainActivity는 ‘중단’ 상태가 되었기 때문이다. 따라서 MainActivity 인스턴스는 여전히 메모리에 있으므로 다시 생성될 필요가 없다. 그리고 오버뷰 화면에서 선택되면 액티비티만 다시 시작되어('일시 정지’이면서 화면에 볼 수 있는 상태) 실행이 재개된다(포그라운드로 '실행 재개’되는 상태). 액티비티는 ‘일시 중지’ 상태에 머물러 있을 수도 있는데, 이때는 일부만 화면에 보이거나(예를 들어, 투명한 백그라운드를 갖거나 더 작은 화면 크기를 갖는 다른 액티비티가 '일시 중지’된 액티비티 화면 위에 있을 때) 또는 전체 화면이 보일 수도 있다(다중 창 모드일 때). 다중 창 모드(multi window mode)에서의 동작은? &emsp;&emsp;&emsp;&emsp; 아래 창에 열린 다른 앱을 클릭하고 로그캣의 메시지를 보면 GeoQuiz의 MainActivity에서 onPause()가 호출되었음을 알 수 있다. 즉, MainActivity는 현재 ‘일시 중지’ 상태다. 그리고 위의 창에 열린 GeoQuiz를 클릭하면 MainActivity의 onResume()가 호출된다. 이제는 MainActivity가 ‘실행 재개’ 상태가 되었기 때문이다. 액티비티 끝내기 장치의 백 버튼을 누른 후 로그캣의 메시지를 확인해보자. MainActivity의 onPause(), onStop(), onDestroy()가 호출되었을 것이다. MainActivity의 인스턴스가 존재하지 않는 상태다(메모리에 없고 화면에도 보이지 않으며, 포그라운드에서도 동작하지 않음). 백 버튼을 누르면 액티비티 인스턴스가 소멸되어 onPause(), onStop(), onDestroy()가 호출된다. 장치의 백 버튼을 눌렀다는 것은 앱의 사용자가 해당 액티비티를 끝냈다는 의미다. 달리 말해, 안드로이드 운영체제에 '나는 이 액티비티를 다 사용했으므로 더 이상 필요 없다.'라고 알리는 셈이다. 그러면 안드로이드 운영체제는 해당 액티비티를 소멸시키고 메모리로부터 모든 흔적을 지운다. 이것이 바로 장치의 제한된 리소스를 절약하는 안드로이드의 방식이다. 또한, 오버뷰 화면에서 해당 앱의 카드를 옆으로 밀어내도 앱을 끝낼 수 있으며, 코드에서는 Activity.finish()를 호출해 액티비티를 끝낼 수 있다. 오버뷰 화면에서 앱 종료 시, onDestroy() 호출 액티비티 회전시키기 장치를 회전하면 onPause(), onStop(), onDestroy(), onCreate(…), onStart(), onResume()이 차례로 호출된다. 장치 회전 시, MainActivity가 죽었다가 다시 살아난다! 위 메시지를 보면 알 수 있듯, 장치를 회전하면 보고 있던 MainActivity 인스턴스는 소멸되었다가 다시 새로운 인스턴스로 생성된다. 현재 인스턴스의 currentIndex에 저장된 값이 메모리에서 지워지므로, 장치를 회전하면 그 당시 사용자가 어떤 문제를 보고 있었는지 GeoQuiz가 모르게 된다는 의미다. 장치가 회전될 때 안드로이드는 완전히 새로운 MainActivity 인스턴스를 생성한다. 따라서 onCreate(Bundle?)에서 currentIndex이 값이 0으로 초기화되므로 사용자는 첫 번째 문제를 다시 보게 된다. 장치 구성 변경과 액티비티 생명주기 장치를 회전하면 장치 구성(device configuration) 이 변경된다. 장치 구성은 각 장치의 현재 상태를 나타내는 특성들의 집합이다. 장치 구성을 이루는 특성에는 화면 방향, 화면 밀도, 화면 크기, 키보드 타입, 도크(dock) 모드, 언어 등이 있다. 일반적으로 앱에서는 서로 다른 장치 구성에 맞추기 위해 대체 리소스를 제공한다. 장치마다 다른 화면 밀도를 고려해 여러 화살표 아이콘을 프로젝트에 추가했을 때 이미 이런 예를 보았다. 런타임 구성 변경(runtime configuration change) 이 생길 때는 새로운 구성에 더 잘 맞는 리소스들이 있을 수 있다. 따라서 안드로이드는 현재의 액티비티 인스턴스를 소멸시키고 새로운 구성에 가장 적합한 리소스를 찾는다. 그리고 그런 리소스를 사용해서 해당 액티비티의 새 인스턴스를 다시 빌드한다. 예로 장치의 화면 방향이 가로 방향으로 변경될 때 안드로이드가 찾아 사용할 대체 리소스를 생성할 수 있다. 가로 방향 레이아웃 activity_main.xml (land) 생성 방향에 따른 레이아웃이 나온다 &emsp;&emsp;&emsp;&emsp;","link":"/2021/05/08/android-bnr-03/"},{"title":"[Android] ViewModel과 SIS","text":"안드로이드는 적절한 시점에 대체 리소스를 제공하지만, 장치 회전에 따른 액티비티 소멸 및 재생성은 문제가 생길 수 있다. 회전 시 데이터가 초기화되는 결함을 해결하려면, 장치 회전 후에 재생성되는 MainActivity 인스턴스가 초기화 되는 데이터의 직전 값을 알아야 한다. 그러려면 장치 회전과 같은 런타임 구성 변경 시에 해당 데이터를 보존할 방법이 필요하다. ViewModel에 UI 데이터를 저장해 UI 상태가 유실되는 결함을 해결할 수 있다. 또한, 이보다는 덜 생기지만 여전히 문제가 많은 결함인 '프로세스 종료에 따른 UI 상태 유실’도 안드로이드의 인스턴스 상태 보존 메커니즘을 사용해 해결한다. ViewModel 의존성 추가하기 우선 ViewModel 클래스를 프로젝트에 추가한다. ViewModel 클래스는 안드로이드 Jetpack의 lifecycle-extensions(생명주기 확장) 라이브러리에 포함되어 제공되는데, 사용하려면 우선 프로젝트 의존성(dependencies) 에 lifecycle-extensions 라이브러리를 포함시켜야 한다. 프로젝트 의존성은 그래들(Gradle) 구성 파일인 build.gradle 파일에 지정한다(그래들은 안드로이드 앱의 빌드 도구다). 두 개의 build.gradle 파일 중 build.gradle(Module: YourProject.app), 즉 app 모듈의 빌드 파일에 지정한다. build.gradle에 lifecycle-extensions 의존성 추가 123456789101112131415plugins { id 'com.android.application' id 'kotlin-android'}android { ...}dependencies { ... implementation 'androidx.constraintlayout:constraintlayout:2.0.4' implementation 'androidx.lifecycle:lifecycle-extensions:2.2.0' // lifecycle-extensions library 포함시키기 ...} ViewModel 추가하기 ViewModel은 특정 액티비티 화면과 연동되며, 해당 화면에 보여줄 데이터를 형식화하는 로직을 두기 좋은 곳이다. ViewModel은 모델 객체와 연동되어 모델을 ‘장식한다’. 즉, 모델 데이터를 화면에 보여주는 기능을 ViewModel이 수행한다. ViewModel을 사용하면 화면에서 필요한 모든 데이터를 한곳에서 종합하고 데이터를 형식화할 수 있다. android.lifecycle 패키지는 생명주기를 인식하는 컴포넌트를 비롯해서 생명주기 관련 API도 제공하며, ViewModel도 android.lifecycle 패키지의 일부다. 생명주기를 인식하는 컴포넌트는 액티비티와 같은 다른 컴포넌트의 생명주기를 관찰하고 상태를 고려해 작동한다. 구글에서는 액티비티 생명주기와 다른 컴포넌트 생명주기 처리를 쉽게 할 수 있도록 android.lifecycle 패키지와 이 패키지의 내용물(클래스나 인터페이스 등)을 만들었다. 이는 또다른 생명주기 인식 컴포넌트인 LiveData 및 백그라운드 스레드 내용과 연결된다. ViewModel 클래스 생성 1234567891011121314private const val TAG = &quot;QuizViewModel&quot;class QuizViewModel : ViewModel() { init { Log.d(TAG, &quot;ViewModel instance created&quot;) } // ViewModel 인스턴스가 소멸되기 전에 호출됨 override fun onCleared() { super.onCleared() Log.d(TAG, &quot;ViewModel instance about to be destroyed&quot;) }} ViewModel 인스턴스 사용하기 MainActivity.kt의 onCreate(Bundle?)에서 현재 액티비티를 QuizViewModel 인스턴스와 연결한다. 123456789101112131415class MainActivity : AppCompatActivity() { ... override fun onCreate(savedInstanceState: Bundle?) { ... setContentView(R.layout.activity_main) val provider: ViewModelProvider = ViewModelProvider(this) val quizViewModel = provider.get(QuizViewModel::class.java) Log.d(TAG, &quot;Got a QuizViewModel: $quizViewModel&quot;) trueButton = findViewById(R.id.true_button) ... } ...} ViewModelProvider는 ViewModel의 레지스트리처럼 작동한다. 즉, 액티비티(여기선 MainActivity) 인스턴스가 처음으로 QuizViewModel을 요청하면 ViewModelProvider가 새로운 QuizViewModel 인스턴스를 생성하고 반환한다. 그리고 장치 구성이 변경되어 새로 생성된 MainActivity 인스턴스가 QuizViewModel을 또 요청하면 QuizViewModel 인스턴스가 새로 생성되지 않고 최초 생성되었던 인스턴스가 반환된다. 또한, MainActivity 인스턴스가 종료되어(예를 들어, 사용자가 백 버튼을 눌러서) 소멸될 때는 QuizViewModel 인스턴스도 같이 메모리에서 제거된다. ViewModel 생명주기와 ViewModelProvider 사용자가 액티비티를 끝낸다는 것은 그 당시 UI 상태가 더 이상 필요 없음을 의미하므로 상태 데이터를 초기화하면 된다. 이와 달리 사용자가 장치를 회전해서 액티비티 화면의 방향이 바뀔 때는 회전 이전과 이후의 UI 상태는 같아야 한다. 사용자는 계속 같은 화면을 볼 수 있기를 기대하기 때문이다. 액티비티의 isFinishing 속성으로 이런 두 가지 시나리오 중 어느 것에 해당되는지 판단할 수 있다. 만일 isFinishing이 true면 사용자가 액티비티를 끝냈음을 의미한다(예를 들어, 백 버튼을 누르거나 오버뷰 화면에서 해당 앱 카드를 없앴을 때). 따라서 현재의 액티비티 인스턴스가 소멸되더라도 이 당시의 UI 상태는 보존할 필요가 없다. 그렇지 않고 isFinishing이 false면 장치의 회전에 따른 구성 변경으로 인해 시스템이 현재의 액티비티 인스턴스를 소멸시킨다는 것을 의미한다. 따라서 사용자가 계속 같은 화면을 볼 수 있도록 UI 상태가 보존되어야 한다. 이때 ViewModel을 사용하면 다른 방법을 사용하지 않아도 액티비티의 UI 상태 데이터를 메모리에 보존할 수 있다. ViewModel의 생명주기는 사용자의 기대를 더 잘 반영하는데, 이는 장치의 구성 변경이 생겨도 계속 존재하다가 액티비티가 종료될 때만 소멸되기 때문이다. 위의 MainActivity 코드에서 했던 것처럼, ViewModel 인스턴스는 액티비티 생명주기와 연동된다. ViewModel 인스턴스는 액티비티 상태 변화와 무관하게 액티비티가 종료될 때까지 메모리에 남아 있다가 액티비티가 종료되면 소멸된다. MainActivity와 연동되는 QuizViewModel 장치의 회전 등에 따른 구성 변경이 생길 때마다 현재의 액티비티 인스턴스는 소멸되고 다시 새 인스턴스가 생성되지만, 액티비티와 연관되는 ViewModel은 메모리에 남는다. 장치 회전 시 MainActiviy와 QuizViewModel 로그캣으로 확인해보기 QuizViewModel의 인스턴스가 생성됨 앱 실행 시, MainActivity 인스턴스가 생성되고 onCreate(Bundle?)에서 최초로 ViewModel을 요청할 때 새로운 QuizViewModel 인스턴스가 생성됨을 알 수 있다. 장치 회전 시, MainActivity 인스턴스는 소멸되지만 QuizViewModel 인스턴스는 남아있음 장치 회전 시, MainActivity 인스턴스는 소멸되지만 QuizViewModel 인스턴스는 남아있음을 알 수 있다. 장치가 회전된 후 새로운 MainActivity 인스턴스가 생성될 대 QuizViewModel을 다시 요청한다. 그런데 이전에 생성된 QuizViewModel 인스턴스가 여전히 메모리에 남아있으므로 ViewModelProvide는 새 인스턴스를 생성하지 않고 기존 인스턴스를 반환한다. (QuizViewModel@5a77eca를 그대로 사용하는 것을 확인할 수 있다.) MainActivity 인스턴스와 QuizViewModel 인스턴스가 모두 소멸됨 백 버튼을 누르면 MainActivity 인스턴스가 소멸될 때 QuizViewModel 인스턴스도 같이 소멸됨을 알 수 있다. 이때 QuizViewModel의 onCleared()가 호출된다. MainActivity와 QuizViewModel 간의 관계는 단방향이다. 즉, 액티비티는 ViewModel을 참조하지만, ViewModel은 액티비티를 참조하지 않는다. ViewModel은 액티비티나 다른 뷰의 참조를 가지면 안 된다. 메모리 유실(memory leak) 이 생길 수 있기 때문이다. 소멸되어야 하는 객체의 참조를 다른 객체가 가지면 메모리 유실이 생길 수 있다. 이때 참조되는 객체를 가비지 컬렉터가 메모리에서 제거할 수 없게 된다(이것을 강한 참조(strong reference)라고 한다). 구성 변경으로 인한 메모리 유실은 흔히 생기는 결함이다. 장치 회전 시에 액티비티 인스턴스는 소멸되지만, ViewModel 인스턴스는 메모리에 남는다. 그런데 ViewModel 인스턴스가 액티비티 인스턴스에 대해 강한 참조를 가지면 다음 두 가지 문제가 생길 수 있다. 액티비티 인스턴스가 메모리에서 제거되지 않아 이 인스턴스가 사용하는 메모리가 유실된다. ViewModel 인스턴스가 과거 액티비티의 뷰를 변경하려고 하면 IllegalStateException이 발생한다. ViewModel에 데이터 추가하기 QuizViewModel에 모델 데이터와 비즈니스 로직 추가하기 currentQuestionAnswer와 currentQuestionText는 연산 프로퍼티 속성이다. 이것은 다른 프로퍼티의 값을 사용해서 산출된 값을 자신의 값으로 반환하므로 이 프로퍼티의 값을 저장하는 필드 backing field가 클래스 인스턴스에 생기지 않는다. get()은 프로퍼티의 값을 반환하는 접근자 accessor이다. 123456789101112131415161718192021222324class QuizViewModel : ViewModel() { // 모델 데이터 추가 ↓ var currentIndex = 0 private val questionBank = listOf( Question(R.string.question_australia, true), Question(R.string.question_oceans, true), Question(R.string.question_mideast, false), Question(R.string.question_africa, false), Question(R.string.question_americas, true), Question(R.string.question_asia, true) ) // 비즈니스 로직 추가 ↓ val currentQuestionAnswer: Boolean get() = questionBank[currentIndex].answer val currentQuestionText: Int get() = questionBank[currentIndex].textResId fun moveToNext() { currentIndex = (currentIndex + 1) % questionBank.size }} ViewModel은 사용하기 쉽도록 자신과 연관된 화면에서 필요한 모든 데이터를 저장하고 형식화한다. 따라서 프레젠테이션 로직 코드를 액티비티와 분리할 수 있어서 액티비티를 좀 더 간단하게 유지할 수 있다. 가능한 한 액티비티를 간단히 유지하는 것이 좋은 이유는 액티비티에 추가되는 모든 코드는 뜻하지 않게 액티비티 생명주기의 영향을 받을 수 있기 때문이다. 간단하게 유지하면 액티비티는 화면에 나타나는 것을 처리하는 것만 집중하고, 보여줄 데이터를 결정하는 내부로직은 신경 쓰지 않아도 된다. 늦게 초기화되는 QuizViewModel 12345678910111213class MainActivity : AppCompatActivity() { ... // by lazy 키워드 사용 private val quizViewModel: QuizViewModel by lazy { ViewModelProvider(this).get(QuizViewModel::class.java) } override fun onCreate(savedInstanceState: Bundle?) { ... } ...} by lazy 키워드를 사용하면 quizViewModel을 var이 아닌 val 속성으로 선언할 수 있어 좋다. 액티비티 인스턴스가 생성될 때 QuizViewModel 인스턴스 참조를 quizViewModel에 한번만 저장하기 때문. 또한, by lazy 키워드를 사용하면 최초로 quizViewModel이 사용될 때까지 초기화를 늦출 수 있다. MainActivity 인스턴스가 생성된 후 호출되는 onCreate(Bundle?)에서 quizViewModel이 사용되므로 이때 quizViewModel이 QuizViewModel 인스턴스 참조로 초기화되어 안전하게 사용할 수 있다. QuizViewModel로부터 문제, 정답 및 인덱스 가져오기 1234567891011121314151617181920212223class MainActivity : AppCompatActivity() { ... override fun onCreate(savedInstanceState: Bundle?) { ... nextButton.setOnClickListener { // currentIndex = (currentIndex + 1) % questionBank.size quizViewModel.moveToNext() updateQuestion() } ... } ... private fun updateQuestion() { // val questionTextResId = questionBank[currentIndex].textResId val questionTextResId = quizViewModel.currentQuestionText questionTextView.setText(questionTextResId) } private fun checkAnswer(userAnswer: Boolean) { // val correctAnswer = questionBank[currentIndex].answer val correctAnswer = quizViewModel.currentQuestionAnswer ... } ViewModel을 사용함으로써 회전하기 직전에 보던 문제를 MainActivity가 기억해서 보여준다. 이로써 장치 회전으로 생긴 UI 상태 유실 결함은 해결되었다. 하지만 아직 눈에 띄지 않는 또 다른 결함이 있다. 프로세스 종료 시에 데이터 보존하기 안드로이드 운영체제가 앱의 프로세스를 소멸시킬 때는 메모리에 있는 앱의 모든 액티비티들과 ViewModel들이 제거되지만, 액티비티나 ViewModel의 그 어떤 생명주기 콜백 함수도 호출하지 않는다. 그렇다면 액티비티가 소멸될 때 UI 상태 데이터를 보존해 액티비티의 재구성에 사용할 수 있는 방법은 무엇일까? SIS(Saved Instance State, 저장된 인스턴스 상태) 에 데이터를 저장하는 것이 방법이 될 수 있다. SIS는 안드로이드 운영체제가 일시적으로 액티비티 외부에 저장하는 데이터이며, Activity.onSaveInstanceState(Bundle)을 오버라이드해 SIS에 데이터를 추가할 수 있다. 액티비티가 ‘중단’ 상태로 바뀔 때는 언제든지 안드로이드 운영체제가 Activity.onSaveInstanceState(Bundle)을 호출한다. 중단된 액티비티는 종료 대상이 되므로 이때 시점이 중요하다. 만일 우선순위가 낮은 백그라운드 앱이라서 앱의 프로세스가 종료된다면 Activity.onSaveInstanceState(Bundle)이 이미 호출되었다고 생각하면 된다. 액티비티의 슈퍼 클래스에 기본 구현된 onSaveInstanceState(Bundle)에서는 현재 액티비티의 모든 뷰가 자신들의 상태를 Bundle 객체의 데이터로 저장한다. Bundle은 문자열 키와 값을 쌍으로 갖는 구조체다. onCreate(Bundle?)의 인자로 전달되는 Bundle 객체를 앞에서 이미 보았다. 1234override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) ...} 그리고 오버라이드한 onCreate(Bundle?)에서는 인자로 받은 Bundle 객체를 액티비티의 슈퍼 클래스에 정의된 onCreate(Bundle?)에 전달해 호출한다. 그러면 슈퍼 클래스의 onCreate(Bundle?)에서는 인자로 받은 Bundle 객체에 저장된 뷰들의 상태 데이터를 사용해서 액티비티의 뷰 계층을 다시 생성한다. onSaveInstanceState(Bundle) 오버라이드하기 액티비티의 슈퍼 클래스에 기본 구현된 onSaveInstanceState(Bundle)에서는 현재 액티비티의 모든 뷰가 자신들의 상태를 Bundle 객체의 데이터로 저장 액티비티에서 onSaveInstanceState(Bundle)을 오버라이드하면 추가적으로 Bundle 객체에 데이터를 저장 가능하며 onCreate(Bundle?)에서 다시 받을 수 있다. 키로 이용할 상수 추가하기 123456private const val TAG = &quot;MainActivity&quot;private const val KEY_INDEX = &quot;index&quot; // Bundle 객체에 저장될 데이터의 키로 사용class MainActivity : AppCompatActivity() { ...} onSaveInstanceState(Bundle) 오버라이드하기 currentIndex의 값을 Bundle 객체에 저장 이때 키는 상수인 KEY_INDEX이며 키의 값은 currentIndex다. 12345678910111213override fun onPause() { ...}override fun onSaveInstanceState(savedInstanceState: Bundle) { super.onSaveInstanceState(savedInstanceState) Log.d(TAG, &quot;onSaveInstanceState&quot;) savedInstanceState.putInt(KEY_INDEX, quizViewModel.currentIndex)}override fun onStop() { ...} onCreate(Bundle?)에서 Bundle 객체 값 확인하기 마지막으로 onCreate(Bundle?)에서는 Bundle 객체에 저장된 값을 확인해 값이 있으면 그 값을 currentIndex에 지정하면 된다. 키(“index”)가 Bundle 객체에 없거나 Bundle 객체 참조가 null이면 currentIndex의 값을 0으로 설정한다. 123456789override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) Log.d(TAG, &quot;onCreate(Bundle?) called&quot;) setContentView(R.layout.activity_main) val currentIndex = savedInstanceState?.getInt(KEY_INDEX, 0) ?: 0 quizViewModel.currentIndex = currentIndex ...} onCreate(Bundle?)에서는 null이 될 수 있는 Bundle 객체 참조를 인자로 받는다. 액티비티의 새로운 인스턴스가 최초로 생성될 때는 상태 데이터가 없으므로 Bundle 객체 참조가 null이 되기 때문. 하지만 장치 회전이나 프로세스 종료 후에 액티비티 인스턴스가 다시 생성될 때는 Budle 객체 참조가 null이 아니며, 이때는 onSaveInstanceState(Bundle)에서 추가한 키와 값의 쌍으로 된 데이터가 Bundle 객체에 포함된다. 물론 Bundle 객체에는 프레임워크에서 추가한 정보 예로, EditText의 값이나 다른 기본 UI 위젯의 상태 데이터도 포함될 수 있다. 복원 테스트 해보기 설정 → 개발자 옵션에서 '앱’으로 표시된 항목의 ‘활동 유지 안함’ 옵션을 활성화하여 사용자가 종료하면 즉시 모든 작업을 삭제시킬 수 있다. ‘활동 유지 안함’ 비활성화 상태에서 홈 버튼 클릭 onDestroy() 호출이 되지 않아 액티비티가 소멸하지 않고 중단된 상태로 유지된다. ‘활동 유지 안함’ 활성화에서 홈 버튼 클릭 onDestroy() 호출이 되어 중단 상태의 액티비티가 소멸되어 메모리에서 제거된다. 따라서 새로 생성된 액티비티 인스턴스의 onCreate(Bundle?)에서는 소멸된 인스턴스에서 Bundle 객체에 저장했던 문제의 인덱스를 사용해서 현재 액티비티 인스턴스의 문제 인덱스를 복원할 수 있다. onSaveInstanceState(Bundle)를 오버라이드하여 Bundle 객체에 저장하지 않았을 때는 홈 버튼 클릭 후 다시 앱을 실행시키면 홈 버튼을 누를 당시의 문제가 유지되지 않고 첫번째 문제 인덱스인 '캔버라는 호주의 수도이다’가 표시되지만, onSaveInstanceState(Bundle)를 오버라이드하여 Bundle 객체에 currentIndex 값을 저장시키면 홈 버튼 클릭 후 다시 앱을 실행시켜도 홈 버튼을 누를 당시의 문제가 그대로 보인다. 아래 이미지에서 ‘수에즈 운하는 홍해와 인도양을 연결한다’ 문제가 그대로 유지되고 있는 것을 확인할 수 있다. 위의 테스트에서는 액티비티가 확실하게 메모리에서 제거되도록 하기 위해 임시로 ‘활동 유지 안함’ 옵션을 활성화했지만, 이 경우에는 성능 저하가 생길 수 있으므로 테스트가 끝나면 해당 옵션을 비활성화 하도록 한다. 홈 버튼 대신 백 버튼을 누르면 ‘활동 유지 안함’ 옵션과는 무관하게 항상 액티비티가 소멸된다는 사실을 알아두자. SIS와 액티비티 레코드 액티비티(프로세스)의 소멸에도 어떻게 onSaveInstanceState(Bundle)에 저장된 데이터가 존속할까? onSaveInstanceState(Bundle)이 호출될 때 데이터가 저장된 Bundle 객체는 안드로이드 운영체제에 의해 액티비티 레코드 activity record 로 저장되기 때문이다. 아래는 액티비티 레코드가 무엇인지 알기 위해 액티비티 생명주기에 보존 stashed 상태가 추가된 이미지이다. 완전한 액티비티 생명주기 액티비티가 보존 상태이면 액티비티 인스턴스는 존재하지 않지만, 액티비티 레코드 객체는 안드로이드 운영체제에 살아있다. 따라서 안드로이드 운영체제는 해당 액티비티 레코드를 사용해서 액티비티를 되살릴 수 있다. 액티비티는 onDestroy()가 호출되지 않고 보존 상태가 될 수 있다. 그러므로 장치에 이상이 생기지 않는 한, onStop()과 onSaveInstanceState(Bundle)이 호출되는 거에 의존해서 코드를 작성하면 된다. 일반적으로는 현재 액티비티에 속하는 작고 일시적인 상태 데이터를 Bundle 객체에 보존하기 위해 onSaveInstanceState(Bundle)을 오버라이드 한다. 그리고 지속해서 저장할 데이터(예로, 사용자가 입력/수정한 것)는 onStop()을 오버라이드해서 처리한다. 이 함수가 실행된 후에는 언제든 해당 액티비티가 소멸될 수 있기 때문이다. 그런데 액티비티 레코드는 언제 없어질까? 액티비티가 종료되면 액티비티 레코드도 같이 소멸된다. 액티비티 레코드는 장치가 다시 부팅될 때도 폐기된다. ViewModel vs SIS SIS에는 프로세스가 종료될 때는 물론이고, 장치의 구성 변경이 생길 때도 Bundle 객체를 사용해서 액티비티 레코드를 저장할 수 있다. 액티비티가 최초 실행될 때는 SIS의 Bundle 객체 참조가 null이다. 그리고 장치를 회전하면 안드로이드 운영체제가 현재 액티비티 인스턴스의 onSaveInstanceState(Bundle)을 호출하므로 보존할 상태 데이터를 이 함수에서 Bundle 객체에 저장할 수 있다. 그리고 이후에 새로운 액티비티 인스턴스가 생성되면 안드로이드 운영체제가 Bundle 객체에 저장된 상태 데이터를 onCreate(Bundle?)의 인자로 전달한다. 그렇다면 SIS만 사용해도 충분한데, GeoQuiz 앱에서는 굳이 ViewModel도 같이 사용할까? 사실 GeoQuiz 앱은 간단해서 SIS만 사용해도 된다. 그러나 대부분의 앱은 GeoQuiz처럼 작으면서 하드코딩된 데이터에 의존하지 않는다. 대신에 데이터베이스, 인터넷, 또는 둘 다로부터 동적인 데이터를 가져온다. 그리고 이런 작업은 비동기적이면서 느릴 수 있으며, 장치의 배터리나 네트워크 리소스를 많이 사용한다. 또한, 이런 작업을 액티비티 생명주기와 결속해서 처리하면 오류도 많이 생길 수 있다. ViewModel의 진가는 액티비티의 동적 데이터를 처리할 때 발휘된다. ViewModel은 장치의 구성 변경이 생겨도 다운로드 작업을 계속할 수 있게 해준다. 그리고 이미 알고 있듯이, 사용자가 액티비티를 끝내면 ViewModel은 자동으로 클린업이 된다. 하지만 프로세스가 종료되면 ViewModel이 처리하지 못한다. 자신이 가진 모든 것이 프로세스와 함께 메모리에서 완전히 제거되기 때문이다. SIS가 주목받는 이유가 바로 이 때문이다. 그런데 SIS에는 제약이 있다. SIS는 직렬화되어 serialized 디스크에 저장되므로 크거나 복잡한 객체를 저장하는 것은 피해야 한다. 그런데 구글 안드로이드 팀의 적극적인 ViewModel 개선 작업으로 lifecycle-viewmodel-savedstate 라이브러리가 새로 배포되었는데, 이 라이브러리는 프로세스가 종료될 때 ViewModel이 자신의 상태 데이터를 보존할 수 있게 해준다. 따라서 액티비티의 SIS와 더불어 ViewModel 사용할 때의 어려움을 덜어줄 것이다. 이제는 ViewModel이나 SIS 중 어느 것이 더 좋은가는 문제되지 않으므로 두 가지를 절충해서 사용하면 된다. UI 상태를 다시 생성하기 위해 필요한 소량의 정보를 저장할 때 -&gt; SIS 장치의 구성 변경이 생겨서 UI에 넣는데 필요한 많은 데이터에 빠르고 쉽게 접근하고자 메모리에 캐싱할 때 -&gt; ViewModel 프로세스가 종료된 후 액티비티 인스턴스가 다시 생성될 때는 SIS 데이터를 사용해서 ViewModel을 설정할 수 있다. 이렇게 하면 ViewModel과 액티비티가 절대 소멸되지 않는 것처럼 처리할 수 있다. 그런데 장치의 구성 변경 후에 SIS 데이터를 사용해서 ViewModel을 변경하면 앱에서 불필요한 작업을 하게 된다. 구성 변경 시에는 ViewModel이 메모리에 남아 있기 때문이다. 또한, ViewModel의 변경 작업으로 사용자가 기다리게 되거나 쓸데없이 리소스 배터라를 사용하게 된다. 이 문제를 해결하려면 ViewModel의 데이터를 변경하기 위해 더 많은 작업이 필요할 때는 ViewModel의 데이터 갱신이 필요한지 먼저 검사한 후에 데이터를 가져오는 작업을 수행하고 변경한다. 123456789class SomeFancyViewModel : ViewModel() { ... fun setCurrentIndex(index: Int) { if (index != currentIndex) { currentIndex = index // 현재의 문제를 데이터베이스에서 로드한다. } }} 여기서는 문제의 인덱스 값을 현재의 인덱스 값과 비교해서 다를 때만 해당 인덱스의 문제를 데이터베이스 등에서 새로 가져온다. 같으면 이미 문제를 갖고 있는 것이기 때문이다. 따라서 필요할 때만 ViewModel 데이터의 변경 작업이 수행된다. 장기간 저장하는 데이터의 경우에는 ViewModel이나 SIS 모두 해결책이 아니다. 따라서 액티비티의 상태와 무관하게 앱이 장치에 설치되어 있는 동안 계속 남아 있어야 할 데이터를 저장해야 한다면 다른 영구 저장소를 사용해야한다. 이때 데이터베이스와 shared preference를 사용할 수 있다. 섣부른 해결책 피하기 장치의 구성 변경으로 인한 앱의 결함(UI 상태 유실)을 앱 회전을 비활성화해서 해결하려는 시도는 장치 회전에 따른 문제는 해결하겠지만, 앱의 다른 결함을 일으키기 쉽다. 개발이나 테스트할 때는 잘 나타나지 않지만, 사용자는 틀림없이 생명주기와 관련해서 다음 두 가지 결함에 직면할 여지를 남기기 때문이다. 런타임 시에 생길 수 있는 구성 변경이 있다. 창 크기 조정이나 야간 모드 변경 등의 구성 변경이 예시이다. 물론 이런 구성 변경도 별도로 잡아내어 무시하거나 처리할 수 있을 것이다. 하지만 런타임 구성 변경에 따라 올바른 리소스를 자동 선택해주는 시스템의 기능을 비활성화시키기 때문에 나쁜 방법이다. 회전의 비활성화나 첫째 방법과 같은 구성 변경 처리는 프로세스 중단으로 인한 문제를 해결하지 못한다. 따라서 앱에서 필요해서 가로나 세로 방향으로 고정시키고 싶다고 하더라도 구성 변경과 프로세스 중단에 대비하는 코드를 여전히 작성해야 한다. 이를 위해선 ViewModel과 SIS를 잘 알아야 한다. Jetpack, AndroidX 그리고 아키텍처 컴포넌트 ViewModel을 포함하는 lifecycle-extensions와 lifecycle-viewmodel 라이브러리는 안드로이드 Jetpack 컴포넌트의 일부다. 줄여서 Jetpack이라고 하는 안드로이드 Jetpack 컴포넌트는 안드로이드 앱 개발을 더욱더 쉽게 하고자 구글이 만든 라이브러리의 모음이며, developer.android.com/jetpack에서 모든 Jetpack 라이브러리의 내역을 볼 수 있다. app 모듈의 build.gradle 파일에 해당 라이브러리의 의존성을 추가하면 어떤 Jetpack 라이브러리도 프로젝트에 포함시킬 수 있다. 각 Jetpack 라이브러리는 androidx 네임스페이스로 시작하는 패키지에 위치한다. 이러한 이유로 때로는 'AndroidX’와 'Jetpack’을 혼용하기도 한다. Jetpack 라이브러리는 기반(foundation), 아키텍처(architecture), 행동(behavior), UI의 네 가지 범주로 분류된다. 이 중에서 아키텍처 범주의 라이브러리들을 아키텍처 컴포넌트 architecture components 라고도 한다. ViewModel도 이런 아키텍처 컴포넌트 중 하나다. 다른 주요 아키텍처 컴포넌트는 Room, Data Binding, WorkManager가 있다. 일부 Jetpack 컴포넌트들은 완전히 새로운 것인 반면에, 다른 컴포넌트는 지원 라이브러리 support library로 불렸던 이전의 많은 라이브러리를 소수의 더 큰 라이브러리로 모아 놓은 것이다. 따라서 이제부터는 종전의 지원 라이브러리 대신 Jetpack(AndroidX) 버전을 사용한다.","link":"/2021/05/13/android-bnr-04/"},{"title":"[Android] Intent: 액티비티 간 데이터 전달","text":"액티비티 시작시키기 startActivity(Intent)는 시작시키고자 하는 액티비티에 대해 호출하는 static 함수라고 생각할지도 모르겠지만 그렇지 않다. 액티비티에서 startActivity(Intent)를 호출하면 이 호출은 안드로이드 운영체제에게 전달된다. 조금 더 구체적으로 말해서, startActivity(Intent) 호출은 ActivityManager라고 하는 안드로이드 운영체제의 컴포넌트로 전달된다. 그다음에 ActivityManager는 해당 액티비티의 인스턴스를 생성하고 이 인스턴스의 onCreate(Bundle?) 함수를 호출한다. 그렇다면 어떤 액티비티를 시작시킬지 ActivityManager가 어떻게 알 수 있을까? 이 정보는 Intent 매개변수에 있다. 인텐트로 통신하기 인텐트(intent) 는 컴포넌트가 운영체제와 통신하는 데 사용할 수 있는 객체다. 지금까지 보았던 컴포넌트는 액티비티뿐 activity이지만, 컴포넌트에는 서비스 service, 브로드캐스트 수신자 broadcast receiver, 콘텐츠 제공자 content provider도 있다. ※ 안드로이드 4대 컴포넌트 인텐트는 다목적 통신 도구로, 이것을 추상화한 Intent 클래스는 인텐트의 용도에 따라 서로 다른 생성자들을 제공한다. 여기서는 시작시킬 액티비티를 ActivityManager에 알려주려고 인텐트를 사용한다. 따라서 다음 생성자를 사용한다. 1Intent(packageContext: Context, class: Class&lt;?&gt;) CheatActivity 클래스를 인자로 받는 Intent 객체를 생성하고 이 인텐트를 startActivity(Intent) 인자로 전달하는 코드를 cheatButton의 리스너 내부에 추가한다. MainActiviy에서 CheatActivity 시작시키기 12345cheatButton.setOnClickListener { // CheatActivity를 시작시킨다 val intent = Intent(this, CheatActivity::class.java) startActivity(intent)} Intent 생성자에게 전달하는 Class 인자에는 ActivityManager가 시작시켜야 하는 액티비티 클래스를 지정한다. 여기서 Context 인자는 이 액티비티 클래스가 있는 애플리케이션 패키지를 ActivityManager에게 알려준다. 액티비티를 시작시키기에 앞서, ActivityManager는 시작시킬 액티비티 클래스가 매니페스트의 activity 요소에 선언되어 있는지 확인한다. 만일 선언되어 있다면 해당 액티비티를 시작시키고, 선언되어 있지 않으면 ActivityNotFoundException이 발생되고 앱 실행이 중단된다. 모든 액티비티가 반드시 매니페스트에 선언되어야 하는 이유가 바로 이 때문이다. 명시적 인텐트와 암시적 인텐트 Context 객체와 Class 객체를 사용해서 생성하는 Intent는 명시적(explicit) 인텐트다. 명시적 인텐트는 앱 내부에 있는 액티비티를 시작시키기 위해 사용한다. 같은 앱 내부에 있는 두 개의 액티비티가 앱 외부의 ActivityManager를 통해서 통신하는 것이 이상하게 보일 수 있다. 그렇지만 이렇게 하면 한 애플리케이션의 액티비티가 다른 애플리케이션의 액티비티와 함께 동작하는 것이 쉬워진다. 한 애플리케이션의 액티비티에서 다른 애플리케이션의 액티비티를 시작시키려면 암시적(implicit) 인텐트를 생성한다. 액티비티 간의 데이터 전달 MainActivity와 CheatActivity 간의 통신 인텐트 엑스트라 사용하기 엑스트라는 호출하는 액티비티가 인텐트에 포함시킬 수 있는 임의의 데이터로, 생성자 인자로 생각할 수 있다(액티비티 인스턴스는 안드로이드 운영체제에 의해 생성되고 그 생명주기가 관리된다). 요청된 인텐트는 안드로이드 운영체제가 받아서 수신 액티비티에 전달한다. 그다음에 수신 액티비티는 해당 인텐트의 엑스트라로 전달된 데이터를 추출해 사용한다. 엑스트라는 키와 값이 한 쌍으로 된 구조로, MainActivity.onSaveInstanceState(Bundle)에서 currentIndex의 값을 저장하기 위해 사용했던 Bundle 객체의 구조와 동일하다. 인텐트에 엑스트라를 추가할 때는 Intent.putExtra(...) 를 사용하며, 주로 putExtra(name: String, value: Boolean)을 호출한다. Intent.putExtra(...)는 여러 형태로 오버로딩되어 있지만 항상 두 개의 인자를 갖는다. 첫 번째 인자는 항상 String 타입이며 엑스트라로 저장할 데이터 항목의 키를 나타낸다. 두 번째 인자는 이 키의 값을 나타내며, 다양한 타입으로 오버로딩되어 있다. 엑스트라 상수 추가하기 12345private const val EXTRA_ANSWER_IS_TRUE = &quot;com.june0122.geoquiz.answer_is_true&quot;class CheatActivity : AppCompatActivity() { ...} 액티비티 코드는 여러 곳에서부터 시작될 수 있다. 따라서 엑스트라 키는 엑스트라의 데이터를 읽어서 사용하는 액티비티에 정의해야 한다. 이때 위의 코드처럼 엑스트라의 키 값에 패키지 이름을 사용하면 다른 앱의 엑스트라와의 충돌 방지가 가능하다. 다음으로 MainActivity로 돌아가서 인텐트에 엑스트라를 쓰는 코드를 추가해야 한다. 그런데 더 좋은 방법이 있다. MainActivity나 앱의 다른 코드에서는 CheatActivity가 인텐트의 엑스트라로 무엇을 받는지 알 필요가 없다. 따라서 CheatActivity의 실행의 위해 인텐트를 요청하는 코드를 별도의 함수로 캡슐화하면 좋다. 아래와 같이 CheatActivity에 newIntent(...) 함수를 동반 객체 companion object 내부에 둔다. CheatActivity의 newIntent(...) 함수 추가하기 1234567891011121314class CheatActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { ... } companion object { fun newIntent(packageContext: Context, answerIsTrue: Boolean): Intent { return Intent(packageContext, CheatActivity::class.java).apply { putExtra(EXTRA_ANSWER_IS_TRUE, answerIsTrue) } } }} 이 함수에서는 CheatActivity가 필요로 하는 엑스트라 데이터를 갖는 인텐트를 생성한다. Boolean 타입의 answerIsTrue 인자는 EXTRA_ANSWER_IS_TRUE 상수 값을 키로 갖도록 엑스트라에 저장된다. 이처럼 동반 객체를 사용하면 클래스 인스턴스를 생성하지 않고 동반 객체의 함수를 사용할 수 있다. (java의 static 메서드와 유사) 따라서 아래에 나올 코드에서 CheatActivity.newIntent(this@MainActivity, answerIsTrue)처럼 동반 객체를 포함하는 클래스 이름을 사용해서 동반 객체의 함수를 호출할 수 있다. 또한, 동반 객체를 포함하는 클래스에서는 동반 객체를 자신의 멤버인 것처럼 인식하므로 편리하다. 엑스트라를 갖는 인텐트로 CheatActivity 시작시키기 (MainActivity.kt) 123456cheatButton.setOnClickListener { // val intent = Intent(this, CheatActivity::class.java) val answerIsTrue = quizViewModel.currentQuestionAnswer val intent = CheatActivity.newIntent(this@MainActivity, answerIsTrue) startActivity(intent)} 여기서는 엑스트라 하나만 있으면 되지만, 필요하다면 newIntent(...) 함수에 더 많은 인자를 추가하여 Intent 하나에 여러 개의 엑스트라를 쓸 수 있다. 아래의 이미지와 같이 다양한 타입의 값을 엑스트라에 넣고 추출할 수 있다. 다음으로 CheatActivity 클래스의 onCreate(Bundle?) 함수에 코드를 추가한다. 이 코드에서는 인텐트로 전달된 엑스트라의 값을 추출해 클래스 속성에 저장한다. 엑스트라 사용하기 123456789101112class CheatActivity : AppCompatActivity() { private var answerIsTrue = false override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_cheat) answerIsTrue = intent.getBooleanExtra(EXTRA_ANSWER_IS_TRUE, false) } ...} Activity.intent는 항상 액티비티를 시작시켰던 Intent 객체를 반환한다. 이 Intent 객체는 startActivity(Intent)를 호출할 때 인자로 전달되었던 객체다. 여기서 intent 대신 자바 스타일로 getIntent()를 사용해도 되지만 코틀린에서는 클래스 속성의 값을 가져올 떄 게터(getter)를 사용하지 않아도 된다. 속성을 참조할 때 자동으로 게터를 호출해주기 때문이다. 엑스트라에서 추출한 값을 사용하도록 CheatActiviy에 코드 추가 1234567891011121314151617181920212223class CheatActivity : AppCompatActivity() { private lateinit var answerTextView: TextView private lateinit var showAnswerButton: Button private var answerIsTrue = false override fun onCreate(savedInstanceState: Bundle?) { ... answerIsTrue = intent.getBooleanExtra(EXTRA_ANSWER_IS_TRUE, false) answerTextView = findViewById(R.id.answer_text_view) showAnswerButton = findViewById(R.id.show_answer_button) showAnswerButton.setOnClickListener { val answerText = when { answerIsTrue -&gt; R.string.true_button else -&gt; R.string.false_button } answerTextView.setText(answerText) } } ...} 자식 액티비티로부터 결과 돌려받기 자식 액티비티로부터 데이터를 돌려받고 싶다면 Activity.startActivityForResult(Intent, Int) 함수를 호출한다. 첫 번째 매개변수는 종전과 동일한 Intent 객체다. 두 번째 매개변수는 요청 코드(request code) 로 사용자가 정의한 정수다. 요청 코드는 자식 액티비티에 전달되었다가 부모 액티비티가 다시 돌려받으며 부모 액티비티가 여러 타입의 자식 액티비티들을 시작시킬 때 어떤 자식 액티비티가 결과글 돌려주는 것인지 알고자 할 때도 사용된다. 현재 MainActivity는 한 가지 타입의 자식 액티비티만 시작시키지만, 향후를 대비해서 요청 코드의 상수 값을 사용하는 것이 좋다. MainActivity에서 startActivityForResult(Intent, Int)를 호출하기 123456789101112131415161718private const val TAG = &quot;MainActivity&quot;private const val KEY_INDEX = &quot;index&quot;private const val REQUEST_CODE_CHEAT = 0class MainActivity : AppCompatActivity() { ... override fun onCreate(savedInstanceState: Bundle?) { ... cheatButton.setOnClickListener { ... // startActivity(intent) startActivityForResult(intent, REQUEST_CODE_CHEAT) } updateQuestion() } ...} 결과 데이터 설정하기 부모 액티비티에 데이터를 돌려주기 위해 자식 액티비티에서 호출하는 함수에는 다음 두 가지가 있다. 12setResult(resultCode: Int)setResult(resultCode: Int, data: Intent) 일반적으로 결과 코드(result code) 는 사전 정의된 두 개의 상수, 즉 Activity.RESULT_OK (정수 -1), 또는 Activity.RESULT_CANCELED (정수 0) 중 하나다 (결과 코드를 정의할 때 RESULT_FIRST_USER(정수 1) 상수도 사용할 수 있다.). 자식 액티비티가 어떻게 끝났는지에 따라 부모 액티비티에서 다른 액션을 취할 때 결과 코드를 사용하면 유용하다. 예를 들어, 자식 액티비티가 OK 버튼과 Cancel 버튼을 갖고 있고, 둘 중 어떤 버튼이 눌러졌는가에 따라 자식 액티비티가 결과 코드 값을 다르게 설정한다고 해보자. 그러면 부모 액티비티는 해당 결과 코드 값에 따라 다른 액션을 취할 수 있다. 자식 액티비티에서는 setResult(...)를 호출하지 않을 수도 있다. 부모 액티비티에서 어떤 결과 코드인지 구분할 필요가 없거나 인텐트의 데이터를 받을 필요가 없다면, 안드로이드 운영체제가 기본 결과 코드를 전달하게 할 수 있다. 자식 액티비티가 startActivityForResult(...)로 시작되었다면 결과 코드는 항상 부모 액티비티에 반환된다. 이때 자식 액티비티에서 setResult(...)를 호출하지 않은 상태에서 사용자가 장치의 백 버튼을 누르면 부모 액티비티는 결과 코드로 Activity.RESULT_CANCELED를 받게 된다. 인텐트 돌려주기 자식 액티비티가 부모 액티비티에 인텐트의 엑스트라를 돌려줄 수도 있다. 여기서는 엑스트라를 부모 액티비티인 MainActivity에 전달하는 것이 주 관심사다. 따라서 Intent를 생성하고 엑스트라를 저장한 후 Activity.setResult(Int, Intent)를 호출해 부모인 MainActivity에서 엑스트라 데이터를 받게 한다. 앞에서 CheatActivity가 받는 엑스트라 키의 상수를 CheatActivity에 정의했으니, 자식인 CheatActivity가 부모인 MainActivity에 전달할 새로운 엑스트라도 그것처럼 하면 된다. 결과 설정하기 엑스트라의 키로 사용할 상수를 CheatActivity에 추가 인텐트를 생성해 거기에 엑스트라를 저장 결과 코드를 설정하는 private 함수 추가 ‘정답 보기’ 버튼의 리스너에 이 함수의 호출 코드를 추가 12345678910111213141516171819202122const val EXTRA_ANSWER_SHOWN = &quot;com.june0122.geoquiz.answer_shown&quot;private const val EXTRA_ANSWER_IS_TRUE = &quot;com.june0122.geoquiz.answer_is_true&quot;class CheatActivity : AppCompatActivity() { ... override fun onCreate(savedInstanceState: Bundle?) { ... showAnswerButton.setOnClickListener { ... answerTextView.setText(answerText) setAnswerShownResult(true) } } private fun setAnswerShownResult(isAnswerShown: Boolean) { val data = Intent().apply { putExtra(EXTRA_ANSWER_SHOWN, isAnswerShown) } setResult(Activity.RESULT_OK, data) } ...} 사용자가 정답 보기 버튼(showAnswerButton)을 누르면 CheatActivity는 setResult(Int, Intent)를 호출하기 위해 인텐트를 생성하고 결과 코드를 추가한다. 그리고 사용자가 장치의 백 버튼을 눌러서 다시 MainActivity로 돌아가면 ActivityManager가 부모 액티비티인 MainActivity의 다음 함수를 호출한다. 1onActivityResult(requestCode: Int, resultCode: Int, data: Intent) 여기서 첫 번째 매개변수는 MainActivity에서 전달했던 요청 코드다. 나머지 매개변수인 결과 코드와 인텐트는 자식 액티비티인 CheatActivity의 setResult(Int, Intent)로 전달되었던 것들이다. 아래는 이러한 상호작용을 보기 쉽게 시퀀스 다이어그램으로 정리한 이미지이다. GeoQuiz의 시퀀스 다이어그램 이제는 CheatActivity에서 설정한 결과 데이터를 처리하기 위해 MainActivity에서 onActivityResult(Int, Int, Intent)를 오버라이딩하여 구현하는 것만 남았다. 결과 데이터 처리하기 CheatActivity가 돌려주는 값을 저장하는 새로운 속성을 QuizViewModel.kt에 추가한다. 사용자의 커닝 상태(커닝 여부를 나타내는 데이터)는 UI 상태의 일부다. 따라서 사용자의 커닝 상태는 MainActivity 대신 QuizViewModel에서 보존해야 한다. 이렇게 하면 액티비티 소멸이 아닌 구성 변경 시에 계속 보존되기 때문이다. QuizViewModel에 사용자 커닝 상태 보존하기 123456class QuizViewModel : ViewModel() { var currentIndex = 0 var isCheater = false // 사용자 커닝 상태를 보존할 변수 추가 ...} 그다음에 CheatActivity가 돌려주는 결과 값을 가져오기 위해 MainActivity.kt에서 onActivityResult(...)를 오버라이드한다. 이때 요청 코드와 결과 코드가 기대한 값인지 확인한다. 이렇게 하면 코드의 유지 보수가 쉬워진다. 특히, 인텐트로 시작시키는 자식 액티비티의 종류가 늘어났을 때 아주 유용하다. onActivityResult(...) 오버라이드하기 1234567891011121314151617181920class MainActivity : AppCompatActivity() { ... override fun onCreate(savedInstanceState: Bundle?) { ... } override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) if (resultCode != Activity.RESULT_OK) { return } if (requestCode == REQUEST_CODE_CHEAT) { quizViewModel.isCheater = data?.getBooleanExtra(EXTRA_ANSWER_SHOWN, false) ?: false } } ...} 마지막으로 사용자가 정답을 커닝했는지 여부를 확인하고 그에 따른 적절한 응답을 주기 위해 MainActivity의 checkAnswer(Boolean) 함수를 수정한다. isCheater 값에 따라 토스트 메시지 변경하기 123456789101112131415161718192021class MainActivity : AppCompatActivity() { ... private fun checkAnswer(userAnswer: Boolean) { val correctAnswer = quizViewModel.currentQuestionAnswer// val messageResId = if (userAnswer == correctAnswer) {// R.string.correct_toast// } else {// R.string.incorrect_toast// } val messageResId = when { quizViewModel.isCheater -&gt; R.string.judgment_toast userAnswer == correctAnswer -&gt; R.string.correct_toast else -&gt; R.string.incorrect_toast } Toast.makeText(this, messageResId, Toast.LENGTH_SHORT) .show() }} 챌린지 장치 회전과 프로세스 종료 시 CheatActivity의 UI 상태 보존하기 사용자가 정답을 커닝한 후에 CheatActivity 화면에서 장치를 회전해서 커닝 결과를 지울 수 있다. 그리고 MainActivity로 돌아오면 전혀 커닝하지 않은 것처럼 되는 문제를 해결해보자. CheatActivity.kt by lazy 키워드를 사용하여 quizViewModel을 선언한다. Bundle 객체에 저장될 데이터의 키로 사용할 상수 KEY_CHEAT_STATUS를 추가한다. onSaveInstanceState(Bundle)을 오버라이드한다. isCheater 값을 Bundle 객체에 저장시킨다. 이때 키는 상수인 KEY_CHEAT_STATUS이며 키의 값은 quizViewModel.isCheater다. onCreate(Bundle?)에서 Bundle 객체 값을 확인한다. Bundle 객체에 저장된 값을 확인해 값이 있으면 그 값을 quizViewModel.isCheater에 지정한다. 키가 Bundle 객체에 없거나 Bundle 객체 참조가 null이면 cisCheater의 값을 false으로 설정한다. updateAnswer() 함수를 작성하여 onCreate(Bundle?) 함수와 정답 보기 버튼의 리스너 내부에서 호출한다. updateAnswer()에선 커닝을 했을 경우 (quizViewModel.isCheater == true) QuizViewModel로부터 커닝에 대한 답을 가져오고, answerTextView에 보일 값을 설정한다. 그리고 부모 액티비티에 데이터를 돌려주기 위해 자식 액티비티에서 호출하는 함수 setResult(...)가 포함된 함수 setAnswerShownResult를 updateAnswer() 함수의 마지막에 호출한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152...private const val KEY_CHEAT_STATUS = &quot;cheat&quot; // ② Bundle 객체에 저장될 데이터의 키로 사용될 상수 선언class CheatActivity : AppCompatActivity() { ... private val quizViewModel: QuizViewModel by lazy { // ① quizViewModel을 선언 ViewModelProvider(this).get(QuizViewModel::class.java) } private var answerIsTrue = false override fun onCreate(savedInstanceState: Bundle?) { ... // ④ Bundle 객체 값 확인 val isCheater = savedInstanceState?.getBoolean(KEY_CHEAT_STATUS, false) ?: false quizViewModel.isCheater = isCheater ... // ⑥ 정답 보기 버튼 클릭 시, quizViewModel의 isCheater 값을 true로 변경하고 updateAnswer() 호출 showAnswerButton.setOnClickListener { quizViewModel.isCheater = true updateAnswer() } // ⑦ 액티비티 생성 시 updateAnswer() 호출 updateAnswer() } // ③ `onSaveInstanceState(Bundle)`을 오버라이드 override fun onSaveInstanceState(savedInstanceState: Bundle) { super.onSaveInstanceState(savedInstanceState) savedInstanceState.putBoolean(KEY_CHEAT_STATUS, quizViewModel.isCheater) } // ⑤ updateAnswer() 함수를 작성 private fun updateAnswer() { if (quizViewModel.isCheater) { val questionTextResId = when { quizViewModel.currentQuestionAnswer -&gt; R.string.true_button else -&gt; R.string.false_button } answerTextView.setText(questionTextResId) setAnswerShownResult(true) } } private fun setAnswerShownResult(isAnswerShown: Boolean) { val data = Intent().apply { putExtra(EXTRA_ANSWER_SHOWN, isAnswerShown) } setResult(Activity.RESULT_OK, data) } ...} 문제마다 커닝 여부 관리하기 QuizViewModel.kt 커닝 여부를 저장하는 MutableList인 cheatStatusList를 questionBank의 크기만큼 false로 초기화한다. 커스텀 접근자를 통해 cheatStatusList의 커닝 여부 값을 가져오고 저장할 수 있는 연산 프로퍼티 currentQuestionCheatStatus를 추가한다. 12345678910111213141516171819202122232425class QuizViewModel : ViewModel() { var currentIndex = 0 private val questionBank = listOf( Question(R.string.question_australia, true), Question(R.string.question_oceans, true), Question(R.string.question_mideast, false), Question(R.string.question_africa, false), Question(R.string.question_americas, true), Question(R.string.question_asia, true) ) private val cheatStatusList = MutableList(questionBank.size) { false } ... var currentQuestionCheatStatus: Boolean get() = cheatStatusList[currentIndex] set(value) { cheatStatusList[currentIndex] = value } ...} MainActivity.kt requestCode가 REQUEST_CODE_CHEAT일 때, quizViewModel.isCheater 대신 quizViewModel.currentQuestionCheatStatus의 값을 변경한다. 마찬가지로 checkAnswer 함수에서 quizViewModel.isCheater 대신 quizViewModel.currentQuestionCheatStatus, 즉 커닝 여부가 True일 때 경고성 토스트를 보여주도록 변경한다. 1234567891011121314151617181920212223242526class MainActivity : AppCompatActivity() { ... override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) ... if (requestCode == REQUEST_CODE_CHEAT) {// quizViewModel.isCheater = ... 을 아래의 코드로 변경 quizViewModel.currentQuestionCheatStatus = data?.getBooleanExtra(EXTRA_ANSWER_SHOWN, false) ?: false } } ... private fun checkAnswer(userAnswer: Boolean) { val correctAnswer = quizViewModel.currentQuestionAnswer val messageResId = when {// quizViewModel.isCheater -&gt; R.string.judgment_toast quizViewModel.currentQuestionCheatStatus -&gt; R.string.judgment_toast userAnswer == correctAnswer -&gt; R.string.correct_toast else -&gt; R.string.incorrect_toast } ... }} 참고 실무에 바로 적용하는 안드로이드 프로그래밍(제4판) : CHAPTER 6 코드","link":"/2021/05/17/android-bnr-06/"},{"title":"[Android] RecyclerView","text":"본문에서 예시로 설명할 앱 CriminalIntent의 객체 다이어그램 새로운 프래그먼트 및 ViewModel 추가하기 CrimeListViewModel 1234567891011121314class CrimeListViewModel: ViewModel() { val crimes = mutableListOf&lt;Crime&gt;() // 모의 데이터 채우기 init { for (i in 0 until 100) { val crime = Crime() crime.title = &quot;Crime #$i&quot; crime.isSolved = i % 2 == 0 crimes += crime } }} CrimeListFragment 생성 및 구현 12345678910111213141516171819private const val TAG = &quot;CrimeListFragment&quot;class CrimeListFragment: Fragment() { private val crimeListViewModel: CrimeListViewModel by lazy { ViewModelProvider(this).get(CrimeListViewModel::class.java) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) Log.d(TAG, &quot;Total crimes: ${crimeListViewModel.crimes.size}&quot;) } companion object { fun newInstance() : CrimeListFragment { return CrimeListFragment() } }} 동반 객체에서 정의된 newInstance() 함수에서는 CrimeListFragment 인스턴스를 생성하고 반환한다. 이때 newInstance() 함수는 CrimeListFragment 클래스의 인스턴스를 생성하지 않고 호출할 수 있다. 자바의 static 메서드와 유사 따라서 액티비티에서 CrimeListFragment 인스턴스를 생성하려면 newInstance() 함수를 호출하면 된다. 프래그먼트에 사용되는 ViewModel 생명주기 [Android] ViewModel과 SIS에서 액티비티와 함께 사용되는 ViewModel의 생명주기를 알아보았다. 그런데 ViewModel이 프래그먼트와 같이 사용되면 생명주기가 약간 달라진다. 이때도 두 개의 상태 ('생성됨’또는 ‘소멸되어 존재하지 않음’)만 갖는 것은 동일하나, 액티비티 대신 프래그먼트의 생명주기와 결합된다. 다시 말해, 프래그먼트의 뷰가 화면에 나타나 있는 한 ViewModel은 활성화된 상태를 유지하며, 장치 회전 시에도 유지되어 새로 생성된 프래그먼트 인스턴스가 이어서 사용할 수 있다. ViewModel은 프래그먼트가 소멸할 때 같이 소멸한다. 예를 들어, 사용자가 백 버튼을 누르거나 호스팅 액티비티가 프래그먼트를 다른 것으로 교체할 때 해당 액티비티가 화면에 나타나 있더라도 프래그먼트 및 이것과 연관된 ViewModel은 더 이상 필요 없으므로 소멸한다. 한 가지 특별한 경우는 프래그먼트 트랜잭션을 백 스택에 추가할 때다. 만일 액티비티가 현재 프래그먼트를 다른 것으로 교체할 때 트랜잭션이 백 스택에 추가된다면 해당 프래그먼트 인스턴스와 이것의 ViewModel은 소멸되지 않는다. 따라서 사용자가 백 버튼을 누르면 프래그먼트 트랜잭션이 역으로 수행되어 교체되기 전의 프래그먼트 인스턴스가 다시 화면에 나타나고 ViewModel의 모든 데이터는 보존된다. 프래그먼트 트랜잭션을 사용해서 CrimeListFragment 추가하기 CrimeFragment 대신 CrimeListFragment의 인스턴스를 호스팅하도록 변경 1234567891011121314151617class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { ... val currentFragment = supportFragmentManager.findFragmentById(R.id.fragment_container) if (currentFragment == null) {// val fragment = CrimeFragment() val fragment = CrimeListFragment.newInstance() supportFragmentManager .beginTransaction() .add(R.id.fragment_container, fragment) .commit() } }} 현재는 MainActivity가 항상 CrimeListFragment를 보여주도록 하드코딩되어 있지만, 후에는 사용자가 앱 화면을 이동하는 것에 따라 MainActivity가 CrimeListFragment와 CrimeFragment를 상호 교체하도록 변경할 것이다. RecyclerView 추가하기 RecyclerView 클래스는 다른 Jetpack 라이브러리에 있어서 사용하려면 우선 RecyclerView 라이브러리 의존성을 app/build.gradle 파일에 추가해야 한다. RecyclerView 의존성 추가하기 123456dependencies { ... implementation 'androidx.lifecycle:lifecycle-extensions:2.2.0' implementation 'androidx.recyclerview:recyclerview:1.2.0' ...} RecyclerView를 레이아웃 파일에 추가하기 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.recyclerview.widget.RecyclerView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/crime_recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; CrimeListFragment의 뷰가 준비되었으니 이 뷰를 프래그먼트와 연결한다. CrimeListFragment의 뷰 설정하기 1234567891011121314151617181920212223class CrimeListFragment: Fragment() { private lateinit var crimeRecyclerView: RecyclerView private val crimeListViewModel: CrimeListViewModel by lazy { ViewModelProvider(this).get(CrimeListViewModel::class.java) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) Log.d(TAG, &quot;Total crimes: ${crimeListViewModel.crimes.size}&quot;) } override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { val view = inflater.inflate(R.layout.fragment_crime_list, container, false) crimeRecyclerView = view.findViewById(R.id.crime_recycler_view) as RecyclerView crimeRecyclerView.layoutManager = LinearLayoutManager(context) return view } ...} RecyclerView가 생성된 후에는 곧바로 LayoutManager를 설정해야 하며, 여기서는 LinearLayoutManager를 설정했다. 만일 설정하지 않으면 RecyclerView가 작동하지 않는다. RecyclerView는 항목들을 화면에 위치시키는 일을 직접하지 않고 LayoutManager에게 위임한다. 그러면 LayoutManager는 모든 항목들의 화면 위치를 처리하고 스크롤 동작도 정의한다. 따라서 LayoutManager가 설정되지 않으면 RecyclerView의 작동이 바로 중단된다. LayoutManager는 안드로이드 프레임워크에 내장된 것 중 하나를 선택할 수 있으며, 서드파티 라이브러리의 것도 사용할 수 있다. 여기서는 LinearLayoutManager를 사용했는데, 이것은 리스트의 항목들을 수직 방향으로 배치한다. 이 책 후반부에서는 GridLayoutManager를 사용해서 격자 형태로 항목들을 배치할 것이다. 항목 뷰 레이아웃 생성하기 RecyclerView는 ViewGroup의 서브 클래스이며, 항목 뷰(item view) 라고 하는 자식 View 객체들의 리스트를 보여준다. 각 itemView는 RecyclerView의 행으로 나타나며 데이터 저장소에서 가져온 하나의 객체를 나타낸다. 객체가 갖는 데이터 중에서 어떤 것들을 화면에 보여주는가에 따라 항목 View가 복잡해질 수도 있고 간단할 수도 있다. 자식 뷰를 갖는 RecyclerView 한 행으로 보이는 RecyclerView의 각 항목은 자신의 뷰 계층 구조를 가질 수 있다. 여기서는 각 항목의 View 객체가 두 개의 TextView를 포함하는 LinearLayout이 된다. 리스트 항목 레이아웃 변경하기 (layout/list_item_crime.xml) 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;8dp&quot;&gt; &lt;TextView android:id=&quot;@+id/crime_title&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Crime Title&quot;/&gt; &lt;TextView android:id=&quot;@+id/crime_date&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Crime Date&quot;/&gt;&lt;/LinearLayout&gt; ViewHolder 구현하기 RecyclerView는 항목 View가 ViewHolder 인스턴스에 포함되어 있다고 간주한다. ViewHolder는 항목 View의 참조를 갖는다. RecyclerView.ViewHolder의 서브 클래스인 CrimeHolder를 CrimeListFragment의 내부 클래스로 정의하자. 초기 버전의 CrimeHolder (CrimeListFragment) 1234567891011class CrimeListFragment: Fragment() { ... override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ... } private inner class CrimeHolder(view: View) : RecyclerView.ViewHolder(view) { } ...} ViewHolder와 이것의 itemView 속성 CrimeHolder의 생성자는 항목 View를 인자로 받으며, CrimeHolder 인스턴스가 생성될 대 이 View는 슈퍼 클래스인 RecyclerView.ViewHolder의 생성자 인자로 전달된다. 그리고 RecyclerView.ViewHolder 슈퍼 클래스로부터 상속받은 itemView 속성이 생성자로 전달된 항목 View의 참조를 갖는다. RecyclerView는 자체적으로 View를 생성하지 않으며, 항상 항목 View를 참조하는 ViewHolder를 생성한다. ViewHolder itemView가 참조하는 항목 View가 간단할 때는 ViewHolder가 할 일이 적다. 그러나 복잡해지면 ViewHolder가 항목 View의 서로 다른 부분(자식 View)을 Crime 객체에 더 쉽고 효율적으로 연결해준다. ViewHolder의 인스턴스가 처음 생성될 때 항목 View에 포함된 TextView의 참조를 알아내어 속성에 저장하도록 CrimeHolder를 변경한다. 항목 View의 TextView 참조를 속성에 저장하기 1234private inner class CrimeHolder(view: View) : RecyclerView.ViewHolder(view) { val titleTextView: TextView = itemView.findViewById(R.id.crime_title) val dateTextView: TextView = itemView.findViewById(R.id.crime_date)} 여기서 CrimeHolder의 기본 생성자에 정의된 인자 겸 속성인 view는 itemView 속성과 동일한 항목 View의 참조 값을 갖는다. 따라서 새로 추가한 코드에서 itemView 대신 view를 사용해도 된다. 이제는 변경된 CrimeHolder가 항목 View의 TextView들에 대한 참조를 보존할 수 있으므로 이 TextView들의 값을 쉽게 보여줄 수 있게 되었다. 그런데 CrimeHolder의 인스턴스는 누가 또는 어디서 생성하는 것일까? 어댑터를 구현해 RecyclerView에 데이터 채우기 ViewHolder 이미지에 간단하게 나타나 있지만, RecyclerView는 자신이 ViewHolder를 생성하지 않는다. 대신에 이 일을 어댑터(adapter) 에 요청한다. 어댑터는 컨트롤러 객체로, RecyclerView와 RecyclerView가 보여줄 데이터 사이에 위치한다. Adapter는 다음의 일을 처리한다. 필요한 ViewHolder 인스턴스들을 생성한다. 모델 계층의 데이터를 ViewHolder들과 바인딩한다. 그리고 RecyclerView는 다음의 일을 처리한다. 새로운 ViewHolder 인스턴스의 생성을 어댑터에게 요청한다. 지정된 위치의 데이터 항목에 ViewHolder를 바인딩하도록 어댑터에게 요청한다. 이제는 어댑터를 생성할 때가 되었다. 아래의 코드와 같이 CrimeAdapter라는 이름의 내부 클래스를 CrimeListFragment에 추가하고 RecyclerView.Adapter의 서브 클래스로 지정한다. 그리고 Crime 객체가 저장된 List를 인자로 받아 crimes 속성에 저장하는 기본 생성자도 추가한다. CrimeAdapter 생성하기 1234567891011121314151617181920212223242526class CrimeListFragment: Fragment() { ... private inner class CrimeHolder(view: View) : RecyclerView.ViewHolder(view) { ... } private inner class CrimeAdapter(var crimes: List&lt;Crime&gt;) : RecyclerView.Adapter&lt;CrimeHolder&gt;() { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): CrimeHolder { val view = layoutInflater.inflate(R.layout.list_item_crime, parent, false) return CrimeHolder(view) } override fun getItemCount(): Int = crimes.size override fun onBindViewHolder(holder: CrimeHolder, position: Int) { val crime = crimes[position] holder.apply { titleTextView.text = crime.title dateTextView.text = crime.date.toString() } } } ...} Adapter.onCreateViewHolder(...)는 보여줄 뷰 (여기서는 list_item_view.xml)를 인플레이트한 후 이 뷰를 처리하는 ViewHolder (여기서는 CrimeHolder) 인스턴스를 생성하고 반환한다. onCreateViewHolder(...)의 매개변수는 서로 다른 타입의 뷰를 보여줄 때 필요한데, 아래 RecyclerView의 ViewType에서 볼 수 있다. Adapter.onBindViewHolder(holder: CrimeHolder, position: Int)는 인자로 전달된 위치에 있는 Crime 객체의 범좌 제목과 발생일자를 CrimeHolder 인스턴스가 참조하는 TextView의 text 속성에 지정한다. 여기서는 Crime 객체가 List에 저장되어 있으므로 인자로 전달된 위치가 List 인덱스로 사용된다. 데이터가 저장된 데이터 셋에 몇 개의 데이터가 있는지 RecyclerView가 알아야 할 때 Adapter.getItemCount()를 호출해 어댑터에게 요청한다. 여기서는 getItemCount()가 List에 저장된 Crime 객체의 수를 반환한다. 화면에 보여줄 Crime 객체 또는 이 객체가 저장된 List를 RecyclerView는 모르며, CrimeAdapter가 안다. CrimeAdapter는 RecyclerView와 List&lt;Crime&gt; 사이에 위치 RecyclerView는 화면에 보여줄 뷰 객체가 필요하면 자신과 연관된 Adapter에게 요청한다. RecyclerView와 CrimeAdapter 간의 소통 과정 RecyclerView는 CrimeAdapter의 onCreateViewHolder(ViewGroup, Int) 함수를 호출해 CrimeHolder 인스턴스를 생성한다. 이때 화면에 보여줄 항목 View를 생성자 인자로 전달한다. 그러나 CrimeAdapter가 생성해 RecyclerView에게 반환하는 CrimeHolder (그리고 이것의 itemView 속성)는 아직 데이터가 바인딩되지 않았다. 그런 다음에 RecyclerView는 CrimeAdapter의 onBindViewHolder(ViewHolder, Int) 함수를 호출한다. 이때 CrimeHolder의 데이터 셋 내부의 Crime 객체 위치를 인자로 전달한다. 그리고 CrimeAdapter는 이 함수에서 해당 위치의 모델 데이터인 Crime 객체를 찾아 이것을 CrimeHolder의 항목 View와 바인딩(binding) 즉, Crime 객체의 데이터를 항목 View에 채운다. RecyclerView의 어댑터 설정하기 이제는 어댑터가 준비되었으니 RecyclerView에 연결해야 한다. CrimeListFragment의 UI를 설정하는 updateUI 함수를 구현할 것인데, 지금은 이 함수에서 CrimeAdapter를 생성해 RecyclerView에 설정한다. 어댑터 설정하기 123456789101112131415161718192021222324class CrimeListFragment: Fragment() { private lateinit var crimeRecyclerView: RecyclerView private var adapter: CrimeAdapter? = null ... override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { val view = inflater.inflate(R.layout.fragment_crime_list, container, false) crimeRecyclerView = view.findViewById(R.id.crime_recycler_view) as RecyclerView crimeRecyclerView.layoutManager = LinearLayoutManager(context) updateUI() return view } private fun updateUI() { val crimes = crimeListViewModel.crimes adapter = CrimeAdapter(crimes) crimeRecyclerView.adapter = adapter } ...} 맨 끝에 추가한 crimeRecyclerView.adapter에서 adapter는 RecyclerView의 속성이다. 코틀린에서는 속성의 값을 보존하는 필드를 내부적으로 유지하는데, 이것을 후원 필드 backing field라고 한다. 또한, 필드의 값을 반환하는 게터와 값을 변경하는 세터가 자동 생성되고 자동 호출된다.(자바와는 다르다) 즉, 속성의 값을 참조할 때는 게터가 자동으로 호출되며, 이 코드처럼 속성의 값을 지정/변경할 때는 세터가 자동 호출된다. 그러므로 게터 getAdapter()나 세터 setAdapter(RecyclerView.Adapter)를 호출할 필요가 없다. crimeRecyclerView.adapter = adapter 대신 crimeRecyclerView.setAdapter(adapter)로 해도 결과는 같다. 두 가지 모두 adapter 속성의 세터를 호출하는 것이기 때문이다. 그러나 코틀린 속성의 특성을 잘 활용하는 코드는 crimeRecyclerView.adapter = adapter이다. 더미 데이터로 채워진 RecyclerView onBindViewHolder(...) 함수가 최소한의 꼭 필요한 일만 수행하도록 작고 효율적으로 만들었기 때문에 상하 스크롤 시 매우 부드럽게 움직일 것이다. 뷰의 재활용: RecyclerView 위의 이미지에서는 한 화면에 14개의 View를 보여준다. 그리고 화면을 스크롤하면 100개의 View를 볼 수 있다. 그렇다면 메모리에 100개의 View를 모두 갖고 있는 것일까? 그렇지 않다. 이게 다 RecyclerView 덕분이다. List에 저장된 모든 Crime 객체에 대해 하나씩 항목 View를 생성한다면 앱이 제대로 실행되지 않는다. List가 100개보다 훨씬 많은 데이터를 가질 수 있지만, 화면에서는 하나의 Crime이 하나의 항목 View만 필요하므로 한꺼번에 100개의 항목 View를 미리 생성하고 기다릴 필요가 없다. 그러므로 필요할 때만 항목 View 객체를 생성하는 것이 좋다. RecyclerView가 바로 이런 일을 수행한다. 100개의 항목 View를 생성하는 대신에 한 화면을 채우는데 충분한 개수만 생성해, 화면이 스크롤되면서 항목 View가 화면을 벗어날 때 RecyclerView는 해당 항목 View를 버리지 않고 재활용한다. 이름 그대로 RecyclerView는 끊임없이 항목 View를 재활용한다. 이런 이유로 onCreateViewHolder(ViewGroup, Int) 함수는 onBindViewHolder(ViewHolder, Int)보다 덜 호출된다. 일단 충분한 수의 ViewHolder가 생성되면 RecyclerView는 onCreateViewHolder(...)의 호출을 중단하고 기존의 ViewHolder를 재활용해 onBindViewHolder(ViewHolder, Int)에 전달함으로써 시간과 메모리를 절약한다. 리스트 항목의 바인딩 개선하기 현재는 CrimeAdapter가 Adapter.onBindViewHolder(...) 함수에서 Crime 객체의 데이터를 CrimeHolder가 참조하는 TextView로 직접 바인딩한다. 이렇게 해도 앱은 잘 실행된다. 그렇지만 CrimeHolder와 CrimeAdapter 간의 기능 분담을 명쾌하게 하는 것이 좋다. CrimeAdapter는 CrimeHolder가 내부적으로 하는 일을 모르는 것이 좋기 때문이다. 데이터 바인딩 작업을 수행하는 모든 코드는 CrimeHolder 내부에 두는 것이 좋다. 이렇게 하려면 우선 바인딩되는 Crime 객체의 참조를 보존하는 속성을 추가하면 된다. 그리고 내친 김에 기존의 TextView 참조 속성들을 private으로 변경하고 bind(Crime) 함수를 CrimeHolder에 추가한다. 이 함수에서는 바인딩되는 Crime 객체의 참조를 새로 추가하는 속성에 보존하며, TextView의 text 속성값을 현재 참조되는 Crime 객체의 속성값으로 설정한다. bind(Crime) 함수 작성하기 123456789101112private inner class CrimeHolder(view: View) : RecyclerView.ViewHolder(view) { private lateinit var crime: Crime val titleTextView: TextView = itemView.findViewById(R.id.crime_title) val dateTextView: TextView = itemView.findViewById(R.id.crime_date) fun bind(crime: Crime) { this.crime = crime titleTextView.text = this.crime.title dateTextView.text = this.crime.date.toString() }} 이제는 바인딩할 Crime 객체가 전달되면 CrimeHolder가 이 객체의 데이터를 반영해 제목 TextView와 발생일자 TextView의 text 속성값을 변경한다. 다음으로 RecyclerView가 요청할 때마다 bind(Crime) 함수를 호출하도록 변경해서 지정된 CrimeHolder를 특정 Crime 객체와 바인딩하자. bind(Crime) 함수 호출하기 1234567891011121314151617private inner class CrimeAdapter(var crimes: List&lt;Crime&gt;) : RecyclerView.Adapter&lt;CrimeHolder&gt;() { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): CrimeHolder { val view = layoutInflater.inflate(R.layout.list_item_crime, parent, false) return CrimeHolder(view) } override fun getItemCount(): Int = crimes.size override fun onBindViewHolder(holder: CrimeHolder, position: Int) { val crime = crimes[position]// holder.apply {// titleTextView.text = crime.title// dateTextView.text = crime.date.toString()// } holder.bind(crime) }} 리스트 항목 선택에 응답하기 사용자가 RecyclerView의 리스트 항목을 누르면 앱이 응답하도록 간단하게 Toast 메시지를 보여주자. RecyclerView는 강력하고 기능도 좋지만 실질적인 책임은 거의 없다. 여기서도 그렇다. 터치 이벤트를 처리하는 것은 우리의 몫이다. 따라서 OnClickListener를 설정해 터치 이벤트를 처리하면 된다. 이때 각 항목 View는 자신과 연관된 CrimeHolder를 갖고 있으므로 CrimeHolder에서 항목 View의 OnClickListener를 구현하면 된다. 리스트 항목의 모든 View에 클릭 이벤트를 처리하도록 CrimeHolder를 변경한다. CrimeHolder에서 클릭 이벤트 처리하기 123456789101112131415161718private inner class CrimeHolder(view: View) : RecyclerView.ViewHolder(view), View.OnClickListener { private lateinit var crime: Crime val titleTextView: TextView = itemView.findViewById(R.id.crime_title) val dateTextView: TextView = itemView.findViewById(R.id.crime_date) init { itemView.setOnClickListener(this) } fun bind(crime: Crime) { this.crime = crime titleTextView.text = this.crime.title dateTextView.text = this.crime.date.toString() } override fun onClick(v: View) { Toast.makeText(context, &quot;${crime.title} pressed!&quot;, Toast.LENGTH_SHORT).show() }} CrimeHolder 자신이 OnClickListener 인터페이스를 구현하고 있다. 그리고 리스트 행의 항목 View (itemView 속성이 참조함)에 발생하는 클릭 이벤트를 CrimeHolder가 받도록 설정되어 있다. ListView와 GridView 안드로이드 운영체제에는 ListView, GridView, Adapter 클래스가 포함되어 있다. 안드로이드 5.0까지는 이 클래스들을 사용해서 리스트나 그리드 형태로 항목들을 생성했다. 이 컴포넌트들의 API는 RecyclerView의 것과 매우 유사하다. ListView나 GridView 클래스는 리스트의 항목들을 스크롤하지만 각 항목에 관해서는 잘 알지 못한다. 그리고 리스트의 각 항목 View를 생성하는 일은 Adapter가 수행하지만, ListView나 GridView에서는 ViewHolder 패턴을 사용하도록 강제하지 않는다 (하지만 사용하는 것이 좋다). 이런 기존 컴포넌트들은 RecyclerView로 대체되었다. ListView나 GridView의 작동 방식을 변경하려면 복잡하기 때문이다. 예를 들어, 수평 방향으로 스크롤 가능한 ListView를 생성하는 기능은 ListView API에 포함되어 있지 않아 많은 작업이 필요하다. 커스텀 레이아웃을 갖고 스크롤 가능한 RecyclerView를 생성하는 것도 여전히 많은 작업이 필요하다. 그러나 RecyclerView는 기능 확장이 되도록 설계되었으므로 나쁘지 않다. RecyclerView의 또 다른 주요 기능은 리스트 항목의 애니메이션이다. ListView나 GridView의 경우 항목을 추가하거나 삭제할 때 생동감 있게 보이도록 하려면 구현이 복잡하고 에러가 생기기 쉽ㄴ다. 그러나 RecyclerView는 몇 가지 애니메이션 기능이 내장되어 있어서 훨씬 쉬우며, 이런 애니메이션 기능을 쉽게 커스터마이징 할 수 있다. RecyclerView의 ViewType ↩ RecyclerView에 평범한 범죄를 보여주는 행과 심각한 범죄를 보여주는 행, 두 가지 타입 행을 생성한다. 123456789101112data class Crime( val id: UUID = UUID.randomUUID(), var title: String = &quot;&quot;, var date: Date = Date(), var isSolved: Boolean = false, var requirePolice: Int = VIEW_TYPE_NORMAL) { companion object { const val VIEW_TYPE_NORMAL = 0 const val VIEW_TYPE_SERIOUS = 1 }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123class CrimeListFragment : Fragment() { private lateinit var crimeRecyclerView: RecyclerView private var adapter: CrimeAdapter? = null private val crimeListViewModel: CrimeListViewModel by lazy { ViewModelProvider(this).get(CrimeListViewModel::class.java) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) Log.d(TAG, &quot;Total crimes: ${crimeListViewModel.crimes.size}&quot;) } override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { val view = inflater.inflate(R.layout.fragment_crime_list, container, false) crimeRecyclerView = view.findViewById(R.id.crime_recycler_view) as RecyclerView crimeRecyclerView.layoutManager = LinearLayoutManager(context) updateUI() return view } private fun updateUI() { val crimes = crimeListViewModel.crimes adapter = CrimeAdapter(crimes) crimeRecyclerView.adapter = adapter } private inner class CrimeHolder(view: View) : RecyclerView.ViewHolder(view), View.OnClickListener { private lateinit var crime: Crime val titleTextView: TextView = itemView.findViewById(R.id.crime_title) val dateTextView: TextView = itemView.findViewById(R.id.crime_date) init { itemView.setOnClickListener(this) } fun bind(crime: Crime) { this.crime = crime titleTextView.text = this.crime.title dateTextView.text = this.crime.date.toString() } override fun onClick(v: View) { Toast.makeText(context, &quot;${crime.title} pressed!&quot;, Toast.LENGTH_SHORT).show() } } private inner class SeriousCrimeHolder(view: View) : RecyclerView.ViewHolder(view), View.OnClickListener { private lateinit var crime: Crime val titleTextView: TextView = itemView.findViewById(R.id.crime_title) val dateTextView: TextView = itemView.findViewById(R.id.crime_date) init { itemView.setOnClickListener(this) } fun bind(crime: Crime) { this.crime = crime titleTextView.text = this.crime.title dateTextView.text = this.crime.date.toString() } override fun onClick(v: View) { Toast.makeText(context, &quot;${crime.title} pressed!&quot;, Toast.LENGTH_SHORT).show() } } private inner class CrimeAdapter(var crimes: List&lt;Crime&gt;) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() { override fun getItemViewType(position: Int): Int { val crime = crimes[position] return when (crime.requirePolice) { 0 -&gt; Crime.VIEW_TYPE_NORMAL 1 -&gt; Crime.VIEW_TYPE_SERIOUS else -&gt; throw RuntimeException(&quot;Unknown View Type Error&quot;) } } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder { val view: View? return when(viewType) { Crime.VIEW_TYPE_NORMAL -&gt; { view = layoutInflater.inflate(R.layout.list_item_crime, parent, false) CrimeHolder(view) } Crime.VIEW_TYPE_SERIOUS -&gt; { view = layoutInflater.inflate(R.layout.list_item_serious_crime, parent, false) SeriousCrimeHolder(view) } else -&gt; throw RuntimeException(&quot;Unknown View Type Error&quot;) } } override fun getItemCount(): Int = crimes.size override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) { val crime = crimes[position] when (crime.requirePolice) { Crime.VIEW_TYPE_NORMAL -&gt; { (holder as CrimeHolder).bind(crime) } Crime.VIEW_TYPE_SERIOUS -&gt; { (holder as SeriousCrimeHolder).bind(crime) } } } } companion object { fun newInstance(): CrimeListFragment { return CrimeListFragment() } }} 참고하면 좋은 RecyclerView 관련 글들 https://developer.android.com/guide/topics/ui/layout/recyclerview?hl=ko https://medium.com/hongbeomi-dev/번역-recyclerview의-내부-동작-941a2827fa5a https://woovictory.github.io/2019/01/03/Android-Diff-of-ListView-and-RecyclerView/","link":"/2021/05/23/android-bnr-09/"},{"title":"[Kotlin] Data Class","text":"자바 플랫폼에서는 클래스가 equals, hashCode, toString 등의 메소드를 구현해야 한다. 다행히 자바 IDE들이 이런 메소드를 자동으로 생성해주긴 하지만 코드베이스가 번잡해지는건 변함이 없다. 코틀린 컴파일러는 한걸음 더 나가서 이런 메소드를 기계적으로 생성하는 작업을 보이지 않는 곳에서 해주기 때문에 필수 메소드로 인한 번잡함 없이 소스코드를 깔끔하게 유지 가능하다. 그런 코틀린의 원칙이 잘 드러나는 사례가 클래스 생성자나 프로퍼티 접근자를 컴파일러가 자동으로 만들어주는 것이다. 코틀린 컴파일러는 데이터 클래스에 유용한 메소드를 자동으로 만들어준다. 1. 모든 클래스가 정의해야 하는 메소드 자바와 마찬가지로 코틀린 클래스도 toString, equals, hashCode 등을 오버라이드할 수 있다. 각각이 어떤 메소드이고 어떻게 그런 메소드를 정의해야 하는지 살펴보자. 1class Client (val name: String, val postalCode: Int) 이제 이 클래스의 인스턴스를 어떻게 문자열로 표현할지 생각해보자. 1-1. 문자열 표현 : toString() 자바처럼 코틀린의 모든 클래스도 인스턴스의 문자열 표현을 얻을 방법을 제공한다. 주로 디버깅과 로깅 시 이 메소드를 사용한다. 기본으로 제공되는 객체의 문자열 표현 1class Client (val name: String, val postalCode: Int) 1234&gt;&gt;&gt; val client1 = Client(&quot;KAMIYU&quot;, 123456)&gt;&gt;&gt; println(client1)Client@61bbe9ba 기본으로 제공되는 객체의 문자열 표현은 위와 같이 Client@61bbe9ba 같은 방식인데, 이 기본 구현을 바꾸려면 toString 메소드를 오버라이드해야 한다. Client에 toString() 구현 123class Client (val name: String, val postalCode: Int) { override fun toString(): String = &quot;Client(name=$name, postalCode=$postalCode)&quot;} 1234&gt;&gt;&gt; val client1 = Client(&quot;KAMIYU&quot;, 123456)&gt;&gt;&gt; println(client1)Client(name=KAMIYU, postalCode=123456) 이런 문자열 표현으로부터 기본 문자열 표현보다 더 많은 정보를 얻을 수 있다. 1-2. 객체의 동등성 : equals() Client 클래스를 사용하는 모든 계산은 클래스 밖에서 이뤄진다. Client는 단지 데이터를 저장할 뿐이며, 그에 따라 구조도 단순하고 내부 정보를 외부에 투명하게 노출하게 설계됐다. 그렇지만 클래스는 단순할지라도 동작에 대한 몇 가지 요구 사항이 있을 수 있다. 예를 들어 서로 다른 두 객체가 내부에 동일한 데이터를 포함하는 경우 그 둘을 동등한 객체로 간주해야 할 수도 있다. 12345&gt;&gt;&gt; val client1 = Client(&quot;KAMIYU&quot;, 123456)&gt;&gt;&gt; val client2 = Client(&quot;KAMIYU&quot;, 123456)&gt;&gt;&gt; println(client1 == client2)false 위 예제에서는 두 객체가 동일하지 않다. 이는 Client 클래스의 요구 사항을 만족시키고 싶다면 equals를 오버라이드 할 필요가 있다는 뜻이다. 참고로 코틀린에서 == 연산자는 참조 동일성을 검사하지 않고 객체의 동등성을 검사한다. 따라서 == 연산은 equals를 호출하는 식으로 컴파일된다.1 Client에 equals() 구현하기 12345678910class Client(val name: String, val postalCode: Int) { override fun equals(other: Any?): Boolean { if (other == null || other !is Client) // other가 Client인지 검사 return false return name == other.name &amp;&amp; // 두 객체의 프로퍼티 값 비교, 코틀린의 is 검사는 자바의 instanceof와 같다. postalCode == other.postalCode } override fun toString(): String = &quot;Client(name=$name, postalCode=$postalCode)&quot;} equals를 오버라이드하고 나면 프로퍼티의 값이 모두 같은 두 Client 객체는 동등하리라 예상할 수 있다. 실제로 client1 == client2는 이제 true를 반환한다. 하지만 Client 클래스로 더 복잡한 작업을 수행해보면 제대로 작동하지 않는 경우가 있다. 이와 관련해서 흔히 면접에서 질문하는 내용이 “Client가 제대로 작동하지 않는 경우를 말하고 문제가 무엇인지 설명하시오” 다. hashCode 정의를 빠뜨려서 그렇다고 답하는 개발자가 많을 것이다. 이 경우에는 실제 hashCode가 없다는 점이 원인이다. 이제 왜 hashCode가 중요한지 알아보자. 1-3. 해시 컨테이너: hashCode() 자바에서는 equals를 오버라이드할 때 반드시 hashCode도 함께 오버라이드해야 한다. 이유는 다음과 같다. 원소가 'KAMIYU’라는 고객 하나뿐인 집합을 만들자. 그 후 새로 원래의 'KAMIYU’와 똑같은 프로퍼티를 포함하는 새로운 Client 인스턴스를 만들어서 그 인스턴스가 집합 안에 들어있는지 검사해보자. 프로퍼티가 모두 일치하므로 새 인스턴스와 집합에 있는 기존 인스턴스는 동등하다. 따라서 새 인스턴스가 집합에 속했는지 여부를 검사하면 true가 반환되리라 예상할 수 있다. 하지만 실제로는 false가 나온다. 1234&gt;&gt;&gt; val processed = hashSetOf(Client(&quot;KAMIYU&quot;, 123456))&gt;&gt;&gt; println(processed.contains(Client(&quot;KAMIYU&quot;, 123456)))false 이는 Client 클래스가 hashCode 메소드를 정의하지 않았기 때문이다. JVM 언어에서는 hashCode가 지켜야 하는 “equals()가 true를 반환하는 두 객체는 반드시 같은 hashCode()를 반환해야 한다” 라는 제약이 있는데 이를 Client는 어기고 있기 때문이다. processed 집합은 HashSet이다. HashSet은 원소를 비교할 때 비용을 줄이기 위해 먼저 객체의 해시 코드를 비교하고 해시 코드가 같은 경우에만 실제 값을 비교한다. 방금 본 예제의 두 Client 인스턴스는 해시 코드가 다르기 때문에 두 번째 인스턴스가 집합 안에 들어있지 않다고 판단한다. 해시 코드가 다를 때 equals가 반환하는 값은 판단 결과에 영향을 끼치지 못한다. 즉, 원소 객체들이 해시 코드에 대한 규칙을 지키지 않는 경우 HashSet은 제대로 작동할 수 없다. 이 문제를 고치려면 Client가 hashCode를 구현해야 한다. Client에 hashCode() 구현하기 1234class Client(val name: String, val postalCode: Int) { ... override fun hashCode(): Int = name.hashCode() * 31 + postalCode} 이제 이 클래스는 예상대로 작동한다. 하지만 지금까지 얼마나 많은 코드를 작성해야 했는지 생각해보라. 다행히 코틀린 컴파일러는 이 모든 메소드를 자동으로 생성해줄 수 있다. 어떻게 하면 코틀린이 이런 메소드를 생성하게 만들 수 있는지 살펴보자. 2. 데이터 클래스: 모든 클래스가 정의해야 하는 메소드 자동 생성 어떤 클래스가 데이터를 저장하는 역할만을 수행한다면 toString, equals, hashCode를 반드시 오버라이드해야 한다. IntelliJ 같은 IDE는 이러한 메소드들을 자동으로 정의해주고, 작성된 메소드의 정확성과 일관성을 검사해준다. 하지만 코틀린은 더 편리하다! 이제는 이런 메소드를 IDE를 통해 생성할 필요도 없이 data라는 변경자를 클래스 앞에 붙이면 필요한 메소드를 컴파일러가 자동으로 만들어준다. data 변경자가 붙은 클래스를 데이터 클래스라고 부른다. Client를 데이터 클래스로 선언하기 1data class Client(val name: String, val postalCode: Int) 이제 Client 클래스는 자바에서 요구하는 모든 메소드를 포함한다. 인스턴스 간 비교를 위한 equals HashMap과 같은 해시 기반 컨테이너에서 키로 사용할 수 있는 hashCode 클래스의 각 필드를 선언 순서대로 표시하는 문자열 표현을 만들어주는 toString equals와 hashCode는 주 생성자에 나열된 모든 프로퍼티를 고려해 만들어진다. 생성된 equals 메소드는 모든 프로퍼티 값의 동등성을 확인한다. hashCode 메소드는 모든 프로퍼티의 해시 값을 바탕으로 계산한 해시 값을 반환한다. 이때 주 생성자 밖에 정의된 프로퍼티는 equals나 hashCode를 계산할 때 고려의 대상이 아니라는 사실에 유의하라. 코틀린 컴파일러는 data 클래스에게 방금 말한 세 메소드뿐 아니라 몇 가지 유용한 메소드를 더 생성해준다. 2-1. 데이터 클래스와 불변성: copy() 메소드 데이터 클래스의 프로퍼티가 꼭 val 일 필요는 없다. 원한다면 var 프로퍼티를 써도 되지만 모든 프로퍼티를 읽기 전용으로 만들어서 데이터 클래스를 불변 immutable 클래스로 만들라고 권장한다. HashMap 등의 컨테이너에 데이터 클래스 객체를 담는 경우엔 불변성이 필수적이다. 데이터 클래스 객체를 키로 하는 값을 컨테이너애 담은 다음에 키로 쓰인 데이터 객체의 프로퍼티를 변경하면 컨테이너 상태가 잘못될 수 있다. 게다가 불변 객체를 사용하면 프로그램에 대해 훨씬 쉽게 추론할 수 있다. 특히 다중 스레드 프로그램의 경우 이런 성질은 더 중요하다. 불변 객체를 주로 사용하는 프로그램에서는 스레드가 사용 중인 데이터를 다른 스레드가 변경할 수 없으므로 스레드를 동기화해야 할 필요가 줄어든다. 데이터 클래스 인스턴스를 불변 객체로 더 쉽게 활용할 수 있게 코틀린 컴파일러는 객체를 복사하면서 일부 프로퍼티를 바꿀 수 있게 해주는 copy 메소드를 제공한다. 객체를 메모리상에서 직접 바꾸는 대신 복사본을 만드는 편이 더 낫다. 복사본은 원본과 다른 생명주기를 가지며, 복사를 하면서 일부 프로퍼티 값을 바꾸거나 복사본을 제거해도 프로그램에서 원본을 참조하는 다른 부분에 전혀 영향을 끼치지 않는다. Client의 copy를 직접 구현한다면 다음과 같을 것이다. 1234class Client(val name: String, val postalCode: Int) { ... fun copy(name: String = this.name, postalCode: Int = this.postalCode) = Client(name, postalCode)} 다음은 copy 메소드를 사용하는 방법이다. 1234&gt;&gt;&gt; val kamiyu = Client(&quot;KAMIYU&quot;, 123456)&gt;&gt;&gt; println(kamiyu.copy(postalCode = 111000))Client(name=KAMIYU, postalCode=111000) 2-2. 구조 분해 선언과 component 함수 구조 분해 선언 destructuring declaration이라는 개념에서 구조 분해를 사용하면 복합적인 값을 분해해서 여러 다른 변수를 한꺼번에 초기화 할 수 있다. 구조 분해 사용 방법 123456789data class Point(val x: Int, val y: Int)...&gt;&gt;&gt; val p = Point(10, 20)&gt;&gt;&gt; val (x, y) = p&gt;&gt;&gt; println(x)10&gt;&gt;&gt; println(y)20 구조 분해 선언은 일반 변수 선언과 비슷해 보인다. 다만 =의 좌변에 여러 변수를 괄호로 묶었다는 점이 다르다. 내부에서 구조 분해 선언은 다시 관례를 사용한다. 구조 분해 선언의 각 변수를 초기화하기 위해 componentN이라는 함수를 호출한다. 여기서 N은 구조 분해 선언에 있는 변수 위치에 따라 붙는 번호다. 앞에서 살펴본 val (x, y) = p는 아래와 같이 컴파일된다. 1234val (a,b) = p ↓val a = p.component1()val b = p.component2() data 클래스의 주 생성자에 들어있는 프로퍼티에 대해서는 컴파일러가 자동으로 componentN 함수를 만들어준다. 다음 예제는 데이터 타입이 아닌 클래스에서 이런 함수를 어떻게 구현하는지 보여준다. 1234567class Point(val x: Int, val y: Int) { operator fun component1() = x operator fun component2() = y}// componentN 함수가 구현되어 있지 않다면 아래와 같은 오류를 보여준다.// Destructuring declaration initializer of type Point must have a 'component1()' function 구조 분해 선언은 함수에서 여러 값을 반환할 때 유용하다. 여러 값을 한꺼번에 반환해야 하는 함수가 있다면 반환해야 하는 모든 값이 들어갈 데이터 클래스를 정의하고 함수의 반환 타입을 그 데이터 클래스로 바꾼다. 구조 분해 선언 구문을 사용하면 이런 함수가 반환하는 값을 쉽게 풀어서 여러 변수에 넣을 수 있다. 이런 동작을 보여주기 위해 파일 이름을 이름과 확장자로 나누는 함수를 작성해보자. 구조 분해 선언을 사용해 여러 값 반환하기 123456789101112data class NameComponents(val name: String, val extension: String) // 값을 저장하기 위한 데이터 클래스를 선언fun splitFileName(fullName: String) : NameComponents { val result = fullName.split(&quot;.&quot;, limit = 2) return NameComponents(result[0], result[1]) // 함수에서 데이터 클래스의 인스턴스를 반환}&gt;&gt;&gt; val (name, ext) = splitFileName(&quot;example.kt&quot;) // 구조 분해 선언 구문을 사용해 데이터 클래스를 푼다&gt;&gt;&gt; println(name)example&gt;&gt;&gt; println(ext)kt 배열이나 컬렉션에도 componentN 함수가 있음을 안다면 위 예제를 더 개선할 수 있다. 크기가 정해진 컬렉션을 다루는 경우 구조 분해가 특히 더 유용하다. 예를 들어 여기서 split은 2개의 원소로 이뤄진 리스트를 반환한다. 컬렉션에 대해 구조 분해 선언 사용하기 123456data class NameComponents(val name: String, val extension: String)fun splitFileName(fullName: String) : NameComponents { val (name, ext) = fullName.split(&quot;.&quot;, limit = 2) return NameComponents(name, ext)} 물론 무한히 componentN을 선언할 수 없으므로 이런 구문을 무한정 사용할 수는 없다. 그럼에도 불구하고 여전히 컬렉션에 대한 구조 분해는 유용하다. 코틀린 표준 라이브러리에서는 맨 앞의 다섯 원소에 대한 componentN을 제공한다. 구조 분해 선언과 루프 함수 본문 내의 선언문뿐만 아니라 변수 선언이 들어갈 수 있는 장소라면 어디든 구조 분해 선언을 할 수 있다. 예를 들어 루프 안에서도 구조 분해 선언을 사용할 수 있다. 특히 Map의 원소에 대해 이터레이션할 때 구조 분해 선언이 유용하다. 구조 분해 선언을 사용해 맵 이터레이션 하기 12345678910fun printEntries(map: Map&lt;String, String&gt;) { for ((key, value) in map) { // 루프 변수에 구조 분해 선언 사용 println(&quot;$key -&gt; $value&quot;) }}&gt;&gt;&gt; val map = mapOf(&quot;Oracle&quot; to &quot;Java&quot;, &quot;JetBrains&quot; to &quot;Kotlin&quot;)&gt;&gt;&gt; printEntries(map)Oracle -&gt; JavaJetBrains -&gt; Kotlin 이 간단한 예제는 두 가지 코틀린 관례를 활용한다. 하나는 객체를 iteration하는 관례고, 다른 하나는 구조 분해 선언이다. 코틀린 표준 라이브러리에는 맵에 대한 확장 함수로 iterator가 들어있다. 그 iterator는 맵 원소에 대한 이터레이터를 반환한다. 따라서 자바와 달리 코틀린에서는 맵을 직접 이터레이션할 수 있다. 또한 코틀린 라이브러리는 Map.Entry에 대한 확장 함수로 component1과 component2를 제공한다. 위의 루프는 이런 확장 함수를 사용하는 아래의 코드와 같다. 12345for (entry in map.entries) { val key = entry.component1() val value = entry.component2() println(&quot;$key -&gt; $value&quot;)} 이 예제는 코틀린 관례를 적용할 때 확장 함수가 얼마나 중요한 역할을 하는지 잘 보여준다. References Kotlin in Action - 4.3절 171p, 7.4절 326p https://kotlinlang.org/docs/data-classes.html#data-classes-and-destructuring-declarations https://kotlinlang.org/docs/destructuring-declarations.html#example-returning-two-values-from-a-function 1 동등성 연산에 == 사용 ↩ 동일하다 : 두 객체가 완전히 같을 경우 / 동등하다 : 두 객체가 같은 정보를 같고 있을 경우 자바에서는 ==를 원시 타입과 참조 타입을 비교할 때 사용한다. 원시 타입의 경우 ==는 두 피연사자의 값이 같은지 비교한다 동등성(equality). 반면 참조 타입의 경우 ==는 두 피연산자의 주소가 같은지를 비교한다 참조 비교(reference comparision). 따라서 자바에서는 두 객체의 동등성을 알려면 equals를 호출해야 한다. 자바에서는 equals 대신 ==를 호출하면 문제가 될 수 있다는 사실도 아주 잘 알려져 있다. 코틀린에서는 == 연산자가 두 객체를 비교하는 기본적인 방법이다. ==는 내부적으로 equals를 호출해서 객체를 비교한다. 따라서 클래스가 equals를 오버라이드하면 ==를 통해 안전하게 그 클래스의 인스턴스를 비교할 수 있다. 참조 비교를 위해서는 === 연산자를 사용할 수 있다. === 연산자는 자바에서 객체의 참조를 비교할 때 사용하는 == 연산자와 같다. == 연산자는 자바와 코틀린에서 원시 타입의 비교에서는 동일하게 동작하지만, 참조 타입의 비교에서는 다르게 동작한다. 자바의 참조 타입 비교 == : 주소가 같은지를 비교 코틀린의 참조 타입 비교 == : 내부적으로 equals를 호출해서 주소 비교가 아닌 동등성 비교를 한다.","link":"/2021/05/13/kotiln-data-class/"},{"title":"[Android] 데이터베이스와 Room 라이브러리","text":"거의 모든 애플리케이션은 장시간 동안 데이터를 저장할 곳이 필요하다. 본문에서는 Room 라이브러리를 사용해서 앱의 데이터베이스를 쿼리할 수 있는 코드를 구현하고, 데이터베이스로부터 데이터를 가져와서 리스트에 보여주도록 한다. ViewModel과 SIS에서 장치 회전 및 프로세스 종료 시에 ViewModel과 SIS Saved Instance Status를 사용해서 일시적인 UI 상태 데이터를 지속하는 방법을 기술했다. ViewModel과 SIS는 UI와 관련된 적은 수의 데이터에는 아주 좋지만 UI와 결부되지 않는 데이터의 저장에는 사용할 수 없다. 또한, 액티비티나 프래그먼트 인스턴스에 연관되지 않으면서 UI 상태와 무관하게 영구적으로 지속할 필요가 있는 데이터의 저장에도 사용할 수 없다. 따라서 이런 앱 데이터는 ViewModel이나 SIS 대신 로컬 파일 시스템이나 로컬 데이터베이스 또는 웹 서버에 저장해야 한다. Room 아키텍처 컴포넌트 라이브러리 Room은 Jetpack의 아키텍처 컴포넌트 라이브러리로, 데이터베이스 설정과 사용을 쉽게 해준다. Room을 사용하면 애노테이션이 지정된 코틀린 클래스로 데이터베이스 구조와 쿼리를 정의할 수 있다. Room은 API, 애노테이션 annotation, 컴파일러로 구성되어 있다. 데이터베이스를 정의하고 인스턴스를 생성하기 위해 상속받는 클래스들이 API에 포함되어 있다. 데이터베이스에 저장할 필요가 있는 클래스, 데이터베이스를 나타내는 클래스, 데이터베이스 테이블을 사용하는 함수들을 정의하는 클래스 등을 나타내기 위해 애노테이션을 사용한다. 컴파일러는 지정한 애노테이션을 컴파일해서 데이터베이스 구현체 (클래스나 인터페이스 등)를 생성한다. Room을 사용하는데 필요한 의존성 추가 1234567891011121314151617181920plugins { id 'com.android.application' id 'kotlin-android' // Kotlin annotation processor tool 추가 id 'kotlin-kapt'}...dependencies { ... implementation 'androidx.core:core-ktx:1.3.2' // room-runtime과 room-compiler 추가 implementation 'androidx.room:room-runtime:2.3.0' kapt 'androidx.room:room-compiler:2.3.0' ...} 먼저 안드로이드 스튜디오의 플러그인 plug-in 으로 kotlin-kapt를 추가한다. 플러그인은 안드로이드 스튜디오 같은 IDE에 기능을 추가하는 방법이다. kotlin-kapt는 코틀린 애노테이션 처리 도구 Kotlin annotation processor tool다. 라이브러리에서 생성한 클래스를 코드에서 직접 사용하고자 할 때가 있다. 그런데 기본적으로 라이브러리가 생성한 클래스들은 안드로이드 스튜디오에서 알 수 가 없어 이런 클래스들을 import해서 사용하려고 하면 에러가 발생한다. kotlin-kapt 플러그인을 추가하면 라이브러리가 생성한 클래스들을 안드로이드 스튜디오에서 알 수 있으므로 import해서 사용할 수 있다. 위에서 추가한 첫 번째 의존성인 room-runtime은 데이터베이스를 정의하는 데 필요한 모든 클래스와 애노테이션을 포함하는 Room API다. 두 번째 의존성인 room-compiler는 지정한 애노테이션을 컴파일해서 데이터베이스 구현채를 생성한다. room-compiler 의존성을 지정할 때는 implementation 대신 kapt 키워드를 사용해 Room 컴파일러가 생성한 클래스들을 안드로이드 스튜디오가 알 수 있게 한다. 데이터베이스 생성하기 Room으로 데이터베이스를 생성할 때는 다음 세 단계로 한다. 모델 클래스에 애노테이션을 지정해 데이터베이스 엔터티 entity 로 만든다. 데이터베이스 자체를 나타내는 클래스를 생성한다. 데이터베이스가 모델 데이터를 처리할 수 있게 타입 변환기 type converter를 생성한다. Room은 이 단계가 수월하게 이루어지도록 해준다. Entity 정의하기 Room은 우리가 정의한 엔터티를 기반으로 앱의 데이터베이스 테이블 구조를 만든다. 엔터티는 우리가 생성하는 모델 클래스로, @Entity 애노테이션으로 지정한다. 그러면 이 애노테이션으로 Room이 해당하는 클래스의 데이터베이스 테이블을 생성한다. 본문의 예시로는 Crime 객체를 데이터베이스에 저장할 것이므로 Crime 클래스를 엔터티로 변경한다. Crime을 엔터티로 만들기 1234567@Entitydata class Crime( @PrimaryKey val id: UUID = UUID.randomUUID(), var title: String = &quot;&quot;, var date: Date = Date(), var isSolved: Boolean = false) @Entity 애노테이션은 클래스 수준에 적용된다. 이 엔터티 애노테이션은 Crime 클래스가 데이터베이스 테이블의 구조를 정의함을 나타낸다. 따라서 테이블의 각 행 row이 하나의 Crime 객체를 나타내며, 클래스에 정의된 각 속성은 테이블의 열 column이므로 속성 이름은 열의 이름이 된다. 따라서 Crime 객체 데이터를 저장하는 테이블은 id, title, date, isSolved 열을 갖는다. id 속성에는 @PrimaryKey 애노테이션이 추가되었다. 이 애노테이션은 기본 키 primary key 열을 지정한다. 기본 키는 테이블의 모든 행에 고유한 데이터를 갖는 열이므로 각 행을 검색하는데 사용할 수 있다. 여기서는 id 속성값이 모든 Crime 객체에 고유하다. 따라서 id 속성에 @PrimaryKey를 지정하면 이 속성을 사용해 특정 Crime 객체 데이터를 쿼리할 수 있다. 데이터베이스 클래스 생성하기 엔터티 클래스는 데이터베이스 테이블의 구조를 정의한다. 앱에 여러 개의 데이터베이스가 있을 때는 특정 엔터티 클래스는 여러 데이터베이스에서 사용될 수 있다. 이런 경우가 흔하지는 않지만 가능하다. 이런 이유로 엔터티 클래스를 데이터베이스와 연관시켜 주어야 Room이 테이블을 생성하는데 사용할 수 있다. 우선 데이터베이스에 특정한 코드를 모아둘 패키지인 database를 생성하여 데이터베이스 클래스를 생성한다. 초기의 CrimeDatabase 클래스 (database/CrimeDatabase.kt) 123@Database(entities = [Crime::class], version = 1)abstract class CrimeDatabase : RoomDatabase() {} @Database 애노테이션은 이 클래스가 앱의 데이터베이스를 나태난다고 Room에게 알려준다. 이 애노테이션에는 두 개의 매개변수를 지정해야 한다. 첫 번째 매개변수에는 이 데이터베이스의 테이블들을 생성하고 관리하는 데 사용할 엔터티 클래스들을 지정한다 여기서는 앱에서 유일한 엔터티 클래스인 Crime 클래스만 지정하였다. 두 번째 매개변수에는 데이터베이스의 버전을 지정한다. 데이터베이스를 처음 생성했을 때는 버전이 1이다. 앱을 계속 개발하는 동안 새로운 엔터티를 추가하거나 기존 엔터티에 새로운 속성을 추가할 수 있다. 추가할 대는 @Database 애노테이션의 엔터티를을 변경하거나 데이터벵스 버전 번호를 증가시켜야 한다. 데이터베이스 클래스인 CrimeDatabase는 RoomDatabase의 서브 클래스다. 현재는 아무것도 갖고 있지 않으며, abstract로 지정되어서 이 클래스의 인스턴스를 생성할 수 없다. Room을 사용해서 데이터베이스 인스턴스를 얻는 방법은 이번 장 뒤에서 기술한다. 타입 변환기 생성하기 Room은 내부적으로 SQLite를 사용한다. SQLite는 MySQL이나 PostgreSQL 같은 오픈 소스 관계형 데이터베이스다 (SQL은 Structured Query Language의 약어이며 표준 데이터베이스 언어다). 다른 데이터베이스와 달리 SQLite는 라이브러리를 사용해서 데이터를 읽거나 데이터를 쓸 수 있는 파일에 저장한다. 안드로이드는 추가 도우미 클래스들과 함께 SQLite 라이브러리를 표준 라이브러리에 포함하고 있다. Room은 코틀린 객체와 데이터베이스 사이에서 객체-관계 매핑 ORM, Object-Relational Mapping계층의 역할을 하면서 SQLite 사용을 쉽게 해준다. Room을 사용하면 대부분의 경우에 SQLite를 자세히 알 필요 없다. Room은 기본 데이터 타입을 SQLite 데이터베이스 테이블에 쉽게 저장할 수 있지만, 이외의 다른 타입은 문제가 생길 수 있다. Crime 클래스에는 Room이 저장 방법을 모르는 Date와 UUID 타임 속성이 있다. 따라서 이런 타입의 데이터를 데이터베이스 테이블에 저장하거나 가져오는 방법을 Room에게 알려줘야 한다. 데이터 타입을 변환하는 방법을 Room에게 알려주려면 타입 변환기를 지정하면 된다. 타입 변환기는 Room에게 특정 타입을 데이터베이스에 저장되는 타입으로 변환하는 방법을 알려준다. 이때 각 타입에 대해서 @TypeConverter 애노테이션이 지정된 두 개의 함수가 필요하다. 데이터베이스에 데이터를 저장하기 위해 타입을 변환하는 함수 데이터베이스로부터 읽은 데이터를 우리가 원하는 타입으로 변환하는 함수 타입 변환 클래스와 함수 추가하기 (database/CrimeTypeConverters.kt) Date, UUID 타입에 대해 변환을 처리하는 두 개의 함수를 각각 추가한다. 123456789101112131415161718192021222324class CrimeTypeConverters { @TypeConverter fun fromDate(date: Date?): Long? { return date?.time } @TypeConverter fun toDate(millisSinceEpoch: Long?): Date? { return millisSinceEpoch?.let { Date(it) } } @TypeConverter fun toUUID(uuid: String?): UUID? { return UUID.fromString(uuid) } @TypeConverter fun fromUUID(uuid: UUID?): String? { return uuid?.toString() }} 타입 변환기 활성화하기 (database/CrimeDatabase.kt) 변환기 클래스를 데이터베이스 클래스에 추가한다. 1234@Database(entities = [Crime::class], version = 1)@TypeConverters(CrimeTypeConverters::class) // 변환기 클래스 추가abstract class CrimeDatabase : RoomDatabase() {} 이처럼 @TypeConverters 애노테이션을 추가하면서 CrimeTypeConverters 클래스를 전달하면, Room은 타입을 변환할 때 해당 클래스의 함수들을 사용한다. 이것으로 데이터베이스와 테이블 정의는 완료되었다. DAO 정의하기 데이터베이스 테이블의 데이터를 액세스하려면 DAO Data Access Object를 생성해야 한다. DAO는 데이터베이스 작업을 수행하는 함수들을 포함하는 인터페이스다. 본문에서의 예시의 DAO에는 두 개의 쿼리 함수가 필요하다. 바로 데이터베이스의 모든 범죄 데이터를 반환하는 함수와 지정된 UUID를 갖는 하나의 범죄 데이터를 반환하는 함수다. DAO 인터페이스 (database/CrimeDao.kt) 123@Daointerface CrimeDao {} 이처럼 @Dao 애노테이션을 지정하면 CrimeDao가 DAO 중 하나임을 Room이 알게 된다. 그리고 데이터베이스 클래스에 CrimeDao를 등록하면 이 인터페이스에 추가된 함수들의 실행 코드를 Room이 생성한다. DAO에 두 개의 쿼리 함수 추가하기 (database/CrimeDao.kt) 123456789@Daointerface CrimeDao { @Query(&quot;SELECT * FROM crime&quot;) fun getCrimes(): List&lt;Crime&gt; @Query(&quot;SELECT * FROM crime WHERE id=(:id)&quot;) fun getCrime(id: UUID): Crime?} @Query 애노테이션은 getCrimes()와 getCrime(UUID) 함수가 데이터베이스의 데이터를 읽는다는 것을 나타낸다(추가, 변경, 삭제가 아님). 이 DAO에 정의된 각 쿼리 함수의 반환 타입은 쿼리가 반환하는 결과의 타입을 반영한다. @Query 애노테이션은 문자열로 된 SQL 명령을 받는다. 대부분의 경우에는 간단한 SQL만 알면 되지만, SQL에 관한 더 자세한 내용은 https://www.sqlite.org 사이트의 SQL Syntax에서 참고할 수 있다. SELECT * FROM crime은 crime 데이터베이스 테이블에 저장된 모든 행의 모든 열을 가져오며, SELECT * FROM crime WHERE id=(:id)는 id 값이 일치하는 행의 모든 열만 가져온다. 기존 데이터를 변경하는 함수를 인터페이스에 추가하는 것은 링크 추가 예정에서, 새로운 데이터를 추가하는 함수의 추가는 링크 추가 예정에서 다룬다. 다음으로 CrimeDao 인터페이스를 데이터베이스 클래스에 등록해야 한다. CrimeDao는 인터페이스이므로 이것을 구현하는 클래스를 Room이 생성한다. 하지만 이렇게 되려면 CrimeDao의 인스턴스를 생성하게 데이터베이스 클래스에 알려주어야 한다. 아래와 같이 CrimeDao를 반환 타입으로 갖는 추상 함수를 CrimeDatabase.kt에 추가한다. 데이터베이스에 CrimeDao 등록하기 (database/CrimeDatabase.kt) 1234567@Database(entities = [Crime::class], version = 1)@TypeConverters(CrimeTypeConverters::class)abstract class CrimeDatabase : RoomDatabase() { // CrimeDao 등록 abstract fun crimeDao(): CrimeDao} 이제는 데이터베이스가 생성되면 우리가 사용할 수 있는 CrimeDao 구현 클래스를 Room이 생성한다. 따라서 CrimeDao의 참조를 가지면 CrimeDao에 정의된 함수들을 호출해서 데이터베이스를 사용할 수 있다. 리포지터리 패턴으로 데이터베이스 액세스하기 리포지터리 패턴 다이어그램 데이터베이스 액세스를 위해 본문에서는 구글의 앱 아키텍처 지침에서 권장하는 리포지터리 패턴 repository pattern 을 사용한다. 리포지터리 클래스는 리포지터리 데이터 저장소를 구현한다. 또한 단일 또는 여러 소스로부터 데이터를 액세스하는 로직을 캡슐화하고, 로컬 데이터베이스나 원격 서버로부터 특정 데이터 셋을 가져오거나 저장하는 방법을 결정한다. 그리고 UI 코드에서는 리포지터리에 모든 데이터를 요청한다. UI는 어떻게 데이터를 저장하거나 가져오는지에 관여하지 않으므로 이런 일은 리포지터리에서 구현한다. 리포지터리 구현하기 ↩ (CrimeRepository.kt) 123456789101112131415class CrimeRepository private constructor(context: Context){ companion object { private var INSTANCE: CrimeRepository? = null fun initialize(context: Context) { if (INSTANCE == null) { INSTANCE = CrimeRepository(context) } } fun get(): CrimeRepository { return INSTANCE ?: throw IllegalStateException(&quot;CrimeRepository must be initialized&quot;) } }} CrimeRepository는 싱글톤 singleton 이다. 즉, 앱이 실행되는 동안 하나의 인스턴스만 생성된다는 의미다. 싱글톤은 앱이 메모리에 있는 한 계속 존재하므로, 싱글톤이 갖는 속성은 액티비티나 프래그먼트의 생명주기 상태가 변경되어도 계속 유지될 수 있다. 그러나 안드로이드 운영체제가 메모리에서 앱을 제거하면 싱글톤도 같이 소멸한다. 따라서 CrimeRepository 싱글톤은 데이터를 장기간 저장하기 위한 해결책이 될 수 없지만, 대신에 CriminalIntent 앱에서 범죄 데이터를 갖고 있으면서 컨트롤러 클래스 간의 데이터를 쉽게 전달하는 방법을 제공한다. CrimeRepository를 싱글톤으로 만들고자 여기서는 두 개의 함수를 동반 객체에 추가하였다. 하나는 CrimeRepository의 인스턴스를 생성하는 함수이고, 다른 하나는 기존에 생성된 CrimeRepository 인스턴스를 반환하는 함수다. 그리고 CrimeRepository의 생성자를 private로 지정해서 외부에서 CrimeRepository.initialize(Context)를 호출해야만 CrimeRepository 인스턴스를 생성할 수 있게 했다. 게터 함수인 get()에서는 CrimeRepository 인스턴스가 생성되지 않으면 IllegalStateException을 발생시킨다. 따라서 앱이 시작될 대 리포지터리인 CrimeRepository 인스턴스를 생성해야 한다. 이렇게 하려면 Application의 서브 클래스를 생성하면 된다. Application 서브 클래스 생성하기 1234567class CriminalIntentApplication: Application() { override fun onCreate() { super.onCreate() CrimeRepository.initialize(this) }} Activity.onCreate(...)와 유사하게 Application.onCreate(...)는 앱이 최초로 메모리에 로드될 때 안드로이드 시스템이 자동 호출한다. 따라서 한번만 초기화되는 작업을 수행하는 데 적합하다. 액티비티나 프래그먼트와는 달리 Application 인스턴스 즉, CriminalIntentApplication 인스턴스는 CriminalIntent 앱이 최초 실행될 때 생성되거나 앱 프로세스 소멸로 인해 CriminalIntentApplication 인스턴스가 소멸된 후 CriminalIntent 앱이 다시 실행될 때 재생성된다. CriminalIntentApplication 인스턴스를 안드로이드 시스템에서 사용하려면 매니페스트에 등록해야 한다. AndroidManifest.xml에 android:name 속성을 추가해서 앱을 설정하면 이후부터는 CriminalIntentApplication 인스턴스가 앱의 Context 객체로 사용된다. CriminalIntentApplication을 등록하기 1234567891011&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.june0122.criminalintent&quot;&gt; &lt;application android:name=&quot;.CriminalIntentApplication&quot; android:allowBackup=&quot;true&quot; ...&gt; ... &lt;/application&gt;&lt;/manifest&gt; 이제는 CriminalIntent 앱이 실행될 때 안드로이드 운영체제가 CriminalIntentApplication 인스턴스를 생성하고 이 인스턴스의 onCreate()를 호출한다. 따라서 CrimeRepository 인스턴스가 생성되어 사용할 수 있다. 다음으로 데이터베이스 객체와 DAO 객체의 참조를 저장하는 두 개의 속성을 CrimeRepository에 추가한다. 리포지터리 속성 설정하기 12345678910111213141516private const val DATABASE_NAME = &quot;crime-database&quot;class CrimeRepository private constructor(context: Context){ private val database: CrimeDatabase = Room.databaseBuilder( context.applicationContext, CrimeDatabase::class.java, DATABASE_NAME ).build() private val crimeDao = database.crimeDao() companion object { ... }} Room.databaseBuilder()는 세 개의 매개변수를 사용해서 CrimeDatabase의 실체 클래스를 생성한다. 데이터베이스가 안드로이드 장치의 파일 시스템을 액세스하므로 첫 번째 매개변수는 데이터베이스의 컨텍스트로, 주로 앱의 Context (여기서는 CriminalIntentApplication) 객체를 전달한다. 두 번째 매개변수는 Room으로 생성하고자 하는 데이터베이스 클래스 (여기서는 CrimeDatabase) 세 번째 매개변수는 Room으로 생성하고자 하는 데이터베이스 파일 이름이다. 다른 컴포넌트에서는 CrimeDatabase를 액세스할 필요가 없으므로 여기서는 private 문자열로 지정하였다 (SQLite에서는 한 데이터베이스가 하나의 파일로 생성된다). 다음으로 DAO의 데이터베이스 액세스 함수들을 CrimeRepository에서 사용하기 위한 함수를 추가한다. 리포지터리 함수 추가하기 12345678910111213class CrimeRepository private constructor(context: Context){ ... private val crimeDao = database.crimeDao() fun getCrimes(): List&lt;Crime&gt; = crimeDao.getCrimes() fun getCrime(id: UUID): Crime? = crimeDao.getCrime(id) companion object { ... }} Room은 DAO에 쿼리를 구현하므로 리포지터리에 DAO의 함수를 호출하는 함수가 필요하다. 이렇게 하면 리포지터리에서 DAO (여기서는 CrimeDao)의 함수를 호출만 하면 되므로 코드가 간단해지고 이해하기 쉬워진다. 쿼리 테스트하기 리포지터리가 준비되었지만 쿼리 함수를 테스트하기 전에 할 일이 하나 더 있다. 현재 데이터베이스에는 범죄 데이터가 하나도 없다. 코드에서 모의 데이터를 생성해 데이터베이스에 추가할 수 있찌만, 데이터를 추가하는 DAO 함수를 아직 구현하지 않았기 때문에 데이터베이스 파일을 이용한다. 안드로이드 스튜디오의 장치 파일 탐색기(Device File Explorer)를 사용해서 에뮬레이터에 파일을 업로드하면 된다. 참고로 에뮬레이터는 루트 권한으로 사용할 수 있어서 데이터베이스 파일의 업로드 및 앱에서의 사용이 가능하지만, 실제 장치에서는 데이터베이스 파일을 복사하지 못하거나 복사가 되더라도 권한이 없어서 앱에서 사용하지 못할 수 있기 때문에 데이터베이스 파일을 사용할 경우 에뮬레이터에서 테스트한다. 리포지터리를 사용해서 퀴리할 수 있는 데이터가 준비되었으니 CrimeListViewModel에서 기존의 모의 데이터 코드를 삭제하고 CrimeRepository의 getCrimes() 함수를 호출하는 코드로 교체한다. CrimeListViewModel에서 리포지터리 액세스하기 1234567891011121314151617class CrimeListViewModel: ViewModel() {// val crimes = mutableListOf&lt;Crime&gt;()//// init {// for (i in 0 until 100) {// val crime = Crime()// crime.title = &quot;Crime #$i&quot;// crime.isSolved = i % 2 == 0// crimes += crime// }// } private val crimeRepository = CrimeRepository.get() val crimes = crimeRepository.getCrimes()} 변경 후 앱을 실행하면 앱이 중단이 된다…! LogCat의 에러 메시지를 보면 아래와 같다. 이 에러는 Room 라이브러리에서 발생된 것으로, 긴 시간 동안 UI를 차단하는 데이터베이스 액세스를 main 스레드에서 하려고 했기 때문이다. 따라서 데이터베이스 액세스와 같이 시간이 걸리는 작업은 백그라운드에서 수행해야 한다. 애플리케이션의 스레드 데이터베이스로부터 데이터를 가져오는 것은 즉시 처리되지 않고 오래 걸릴 수 있다. Room은 메인 스레드에서의 데이터베이스 액세스를 허용하지 않으며, 액세스하려고 하면 IllegalStateException을 발생시킨다. 이것을 이해하려면 스레드가 무엇인지, 그리고 메인 스레드는 무엇이고 무슨 일을 하는지 알아야 한다. 스레드는 단일의 실행 시퀀스다. 스레드 내부의 코드는 한 단계씩 실행된다. 모든 안드로이드 앱은 main 스레드로 시작된다. 그러나 main 스레드는 미리 정해진 순서로 실행되지 않는다. 대신에 무한 루프에 머물면서 사용자나 시스템이 유발한 이벤트를 기다린다. 그리고 이벤트가 발생하면 응답하는 코드를 실행한다. 일반 스레드 vs main 스레드 main 스레드는 UI를 변경하는 모든 코드들을 실행하며, 액티비티 시작, 버튼 클릭 등 서로 다른 UI 관련 이벤트들에 대한 응답으로 실행되는 코드들도 포함된다. 이벤트들은 어떤 형태로든 모두 UI와 관련이 있어서 main 스레드를 UI 스레드라고도 한다. 이벤트 루프에서는 UI 코드를 순서대로 유지한다. 따라서 시기 적절하게 코드가 실행되면서도 상호 충돌이 생기지 않는다. 지금까지 작성했던 모든 코드는 main 스레드에서 실행되었다. 백그라운드 스레드 데이터베이스 액세스는 다른 일보다 시간이 많이 걸린다. 따라서 이 시간 동안 UI는 완전히 응답 불가능이 될 것이고, 결국은 애플리케이션이 응답하지 않는(ANR, Application Not Responding) 결과를 초래하게 된다. main 스레드가 중요한 이벤트에 대한 응답에 실패했다고 안드로이드의 와치독 watchdog이 판단하면 ANR이 발생하며, 애플리케이션이 중단된다 (10초 이내에 UI 응답이 없으면 사용자가 불편하지 않도록 안드로이드 시스템에서 ANR을 발생시킨다). 이를 해결하기 위해 백그라운드 스레드를 생성해서 데이터베이스를 액세스해야 한다. 백그라운드 스레드를 앱에 추가할 때 중요한 규칙이 두 가지 있다. 장시간 실행되는 모든 작업은 백그라운드 스레드로 실행되어야 한다. 이렇게 하면 main 스레드가 UI 관련 작업을 자유롭게 처리할 수 있어서 사용자를 위한 UI 응답을 지속적으로 처리할 수 있다. UI는 main 스레드에서만 변경할 수 있다. 백그라운드 스레드에서 UI를 변경하려고 하면 에러가 발생한다. 따라서 백그라운드 스레드에서 생성되는 모든 데이터는 main 스레드에 전달해서 UI를 변경하게 해야 한다. 안드로이드에서 백그라운드 스레드로 작업을 실행하는 방법에는 여러 가지가 있다. 비동기 네트워크를 요청하는 방법은 링크 추가 예정에서, 핸들러 Handler를 사용해서 많은 소규모 백그라운드 작업을 수행하는 방법은 링크 추가 예정에서, WorkManager를 사용해서 주기적인 백그라운드 작업을 수행하는 방법은 링크 추가 예정에서 알아본다. 백그라운드에서 데이터베이스 작업을 실행하기 위해 두 가지 방법을 사용하는데, 본문에서는 쿼리 데이터를 포함하는 LiveData를 사용하고, 후에 Executor를 사용해서 데이터를 추가 및 변경한다. LiveData 사용하기 LiveData는 Jetpack의 lifecycle-extensions 라이브러리에 있는 데이터 홀더 클래스이며, Room에서 LiveData를 사용한다. LiveData의 목적은 앱의 서로 다른 부분 간에 데이터 전달을 쉽게 만드는 것이다. 범죄 데이터를 보여줘야하는 프래그먼트로 CrimeRepository에서 데이터를 전달할 수 있으며 스레드 간에도 데이터를 전달할 수 있어서 백그라운드 스레드에서 main 스레드로 데이터를 전달할 수 있다. Room DAO의 쿼리에서 LiveData를 반환하도록 구성하면, Room이 백그라운드 스레드에서 쿼리 작업을 자동 실행한 후 그 결과를 LiveData 객체로 반환한다. 따라서 액티비티나 프래그먼트에서는 LiveData 객체를 관찰하도록 설정만 하면 된다. 그리고 LiveData 객체가 준비되면 main 스레드의 액티비티나 프래그먼트에 통보되므로 이때 LiveData를 사용해서 데이터를 처리하면 된다. DAO에서 LiveData 반환하기 원래의 반환 타입을 포함하는 LiveData 객체를 반환하도록 쿼리 함수들의 반환 타입을 변경한다. 1234567891011@Daointerface CrimeDao { @Query(&quot;SELECT * FROM crime&quot;)// fun getCrimes(): List&lt;Crime&gt; fun getCrimes(): LiveData&lt;List&lt;Crime&gt;&gt; @Query(&quot;SELECT * FROM crime WHERE id=(:id)&quot;)// fun getCrime(id: UUID): Crime? fun getCrime(id: UUID): LiveData&lt;Crime?&gt;} CrimeDao를 구현한 자동 생성된 클래스에서 LiveData의 인스턴스를 반환하므로 Room은 백그라운드 스레드에서 쿼리를 실행한다. 그리고 쿼리가 완료되면 범죄 데이터가 main 스레드로 전달되고 LiveData 객체를 관찰하는 옵저버 observer에 통보된다. (본문에서는 CrimeListFragment가 옵저버) 다음으로 CrimeRepository의 쿼리 함수들이 LiveData를 반환하도록 변경한다. 리포지터리에서 LiveData 반환하기 1234567891011class CrimeRepository private constructor(context: Context){ ... private val crimeDao = database.crimeDao()// fun getCrimes(): List&lt;Crime&gt; = crimeDao.getCrimes() fun getCrimes(): LiveData&lt;List&lt;Crime&gt;&gt; = crimeDao.getCrimes()// fun getCrime(id: UUID): Crime? = crimeDao.getCrime(id) fun getCrime(id: UUID): LiveData&lt;Crime?&gt; = crimeDao.getCrime(id) ...} LiveData 관찰하기 데이터베이스의 범죄 데이터를 범죄 리스트 화면에 보고자 CrimeRepository.getCrimes()로부터 반환되는 LiveData 객체를 관찰하도록 CrimeListFragment를 변경한다. 속성에서 무슨 데이터를 저장하는지 알기 쉽게 하기 위해 이름 변경 12345class CrimeListViewModel: ViewModel() { private val crimeRepository = CrimeRepository.get()// val crimes = crimeRepository.getCrimes() val crimeListLiveData = crimeRepository.getCrimes()} LivaData는 데이터베이스로부터 반환되는 범죄 데이터들을 포함한다. 그리고 CrimeListFragment는 데이터베이스로부터 결과가 반환되는 것을 기다렸다가 LiveData가 반환되면 RecyclerView를 범죄 데이터로 채울 수 있다. 따라서 RecyclerView 어댑터를 비어 있는 List로 초기화해야 한다. 그리고 새로운 범죄 데이터가 LiveData로 반환될 때 RecyclerView 어댑터가 새로운 범죄 List를 갖도록 설정한다. LiveData 옵저버와 RecyclerView 어댑터 설정하기 123456789101112131415161718192021222324252627282930313233class CrimeListFragment : Fragment() { private lateinit var crimeRecyclerView: RecyclerView// private var adapter: CrimeAdapter? = null private var adapter: CrimeAdapter? = CrimeAdapter(emptyList()) ... override fun onCreateView( ... ): View? { ... crimeRecyclerView.layoutManager = LinearLayoutManager(context) crimeRecyclerView.adapter = adapter return view } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) crimeListViewModel.crimeListLiveData.observe( viewLifecycleOwner, Observer { crimes -&gt; crimes.let { Log.i(TAG, &quot;Got crimes ${crimes.size}&quot;) updateUI(crimes) } }) } private fun updateUI(crimes: List&lt;Crime&gt;) { adapter = CrimeAdapter(crimes) crimeRecyclerView.adapter = adapter } LiveData.observe(LifecycleOwner, Observer) 함수는 LiveData 인스턴스에 옵저버를 등록하기 위해 사용된다. observe(...) 함수의 첫 번째 인자로 지정된 viewLifeCycleOwner는 코틀린의 속성이며, androidx.fragment.app.fragment의 getViewLifeCycleOwner() 함수를 호출하는 것과 같다. viewLifeCycleOwner는 프래그먼트 뷰의 생명주기를 나타내는 LifecycleOwner 구현 객체를 반환한다. 따라서 여기서는 CrimeListFragment의 생명주기가 아닌 CrimeListFragment의 뷰의 생명주기에 맞춰 옵저버가 LiveData 인스턴스의 변경을 관찰하고 변경이 생기면 실행된다는 의미다. observe(...) 함수의 두 번째 인자는 Observer 인터페이스를 구현하는 객체, 즉 옵저버이며 여기서는 람다식으로 구현되었다. 옵저버는 LiveData의 새로운 데이터를 처리하며, 여기서는 LiveData의 범죄 데이터 리스트가 변경될 때마다 실행된다. 즉, LiveData의 범죄 List를 받아서 로그 메시지를 출력하고 updateUI() 함수를 호출한다. 만일 LiveData의 변경이 생길 때마다 옵저버가 실행되면 프래그먼트의 뷰가 유효한 상태가 아닐 때(예로, 화면에 보이지 않을 때)도 updateUI(crimes) 함수에서 프래그먼트의 뷰를 변경하려 할 것이고 결국 앱이 중단될 것이다. 그러므로 LiveData.observe(...) 함수의 첫 번째 인자로 LifecycleOwner 객체를 지정하는 것이다. 이렇게 하면 옵저버의 생명주기는 지정한 LifecycleOwner 객체가 나타내는 안드로이드 컴포넌트의 생명주기에 한정된다. 따라서 프래그먼트의 뷰가 유효한 상태일 때만 LiveData 객체가 옵저버에게 변경 (새로운 데이터를 받았음)을 통보해 UI를 변경할 수 있다. 이처럼 LiveData는 프래그먼트 뷰의 생명주기에 따라 반응해서 이런 컴포넌트를 생명주기-인식 컴포넌트 lifecycle-aware component 라고 한다. 이 내용은 링크 추가 예정에서 자세히 다룬다. LifecycleOwner 인터페이스를 구현하는 객체는 Lifecycle 객체를 포함한다. Lifecycle은 안드로이드 생명주기의 현재 상태를 유지 관리하는 객체다 (액티비티, 프래그먼트, 뷰, 심지어 앱 자체도 자신의 생명주기를 갖는다). '생성’이나 '실행 재개’와 같은 생명주기 상태는 Lifecycle.State 열거형 enum에 정의되어 있으며, Lifecycle.getCurrentState()를 사용하면 Lifecycle 객체의 상태를 알 수 있다. AndroidX의 Fragment 클래스는 LifecycleOwner 인터페이스를 구현하며, 프래그먼트 인스턴스의 생명주기 상태를 나타내는 Lifecycle 객체를 갖고 있다. 프래그먼트 뷰의 생명주기는 FragmentViewLifecycleOwner가 별개로 유지 및 관리한다. 각 프래그먼트는 자신의 뷰의 생명주기를 유지 및 관리하는 FragmentViewLifecycleOwner 인스턴스를 갖는다. 위의 코드에서는 observe(...) 함수의 첫 번째 인자로 viewLifecycleOwner를 전달하므로 옵저버의 실행이 프래그먼트 자신이 아닌 프래그먼트 뷰의 생명주기와 연동된다. 프래그먼트 뷰의 생명주기는 프래그먼트 인스턴스의 생명주기와 별개지만 프래그먼트의 생명주기를 반영한다. 그런데 프래그먼트의 유보 retaining 로 이를 변경할 수 있다. 뷰의 생명주기와 프래그먼트 유보는 링크 추가 예정에서 더 자세히 다룬다. Fragment.onViewCreated(...)는 Fragment.OnCreateView(...)가 실행된 후 호출되므로 프래그먼트 뷰의 계층 구조에 맞춰 모든 뷰들이 형성된 후 실행된다. 따라서 onCreated(...)에서 LiveData 변경을 관찰하면 프래그먼트 뷰가 범죄 데이터를 보여줄 준비가 되었음을 확신할 수 있다. observe() 함수의 첫 번째 인자로 프래그먼트 자신이 아닌 viewLifecycleOwner를 전달하는 것도 이 때문이다. 여기서 원하는 것은 프래그먼트의 뷰가 좋은 상태일 때 LiveData로부터 범죄 리스트를 받는 것이다. 따라서 프래그먼트 뷰의 LifecycleOwner 객체를 사용하면 뷰가 화면에 보이지 않을 때는 LiveData 변경 데이터를 받지 않는다. 데이터베이스의 범죄 데이터 보여주기 싱글톤 CrimeRepository에서 사용된 것처럼 싱글톤 패턴은 안드로이드에서 매우 자주 사용된다. 그런데 싱글톤이 앱의 유지 보수를 어렵게 만들 수도 있다. 싱글톤은 프래그먼트나 액티비티보다 더 오래 존재한다. 또한, 싱글톤은 장치를 회전시키더라도 여전히 존재하며 앱의 액티비티와 프래그먼트를 오갈 때도 계속 남는다. 싱글톤을 사용하면 모델 객체를 소유하는 클래스를 편리하게 만들 수 있다. 범죄 데이터(Crime 객체)를 변경하는 많은 액티비티와 프래그먼트를 갖고 있는 더 복잡한 앱을 생각해보자. 한 컨트롤러가 범죄 데이터를 변경할 때 변경된 데이터를 어떻게 다른 컨트롤러에 전달할 수 있을까? 이때 만일 CrimeRepository가 범죄 데이터의 소유 클래스이면서 모든 변경 데이터가 CrimeRepository에 전달된다면 변경 데이터의 전달을 훨씬 쉽게 할 수 있다. 즉, 컨트롤러 사이를 이동하는 동안 특정 범죄의 식별자로 범죄 ID를 전달할 수 있으며, 각 컨트롤러는 이 ID를 사용해서 CrimeRepository로부터 해당 범죄 객체의 모든 데이터를 가져올 수 있다. 그러나 싱글톤은 몇 가지 단점을 가지고 있다. 싱글톤은 컨트롤러보다 더 오랜 생애 동안 데이터를 저장하게 해주지만 싱글톤 자신도 생애가 있다. 즉, 앱이 종료된 후 어떤 시점에서 안드로이드 운영체제가 메모리를 회수하면 싱글톤은 자신의 인스턴스 변수와 함께 소멸된다. 따라서 싱글톤은 장기간에 걸쳐 데이터를 저장할 수 있는 방법은 아니며, 데이터를 디스크에 쓰거나 웹 서버로 전송하는 것만이 해결책이다. 싱글톤은 코드의 단위 테스트를 어렵게 만들 수 있다. 안드로이드 개발자들은 주로 의존성 주입 dependency injection 으로 이 문제를 해결한다. 이렇게 하면 객체들을 싱글톤을 공유할 수 있다. 싱글톤은 잘못 사용될 수 있다. 편리하다고 아무 생각 없이 모든 것에 싱글톤을 사용하려고 할 수 있다. 왜냐하면 싱글톤은 코드 어디서나 사용할 수 있으며, 나중에 사용할 데이터가 어떤 것이든 싱글톤에 저장할 수 있기 때문이다. 그러나 '이 데이터는 어디에 사용되는가? 이 기능이 중요한 곳은 어디인가?'라는 매우 중요한 질문을 스스로에게 해야 한다. 싱글톤은 잘 구성된 안드로이드 앱의 핵심 컴포넌트다. 단, 올바르게 사용될 때만 그렇다!","link":"/2021/05/24/android-bnr-11/"},{"title":"[Codility] OddOccurrencesInArray","text":"Lesson 2 - Arrays : OddOccurrencesInArray kotlin 첫 시도 123fun solution(A: IntArray): Int { return A.groupBy { it }.filter { it.value.size % 2 == 1 }.map { it.key }.first()} 날먹 시도 실패 😩 두 번째 시도 : HashMap 이용 12345678910111213fun solution(A: IntArray): Int { val hashMap = HashMap&lt;Int, Int&gt;() A.forEach { hashMap[it] = hashMap.getOrDefault(it, 0) + 1 } hashMap.keys.forEach { if (hashMap.getValue(it) % 2 == 1) return it } return -1} 번외 : step을 이용한 비교 123456789101112fun solution(A: IntArray): Int { if (A.size == 1) return A[0] A.sort() for (i in A.indices step 2) { if (i + 1 == A.size) return A[i] if (A[i] != A[i + 1]) return A[i] } return -1} xor 연산 이용 123456789fun solution(A: IntArray): Int { var result = 0 A.forEach { result = result xor it } return result} 여러 방법으로 시도해도 효율성 테스트의 마지막 케이스가 실패했기에 검색을 해보니 비트 연산자를 활용하는 방법이 있었다! xor 연산은 숫자가 같으면 0, 숫자가 다르면 1을 반환하기 때문에 중복되지 않은 요소를 찾아내는데 유용하다.","link":"/2021/05/24/codility-odd-occurrences/"},{"title":"[Android] Fragment간 데이터 전달","text":"RecyclerView의 특정 항목을 누르면 MainActivity에서 RecyclerView가 존재하는 프래그먼트를 상세 항목을 보여주는 프래그먼트의 새로운 인스턴스로 교체하여 선택된 데이터의 상세 내역을 보여주도록 해보자. 이를 위해선 아래의 방법들을 알고 있어야 한다. 호스팅 액티비티가 프래그먼트들을 바꿔치기해서 이동을 구현하는 방법 프래그먼트 인자 fragment argument 를 사용해서 프래그먼트 인스턴스에게 데이터를 전달하는 방법 UI 변경에 따라 LiveData를 변환 transform 하는 방법 단일 액티비티: 프래그먼트의 우두머리 이전에는 한 액티비티가 다른 액티비티를 시작시켰지만, 본문의 예시 앱인 CriminalIntent 앱에서는 단일 액티비티 아키텍쳐 single activity architecture 를 사용한다. 단일 액티비티 아키텍처를 사용하는 앱은 하나의 액티비티와 다수의 프래그먼트를 가지며, 그 액티비티는 사용자 이벤트에 반응해 프래그먼트들을 상호 교체한다. 리스트의 특정 범죄 데이터를 사용자가 누르면 CrimeListFragment로부터 CrimeFragment로의 이동(혹은 교체)을 구현하기 위해 호스팅 액티비티의 프래그먼트 매니저에서 프래그먼트 트랜잭션을 시작시킨다 그리고 이 일을 수행하는 코드를 CrimeListFragment의 CrimeHolder.onClick(view)에 둔다. 이때 onClick(View)에서는 MainActivity의 FragmentManager 인스턴스를 생성한 후 CrimeListFragment를 CrimeFragement로 교체하는 트랜잭션을 커밋한다. 그런데 CrimeListFragment의 CrimeHolder.onClick(view)의 코드를 아래와 같이 작성하면 작동은 잘 되지만 바람직한 방법은 아니다. 1234567fun onClick(view: View) { val fragment = CrimeFragment.newInstance(crime.id) val fm = activity.supportFragmentManager fm.beginTransaction() .replace(R.id.fragment_container, fragment) .commit()} 프래그먼트는 독자적이고 구성 가능한 단위가 되어야 하는데 그렇지가 않기 때문이다. 이처럼 액티비티의 FragmentManager에서 다른 프래그먼트로 교체하는 일을 액티비티가 아닌 프래그먼트에서 하려면 이 프래그먼트는 자신을 호스팅하는 액티비티가 어떤 레이아웃을 갖고 어떻게 작동하는지 알아야 한다. 따라서 프래그먼트의 기본 취지에 어긋난다. 즉, 위의 코드에서 CrimeListFragment는 CrimeFragment를 MainActivity에 추가하면서 MainActivity의 레이아웃에 fragment_container가 있을 것이라고 가정한다. 그러나 이런 일은 CrimeListFragment의 호스팅 액티비티인 MainActivity가 해야 할 일이다. 따라서 여기서는 프래그먼트의 독립성을 유지하기 위해 프래그먼트에 콜백 인터페이스를 정의하고 호스팅 액티비티가 해당 콜백 인터페이스를 구현해 프래그먼트 교체를 수행하게 한다. 프래그먼트 콜백 인터페이스 프래그먼트 교체 기능을 호스팅 액티비티에 위임하기 위해 프래그먼트에는 Callbacks라는 이름의 커스텀 콜백 인터페이스를 정의하고, 이 인터페이스에는 프래그먼트가 필요로 하는 일을 수행하게 하는 함수를 정의한다. 그리고 이 프래그먼트를 호스팅하는 모든 액티비티는 반드시 해당 인터페이스를 구현해야 한다. 콜백 인터페이스를 사용하면 어떤 액티비티가 호스팅하는지 알 필요 없이 프래그먼트가 자신을 호스팅하는 액티비티의 함수들을 호출할 수 있다. 콜백 인터페이스를 사용해서 CrimeListFragment의 클릭 이벤트 처리를 호스팅 액티비티에게 위임하자. 콜백 인터페이스 추가하기 (CrimeListFragment.kt) 하나의 콜백 함수를 갖는 Callbacks 인터페이스를 선언하고 Callbacks를 구현하는 객체 참조를 저장하기 위해 callbacks 속성을 추가한다. 그리고 onAttach(context)와 onDetach()를 오버라이드해 callbacks 속성을 설정 또는 설정 해제한다. 1234567891011121314151617181920212223242526272829303132333435class CrimeListFragment : Fragment() { /** * 호스팅 액티비티에서 구현할 인터페이스 */ interface Callbacks { fun onCrimeSelected(crimeId: UUID) } // callbacks 속성 추가 private var callbacks: Callbacks? = null ... // callbacks 속성 설정 override fun onAttach(context: Context) { super.onAttach(context) callbacks = context as Callbacks? } override fun onCreateView(...): View? { ... } override fun onViewCreated(...) { ... } // callbacks 속성 해제 override fun onDetach() { super.onDetach() callbacks = null } ...} 중요★ Fragment.onAttach(Context) 생명주기 함수는 프래그먼트가 호스팅 액티비티에 연결될 때 호출된다. 여기서는 onAttach(...)의 인자로 전달된 Context 객체의 참조를 callbacks 속성에 저장하며, CrimeListFragment를 호스팅하는 액티비티 인스턴스가 Context 객체다. Activity는 Context의 서브 클래스다. 따라서 onAttach(...)의 인자로 Activity 타입을 전달해도 되지만, 슈퍼 타입인 Context를 전달하는 것이 코드의 유연성이 좋다. 또한, onAttach(Activity)는 향후 API 버전에서 없어질 수 있으므로 deprecated, onAttach(Context)를 사용한다. onAttach(Context)와 반대로, 프래그먼트가 액티비티에서 분리될 때 호출되는 생명주기 함수인 Fragment.onDetach()에서는 callbacks 속성을 null로 설정한다. 이 함수가 호출될 때는 호스팅 액티비티를 사용할 수 없거나 호스팅 액티비티가 계속 존재한다는 보장이 없기 때문이다. onAttach(Context)에서 인자로 전달된 Context 객체의 참조를 callbacks 속성에 지정할 때는 CrimeListFragment.Callbacks 타입으로 변환한다. 따라서 CrimeListFragment를 호스팅하는 액티비티는 반드시 CrimeListFragment.Callbacks 인터페이스를 구현해야 한다. 호스팅 액티비티의 onCrimeSelected(...) 호출하기 (CrimeListFragment.kt) 어떤 액티비티가 호스팅을 하든 이제는 CrimeListFragment가 호스팅 액티비티의 콜백 구현 함수 (여기서는 onCrimeSelected(UUID)) 를 호출할 수 있게 되었다. CrimeListFragment.Callbacks 인터페이스를 구현하는 호스팅 액티비티면 어떠한 것도 가능하다. 현재는 범죄 리스트의 특정 항목을 누르면 CrimeListFragment의 내부 클래스인 CrimeHolder의 onClick(View)가 호출되고 토스트 메시지만 보여주므로, Callbacks 인터페이스를 통해 호스팅 액티비티의 onCrimeSelected(UUID)를 호출하도록 변경하고 호스팅 액티비티가 Callbacks 인터페이스의 onCrimeSelected(UUID) 구현하도록 변경한다. 12345678910111213141516class CrimeListFragment : Fragment() { ... private inner class CrimeHolder(view: View) : RecyclerView.ViewHolder(view), View.OnClickListener { ... fun bind(crime: Crime) { ... } override fun onClick(v: View) {// Toast.makeText(context, &quot;${crime.title} pressed!&quot;, Toast.LENGTH_SHORT).show() callbacks?.onCrimeSelected(crime.id) } } ...} 호스팅 액티비티에서 콜백 인터페이스 구현하기 (MainActivity.kt) 123456789101112private const val TAG = &quot;MainActivity&quot;class MainActivity : AppCompatActivity(), CrimeListFragment.Callbacks { override fun onCreate(savedInstanceState: Bundle?) { ... } override fun onCrimeSelected(crimeId: UUID) { Log.d(TAG, &quot;MainActivity.onCrimeSelected: $crimeId&quot;) }} LogCat을 확인해보면 범죄 리스트의 각 항목을 클릭할 때마다 MainActivity의 onCrimeSelected(UUID)가 호출되어 로그 메시지가 나타난다. 이 함수는 Callbacks 인터페이슬르 통해 CrimeListFragment로부터 호출된 것이다. 프래그먼트 교체하기 콜백 인터페이스를 제대로 연결하였으니 사용자가 CrimeListFragment의 범죄 리스트에서 특정 항목을 누르면 MainActivity의 onCrimeSelected(UUID)에서 CrimeListFragment가 CrimeFragment 인스턴트로 교체되도록 변경한다. 현재는 콜백으로 전달되는 Crime 객체의 ID를 사용하지 않는다. CrimeListFragment를 CrimeFragment로 교체하기 (MainActivity.kt) 1234567891011121314class MainActivity : AppCompatActivity(), CrimeListFragment.Callbacks { override fun onCreate(savedInstanceState: Bundle?) { ... } override fun onCrimeSelected(crimeId: UUID) { val fragment = CrimeFragment() supportFragmentManager .beginTransaction() .replace(R.id.fragment_container, fragment) .commit() }} FragmentTransaction.replace(Int, Fragment)는 액티비티에 현재 호스팅된 프래그먼트를 두 번째 인자로 전달된 프래그먼트로 교체하여 첫 번째 인자로 전달된 리소스 ID를 갖는 컨테이너에 넣는다. 만일 기존에 호스팅된 프래그먼트가 없으면 FragmentTransaction.add(Int, Fragment)를 호출할 때와 같게 새로운 프래그먼트로 추가된다. 지금은 범죄의 상세 내역 화면이 비어 있는데, 어떤 Crime 객체를 보여줄 것인지 CrimeFragment에게 알려주지 않았기 때문이다. 이 작업은 잠시 후에 하고 프래그먼트 간의 이동을 구현하는데 추가로 해야 할 작업을 먼저 실시하자. 현재 화면에서 백 버튼을 클릭해보면 범죄 리스트를 보여주는 CrimeListFragment 화면으로 돌아가지 않는다. 앱을 시작할 당시에 실행되었던 MainActivity 인스턴스만이 앱의 백 스택에 존재했기 때문이다. 프래그먼트 교체 트랜잭션을 백 스택에 추가해서 구현하여 이전 프래그먼트로 돌아가도록 구현한다. 플래그먼트 트랜잭션을 백 스택에 추가하기 (MainActivity.kt) 1234567891011class MainActivity : AppCompatActivity(), CrimeListFragment.Callbacks { ... override fun onCrimeSelected(crimeId: UUID) { val fragment = CrimeFragment() supportFragmentManager .beginTransaction() .replace(R.id.fragment_container, fragment) .addToBackStack(null) // 백 스택에 추가 .commit() }} 이처럼 트랜잭션을 백 스택에 추가하면 사용자가 백 버튼을 누를 때 해당 트랜잭션이 취소되면서 이전 상태로 복원되며, 여기서는 CrimeFragment가 CrimeListFragment로 교체된다. FragmentTransaction.addToBackStack(String)을 호출할 때 백 스택 상태의 이름을 나타내는 문자열을 인자로 전달할 수 있다. 그러나 여기서는 그럴 필요가 없어서 null을 전달하였다. 프래그먼트 인자 프래그먼트 인자 fragment argument를 사용하면 프래그먼트에 속하는 어딘가에 데이터를 저장할 수 있다. 여기서 프래그먼트에 속하는 ‘어딘가’ 는 인자 번들 argument bundle 을 말한다. 프래그먼트는 자신의 부모 액티비티나 다른 외부 소스에 의존하지 않고 인자 번들로부터 데이터를 가져올 수 있다. 프래그먼트 인자는 프래그먼트의 캡슐화를 도와준다. 그리고 캡슐화가 잘된 프래그먼트는 재사용할 수 있는 구성 요소가 되므로 어떤 액티비티에도 쉽게 호스팅될 수 있다. 프래그먼트 인자를 생성하기 위해 우선 Bundle 객체를 생성한다. 이 Bundle 객체는 액티비티의 인텐트 엑스트라와 마찬가지로 키와 값의 쌍으로 된 데이터를 포함하며, 각 쌍의 데이터를 인자라고 한다. 그다음에 타입마다 따로 있는 Bundle의 put 함수들을 이용해서 인자들을 Bundle 객체에 추가한다. Bunlde 객체에 인자들을 추가하는 예시 모든 프래그먼트 인스턴스는 자신에게 첨부된 Bundle 객체에 프래그먼트 인자들을 저장할 수 있다. 12345val args = Bundle().apply { putSerializable(ARG_MY_OBJECT, myObject) putInt(ARG_MY_INT, myInt) putCharSequence(ARG_MY_STRING, myString)} 인자를 프래그먼트에 첨부하기 인자 번들을 프래그먼트에 추가할 때는 Fragment.setArguments(Bundle)을 호출한다. 단, 프래그먼트가 생성되어 해당 프래그먼트가 액티비티에 추가되기 전에 프래그먼트에 첨부해야 한다. 이렇게 하려면 newInstance(...)라는 이름의 함수를 포함하는 동반 객체 companion object를 Fragment 클래스에 추가하는 것이 좋다. 이 함수에서는 프래그먼트 인스턴스와 번들 인스턴스를 생성하고 번들 인스턴스에 인자를 저장한 후 프래그먼트 인자로 첨부한다. 그리고 호스팅 액티비티가 프래그먼트의 인스턴스를 필요로 할 때 이 프래그먼트의 생성자를 직접 호출하는 대신 newInstance(...) 함수를 호출하면 된다. 그러면 이 함수에서 필요한 인자들을 전달할 수 있다. newInstance(UUID) 함수 작성하기 (CrimeFragment.kt) 12345678910111213141516171819private const val ARG_CRIME_ID = &quot;crime_id&quot;class CrimeFragment : Fragment() { ... override fun onStart() { ... } companion object { fun newInstance(crimeId: UUID): CrimeFragment { val args = Bundle().apply { putSerializable(ARG_CRIME_ID, crimeId) } return CrimeFragment().apply { arguments = args } } }} newInstance(UUID) 함수에서는 UUID 타입의 인자를 받아서 인자 번들 인스턴스를 생성하고 인자를 저장하며, 프래그먼트 인스턴스를 생성한 후 인자 번들을 프래그먼트에 첨부한다. 아래의 동반 객체 리턴 값에서 arguments는 Fragment의 속성이며, 코틀린에서는 속성에 값을 설정할 때 setter를 자동 호출한다. 따라서 끝에 있는 arguments = args는 setArguments(args)와 같다. 다음으로 MainActivity에서 CrimeFragment 인스턴스를 생성할 때 UUID를 인자로 전달해 CrimeFragment.newInstance(UUID)를 호출하도록 변경한다. `CrimeFragment.newInstance(UUID) 사용하기 (MainActivity.kt) 12345678910111213class MainActivity : AppCompatActivity(), CrimeListFragment.Callbacks { ... override fun onCrimeSelected(crimeId: UUID) {// val fragment = CrimeFragment() val fragment = CrimeFragment.newInstance(crimeId) supportFragmentManager .beginTransaction() .replace(R.id.fragment_container, fragment) .addToBackStack(null) .commit() }} 코드의 독립성이 액티비티와 프래그먼트 양쪽 모두에 필요한 것은 아니다. 즉, MainActivity는 CrimeFragment에 관해 많은 것을 알아야 한다. 예를 들면, CrimeFragment가 newInstance(UUID) 함수를 갖고 있다는 것 등이다. 호스팅 액티비티는 자신의 프래그먼트들을 호스팅하는 방법을 자세히 알아야 하므로 지극히 정상적이다. 이와 달리 프래그먼트는 자신의 호스팅 액티비티를 자세히 알 필요가 없다. 프래그먼트 인자 가져오기 프래그먼트가 자신에게 전달된 인자를 액세스할 때는 Fragment 클래스의 arguments 속성을 참조하면 된다. 그런 다음에 Bundle의 get 함수들 중 하나를 호출하면 된다. 프래그먼트 인자에서 범죄 데이터 ID 얻기 (CrimeFragment.kt) 1234567891011121314private const val TAG = &quot;CrimeFragment&quot;private const val ARG_CRIME_ID = &quot;crime_id&quot;class CrimeFragment : Fragment() { ... override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) crime = Crime() val crimeId: UUID = arguments?.getSerializable(ARG_CRIME_ID) as UUID Log.d(TAG, &quot;args bundle crime ID: $crimeId&quot;) // 궁극적으로는 데이터베이스로부터 데이터를 로드해야 한다. } ...} 코틀린에서는 속성을 참조할 때 getter를 자동 호출해준다. 따라서 끝에 새로 추가한 코드의 arguments 대신 getArguments()를 사용해도 된다. 상세 내역 화면에 보여줄 Crime 객체를 LiveData 변환으로 얻기 CrimeFragment가 범죄 데이터 ID를 갖게 되었으니 이 ID를 갖는 범죄 데이터가 화면에 보이도록 데이터베이스에서 범죄 데이터(Crime 객체)를 가져와보자. 이렇게 하기 위해 ViewModel의 서브 클래스로 CrimeDetailViewModel을 생성해 데이터베이스를 검색할 것이다. ViewModel을 사용하면 장치 회전 시에도 데이터가 보존되므로 데이터베이스 검색 쿼리를 매번 다시 할 필요가 없기 때문이다. 지정된 ID를 갖는 범죄 데이터를 CrimeFragment가 CrimeDetailViewModel에 요청하면 리포지터리의 getCrime(UUID)를 호출한 후 쿼리 결과로 받은 범죄 데이터를 CrimeFragment에 전달한다. 이때 리포지터리와 CrimeDetailViewModel, 그리고 CrimeFragment 간의 데이터 전달을 쉽게 하기 위해 Crime 객체를 갖는 LiveData를 사용한다. CrimeDetailViewModel 생성하기 123456789101112131415161718class CrimeDetailViewModel(): ViewModel() { // ① private val crimeRepository = CrimeRepository.get() // ② private val crimeIdLiveData = MutableLiveData&lt;UUID&gt;() // ③ var crimeLiveData: LiveData&lt;Crime?&gt; = Transformations.switchMap(crimeIdLiveData) { crimeId -&gt; crimeRepository.getCrime(crimeId) } // ④ fun loadCrime(crimeId: UUID) { crimeIdLiveData.value = crimeId }} ① crimeRepository 속성은 CrimeRepository 인스턴스 참조를 보존한다. 이렇게 속성을 사용한 이유는 향후에 CrimeDetailViewModel의 여러 곳에서 CrimeRepository 인스턴스를 사용하기 때문이다. ② crimeIdLiveData 속성은 변경 가능한 UUID 타입의 데이터를 저장한 LiveData를 참조한다. 여기서는 CrimeFragment가 현재 화면에 보여주거나 보여줄 범죄 데이터 ID가 LiveData에 저장된 데이터다. CrimeDetailViewModel 인스턴스가 최초 생성될 때는 crimeIdLiveData가 설정되지 않는다. 그러나 향후에 CrimeFragment 인스턴스가 생성될 때 CrimeFragment의 onCreate(Bundle?)에서 CrimeDetailViewModel.loadCrime(UUID)를 호출하므로, 이때 crimeIdLiveData가 범죄 ID로 설정되어 어떤 범죄 데이터를 가져올 것인지 CrimeDetailViewModel이 알 수 있다. ③ crimeLiveData 속성은 상세 내역 화면에 보여줄 Crime 객체를 저장한 LiveData를 참조하며, 이 LiveData는 Transformations.switchMap(crimeIdLiveData) {...}로부터 반환한다. 그리고 switchMap(crimeIdLiveData) {...}에서는 인자로 전달된 crimeIdLiveData의 범죄 ID를 갖는 범죄 데이터를 데이터베이스로부터 가져와서 LiveData로 반환한다. Transformations 클래스는 두 LiveData 객체 간의 변환을 해주는 함수들을 갖고 있다. switchMap(LiveData&lt;X&gt;, Function&lt;X, LiveData&lt;Y&gt;!&gt;) 함수에서는 첫 번째 인자로 전달된 LiveData에 설정된 각 값에 대해 두 번째 인자의 함수를 적용해서 변환하며, 이 결과를 LiveData로 반환한다. switchMap(...) 함수에는 crimeIdLiveData 속성이 첫 번째 인자로 전달되고, 두 번째 인자의 변환 함수로는 람다식이 지정되었다. 이 람다식의 crimeRepository.getCrime(crimeId) 함수는 crimeIdLiveData 속성값(범죄 ID)을 갖는 범죄 데이터를 데이터베이스에서 검색해 가져와서 Crime 객체를 갖는 LiveData로 반환한다. 그리고 이 LiveData가 crimeIdLiveData 속성에 설정된다. 이렇게 상세 내역 화면에 보여줄 Crime 객체를 저장한 LiveData가 준비된다. CrimeFragment를 CrimeDetailViewModel에 연결하기 (CrimeFragment.kt) onCreate(...)에서 CrimeDetailViewModel의 loadCrime(UUID)를 호출해 CrimeFragment를 CrimeDetailViewModel과 연결한다. 1234567891011121314151617class CrimeFragment : Fragment() { private lateinit var crime: Crime ... private val crimeDetailViewModel: CrimeDetailViewModel by lazy { ViewModelProvider(this).get(CrimeDetailViewModel::class.java) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) crime = Crime() val crimeId: UUID = arguments?.getSerializable(ARG_CRIME_ID) as UUID// Log.d(TAG, &quot;args bundle crime ID: $crimeId&quot;) crimeDetailViewModel.loadCrime(crimeId) } ...} 다음으로 CrimeDetailViewModel의 crimeLiveData가 변경되는지 관찰해서 새 데이터가 있으면 UI를 변경하도록 CrimeFragment를 변경한다. 그리고 Observer의 import문도 추가한다. 범죄 데이터 변경 관찰하기 (CrimeFragment.kt) 1234567891011121314151617181920212223242526272829303132333435363738394041...import androidx.lifecycle.ViewModelProviderimport androidx.lifecycle.Observer...class CrimeFragment : Fragment() { private lateinit var crime: Crime ... override fun onCreate(savedInstanceState: Bundle?) { ... } override fun onCreateView(...): View? { ... } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) crimeDetailViewModel.crimeLiveData.observe( viewLifecycleOwner, Observer { crime -&gt; crime?.let { this.crime = crime updateUI() } }) } override fun onStart() { ... } private fun updateUI() { titleField.setText(crime.title) dateButton.text = crime.date.toString() solvedCheckBox.isChecked = crime.isSolved } ...} CrimeFragment는 자신의 crime 속성에 Crime 객체 참조를 따로 갖고 있다. 이 속성은 사용자가 화면에서 변경한 현재의 데이터를 갖는 Crime 객체를 나타낸다. 반면에 CrimeDetailViewModel.crimeLiveData의 Crime 객체 데이터는 데이터베이스에 현재 저장된 것을 나타낸다. CrimeFragment의 crime 속성을 사용해서 현재 화면의 데이터를 데이터베이스에 변경하는 것은 잠시 후에 다룬다. CriminalIntent 앱의 백 스택 애니메이션 깜빡거림 없애기 위의 이미지에서 수갑 이미지가 있는 범죄 데이터를 선택하면 CrimeFragment가 상세 내역 화면을 보여줄 때 CheckBox의 표시가 깜빡거리면서 나타나는 것을 볼 수 있다. 이것은 정상으로, 사용자가 범죄 리스트에서 특정 데이터를 선택할 때 CrimeFragment가 시작되어 해당 데이터의 데이터베이스 쿼리가 시작된다. 그리고 쿼리가 끝나면 CrimeFragment의 CrimeDetailViewModel.crimeLiveData 옵저버가 실행되어 각 위젯의 데이터(제목, 발생일자, 해결 여부)를 화면에 보여준다. 이때 CheckBox는 클릭 시 생동감을 주기 위해 기본적으로 애니메이션을 수행해서 깜빡거리는 것처럼 보인다. 이런 깜빡거림은 View.jumpDrawablesToCurrentState()를 호출해서 애니메이션을 생략하면 해결할 수 있다. CheckBox의 깜빡거림만이 아닌 상세 내역 화면 전체가 나타나는데 Delay가 생긴다면, 일정 개수의 범죄 데이터를 메모리에 미리 로드한 후 공유되는 곳에 보존해서 사용하면 된다. 본문의 앱에서는 이런 시간 지연이 없으니 필요에 따라 애니메이션 정도만 생략해주면 된다. 데이터베이스 변경하기 사용자가 상세 내역 화면을 벗어날 때 사용자가 변경한 데이터를 데이터베이스에 저장해야 한다. 우선 기존의 범죄 데이터를 변경하는 함수와 새로운 데이터를 추가하는 함수를 CrimeDao에 추가한다. 단, 새 데이터 추가 함수는 링크 추가 예정에서 다룬다. 데이터베이스 함수 추가하기 (database/CrimeDao.kt) 123456789101112131415@Daointerface CrimeDao { @Query(&quot;SELECT * FROM crime&quot;) fun getCrimes(): LiveData&lt;List&lt;Crime&gt;&gt; @Query(&quot;SELECT * FROM crime WHERE id=(:id)&quot;) fun getCrime(id: UUID): LiveData&lt;Crime?&gt; @Update fun updateCrime(crime: Crime) @Insert fun addCrime(crime: Crime)} 변경 함수와 추가 함수의 애노테이션에는 매개변수를 지정하지 않아도 Room이 적합한 SQL 명령을 생성한다. updateCrime() 함수에는 @Update 애노테이션을 사용한다. 이 함수는 Crime 객체를 인자로 받아 이 객체에 저장된 ID를 사용해서 데이터베이스 테이블의 관련 행을 찾은 후 이 객체의 데이터로 변경한다. addCrime() 함수에는 @Insert 애노테이션을 사용한다. 이 함수는 인자로 받은 Crime 객체의 데이터를 데이터베이스 테이블에 추가한다. 다음으로 방금 CrimeDao에 추가한 두 함수를 호출하도록 리포지터리를 변경한다. 다시 말하지만, 이 DAO 함수들이 LiveData를 반환하므로 Room은 CrimeDao.getCrimes()와 CrimeDao.getCrime(UUID)의 데이터베이스 쿼리를 백그라운드 스레드로 자동 실행된다. 이 경우 LiveData가 해당 데이터를 main 스레드로 전달하기 때문에 UI를 변경할 수 있다. 그러나 변경이나 추가의 경우에는 Room이 백그라운드 스레드로 자동 실행하지 못한다. 따라서 백그라운드 스레드로 변경이나 추가 함수들을 호출해야 하는데, 이때 주로 executor를 사용한다. Executors 사용하기 Excutors는 스레드를 참조하는 객체다. Excutors 인스턴스는 execute라는 함수를 가지며, 이 함수는 실행할 코드 블록을 받는다. Executors 인스턴스를 생성하면 이 인스턴스가 새로운 백그라운드 스레드를 사용해 블록의 코드를 실행한다. 따라서 main 스레드를 방해하지 않고 데이터베이스 작업을 안전하게 수행할 수 있다. 여기서는 Executors를 CrimeDao에 직접 구현할 수 없다. 정의한 인터페이스를 기반으로 Room이 함수를 자동 생성하기 때문이다. 따라서 CrimeRepository에 Excutors를 구현해야 한다. executor를 사용해서 데이터 변경과 추가하기 (CrimeRepository.kt) Executors 인스턴스의 참조를 저장하는 속성과 Executors를 사용하는 함수를 추가한다. 1234567891011121314151617181920212223class CrimeRepository private constructor(context: Context){ ... private val crimeDao = database.crimeDao() private val executor = Executors.newSingleThreadExecutor() fun getCrimes(): LiveData&lt;List&lt;Crime&gt;&gt; = crimeDao.getCrimes() fun getCrime(id: UUID): LiveData&lt;Crime?&gt; = crimeDao.getCrime(id) fun updateCrime(crime: Crime) { executor.execute { crimeDao.updateCrime(crime) } } fun addCrime(crime: Crime) { executor.execute { crimeDao.addCrime(crime) } } ...} newSingleThreadExecutor() 함수는 새로운 스레드를 참조하는 executors 인스턴스를 반환한다. 따라서 이 인스턴스를 사용해서 실행하는 어떤 작업도 main 스레드와 별개로 수행되므로 UI를 방해하지 않는다. updateCrime(Crime)과 addCrime(Crime) 모두 execute {} 블록 내부에서 DAO 함수를 호출한다. 프래그먼트 생명주기에 맞춰 데이터베이스에 데이터 쓰기 마지막으로 사용자가 상세 내역 화면에서 입력한 데이터를 데이터베이스에 쓰도록 변경한다. 이 작업은 사용자가 상세 내역 화면을 벗어날 때 수행한다. 데이터베이스에 변경하기 (CrimeDetailViewModel.ky) 1234567891011class CrimeDetailViewModel: ViewModel() { ... fun loadCrime(crimeId: UUID) { crimeIdLiveData.value = crimeId } fun saveCrime(crime: Crime) { crimeRepository.updateCrime(crime) }} saveCrime(Crime)에서는 인자로 받은 Crime 객체를 데이터베이스에 변경한다. CrimeRepository는 백그라운드 스레드에서 데이터베이스의 데이터 변경을 처리하므로 saveCrime(Crime) 함수의 코드는 매우 간단하다. 다음으로 사용자가 변경한 범죄 데이터를 데이터베이스에 저장하도록 CrimeFragment를 변경한다. onStop()에서 저장하기 1234567891011121314151617class CrimeFragment : Fragment() { ... override fun onStart() { ... } override fun onStop() { super.onStop() crimeDetailViewModel.saveCrime(crime) } private fun updateUI() { ... } ...} Fragment.onStop()은 프래그먼트가 중단 상태 (프래그먼트 화면 전체가 안보이게 될 때)가 되면 언제든 호출된다. 따라서 여기서는 사용자가 상세 내역 화면을 떠나거나 (백 버튼) 작업을 전환 (홈 버튼 혹은 오버뷰 화면에서 다른 앱으로 전환)하면 데이터가 저장된다. 그러므로 onStop()에서 데이터를 저장하면 사용자가 상세 내역 화면을 떠나거나 메모리 부족으로 안드로이드가 프로세스를 종료할 때도 데이터가 유실되지 않고 저장된다. 💁🏻‍♂️ 궁금증 프래그먼트 인자를 사용하는 이유는? 본문에서 프래그먼트의 새로운 인스턴스를 생성할 때 인자를 전달하려고 newInstance(...) 함수를 프래그먼트에 추가하였다. 이런 패턴은 코드 구성 관점이나 프래그먼트 인자 모두에 유용하다. 이와는 달리, 생성자를 사용하면 프래그먼트 인스턴스에 인자를 전달할 수 없다. 예를 들어, newInstance(UUID) 함수를 추가하는 대신 UUID 타입의 범죄 ID를 인자로 받는 생성자를 CrimeFragment에 추가할 수 있다. 그런데 이 방법에는 결함이 있다. 장치 회전에 따른 구성 변경이 생기면 현재 액티비티의 프래그먼트 매니저는 구성 변경이 생기기 전에 호스팅되었던 프래그먼트 인스턴스를 자동으로 재생성한다. 그다음으로는 재생성된 프래그먼트 인스턴스를 새 액티비티 인스턴스에 추가한다. 그리고 구성 변경 후에 프래그먼트 매니저가 프래그먼트를 다시 생성할 때는 해당 프래그먼트의 인자가 없는 기본 생성자를 호출한다. 따라서 구성 변경 후에는 새로 생성된 프래그먼트 인스턴스가 범죄 ID를 받지 못하게 된다. 그렇다면 프래그먼트 인자를 사용할 때는 무엇이 다를까? 프래그먼트 인자는 프래그먼트 생애에 걸쳐 보존된다. 구성 변경이 생기더라도 프래그먼트 매니저가 새 프래그먼트 인스턴스를 생성하면서 프래그먼트 인자를 다시 첨부하기 때문이다. 따라서 새 프래그먼트는 첨부된 인자 번들을 사용해서 자신의 상태 데이터를 다시 생성할 수 있다. 그런데 이렇게 복잡하게 프래그먼트 인자를 사용하지 않고 프래그먼트의 인스턴스 변수를 사용해서 상태 데이터를 보존하면 되지 않을까? 그러나 항상 보존된다는 보장이 없다. 구성 변경이 생기거나 사용자가 다른 앱 화면으로 이동해서 안드로이드 운영체제가 프래그먼트를 다시 생성하면 프래그먼트의 모든 인스턴스 변수들이 갖는 값이 없어진다. 다른 방법으로는 SIS Saved Instance State 매커니즘이 있다. 이때는 범죄 ID를 프래그먼트 인스턴스 변수에 저장하고 프래그먼트가 소멸하면 자동 호출되는 onSaveInstanceState(Bundle)에서 범죄 ID를 Bundle 객체에 저장했다가 나중에 프래그먼트 인스턴스가 재생성되면 호출되는 onCreate(Bunlde)에서 Bundle 객체의 범죄 ID를 꺼내어 사용하면 된다. 이 방법도 모든 경우에 통용된다. 그런데 이 방법은 유지 보수가 어렵다. 기간이 지난 후에 해당 프래그먼트의 코드를 다시 보면서 또 다른 인자를 추가할 때 onSaveInstanceState(Bundle)에서 해당 인자를 저장했는지 기억하기 어렵기 때문이다. 따라서 모든 경우에 프래그먼트의 상태 데이터를 잘 보존하려면 프래그먼트 인자를 사용하는 것이 가장 좋다. 그외의 Fragment간 데이터 전달 방법들 https://developer.android.com/guide/fragments/communicate https://developer.android.com/guide/navigation/navigation-pass-data 👨🏻‍💻 챌린지 DiffUtil : 효율적으로 RecyclerView 다시 로드하기 본문의 코드는 상세 내역 화면의 데이터를 변경하고 리스트 화면으로 돌아오면 CrimeListFragment가 모든 범죄 데이터를 RecylcerView에 다시 채워서 보여준다. 하나의 범죄 데이터만 변경되었을 뿐인데 이렇게 모두 변경하는 것은 매우 비효율적이다. 변경된 범죄 데이터와 연관된 행만 다시 채워서 보여주도록 CrimeListFragment의 RecyclerView를 변경하자. CrimeListFragment의 내부 클래스로 정의된 CrimeAdapter의 슈퍼 클래스를 RecycelrView.Adapter&lt;CrimeHolder&gt; 대신 androidx.recyclerview.widget.ListAdapter&lt;Crime, CrimeHolder&gt; 로 변경하면 된다. ListAdapter는 현재의 RecyclerView 데이터와 새로 RecyclerView에 설정하는 데이터 간의 차이를 아는 RecyclerView의 어댑터다. 이런 차이점 비교는 백그라운드 스레드에서 수행되므로 UI에 영향을 주지 않는다. 그리고 비교가 끝난 후 ListAdapter는 변경된 데이터의 행들만 다시 채워서 보여주도록 RecyclerView에게 알려준다. ListAdapter는 androidx.recyclerview.widget.DiffUtil을 사용해서 데이터 셋의 어떤 부분이 변경되었는지 판단한다. 이 챌린지를 완료하려면 DiffUtil.ItemCallback&lt;Crime&gt;을 구현하는 클래스를 ListAdapter에 제공해야 한다. 또한, 변경된 범죄 리스트가 RecyclerView의 어댑터에 전달되도록 ListAdapter.submitList(MutableList&lt;T&gt;?)를 호출해서 CrimeListFragment를 변경한다 (UI를 변경할 때마다 RecyclerView의 어댑터를 새로운 어댑터 객체에 다시 지정하지 않게 한다). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class CrimeListFragment : Fragment() { ... override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) crimeListViewModel.crimeListLiveData.observe( viewLifecycleOwner, Observer { crimes -&gt; updateUI(crimes) }) } ... private fun updateUI(crimes: List&lt;Crime&gt;) { adapter = CrimeAdapter(crimes) crimeRecyclerView.adapter = adapter // ListAdapter에게 새로운 리스트가 생겼다는 것을 submitList()를 통해 알려준다. adapter?.submitList(crimes) } private inner class CrimeHolder(view: View) : RecyclerView.ViewHolder(view), View.OnClickListener { ... } /** * CrimeAdapter의 슈퍼 클래스를 ListAdapter로 변경 * RecycelrView.Adapter&lt;CrimeHolder&gt; 대신 androidx.recyclerview.widget.ListAdapter&lt;Crime, CrimeHolder&gt; 로 변경하면 된다. */ private inner class CrimeAdapter(var crimes: List&lt;Crime&gt;) : ListAdapter&lt;Crime, CrimeHolder&gt;(CrimeDiffCallback()) { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) : CrimeHolder { val view = layoutInflater.inflate(R.layout.list_item_crime, parent, false) return CrimeHolder(view) } // getItemCount() 오버라이드 함수를 제거한다. ListAdapter가 해당 메서드를 구현하기 때문 override fun onBindViewHolder(holder: CrimeHolder, position: Int) { val crime = getItem(position) holder.bind(crime) } } // DiffUtil.ItemCallback을 구현하는 클래스 생성 -&gt; ListAdapter에게 제공 private class CrimeDiffCallback : DiffUtil.ItemCallback&lt;Crime&gt;() { override fun areItemsTheSame(oldItem: Crime, newItem: Crime): Boolean { return oldItem.id == newItem.id } override fun areContentsTheSame(oldItem: Crime, newItem: Crime): Boolean { return oldItem == newItem } } ...} API 문서 페이지 Android Developers Reference: DiffUtil Android Developers Reference: ListAdapter Android Kotlin Fundamentals: DiffUtil and data binding with RecyclerView","link":"/2021/05/26/android-bnr-12/"},{"title":"[Codility] FrogJmp","text":"Lesson 3 - Time Complexity : FrogJmp kotlin ceil() 사용 12345import kotlin.math.*fun solution(X: Int, Y: Int, D: Int): Int { return ceil((Y - X) / D.toDouble()).toInt()} ceil() 사용하지 않고 풀기 12345678910fun solution(X: Int, Y: Int, D: Int): Int { if (X == Y) return 0 val quotient = (Y - X) / D if (X + D * quotient &lt; Y) return quotient + 1 else return quotient return -1}","link":"/2021/05/28/codility-frog-jmp/"},{"title":"[Codility] PermMissingElem","text":"Lesson 3 - Time Complexity : PermMissingElem kotlin 케이스 하나하나 처리해주기 123456789101112fun solution(A: IntArray): Int { A.sort() if (A.isEmpty() || A[0] != 1) return 1 if (A.last() != A.size + 1) return A.size + 1 for (i in 0 until A.size - 1) { if (A[i] + 1 != A[i + 1]) return A[i] + 1 } return 0} 다소 무식한 방법이라 할 수 있겠다. BooleanArray 사용 12345678910111213fun solution(A: IntArray): Int { val B = BooleanArray(A.size + 2) for (i in A.indices) { B[A[i]] = true } for (j in 1 until B.size) { if (B[j].not()) return j } return 0} 등차수열의 합공식 사용 1234567fun solution(A: IntArray): Int { val n = (A.size + 1).toLong() val sequence = n * (1 + n) / 2L val sum = A.sum().toLong() return (sequence - sum).toInt()} 구글 검색을 해보니 등차수열의 합공식을 이용하여 멋지게 풀이한 코드가 있어서 참고하였다. 배열 A는 1 ~ N+1 까지의 범위를 가진 N개의 원소로 이루어져 있고, 1씩 증가하는 등차수열의 형태를 보여준다. 비어있는 원소 하나를 찾는 문제이므로 등차수열의 합과 배열 A 요소들의 합의 차이가 비어있는 원소의 값이다. 주의할 점은 배열 A가 0 ~ 100,000 범위의 크기를 가져서 Int 타입으로 계산할 경우 overflow가 발생하므로 Long 타입으로 변환해줘야 한다. 위의 모든 코드들은 아래의 결과를 보여준다.","link":"/2021/05/28/codility-perm-missing-elem/"},{"title":"[Android] Dialog - 대화상자","text":"대화상자 Dialog 는 사용자의 주의를 끌고 입력을 받는 데 사용되며 사용자의 선택을 받거나 중요한 정보를 보여줄 때도 유용하다. 범죄 발생일자를 선택하는 대화상자 위의 대화상자는 AlertDialog의 서브 클래스인 DatePickerDialog의 인스턴스다. DatePickerDialog는 사용자가 날짜를 선택할 수 있게 해주며 사용자 선택을 알아내기 위해 구현하는 리스너 인터페이스를 제공한다. AlertDialog는 다목적의 Dialog 서브 클래스이며 커스텀 대화상자를 생성할 때 흔히 사용한다. DialogFragment 생성하기 DatePickerDialog를 화면에 보여줄 때는 Fragment의 서브 클래스인 DialogFragment 인스턴스에 포함시키는 것이 좋다. DialogFragment 없이 DatePickerDialog를 보여줄 수 있지만, FragmentManager로 DatePickerDialog를 관리하는 것이 유연성이 좋다. 그냥 DatePickerDialog만 사용하면 장치가 회전할 때 화면에서 사라지지만, DatePickerDialog가 프래그먼트에 포함되면 장치 회전 후에도 대화상자가 다시 생성되어 화면에 다시 나타난다. MainActivity에 의해 호스팅되는 두 프래그먼트의 객체 다이어그램 할 일은 다음과 같다. DatePickerFragment 클래스 생성한다. DatePickerDialog 인스턴스를 생성해 대화상자를 만든다. FragmentManager를 통해 대화상자를 화면에 보여준다. DialogFragment 생성하기 123456789101112131415161718192021...import androidx.fragment.app.DialogFragmentimport java.util.*class DatePickerFragment: DialogFragment() { override fun onCreateDialog(savedInstanceState: Bundle?): Dialog { val calendar = Calendar.getInstance() val initialYear = calendar.get(Calendar.YEAR) val initialMonth = calendar.get(Calendar.MONTH) val initialDay = calendar.get(Calendar.DAY_OF_MONTH) return DatePickerDialog( requireContext(), null, initialYear, initialMonth, initialDay ) }} DatePickerDialog 생성자는 여러 개의 인자를 받는다. 첫 번째는 이 뷰에서 필요한 리소스를 사용하려면 지정해야 하는 Context 객체다. 두 번째는 날짜 리스너로 본문의 뒤에서 추가한다. 나머지 세 개는 년, 월, 일의 초기값으로, 일단 오늘 날짜로 초기화한다. DialogFragment 보여주기 다른 모든 프래그먼트처럼 DialogFragment의 인스턴스도 호스팅 액티비티의 FragmentManager가 관리한다. FragmentManager에 추가되는 DialogFragment를 화면에 나타나게 하려면 다음 프래그먼트 인스턴스 함수 중 하나를 호출하면 된다. 12show(manager: FragmentManager, tag: String)show(transaction: FragmentTransaction, tag: String) String 인자는 FragmentManager의 리스트에서 DialogFragment를 고유하게 식별할 때 사용된다. FragmentManager나 FragmentTransaction 중 어떤 것을 사용하는가는 프로그래머에게 달렸다. FragmentTransaction을 인자로 전달할 때는 직접 트랜잭션을 생성한 후 커밋해야 한다. FragmentManager를 인자로 전달하면 트랜잭션이 자동으로 생성되어 커밋된다. 12345678910111213141516171819202122232425262728293031private const val TAG = &quot;CrimeFragment&quot;private const val ARG_CRIME_ID = &quot;crime_id&quot;private const val DIALOG_DATE = &quot;DialogDate&quot;class CrimeFragment : Fragment() { ... override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ... solvedCheckBox = view.findViewById(R.id.crime_solved) as CheckBox// dateButton.apply {// text = crime.date.toString()// isEnabled = false// } return view } ... override fun onStart() { ... solvedCheckBox.apply { ... } dateButton.setOnClickListener { DatePickerFragment().apply { show(this@CrimeFragment.parentFragmentManager, DIALOG_DATE) } } } this@CrimeFragment는 DatePickerFragment가 아닌 CrimeFragment로부터 requireFragmentManager()를 호출하기 위해 필요하다. 여기서는 apply 블록 내부의 this가 DatePickerFragment를 참조하므로 this 다음에 @CrimeFragment를 지정했다. apply 블록 내부의 this가 DatePickerFragment를 참조 DialogFragment의 show(FragmentManager, String) 함수에서 첫 번째 인자인 프래그먼트매니저 인스턴스 참조는 null 값이 될 수 없는 타입니다. 그런데 Fragment.fragmentManager 속성은 null 값이 될 수 있는 타입이므로 첫 번재 인자로 전달 할 수 없다. 따라서 여기서는 Fragment의 getParentFragmentManager() 함수를 사용했는데 이 함수는 null이 아닌 FragmentManager 인스턴스를 반환하기 때문이다. 만일 Fragment.requireFragmentManager()가 호출되었는데 프래그먼트의 fragmentManager 속성이 null이면 IllegalStateException이 발생한다. 이 예외는 해당 프래그먼트와 연관된 프래그먼트 매니저가 없음을 나타낸다. 날짜 선택 대화 상자 두 프래그먼트 간의 데이터 전달하기 인텐트 엑스트라를 사용한 두 액티비티 간의 데이터 전달, 콜백 인터페이스를 사용한 프래그먼트와 액티비티 간의 데이터 전달, 프래그먼트 인자를 사용한 액티비티로부터 프래그먼트로의 데이터 전달에 관해서는 다른 글에 정리되어 있다. 본문에서는 같은 액티비티에 의해 호스팅되는 두 프래그먼트, 즉 CrimeFragment와 DatePickerFragment 간의 데이터 전달이 필요하다. DatePickerFragment에 범죄 발생일자 (Crime 객체의 date)를 전달하기 위해 newInstance(Date) 함수를 작성하고, 이 함수의 인자로 전달된 발생일자를 DatePickerFragment의 프래그먼트 인자로 전달한다. 그다음에 대화상자에서 사용자가 선택한 날짜를 DatePickerFragment에서 CrimeFragment로 돌려준다. 더불어 사용자가 선택한 날짜를 인자로 받는 콜백 인스턴스 함수를 DatePickerFragment에 선언하기 위해 CrimeFragment가 모델 계층 (Crime 객체)과 자신의 뷰 (범죄 상세 내역 화면)를 변경한다. CrimeFragment와 DatePickerFragment 간의 처리 흐름 DatePickerFragment에 데이터 전달하기 DatePickerFragment에 현재의 범죄 발생일자를 전달하고자 여기서는 DatePickerFragment의 인자 번들에 해당 날짜를 저장한다. 일반적으로 프래그먼트 인자의 생성과 설정은 프래그먼트 생성자를 대체하는 newInstance(...) 함수에서 처리한다. 따라서 DatePickerFragment.kt에서 동반 객체 내부에 newInstance(Date) 함수를 추가하면 된다. newInstance(Date) 함수를 추가하기 (DatePickerFragment.kt) 1234567891011121314151617181920private const val ARG_DATE = &quot;date&quot;class DatePickerFragment: DialogFragment() { override fun onCreateDialog(savedInstanceState: Bundle?): Dialog { ... } companion object { fun newInstance(date: Date): DatePickerFragment { val args = Bundle().apply { putSerializable(ARG_DATE, date) } return DatePickerFragment().apply { arguments = args } } }} 여기서 arguments는 DatePickerFragment의 속성 (최상위 슈퍼 클래스인 Fragment로부터 DialogFragment로 상속되고 다시 DatePickerFragment로 상속됨)이며, 프래그먼트 인자를 갖는다. 그다음에 CrimeFragment에서 DatePickerFragment의 생성자 호출 코드를 삭제하고, DatePickerFragment.newInstance(Date) newInstance(...) 호출 추가하기 (CrimeFragment.kt) 123456789override fun onStart() { ... dateButton.setOnClickListener {// DatePickerFragment().apply { DatePickerFragment.newInstance(crime.date).apply { show(this@CrimeFragment.parentFragmentManager, DIALOG_DATE) } }} DatePickerFragment는 Date 객체의 데이터를 사용해서 DatePickerDialog를 초기화해야 한다. DatePickerDialog를 초기화하려면 월, 일, 년의 정수 값들이 필요하다. 그러나 Date 객체는 타임스탬프 형태이므로 이런 형식의 정수를 제공할 수 없다. 따라서 필요한 정수들을 얻으려면 Date 객체를 사용해서 Calendar 객체를 생성해야 한다. 그렇게 해야 이 Calendar 객체로부터 필요한 형태의 정수를 얻을 수 있다. 프래그먼트 인자로부터 얻은 Date 객체의 값을 Calendar 객체로 옮긴 후 DatePickerDialog를 초기화하는 코드를 DatePickerFragment.kt의 onCreateDialog(Bundle?)에 추가한다. DatePickerDialog 초기화하기 (DatePickerFragment.kt) 1234567891011121314151617181920class DatePickerFragment: DialogFragment() { override fun onCreateDialog(savedInstanceState: Bundle?): Dialog { val date = arguments?.getSerializable(ARG_DATE) as Date // ① val calendar = Calendar.getInstance() calendar.time = date // ② val initialYear = calendar.get(Calendar.YEAR) val initialMonth = calendar.get(Calendar.MONTH) val initialDay = calendar.get(Calendar.DAY_OF_MONTH) return DatePickerDialog( requireContext(), null, initialYear, initialMonth, initialDay ) } ...} 이제는 CrimeFragment가 DatePickerFragment에 범죄 발생일자를 전달할 수 있다. CrimeFragment로 데이터 반환하기 CrimeFragment가 DatePickerFragment로부터 사용자가 선택한 날짜를 돌려받으려면 두 프래그먼트 간의 관계를 계속해서 유지하고 관리하는 방법이 필요하다. 액티비티의 경우에 startActivityForResult(...) 함수를 호출하면 ActivityManager가 부모-자식 액티비티 관계를 계속해서 유지하고 관리한다. 따라서 자식 액티비티가 끝나면 이것의 결과를 어떤 액티비티가 받아야 하는지 ActivityManager가 안다. 대상 프래그먼트 설정하기 CrimeFragment를 DatePickerFragment의 대상 프래그먼트 target fragment 로 만들면 액티비티의 경우와 유사한 연결을 만들 수 있다. 그리고 CrimeFragment 인스턴스와 DatePickerFragment 인스턴스 모두가 안드로이드 운영체제에 의해 소멸되었다가 다시 생성되더라도 두 프래그먼트 간의 연결은 자동으로 복구된다. 이렇게 하려면 다음 Fragment 함수를 호출하면 된다. 1setTargetFragment(fragment: Fragment, requestCode: Int) 이 함수는 대상이 되는 프래그먼트와 요청 코드를 인자로 받는데, 이 요청 코드는 startActivityForResult(...)의 인자로 전달되는 것과 같은 의미를 갖는다. 이때 FragmentManager는 대상 프래그먼트와 요청 코드를 계속 관리한다. 대상을 설정했던 프래그먼트의 targetFragment와 targetRequestCode 속성을 사용하면 이 정보를 알 수 있다. 이제 CrimeFragment.kt에서 요청 코드의 상수를 정의하고 DatePickerFragment 인스턴스의 대상 프래그먼트로 CrimeFragment를 설정한다. 대상 프래그먼트 설정하기 (CriemFragment.kt) 123456789101112131415...private const val DIALOG_DATE = &quot;DialogDate&quot;private const val REQUEST_DATE = 0class CrimeFragment : Fragment() { ... override fun onStart() { ... dateButton.setOnClickListener { DatePickerFragment.newInstance(crime.date).apply { setTargetFragment(this@CrimeFragment, REQUEST_DATE) show(this@CrimeFragment.parentFragmentManager, DIALOG_DATE) } } } 대상 프래그먼트로 데이터 전달하기 CrimeFragment와 DatePickerFragment가 연결되었으니 CrimeFragment로 데이터(사용자가 선택한 날짜)를 반환해야 한다. 여기서는 DatePickerFragment에 콜백 인터페이스를 생성한다. 이때 이 콜백 인터페이스는 CrimeFragment가 구현한다. 우선 DatePickerFragment에 onDateSelected()라는 하나의 함수를 갖는 콜백 인터페이스를 생성한다. 콜백 인터페이스 생성하기 (DatePickerFragment.kt) 1234567891011class DatePickerFragment: DialogFragment() { interface Callbacks { fun onDateSelected(date: Date) } override fun onCreateDialog(savedInstanceState: Bundle?): Dialog { ... } ...} 다음으로 Callbacks 인터페이스를 CrimeFragment에 구현한다. 이때 onDateSelected(Date)에서는 인자로 전달된 Date 객체를 Crime 객체의 date 속성(CrimeFragment의 crime 속성이 참조함)에 설정하고 UI를 변경한다. 콜백 인터페이스 구현하기 (CrimeFragment.kt) 123456789101112class CrimeFragment : Fragment(), DatePickerFragment.Callbacks { ... override fun onStop() { ... } override fun onDateSelected(date: Date) { crime.date = date updateUI() } ...} 이제는 CrimeFragment 사용자가 선택한 날짜를 처리할 수 있으므로 이 날짜를 DatePickerFragment가 전달해야 한다. DatePickerDialog의 리스너를 DatePickerFragment에 추가하면, 이 리스너에서는 사용자가 선택한 날짜를 CrimeFragment에 전달한다. 사용자가 선택한 날짜 전달하기 (DatePickerFragment.kt) 1234567891011121314151617181920212223242526class DatePickerFragment : DialogFragment() { ... override fun onCreateDialog(savedInstanceState: Bundle?): Dialog { val dateListener = DatePickerDialog.OnDateSetListener { _: DatePicker, year: Int, month: Int, day: Int -&gt; val resultDate: Date = GregorianCalendar(year, month, day).time targetFragment?.let { fragment -&gt; (fragment as Callbacks).onDateSelected(resultDate) } } val date = arguments?.getSerializable(ARG_DATE) as Date ... return DatePickerDialog( requireContext(),// null, dateListener, initialYear, initialMonth, initialDay ) } ...} OnDateSetListener는 사용자가 선택한 날짜를 받는데 사용된다. 첫 번째 매개변수는 결과가 산출되는 DatePicker 객체이며, 여기서는 사용하지 않으므로 밑줄 _을 지정하였다.(코틀린에서 사용되지 않은 매개변수를 나타낼 때 밑줄을 사용) 선택된 날짜는 년, 월, 일 형식으로 제공된다. 그러나 이 값들을 Date 타입으로 CrimeFragment에 전달해야 하므로 GregorianCalendar의 인자로 이 값들을 전달한 후 time 속성을 사용해서 Date 객체를 얻는다. targetFragment 속성은 DatePickerFragment와 연관된 프래그먼트(여기선 CrimeFragment) 인스턴스 참조를 갖는다. 이 속성은 null 값을 가질 수 있으므로 null에 안전한 let 블록이 사용되었다. let 블록에서는 targetFragment 속성이 참조하는 프래그먼트 인스턴스의 타입을 Callbacks 인터페이스 타입으로 변환한 후, 새로운 날짜를 인자로 전달해 onDateSelected() 함수를 호출한다. 따라서 CrimeFragment에 구현된 onDateSelected() 함수가 호출되어 실행되므로, 사용자가 선택한 날자가 CrimeFragment에 전달될 수 있다.","link":"/2021/05/28/android-bnr-13/"},{"title":"[Android] 앱 바와 메뉴","text":"잘 디자인된 안드로이드 앱에서 중요한 컴포넌트 중 하나가 앱 바 app bar 다. 앱 바는 사용자가 수행할 수 있는 액션과 화면 간을 이동할 수 있는 매커니즘을 제공한다. 더불어 디자인의 일관성도 제공한다. 앱 바는 액션 바 action bar 또는 툴바 toolbar 자세한 내용은 앱 바 vs 액션 바 vs 툴바 에서 다룬다. AppCompat의 기본 앱 바 앱 바를 포함하는 이유는 새로운 프로젝트를 생성할 때 안드로이드 스튜디오가 AppCompatActivity의 서브 클래스인 모든 액티비티에 앱 바를 기본으로 포함하도록 설정하기 때문이다. 이때 안드로이드 스튜디오가 다음 내용을 수행함으로써 아래와 같은 일이 가능해진다. Jetpack의 AppCompat 라이브러리 의존성을 추가한다. 앱 바를 포함하는 AppCompat 테마 중 하나를 적용한다. app/build.gradle 파일을 열면 AppCompat 라이브러리의 의존성이 이미 추가되어 있는 걸 확인할 수 있다. 12345dependencies { ... implementation 'androidx.appcompat:appcompat:1.3.0' ...} AppCompat은 'application compatibility’의 단축어다. Jetpack의 AppCompat 라이브러리는 안드로이드 버전이 달라도 일관된 UI를 유지하는 데 핵심이 되는 클래스와 리소스들을 포함한다. AppCompat의 각 하위 패키지와 관련된 내용은 이곳에서 확인 가능하다. 안드로이드 스튜디오 4.1.1 버전부터는 새 프로젝트를 생성할 때 앱의 테마를 자동으로 Theme.MaterialComponents.DayNight.DarkActionBar으로 설정한다. 이 테마는 res/values/themes.xml에 설정되어 있으며, 앱 전체의 기본 스타일을 지정한다.(스타일 이름은 Theme.앱이름으로 지정된다.) 123456&lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;!-- Base application theme. --&gt; &lt;style name=&quot;Theme.CriminalIntent&quot; parent=&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;&gt; ... &lt;/style&gt;&lt;/resources&gt; 애플리케이션의 테마는 매니페스트 파일에 애플리케이션 수준으로 지정되며, 액티비티마다 선택적으로 지정될 수도 있다. 매니페스트 파일의 태그에 포함된 android:theme 속성을 보면 아래와 같이 지정되어 있음을 볼 수 있다. 1234567&lt;manifest ...&gt; &lt;application ... android:theme=&quot;@style/Theme.CriminalIntent&quot;&gt; ... &lt;/application&gt;&lt;/manifest&gt; 메뉴 앱 바의 오른쪽 위에는 메뉴를 넣을 수 있다. 메뉴는 액션 항목 action item 으로 구성되며 (때로는 메뉴 항목이라고도 함), 액션 항목은 현재 화면과 관련된 액션 또는 앱 전체의 액션을 수행할 수 있다. 본문에선 사용자가 새로운 데이터를 추가할 수 있는 액션 항목을 생성해본다. 액션 항목의 이름은 문자열 리소스로 만들어야 하므로 res/values/strings.xml을 열어 새로운 액션을 나타내는 문자열을 추가한다. 메뉴 문자열 추가 (res/values/strings.xml) 12345&lt;resources&gt; ... &lt;string name=&quot;new_crime&quot;&gt;새로운 범죄&lt;/string&gt;&lt;/resources&gt; XML로 메뉴 정의하기 메뉴는 레이아웃과 유사한 리소스로, XML 파일로 생성해 프로젝트의 res/menu 디렉터리에 둔다. 그리고 코드에서 메뉴를 인플레이트해 사용할 수 있도록 앱을 빌드하면 메뉴 파일의 리소스 ID가 자동 생성된다. 메뉴 파일 생성하기 메뉴 파일의 이름이 CrimeListFragment의 레이아웃 파일의 이름과 같지만 메뉴 파일은 res/menu/ 에 생성된다. CrimeListFragment의 메뉴 리소스 생성하기 (res/menu/fragment_crime_list.xml) 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/new_crime&quot; android:icon=&quot;@android:drawable/ic_menu_add&quot; android:title=&quot;@string/new_crime&quot; app:showAsAction=&quot;ifRoom|withText&quot; /&gt;&lt;/menu&gt; showAsAction 속성은 액션 항목이 앱 바 자체에 보이게 할 것인지, 아니면 오버플로 메뉴 overflow menu 에 포함되어 보이게 될 것인지를 나타낸다. 여기서는 ifRoom과 withText 두 값을 같이 지정했으므로 앱 바에 공간이 있으면 액션 항목의 아이콘과 텍스트 모두 앱 바에 나타난다. 만일 아이콘을 보여줄 공간은 있지만 텍스트의 공간은 없다면 아이콘만 나타나고, 둘 다 보여줄 공간이 없으면 해당 액션 항목은 오버플로 메뉴에 들어간다. showAsAction 속성의 다른 값으로는 always와 never가 있는데, always는 액션 항목을 항상 앱 바에 보여주기 때문에 권장하지 않는다. 대신에 ifRoom을 사용해서 안드로이드 운영체제가 결정하게 하는 것이 좋다. 자주 사용하지 않는 액션에는 never를 지정해서 오버플로 메뉴에 두는 것이 좋다. 화면이 너무 어수선해지는 것을 피하려면 사용자가 자주 사용할 액션 항목들만 앱 바에 두어야 한다. 따라서 위와 같이 ifRoom과 withText 두 값을 같이 지정하는 것이 좋다. 앱의 네임스페이스 fragment_crime_list.xml에서는 xmls 태그를 사용해서 새로운 네임스페이스로 app을 정의하는데, 보통의 android 네임스페이스와는 다르다. 여기서는 showAsAction 속성을 지정하기 위해 app 네임스페이스가 사용되었다. app과 같이 특이한 네임스페이스에는 AppCompat 라이브러리와 관련해서 필요하다. 앱 바 API는 안드로이드 3.0에서 처음 추가되었다(당시에는 액션 바라고 했다). 원래 AppCompat 라이브러리의 앱 바는 더 이전 버전의 안드로이드를 지원하는 앱에 호환성 버전의 액션 바를 넣을 수 있게 만든 것으로, 액션 바를 지원하지 않는 안드로이드 버전을 실행하는 장치까지도 액션 바가 나타날 수 있게 한다. AppCompat 라이브러리는 커스텀 showAsAction 속성을 정의하고 있으며, 안드로이드의 내장된 showAsAction 속성을 사용하지 않는다. 메뉴 생성하기 메뉴는 Activity 클래스의 콜백 함수가 관리한다. 메뉴가 필요하면 안드로이드는 Activity 함수인 onCreateOptionsMenu(Menu)를 호출한다. 그런데 이 앱에서는 액티비티가 아닌 프래그먼트에 구현된 코드를 호출한다. Fragment는 자신의 메뉴 콜백 함수들을 갖고 있다. 본문에서는 이 함수들을 CrimeListFragment에 구현한다. 메뉴를 생성하고 액션 항목의 선택에 응답하는 함수들은 다음과 같다. 12onCreateOptionsMenu(menu: Menu, inflater: MenuInflater)onOptionsItemSelected(item: MenuItem): Boolean CrimeListFragment.kt에서 onCreateOptionsMenu(Menu, MenuInflater)를 오버라이드해 fragment_crime_list.xml에 정의된 메뉴를 인플레이트하자. 메뉴 리소스 인플레이트하기 (CrimeListFragment.kt) 123456789101112class CrimeListFragment : Fragment() { ... override fun onDetach() { ... } override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) { super.onCreateOptionsMenu(menu, inflater) inflater.inflate(R.menu.fragment_crime_list, menu) } ...} 이 함수에서는 MenuInflater.inflate(Int, Menu)를 호출할 때 메뉴 파일의 리소스 ID를 인자로 전달한다. 이렇게 함으로써 파일에 정의된 액션 항목들로 Menu 인스턴스가 채워진다. 여기서는 슈퍼 클래스에 구현된 onCreateOptionsMenu(...)를 먼저 호출했다. 따라서 슈퍼 클래스에 정의된 어떤 메뉴 기능도 여전히 작동할 수 있다. 하지만 슈퍼 클래스인 Fragment의 onCreateOptionsMenu(...) 함수에서는 아무 일도 하지 않기 때문에 특별한 의미는 없다. CrimeListFragment를 호스팅하는 액티비티가 운영체제로부터 자신의 onCreateOptionsMenu(...) 콜백 함수 호출을 받았을 때 FragmentManager는 Fragment.onCreateOptionsMenu(Menu, MenuInflater)를 호출하는 책임을 갖는다. 단, 다음의 Fragment 함수를 호출해서 CrimeListFragment가 onCreateOptionsMenu(...) 호출을 받아야 함을 FragmentManager가 명시적으로 알려주어야 한다. 1setHasOptionsMenu(hasMenu: Boolean) 따라서 CrimeListFragment.onCreate(Bundle?)에 CrimeListFragment가 메뉴 콜백 호출을 받아야 함을 FragmentManager에 알려주는 코드를 추가한다. 메뉴 콜백 호출을 받도록 하기 (CrimeListFragment.kt) 123456789101112class CrimeListFragment : Fragment() { ... override fun onAttach(context: Context) { ... } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setHasOptionsMenu(true) } ...} 앱 바에 나타난 범죄 추가 액션 항목 아이콘과 텍스트 앱 바의 아이콘 제목 보기 대부분의 폰에서는 아이콘을 보여줄 공간밖에 없기에 액션 항목의 텍스트가 표시되지 않는다. 앱 바의 + 아이콘을 길게 누르면 텍스트를 볼 수 있다. 메뉴 선택에 응답하기 사용자가 ‘새로운 범죄’ 액션 항목을 눌렀을 때 그에 대한 응답을 하려면 CrimeListFragment가 데이터베이스에 새로운 범죄 데이터(Crime 인스턴스)를 추가할 방법이 필요하다. 그러기 위해서는 리포지터리의 addCrime(Crime) 함수를 호출하는 코드를 CrimeListViewModel에 추가하면 된다. 새로운 범죄 데이터 추가하기 (CrimeListViewModel.kt) 12345678class CrimeListViewModel : ViewModel() { private val crimeRepository = CrimeRepository.get() val crimeListLiveData = crimeRepository.getCrimes() fun addCrime(crime: Crime) { crimeRepository.addCrime(crime) }} 사용자가 메뉴 항목을 누르면 프래그먼트에서 onOptionsItemSelected(MenuItem) 함수의 콜백 호출을 받게 되고, 이 함수는 사용자가 선택한 MenuItem의 인스턴스를 인자로 받는다. 지금 메뉴에는 액션 항목 하나만 있지만, 메뉴는 대개 둘 이상의 액션 항목을 갖는다. 이때 어떤 액션 항목이 선택되었는지는 MenuItem의 ID를 확인해서 알아낸 뒤 해당 항목에 적합한 응답을 하면된다. 이 ID는 메뉴 파일의 MenuItem에 지정한 리소스 ID와 일치한다. 이제 CrimeListFragment.kt의 onOptionsItemSeleceted(MenuItem) 함수를 구현해서 MenuItem의 선택에 응답하게 한다. 이 함수에서는 새로운 Crime 객체를 생성하고 데이터베이스에 추가한다. 그다음에 부모 액티비티에 구현된 onCrimeSelected(...) 콜백 함수를 호출해 CrimeListFragment를 CrimeFragment로 교체한다. 이렇게 하면 데이터베이스에 새로 추가된 범죄 데이터가 상세 내역 화면에 보이고, 사용자가 변경할 수도 있게 된다. 메뉴 선택에 응답하기 (CrimeListFragment.kt) 1234567891011121314151617181920class CrimeListFragment : Fragment() { ... override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) { super.onCreateOptionsMenu(menu, inflater) inflater.inflate(R.menu.fragment_crime_list, menu) } override fun onOptionsItemSelected(item: MenuItem): Boolean { return when (item.itemId) { R.id.new_crime -&gt; { val crime = Crime() crimeListViewModel.addCrime(crime) callbacks?.onCrimeSelected(crime.id) true } else -&gt; return super.onOptionsItemSelected(item) } } ...} onOptionsItemSeleceted(MenuItem) 함수는 Boolean 값을 반환한다. 즉, 선택된 MenuItem을 정상적으로 처리하고 나면 더 이상의 처리가 필요 없음을 나타내는 true를 반환해야 한다. 만일 false를 반환하면, 호스팅 액티비티의 onOptionsItemSeleceted(MenuItem) 함수를 호출해 메뉴 처리가 계속된다. 그리고 처리를 구현하지 않은 액션 항목 ID에는 슈퍼 클래스에 구현된 onOptionsItemSeleceted(MenuItem) 함수를 호출한다. 새로운 범죄 데이터 추가 궁금증 해소 💁🏻‍♂️ : 앱 바 vs 액션 바 vs 툴바 ↩ 앱 바를 ‘툴바’ 또는 '액션 바’라고 하는 경우를 심심치 않게 볼 수 있으며 안드로이드 문서에서도 이 용어들을 혼용해서 사용한다. 하지만 앱 바, 액션 바, 툴바는 정말로 같은 것일까? 이 용어들은 서로 관련이 있으나 정확하게 같은 것은 아니며, UI 설계 요소로는 '앱 바’라고 한다. 안드로이드 5.0(롤리팝, API 레벨 21) 이전에는 앱 바가 ActionBar 클래스를 사용해서 구현되었다. 따라서 액션 바와 앱 바 두 용어는 같은 것으로 간주했다. 그러나 안드로이드 5.0부터는 앱 바를 구현하는 방법으로 Toolbar 클래스가 도입되었다. 2021년을 기준으로 AppCompat 라이브러리는 Jetpack의 Toolbar 위젯을 사용해서 액션 바(앱 바)를 아래와 같이 구현한다. 레이아웃 검사기로 본 액션 바 앱을 실행하고 리스트에서 항목을 하나 선택해 상세 내역의 화면이 나타나게 한다. 그리고 안드로이드 스튜디오 메뉴 바의 Tools -&gt; Layout Inspector 를 선택하면 아래와 같이 레이아웃 검사기 도구 창이 열린다. 그리고 왼쪽의 컴포넌트 트리 패널에서 원하는 레이아웃이나 컴포넌트를 확장하고 선택하면 중앙의 레이아웃 화면에 표시해주며, 속성과 상세 정보를 오른쪽 패널에 보여준다. ActionBar와 Toolbar는 매우 유사한 컴포넌트다. 그러나 툴바는 변경된 UI를 가지며 액션 바보다 유연성 있게 사용할 수 있는 반면에, 액션 바는 항상 화면의 제일 위쪽에 나타나며 한 화면에 하나만 있는 등 많은 제약을 가졌다. 게다가 액션 바의 크기는 정해져 있어서 변경할 수 없지만, 툴바는 이런 제약을 갖지 않는다. 본문에서는 AppCompat 테마 중 하나에서 제공한 툴바를 사용했지만, 액티비티나 프래그먼트의 레이아웃 파일에 포함된 뷰로 툴바를 포함할 수 있다. 그리고 화면의 어떤 위치에도 툴바를 둘 수 있고 여러 개를 넣을 수도 있다. 이런 유연성 덕분에 흥미로운 화면 디자인이 가능하다. 예를 들어, 각 프래그먼트가 자신의 툴바를 갖는다고 해보자. 그리고 한 화면에서 동시에 여러 개의 프래그먼트를 수용한다면, 화면 위에 하나의 툴바를 공유하지 않고 각 프래그먼트가 자신의 툴바를 갖고 나타날 수 있다. 또한 툴바는 내부에 다른 뷰들을 둘 수 있고 높이도 조정할 수 있어서 앱의 작동 방식에 훨씬 더 좋은 유연성을 제공한다.","link":"/2021/05/29/android-bnr-14/"},{"title":"[Android] 암시적 인텐트","text":"안드로이드에서는 인텐트 intent 를 사용해 장치의 다른 앱에 있는 액티비티를 시작시킬 수 있다. 명시적 인텐트 explicit intent 에서는 시작시킬 액티비티 클래스를 지정하면 안드로이드 운영체제가 해당 액티비티를 시작시킨다. 반면에 암시적 인텐트 implicit intent 에서는 해야 할 작업을 알려주면 안드로이드 운영체제가 이 작업을 수행하는 데 적합한 앱의 액티비티를 찾아서 시작시킨다. 본문에서는 ① 암시적 인텐트를 사용해서 사용자의 연락처에서 범죄 용의자를 한 명 선택하고, ② 텍스트 형태의 범죄 보고서를 전송할 수 있게 한다. 이때 사용자는 장치에 설치된 연락처 앱과 텍스트 전송 앱을 선택해 사용할 수 있다. 암시적 인텐트를 사용하면 추가로 앱을 개발하지 않아도 다른 앱을 이용할 수 있다. 따라서 모바일 장치의 여러 앱들에게 공통으로 필요한 작업을 쉽게 처리할 수 있다. 따라서 모바일 장치의 여러 앱들에게 공통으로 필요한 작업을 쉽게 처리할 수 있다. 그리고 사용자 또한 다른 앱들을 이 앱과 연계해 사용할 수 있다. 암시적 인텐트 생성에 앞서 다음과 같이 몇 가지 준비할 것이 있다. ‘용의자 선택’ 버튼과 ‘범죄 보고서 전송’ 버튼을 CrimeFragment의 레이아웃에 추가한다. 용의자 이름을 저장하는 suspect 속성을 Crime 클래스에 추가한다. 포맷 리소스 문자열 format resource string 을 사용해서 범죄 보고서를 생성한다. 모델 계층에 용의자 추가하기 용의자 이름을 저장할 새로운 속성을 Crime 클래스에 추가한다. suspect 속성 추가하기 (Crime.kt) 12345678@Entitydata class Crime( @PrimaryKey val id: UUID = UUID.randomUUID(), var title: String = &quot;&quot;, var date: Date = Date(), var isSolved: Boolean = false, var suspect: String = &quot;&quot;) 그런 다음 suspect 속성값을 저장하도록 데이터베이스의 Crime 테이블 열 column도 추가해야 한다. 이렇게 하려면 CrimeDatabase 클래스의 버전을 높여서 Room이 데이터베이스를 새 버전으로 이행 migration하게 해야 한다(이행은 기존 데이터베이스의 스키마를 업데이트하고 데이터를 새 버전의 스키마에 맞춰 옮기는 것을 말한다.). 이때 Migration 클래스를 사용한다. 새 버전의 데이터베이스로 이행하기 (database/CrimeDatabase.kt) 123456789101112131415// @Database(entities = [Crime::class], version = 1)@Database(entities = [Crime::class], version = 2)@TypeConverters(CrimeTypeConverters::class)abstract class CrimeDatabase : RoomDatabase() { abstract fun crimeDao(): CrimeDao}val migration_1_2 = object : Migration(1, 2) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL( &quot;ALTER TABLE Crime ADD COLUMN suspect TEXT NOT NULL DEFAULT ''&quot; ) }} 데이터베이스의 초기 버전이 1이었으므로 위의 코드에서는 2로 올렸다. 그리고 Migration 객체를 생성해 데이터베이스를 업데이트한다. Migration 클래스의 생성자는 두 개의 인자를 받는다. 첫 번째는 업데이트 전의 데이터베이스 버전이고, 두 번째는 업데이트할 버전이다. 여기서는 버전 번호를 1과 2로 지정하였다. Migration 객체에는 migrate(SupportSQLiteDatabase) 함수만 구현하면 된다. 이 함수에서는 인자로 전달된 데이터베이스를 사용해서 테이블을 업그레이드하는 데 필요한 SQL 명령을 실행한다. 여기서는 ALTER TABLE 명령으로 suspect 열을 Crime 테이블에 추가한다. 생성된 Migration 객체는 데이터베이스를 생성할 때 제공해야 한다. CrimeRepository에서 CrimeDatabase 인스턴스를 생성할 때 Migration 객체를 Room에 제공하도록 변경한다. Migration 객체를 Room에 제공하기 (CrimeRepository.kt) 1234567891011121314151617...import com.june0122.criminalintent.database.migration_1_2...class CrimeRepository private constructor(context: Context) { private val database: CrimeDatabase = Room.databaseBuilder( context.applicationContext, CrimeDatabase::class.java, DATABASE_NAME// ).build() ).addMigrations(migration_1_2) .build() private val crimeDao = database.crimeDao() ...} Migration 객체를 설정하려면 addMigration(...)를 호출한 후에 build() 함수를 호출해야 한다. addMigration(...) 함수는 여러 개의 Migration 객체를 인자로 받을 수 있으므로 선언했던 모든 Migration 객체를 한꺼번에 전달할 수 있다. 앱이 실행되어 Room이 데이터베이스를 빌드할 때는 맨 먼저 장치의 기존 데이터베이스 버전을 확인한다. 그리고 이 버전이 CrimeDatabase 클래스의 @Database 애노테이션에 지정된 것과 일치하지 않으면, Room이 @Database에 지정된 버전에 맞는 Migration 객체를 찾아서 해당 버전으로 데이터베이스를 업데이트한다. 만일 데이터베이스 버전을 변경할 때 Migration 객체를 제공하지 않으면 Room이 기존 버전의 데이터베이스를 삭제하고 새 버전의 데이터베이스를 다시 생성한다. 이때 기존 데이터가 모두 없어지므로 주의해야 한다. 포맷 문자열 사용하기 마지막으로 특정 범죄의 상세 정보로 구성되는 범죄 보고서의 템플릿을 생성하면 모든 준비가 끝난다. 앱이 실행되기 전까지는 범죄의 상세 정보를 알 수 없으니 런타임 시에 대체될 수 있는 플레이스 홀더를 갖는 다음 포맷 문자열을 사용해야 한다. 1%1$s! 이 범죄가 발견된 날짜는 %2$s. %3$s, 그리고 %4$s %1$s, %2$s 등 이 문자열 이자로 대체되는 플레이스 홀더들이다. 이 포맷 문자열을 코드에서 사용할 때는 getString(...) 함수를 호출하며, 이때 포맷 문자열 리소스 ID, 그리고 플레이스 홀더들을 대체하는 순서대로 네 개의 문자열을 인자로 전달한다. 문자열 리소스 추가하기 (res/values/strings.xml) 1234567891011121314&lt;resources&gt; ... &lt;string name=&quot;crime_suspect_text&quot;&gt;용의자 선택&lt;/string&gt; &lt;string name=&quot;crime_report_text&quot;&gt;범죄 보고서 전송&lt;/string&gt; &lt;string name=&quot;crime_report&quot;&gt;%1$s! 이 범죄가 발견된 날짜는 %2$s. %3$s, 그리고 %4$s &lt;/string&gt; &lt;string name=&quot;crime_report_solved&quot;&gt;이 건은 해결되었음&lt;/string&gt; &lt;string name=&quot;crime_report_unsolved&quot;&gt;이 건은 미해결임&lt;/string&gt; &lt;string name=&quot;crime_report_no_suspect&quot;&gt;용의자가 없음.&lt;/string&gt; &lt;string name=&quot;crime_report_suspect&quot;&gt;용의자는 %s.&lt;/string&gt; &lt;string name=&quot;crime_report_subject&quot;&gt;CriminalIntent 범죄 보고서&lt;/string&gt; &lt;string name=&quot;send_report&quot;&gt;범죄 보고서 전송&lt;/string&gt;&lt;/resources&gt; 다음으로 문자열 네 개를 생성하고 결합해 하나의 완전한 보고서 문자열로 반환하는 함수를 CrimeFragment.kt에 추가한다. getCrimeReport() 함수 추가하기 (CrimeFragment.kt) 123456789101112131415161718192021222324252627282930313233...private const val REQUEST_TIME = 1private const val DATE_FORMAT = &quot;yyyy년 M월 d일 H시 m분, E요일&quot;class CrimeFragment : Fragment(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks { ... private fun updateUI() { ... } private fun getCrimeReport(): String { val solvedString = if (crime.isSolved) { getString(R.string.crime_report_solved) } else { getString(R.string.crime_report_unsolved) } val dateString = DateFormat.format(DATE_FORMAT, crime.date).toString() var suspect = if (crime.suspect.isBlank()) { getString(R.string.crime_report_no_suspect) } else { getString(R.string.crime_report_suspect, crime.suspect) } return getString(R.string.crime_report, crime.title, dateString, solvedString, suspect) } companion object { ... } } (DateFormat 클래스의 import 문을 추가할 때는 android.text.format.DateFormat을 선택해야 한다.) 준비 작업이 끝났으니 이제 암시적 인텐트를 자세히 알아본다. 암시적 인텐트 사용하기 인텐트는 하고자 원하는 것을 안드로이드 운영체제에 알려주는 객체다. 지금까지는 우리가 생성했던 명시적 인텐트를 사용해서 안드로이드 운영체제가 시작시킬 액티비티 이름을 명시적으로 지정하였다. 12val intent = Intent(this, CheatActivity::class.java)startActivity(intent) 암시적 인텐트를 사용할 때는 원하는 작업을 안드로이드 운영체제에 알려준다. 그러면 해당 작업을 할 수 있다고 자신을 알린 액티비티를 안드로이드 운영체제가 찾아서 시작시킨다. 단, 안드로이드 운영체제가 그런 능력을 가진 액티비티를 두 개 이상 찾으면 사용자가 선택할 수 있게 해준다. 암시적 인텐트의 구성 요소 원하는 작업을 정의할 때 사용하는 암시적 인텐트의 주요 구성 요소는 다음과 같다. 수행하고자 하는 액션 action Intent 클래스의 상수다. 예를 들어, 웹 URL을 보기 원한다면 Intent.ACTION_VIEW를 액션으로 사용하며, 텍스트 등을 전송할 때는 Intent.ACTION_SEND를 사용한다. 이외에도 여러 가지 상수가 있다. 데이터의 위치 웹 페이지의 URL과 같은 장치 외부 것이 될 수 있다. 또는 파일에 대한 URI나 Content Provider의 레코드(주로 데이터베이스 테이블의 행)를 가리키는 콘텐츠 URI도 될 수 있다. 액션에서 필요한 데이터의 타입 text/html이나 audio/mpeg3과 같은 MIME 타입이다. 인텐트가 데이터의 위치를 포함하면 해당 데이터로부터 타입을 유추할 수 있다. 선택적으로 사용하는 카테고리 액션이 무엇(what) 을 하는지를 나타내는 데 사용되는 것이라면 카테고리는 액티비티를 어디서(where), 언제(when), 어떻게(how) 사용할지를 나타낸다. 액티비티가 최상위 수준의 앱 론처에 보여야 함을 나타내기 위해 안드로이드는 android.intent.category.LAUNCHER 카테고리를 사용한다. 반면에 액티비티의 패키지에 관한 정보를 사용자에게 보여주되 론처에는 나타나지 않아야 하는 액티비티를 나타내려면 android.intent.category.INFO 카테고리를 사용한다. 예를 들어, 웹 사이트의 페이지를 보는 간단한 암시적 인텐트는 Intent.ACTION_VIEW 액션과 웹 사이트의 URL인 데이터 URI(Uri 객체)를 포함한다. 안드로이드 운영체제는 이런 정보를 기준으로 적합한 애플리케이션의 액티비티를 찾아서 실행한다(만일 하나 이상의 액티비티를 찾으면 대화상자를 보여주고 사용자가 선택하게 해준다). 액티비티는 매니페스트(AndroidManifest.xml)의 인텐트 필터를 통해서 지정된 액션을 수행할 수 있음을 알린다. 예를 들어, 웹 브라우저 앱이라면 ACTION_VIEW를 수행할 수 있는 액티비티를 선언할 때 다음과 같이 인텐트 필터를 포함하면 된다. 123456789&lt;activity android:name=&quot;.BrowserActivity&quot; android:label=&quot;@string/app_name&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;http&quot; android:host=&quot;www.naver.com&quot; /&gt; &lt;intent-filter&gt;&lt;/activity&gt; 액티비티가 암시적 인텐트에 응답하려면 인텐트 필터에 DEFAULT 카테고리를 갖고 있어야 한다. 인텐트 필터의 action 요소는 이 액티비티가 해당 작업(여기서는 VIEW, 즉 웹 URL의 브라우징)을 수행할 수 있음을 안ㄴ드로이드 운영체제에 알린다. 그리고 DEFAULT 카테고리는 해당 작업을 할 의향이 있음을(암시적으로 인텐트를 받겠다는) 안드로이드 운영체제에 알린다. DEFAULT 카테고리는 모든 암시적 이벤트에 기본으로 추가된다. 명시적 인텐트처럼 암시적 인텐트도 엑스트라를 포함할 수 있다. 그러나 암시적 인텐트의 엑스트라는 안드로이드 운영체제가 적합한 액티비티를 찾기 위해 사용하는 것이 아니라 액션에 따른 추가 데이터를 보낼 때 사용한다. 그리고 인텐트의 액션(action 태그로 지정됨)과 데이터(data 태그로 지정됨)는 명시적 인텐트에서도 사용할 수 있다. 범죄 보고서 전송하기 지금부터는 CriminalIntent 앱에서 암시적 인텐트를 생성해 범죄 보고서를 발송하는 방법을 알아본다. 범죄 보고서는 문자열이므로 텍스트를 전송하는 작업을 해야 한다. 따라서 암시적 인텐트의 액션은 ACTION_SEND가 되며, 어떤 데이터나 카테고리도 지정하지 않지만 타입은 text/plain으로 지정한다. CrimeFragment의 onCreatView(...)에서 ‘범죄 보고서 전송’ 버튼의 참조를 얻은 후, onStart()에서 이 버튼의 리스너를 설정한다. 그리고 이 리스너 내부에서는 암시적 인텐트를 생성해 startActivity(Intent)의 인자로 전달한다. 범죄 보고서 전송하기 (CrimeFragment.kt) 123456789101112131415161718192021222324252627282930313233343536373839class CrimeFragment : Fragment(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks { ... private lateinit var solvedCheckBox: CheckBox private lateinit var reportButton: Button ... override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ... solvedCheckBox = view.findViewById(R.id.crime_solved) as CheckBox reportButton = view.findViewById(R.id.crime_report) as Button return view } ... override fun onStart() { ... dateButton.setOnClickListener { ... } timeButton.setOnClickListener { ... } reportButton.setOnClickListener { Intent(Intent.ACTION_SEND).apply { type = &quot;text/plain&quot; putExtra(Intent.EXTRA_TEXT, getCrimeReport()) putExtra(Intent.EXTRA_SUBJECT, getString(R.string.crime_report_subject)) }.also { intent -&gt; startActivity(intent) } } } ...} 여기서는 액션을 정의하는 상수 문자열을 인자로 받는 Intent 생성자를 사용한다. 생성하야 할 암시적 인텐트의 종류에 따라 사용할 수 있는 생성자도 달라진다. 이와 관련된 내용은 API 문서에서 Intent 클래스를 찾아보면 알 수 있다. 그런데 타입을 인자로 받는 생성자는 없으므로 Intent의 type 속성으로 지정해야 한다. 보고서의 텍스트와 제목 문자열은 엑스트라의 값에 포함되며, 엑스트라의 키는 Intent 클래스에 정의한 상수들을 사용한다(EXTRA_SUBJECT는 메시지의 제목이며, EXTRA_TEXT는 메시지의 데이터다). 이 인텐트에 응답해 시작되는 액티비티는 엑스트라의 키로 사용된 상수들과 각 키의 값이 무엇을 의미하는지 알아야 한다. 프래그먼트에서 액티비티르 시작시키는 것은 액티비티에서 다른 액티비티를 시작시키는 것과 거의 같다. 위의 코드에서는 Fragment의 startActivity(Intent) 함수를 호출하며, 이 함수는 내부적으로 이것과 대응되는 Activity 함수를 호출한다. CriminalIntent 앱을 실행하고 범죄 리스트에서 한 항목을 클릭한 후 상세 내역 화면이 나타나면 ‘범죄 보고서 전송’ 버튼을 눌러보면 이 인텐트는 장치의 많은 액티비티와 일치하므로 아래의 이미지과 같이 선택할 액티비티들을 보여준다(ACTION_SEND 인텐트에 응답할 수 있는 액티비티가 하나만 있다면 해당 액티비티의 앱이 바로 실행된다). 범죄 보고서를 전송할 수 있는 액티비티들 선택기 chooser가 보여주는 액티비티 중에서 하나를 선택해 액티비티의 앱에서 범죄 보고서를 전송하고, 종료하면 다시 범죄 상세 내역 화면으로 돌아온다. ‘메시지’ 앱을 선택하면 아래 이미지와 같이 범죄 보고서가 메시지로 작성된 상태에서 새 메시지 화면이 나타난다. 그래고 맨 위의 '받는 사람’만 지정하고 '보내기’를 누르면 메시지가 전송된다. ‘메시지’ 앱으로 범죄 보고서 전송하기 만일 선택기가 나타나지 않는다면 이미 이와 같은 암시적 인텐트의 기본 앱을 설정했거나, 이 인텐트에 응답할 수 있는 액티비티가 장치에 하나만 있어서 그렇다. 액티비티를 시작시키기 위해 암시적 인텐트가 사용될 때마다 매번 선택기가 나타나게 할 수도 있다. 그렇게 하려면 이전처럼 암시적 인텐트를 생성한 후에 Intent.createChooser(Intent, String) 함수를 호출하면 된다. 이때 암시적 인텐트와 선택기의 제목 문자열을 인자로 전달한다. 그다음에 createChooser(...)로부터 반환된 인텐트를 startActivity(...)의 인자로 전달한다. 암시적 인텐트에 응답하는 액티비티들을 보여줄 선택기를 생성하는 코드를 CrimeFragment.kt에 추가한다. 선택기 사용하기 (CrimeFragment.kt) 1234567891011reportButton.setOnClickListener { Intent(Intent.ACTION_SEND).apply { type = &quot;text/plain&quot; putExtra(Intent.EXTRA_TEXT, getCrimeReport()) putExtra(Intent.EXTRA_SUBJECT, getString(R.string.crime_report_subject)) }.also { intent -&gt;// startActivity(intent) val chooserIntent = Intent.createChooser(intent, getString(R.string.send_report)) startActivity(chooserIntent) }} 앱을 다시 실행해 범죄 리스트에서 한 항목을 선택한 후, 상세 내역 화면이 나타나면 ‘범죄 보고서 전송’ 버튼을 눌러보자. 선택기의 제목이 '범죄 보고서 전송’으로 나타나며, 인텐트를 처리할 수 있는 액티비티가 하나 이상이면 항상 앱 선택 리스트가 나타난다. 안드로이드에 연락처 요청하기 지금부터는 사용자가 자신의 연락처에서 용의자를 선택할 수 있게 또 다른 암시적 인텐트를 생성해본다. 이 암시적 인텐트는 액션 및 관련된 데이터를 찾을 수 있는 위치를 갖는다. 이때 액션은 Intent.ACTION_PICK이며, 연락처의 데이터는 ContactsContract.Contacts.CONTENT_URI에 있다. 요컨대 연락처 데이터베이스에서 한 항목을 선택할 수 있게 해달라고 안드로이드에 요청하는 것이다. 여기서는 인텐트로 시작된 액티비티로부터 결과(연락처 데이터)를 돌려받아야 한다. 따라서 startActivityForResult(...) 함수를 호출하면서 인텐트와 요청 코드를 인자로 전달해야 한다. 그리고 요청 코드의 상수와 ‘용의자 선택’ 버튼을 참조하는 속성을 CrimeFragment.kt에 추가한다. ‘용의자 선택’ 버튼을 참조하는 속성 추가하기 (CrimeFragment.kt) 123456789private const val REQUEST_DATE = 0private const val REQUEST_TIME = 1private const val REQUEST_CONTACT = 2 // 연락처 요청 코드의 상수...class CrimeFragment : Fragment(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks { ... private lateinit var reportButton: Button private lateinit var suspectButton: Button // 버튼 참조 속성 그다음에 onCreateView(...)의 끝에서 ‘용의자 선택’ 버튼 객체의 참조를 얻고, onStart()에서 이 버튼의 클릭 리스너를 설정한다. 클릭 리스너 구현 코드에서는 연락처를 요청하는 암시적 인텐트를 생성해서 startActivityForResult(...)의 인자로 전달한다. 그리고 용의자가 선정되면 이 사람들의 이름을 ‘용의자 선택’ 버튼에 보여준다. 암시적 인텐트 전달하기 (CrimeFragment.kt) 1234567891011121314151617181920212223242526272829class CrimeFragment : Fragment(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks { ... override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ... reportButton = view.findViewById(R.id.crime_report) as Button suspectButton = view.findViewById(R.id.crime_suspect) as Button return view } ... override fun onStart() { ... reportButton.setOnClickListener { ... } suspectButton.apply { val pickContactIntent = Intent(Intent.ACTION_PICK, ContactsContract.Contacts.CONTENT_URI) setOnClickListener { startActivityForResult(pickContactIntent, REQUEST_CONTACT) } } } ...} pickContactIntent는 잠시 후에 한번 더 사용하므로 OnClickListener의 외부에 선언하였다. 다음으로 용의자가 선정되었을 때 ‘용의자 선택’ 버튼에 텍스트를 설정하도록 updateUI()를 변경한다. ‘용의자 선택’ 버튼에 텍스트 설정하기 (CrimeFragment.kt) 123456789101112private fun updateUI() { titleField.setText(crime.title) dateButton.text = crime.date.toString() solvedCheckBox.apply { isChecked = crime.isSolved jumpDrawablesToCurrentState() } if (crime.suspect.isNotEmpty()) { suspectButton.text = crime.suspect }} 앱을 다시 실행해 범죄 리스트에서 한 항목을 선택한 후 상세 내역 화면이 나타나면 ‘용의자 선택’ 버튼을 눌러보자. 아래의 이미지와 같이 연락처 리스트가 나타난다. 용의자 선택을 위한 연락처 리스트 연락처 리스트에서 데이터 가져오기 이제 연락처 앱으로부터 결과를 돌려받아야 한다. 그런데 연락처 정보는 많은 앱이 공유한다. 따라서 안드로이드에서는 ContentProvider를 통해 연락처 데이터와 함께 작동하는 상세한 API를 제공한다. 이 API 클래스의 인스턴스들은 데이터베이스를 포함하며, 다른 앱에서 이 데이터베이스의 데이터를 사용할 수 있게 한다. ContentProvider는 ContentReslover를 통해서 사용할 수 있다(연락처 데이터베이스의 자세한 내용은 Content Provider 기본 사항에서 Content Provider API 참고한다). 다음으로 연락처 앱으로부터 연락처의 이름을 가져오는 onActivityResult(...)를 CrimeFragment에 구현한다. 일단 코드를 작성한 후 하나씩 알아본다. 연락처의 이름 가져오기 (CrimeFragment.kt) 123456789101112131415161718192021222324252627282930313233343536class CrimeFragment : Fragment(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks { ... private fun updateUI() { ... } override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { when { requestCode != Activity.RESULT_OK -&gt; return requestCode == REQUEST_CONTACT &amp;&amp; data != null -&gt; { val contactUri: Uri = data.data ?: return // 쿼리에서 값으로 반환할 필드를 지정한다 val queryFields = arrayOf(ContactsContract.Contacts.DISPLAY_NAME) // 쿼리를 수행한다. contactUri는 콘텐츠 제공자의 테이블을 나타낸다 val cursor = requireActivity().contentResolver .query(contactUri, queryFields, null, null, null) cursor?.use { // 쿼리 결과 데이터가 있는지 확인한다 if (it.count == 0) { return } // 첫 번째 데이터 행의 첫 번째 열의 값을 가져온다 // 이 값이 용의자의 이름이다 it.moveToFirst() val suspect = it.getString(0) crime.suspect = suspect crimeDetailViewModel.saveCrime(crime) suspectButton.text = suspect } } } } ...} 위의 코드에서는 반환된 데이터에 있는 연락처의 모든 표시명(display name, 쉽게 말해 테이블의 열 이름)을 가져온다. 그리고 연락처 데이터베이스를 쿼리한 후 반환된 결과셋 result set의 행들을 읽는 데 사용할 Cursor 객체를 얻는다. 그다음에 커서가 최소한 한 행의 데이터를 갖고 있는지 확인한 후, Cursor.moveToFirst()를 호출해 첫 번째 행으로 커서를 이동시킨다. 그리고 Cursor.getString(Int)를 호출해 첫 번째 행의 첫 번째 열 값을 가져오며, 이때 이 값이 바로 용의자의 이름이다. 그다음에 이 값을 Crime 객체의 suspect 속성과 ‘용의자 선택’ 버튼의 text 속성에 설정한다. 여기서는 연락처 앱으로부터 용의자 이름을 받으면 그 즉시 범죄 데이터베이스의 Crime 테이블에 저장한다. 이렇게 해야 하는 이유는 다음과 같다. CrimeFragment가 실행 재개 resumed 상태일 때는 onViewCreated(...) 함수가 호출되므로, 범죄 데이터베이스로부터 범죄 데이터를 쿼리하게 된다. 그러나 onActivityResult(...)가 호출된 후에 onViewCreated(...)가 호출되므로 연락처 앱으로부터 받은 용의자 이름을 범죄 데이터베이스의 범죄 데이터(Crime 테이블의 suspect 열 값)로 덮어쓰게 된다. 따라서 연락처 앱으로부터 받은 용의자 이름이 유실되지 않도록 범죄 데이터베이스에 저장해야 한다. 연락처 앱과 범죄 데이터가 있는 장치에서 앱을 다시 실행한다. 범죄 리스트가 나타나면 한 항목을 선택한 후 상세 내역 화면에서 ‘용의자 선택’ 버튼을 누른다. 그다음에 연락처 리스트에서 한 명을 선택하면 상세 내역 화면으로 돌아오면서 ‘용의자 선택’ 버튼에 해당 이름이 나타난다. 그리고 ‘범죄 보고서 전송’ 버튼을 누른 후 ‘메시지’ 앱을 선택하면, 해당 용의자 이름이 범죄 보고서 메시지에도 나타난다. ‘용의자 선택’ 버튼과 범죄 보고서 메시지에 나타난 용의자 이름 연락처 앱의 퍼미션 연락처 데이터베이스를 읽기 위한 퍼미션 permission은 어떻게 얻을까? 연락처 앱이 우리에게 퍼미션을 부여한다. 연락처 앱은 연락처 데이터베이스의 모든 퍼미션을 갖고 있으며, Intent의 데이터 URI를 부모 액티비티에 반환할 때 Intent.FLAG_GRANT_READ_URI_PERMISSION 플래그도 추가한다. 이 플래그는 안드로이드에게 앱의 부모 액티비티가 해당 데이터를 한번 읽는 것을 허용한다고 알린다. 여기서는 연락처 데이터베이스의 전체 데이터를 액세스할 필요가 없고 하나의 연락처 데이터만 필요하므로 퍼미션 문제는 없다. 응답하는 액티비티 확인하기 본문에서 생성했던 첫 번째 암시적 인텐트(범죄 보고서 전송)는 어떤 경우에도 항상 응답을 받는다. 안드로이드 장치에는 이런저런 종류의 메시지 전송 앱이 반드시 있기 때문이다. 그런데 연락처에서 용의자를 선택하기 위한 두 번째 암시적 인텐트에서는 다르다. 일부 사용자나 장치에는 연락처 앱이 없을 수 있기 때문이다. 따라서 이때는 문제가 되는데, 안드로이드 운영체제가 일치하는 액티비티를 찾을 수 없어 앱이 중단되기 때문이다. 이런 문제의 해결책은 onStart() 함수에서 안드로이드 운영체제의 일부인 PackageManager를 먼저 확인하는 것이다. 연락처 앱이 없을 때를 대비하기 (CrimeFragment.kt) 123456789101112131415161718override fun onStart() { ... suspectButton.apply { val pickContactIntent = Intent(Intent.ACTION_PICK, ContactsContract.Contacts.CONTENT_URI) setOnClickListener { startActivityForResult(pickContactIntent, REQUEST_CONTACT) } val packageManager: PackageManager = requireActivity().packageManager val resolvedActivity: ResolveInfo? = packageManager.resolveActivity(pickContactIntent, PackageManager.MATCH_DEFAULT_ONLY) if (resolvedActivity == null) { isEnabled = false } }} PackageManager는 안드로이드 장치에 설치된 모든 컴포넌트와 이것들의 모든 액티비티를 알고 있다. 따라서 resolveActivity(Intent, Int) 함수를 호출하면 첫 번째 인자로 전달된 인텐트와 일치하는 액티비티를 찾도록 요청한다. 그리고 두 번째 인자로 우리가 원하는 플래그를 전달하면 이 플래그를 갖는 액티비티들만 찾는다. 여기서는 MATCH_DEFAULT_ONLY 플래그를 전달해 CATEGORY_DEFAULT가 매니페스트의 인텐트 필터에 정의된 액티비티들만 찾는데, startActivity(Intent)가 하는 것과 같다. 그리고 찾은 액티비티들이 있으면 이것들의 정보를 갖는 ResolveInfo 인스턴스가 반환되고, 찾지 못하면 null을 반환하므로 이때는 ‘용의자 선택’ 버튼이 작동하지 않도록 비활성화한다. 인텐트 필터의 검사가 제대로 되는지 알아보고 싶지만 연락처 앱이 없는 장치가 없을 수도 있다. 이때는 인텐트에 임의의 카테고리를 추가해 테스트하면 된다. 아래 코드에서는 CATEGORY_HOME 플래그를 인텐트의 카테고리로 추가했다. 이 카테고리는 인텐트와 일치하는 연락처 애플리케이션을 찾지 못하게 일부러 추가한 것이다. 인텐트 필터 테스트 코드 추가하기 (CrimeFragment.kt) 12345678910override fun onStart() { ... suspectButton.apply { ... // CATEGORY_HOME 플래그를 인텐트의 카테고리로 추가 pickContactIntent.addCategory(Intent.CATEGORY_HOME) val packageManager: PackageManager = requireActivity().packageManager ... }} 앱을 다시 실행해 범죄 리스트에서 한 항목을 선택하면 상세 내역 화면의 ‘용의자 선택’ 버튼이 비활성화된 것을 확인할 수 있다. 비활성화된 ‘용의자 선택’ 버튼","link":"/2021/05/30/android-bnr-15/"},{"title":"[Android] 암시적 인텐트를 이용한 촬영 및 저장","text":"암시적 인텐트를 사용해 사용자의 카메라 앱을 실행시켜서 사진을 찍고, 데이터에 추가로 저장하고 사용해보도록 한다. 사진을 어디에 저장하고 저장된 사진을 어떻게 보여주어야 할지도 본문에서 알아보도록 한다. 사진을 위한 장소 먼저 상세 내역 화면에 사진을 보여줄 곳을 만든다. 새로운 사용자 인터페이스 파일 스토리지 사진 파일은 화면이 아닌 다른 곳에 저장해야 한다. 그런데 실제 크기의 사진은 용량이 너무 커서 SQLite 데이터베이스에 넣기도 어렵다. 따라서 장치의 파일 시스템에 저장해야 한다. 다행스럽게도 이런 파일은 장치의 개인 스토리지 영역에 저장할 수 있다. SQLite 데이터베이스도 마찬가지다. Context.getFileStreamPath(String)이나 Context.getFilesDir() 같은 함수를 사용하면 일반 파일도 개인 스토리지 영역에 저장할 수 있다(SQLite 데이터베이스가 저장된 databases 서브 폴더와 인접한 다른 서브 폴더에 저장된다). Context 클래스에 있는 기본적인 파일과 디렉터리 함수는 다음과 같다. getFilesDir(): File 앱 전용 파일들의 디렉터리 핸들을 반환한다. openFileInput(name: String): FileInputStream 데이터를 읽기 위해 파일 디렉터리의 기존 파일을 연다. openFileOutput(name: String, mode: Int): FileOutputStream 데이터를 쓰기 위해 파일 디렉터리의 파일을 연다(생성도 한다). getDir(name: String, mode: Int): File 파일 디렉터리 내부의 서브 디렉터리를 알아낸다. fileList(...): Array&lt;String&gt; 파일 디렉터리의 파일 이름들을 알아낸다. 예를 들면, openFileInput(String)과 함께 사용한다. getCacheDir(): File 캐시 파일 저장에 사용할 수 있는 디렉터리의 핸들을 반환한다. 단, 이 디렉터리는 가능한 한 작은 용량을 사용하도록 주의해야 한다. 그런데 문제가 있다. 개인 스토리지 영역의 파일들은 이 앱에서만 읽거나 쓸 수 있기 때문이다. 물론, 다른 앱에서 해당 파일들을 사용하지 않는다면 앞의 함수들만 사용해도 충분하다. 그러나 다른 애플리케이션이 파일에 써야 한다면 앞의 함수들로는 충분하지 않다. 본문의 CriminalIntent 앱의 경우가 바로 그렇다. 왜냐하면 외부의 카메라 앱에서 개인 스토리지 영역의 파일로 사진을 저장해야 하기 때문이다. 이때 Context.MODE_WORLD_READABLE 플래그를 openFileOutput(String, Int) 함수에 전달해서 쓸 수 있지만, 이제는 사용 금지되어 있어서 새로운 안드로이드 버전의 장치에서도 잘 된다는 보장이 없다. 그리고 이전에는 공용의 외부 스토리지를 사용해서 파일을 전송할 수 있었지만, 보안상의 이유로 최근 버전의 안드로이드에서는 금지되었다. 따라서 다른 앱과 파일을 공유하거나 받으려면 ContentProvider를 통해서 해야 한다. ContentProvider로 파일을 콘텐츠 URI로 다른 앱에 노출하면 다른 앱에서는 해당 URI로부터 파일을 다운로드하거나 쓸 수 있다. 그리고 제어할 수도 있으며, 읽거나 쓰는 것을 거부할 수 있다. FileProvider 사용하기 다른 앱으로부터 파일을 받는 것이 전부라면 굳이 ContentProvider 전체를 구현할 필요 없다. 이런 용도로 사용하라고 구글에서는 FileProvider라는 편의 클래스를 제공한다. ContentProvider로 FileProvider를 선언하기 위해 매니페스트 파일에 콘텐츠 제공자 선언을 추가한다. FileProvider 선언 추가하기 (manifests/AndroidManifest.xml) 1234567891011&lt;activity android:name=&quot;.MainActivity&quot;&gt; ...&lt;/activity&gt;&lt;provider android:name=&quot;androidx.core.content.FileProvider&quot; android:authorities=&quot;com.june0122.criminalintent.fileprovider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt;&lt;/provider&gt;... 여기서 android:authorities 속성은 이 FileProvider의 파일이 저장되는 위치이며, 시스템 전체에서 고유한 문자열이어야 한다. 따라서 패키지 이름을 문자열에 포함하는 것이 좋다(여기선 com.june0122.criminalintent가 패키지 이름). 그리고 exported=“false” 속성을 추가하면 우리 자신 및 우리가 권한을 부여한 사람 외에는 FileProvider를 사용할 수 없다. 그리고 grantUriPermissions 속성을 추가하면 인텐트로 android:authorities의 URI를 전송할 때 전송된 URI에 다른 앱이 쓸 수 있는 권한을 부여할 수 있다. 안드로이드 시스템에 FileProvider가 어디에 있는지 알려주었으니, 어떤 경로 path의 파일들을 노출할 것인지도 별도의 XML 리소스 파일에 정의해서 FileProvider에게 알려준다. app/res 폴더에서 'files’라는 이름의 XML Resource type의 Android Resource File을 생성하고 아래와 같이 코드를 변경한다. 경로 추가하기 (res/xml/files.xml) 1234567&lt;!--&lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;/PreferenceScreen&gt;--&gt;&lt;paths&gt; &lt;files-path name=&quot;crime_photos&quot; path=&quot;.&quot; /&gt;&lt;/paths&gt; 이 XML 파일은 개인 스토리지의 루트 경로를 crime_photos로 매핑하며, 이 이름은 FileProvider가 내부적으로 사용한다. 다음으로 매니페스트 파일에 meta-data 태그를 추가해 FileProvider에 files.xml을 연결한다. 경로를 FileProvider에 연결하기 (manifests/AndroidManifest.xml) 123456789&lt;provider android:name=&quot;androidx.core.content.FileProvider&quot; android:authorities=&quot;com.june0122.criminalintent.fileprovider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/files&quot; /&gt;&lt;/provider&gt; 사진 위치 지정하기 다음으로 사진을 개인 스토리지에 저장할 위치를 지정한다. 먼저 파일 이름을 얻는 연산 속성 computed property을 Crime 클래스에 추가한다(코틀린에서 연산 속성은 다른 속성의 값으로 자신의 값을 산출하므로 값을 저장하는 필드 즉, backing field를 갖지 않는다). 파일 이름 속성 추가하기 (Crime.kt) 12345678910@Entitydata class Crime(@PrimaryKey val id: UUID = UUID.randomUUID(), var title: String = &quot;&quot;, var date: Date = Date(), var isSolved: Boolean = false, var suspect: String = &quot;&quot;) { val photoFileName get() = &quot;IMG_$id.jpg&quot;} photoFileName은 사진 파일이 저장되는 폴더의 경로를 포함하지 않지만, 파일 이름은 고유한 것이 된다. 이는 Crime 클래스의 id 속성 값이 이름 속에 포함되어 있기 때문이다. 다음으로 사진이 저장되는 위치를 찾는다. 본문의 앱에서는 CrimeRepository가 데이터 저장에 관련된 모든 것을 책임지고 있으므로 CrimeRepository에 getPhotoFile(Crime) 함수를 추가한다. 이 함수는 Crime 클래스의 photoFileName 속성이 참조하는 사진 파일의 경로를 제공한다. 사진 파일 위치 찾기 (CrimeRepository.kt) 1234567891011121314class CrimeRepository private constructor(context: Context) { ... private val executor = Executors.newSingleThreadExecutor() private val filesDir = context.applicationContext.filesDir ... fun addCrime(crime: Crime) { ... } fun getPhotoFile(crime: Crime): File = File(filesDir, crime.photoFileName) ...} 이 코드에서는 파일 시스템의 어떤 파일도 생성하지 않는다. 단지 올바른 위치를 가리키는 File 객체만 반환한다. 향후에 FileProvider를 사용해서 이 경로를 URI로 노출할 것이다. 끝으로 사진 파일 정보를 CrimeFragment에 제공하는 함수를 CrimeDetailViewModel에 추가한다. CrimeDetailViewModel을 통해 사진 파일 정보 제공하기 (CrimeDetailViewModel.kt) 123456789101112class CrimeDetailViewModel: ViewModel() { ... fun saveCrime(crime: Crime) { crimeRepository.updateCrime(crime) } // 사진 파일 정보를 CrimeFragment에 제공하는 함수 추가 fun getPhotoFile(crime: Crime): File { return crimeRepository.getPhotoFile(crime) }} 카메라 인텐트 사용하기 다음으로 할 일은 실제로 사진을 찍을 수 있게 하는 작업이다. 암시적 인텐트를 사용하면 되므로 매운 쉬운 작업이다. 먼저, 사진 파일의 위치를 CrimeFragment의 photoFile 속성에 저장한다. 이 속성은 이후에도 몇 번 더 사용한다. 사진 파일 위치 저장하기 (CrimeFragment.kt) 12345678910111213141516171819class CrimeFragment : Fragment(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks { private lateinit var crime: Crime private lateinit var photoFile: File ... override fun onViewCreated(view: View, savedInstanceState: Bundle?) { ... crimeDetailViewModel.crimeLiveData.observe( viewLifecycleOwner, Observer { crime -&gt; crime?.let { this.crime = crime photoFile = crimeDetailViewModel.getPhotoFile(crime) // 사진 파일 위치 저장 updateUI() } }) } ...} 다음으로 사진을 찍고 받을 수 있게 MeidaStore를 사용해 카메라 버튼을 코드와 연결한다. MeidaStore는 미디어와 관련된 모든 것을 갖고 있는 안드로이드 클래스다. 인텐트 실행 요청하기 카메라 인텐트를 실행 요청할 준비가 되었다인텐트는 안드로이드 운영체제가 실행하므로 실행을 요청한다는 표현이 적합. 이때 필요한 액션은 ACTION_IMAGE_CAPTURE이며, MediaStore 클래스에 상수로 정의되어 있다. 여기서는 MediaStore.ACTION_IMAGE_CAPTURE 액션을 갖는 암시적 인텐트를 요청하면 안드로이드가 카메라 액티비티를 시작시켜 사진을 찍을 수 있다. MediaStore에는 이미지, 비디오, 음악 등의 미디어를 처리하는 안드로이드에서 사용되는 public 인터페이스가 정의되어 있다. 그리고 카메라 앱을 시작시키는 이미지 캡처 인텐트 상수도 포함한다. 기본적으로 ACTION_IMAGE_CAPTURE 액션은 카메라 앱을 시작시키고 찍은 사진을 받을 수 있게 해준다. 다만 전체 해상도의 사진은 아니고 낮은 해상도의 섬네일 사진이다. 그리고 찍은 사진은 onActivityResult(...)에서 반환하는 Intent 객체에 포함된다. 전체 해상도의 사진을 받으려면 이미지를 저장할 파일 시스템의 위치를 알려주어야 한다. 이때는 MediaStore.EXTRA_OUTPUT 상수를 엑스트라의 키로, 사진 파일을 저장할 위치를 가리키는 Uri를 엑스트라의 값으로 설정해 인텐트에 전달하면 된다. 여기서 Uri는 FileProvider에 의해 서비스되는 위치를 가리킨다. 우선 사진 URI를 저장하는 photoUri 속성을 추가한다. 그리고 사진 파일의 참조를 얻은 후에 FileProvider가 반환하는 Uri로 photoUri 속성을 초기화한다. 사진 URI 속성 추가하고 초기화하기 (CrimeFragment.kt) 1234567891011121314151617181920212223class CrimeFragment : Fragment(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks { private lateinit var crime: Crime private lateinit var photoFile: File private lateinit var photoUri: Uri ... override fun onViewCreated(view: View, savedInstanceState: Bundle?) { ... crimeDetailViewModel.crimeLiveData.observe( viewLifecycleOwner, Observer { crime -&gt; crime?.let { this.crime = crime photoFile = crimeDetailViewModel.getPhotoFile(crime) photoUri = FileProvider.getUriForFile( requireActivity(), &quot;com.june0122.criminalintent.fileprovider&quot;, photoFile ) updateUI() } }) } FileProvider.getUriForFile(...)을 호출하면 로컬 파일 시스템의 파일 경로를 카메라 앱에서 알 수 있는 Uri로 변환한다. 이 함수의 두 번째 인자는 FileProvider를 나타내며, 매니페스트의 android:authorities 속성에 정의했던 것과 같아야 한다. 다음으로 photoUri가 가리키는 위치에 저장할 새로운 사진을 요청하는 암시적 인텐트를 작성한다. 그리고 카메라 앱이 장치에 없거나 사진을 저장할 위치가 없으면, 카메라 버튼을 비활성화하는 코드도 추가한다(사용할 수 있는 카메라 앱이 있는지 판단하기 위해 여기서는 카메라 암시적 인텐트에 응답하는 액티비티의 PackageManager를 쿼리한다). 카메라 인텐트 실행 요청하기 (CrimeFragment.kt) 123456789101112131415161718192021222324252627282930313233343536373839404142private const val REQUEST_CONTACT = 2private const val REQUEST_PHOTO = 3private const val DATE_FORMAT = &quot;yyyy년 M월 d일 H시 m분, E요일&quot;class CrimeFragment : Fragment(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks { ... override fun onStart() { ... suspectButton.apply { ... } photoButton.apply { val packageManager: PackageManager = requireActivity().packageManager val captureImage = Intent(MediaStore.ACTION_IMAGE_CAPTURE) val resolvedActivity: ResolveInfo? = packageManager.resolveActivity(captureImage, PackageManager.MATCH_DEFAULT_ONLY) if (resolvedActivity == null) { isEnabled = false } setOnClickListener { captureImage.putExtra(MediaStore.EXTRA_OUTPUT, photoUri) val cameraActivities: List&lt;ResolveInfo&gt; = packageManager.queryIntentActivities(captureImage, PackageManager.MATCH_DEFAULT_ONLY) for (cameraActivity in cameraActivities) { requireActivity().grantUriPermission( cameraActivity.activityInfo.packageName, photoUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION ) } startActivityForResult(captureImage, REQUEST_PHOTO) } } } ...} photoUri가 가리키는 위치에 실제로 사진 파일을 쓰려면 카메라 앱 퍼미션이 필요하다. 따라서 cameraImage 인텐트를 처리할 수 있는 모든 액티비티에 Intent.FLAG_GRANT_WRITE_URI_PERMISSION을 부여한다(매니페스트에 grantUriPermissions 속성을 추가했으므로 이처럼 퍼미션을 부여할 수 있다). 이렇게 하면 해당 액티비티들이 Uri에 쓸 수 있는 퍼미션을 갖는다. 앱을 실행해 상세 내역 화면에서 카메라 버튼을 눌러보면 각자 장치에 설치된 카메라 앱이 실행되는 것을 확인할 수 있다. 비트맵의 크기 조정과 보여주기 이제는 사진을 찍을 수 있게 되었다. 그리고 이 앱에서 사용할 수 있도록 사진은 파일 시스템의 파일로 저장된다. 다음으로 사진 파일을 읽어서 로드한 후 사용자에게 보여주자. 이렇게 하려면 적합한 크기의 Bitmap 객체로 로드해야 한다. 파일로부터 Bitmap 객체를 얻을 때는 BitmapFactory 클래스를 사용하면 된다. 1val bitmap = BitmapFactory.decodeFile(photoFile.getPath()) 그런데 한 가지 문제가 있다. 바로 적합한 크기에 관한 것이다. Bitmap은 화소 pixel 데이터를 저장하는 간단한 객체다. 즉, 원래 파일이 압축되었더라도 Bitmap 자체는 압축되지 않는다. 따라서 1600만 화소의 24비트 카메라 이미지는 5MB 크기의 JPG로 압축될 수 있지만, Bitmap 객체로 로드하면 48MB 크기로 커진다. 이 문제를 해결하려면 직접 비트맵의 크기를 줄여야 한다. 이때 파일 크기를 먼저 확인하고, 지정된 영역에 맞추기 위해 얼마나 줄여야 할지 파악한 후 해당 파일을 읽어서 크기를 줄인 Bitmap 객체를 생성하면 된다. PictureUtil.kt라는 이름의 새로운 코틀린 파일을 생성하고 getScaledBitmap(String, Int, Int)라는 이름의 파일 수준 함수(코틀린 파일 내에서 클래스 외부에 정의된 함수이며, 앱의 어떤 코드에서도 사용 가능)를 추가한다. getScaledBitmap(...) 함수 생성하기 (PictureUtils.kt) 1234567891011121314151617181920212223242526272829fun getScaledBitmap(path: String, destWidth: Int, destHeight: Int): Bitmap { // 이미지 파일의 크기를 읽는다 var options = BitmapFactory.Options() options.inJustDecodeBounds = true BitmapFactory.decodeFile(path, options) val srcWidth = options.outWidth.toFloat() val srcHeight = options.outHeight.toFloat() // 크기를 얼마나 줄일지 파악한다 var inSampleSize = 1 if (srcHeight &gt; destHeight || srcWidth &gt; destWidth) { val heightScale = srcHeight / destHeight val widthScale = srcWidth / destWidth val sampleScale = if (heightScale &gt; widthScale) { heightScale } else { widthScale } inSampleSize = Math.round(sampleScale) } options = BitmapFactory.Options() options.inSampleSize = inSampleSize // 최종 Bitmap을 생성한다 return BitmapFactory.decodeFile(path, options)} 여기서 중요한 것은 inSampleSize다. 각 화소에 대해 각 '샘플 sample’이 얼마나 큰지를 결정한다. 예를 들어, inSampleSize가 1이면 원래 파일의 각 수평 화소당 하나의 최종 수평 화소를 갖는다. 그리고 2이면 원래 파일의 두 개의 수평 화소마다 하나의 수평 화소를 갖는다. 따라서 inSampleSize가 2일 때는 원래 이미지 화소의 1/4에 해당하는 화소 개수를 갖는 이미지가 된다. 그런데 문제가 하나 더 있다. 프래그먼트가 최초로 시작될 때는 PhotoView의 크기를 미리 알 수 없다. 왜냐하면 프래그먼트의 onCreate(...)와 onStart(...) 및 onResume(...)이 차례대로 호출되어 실행된 후에 레이아웃이 뷰 객체로 생성되기 때문이다(레이아웃이 뷰 객체로 생성될 때까지는 이것의 뷰들이 화면상의 크기를 갖지 않는다). 이 문제의 해결 방법은 두 가지가 있다. 레이아웃이 뷰 객체로 생성될 때까지 기다리거나, PhotoView의 크기가 어느 정도 될지 추정하는 것이다. 크기를 추정하는 방법은 효율성은 떨어지지만 구현은 쉽다. 여기서는 파일 수준 함수인 getScaledBitmap(String, Activity)를 작성해 특정 액티비티의 화면 크기에 맞춰 Bitmap의 크기를 조정한다. 크기 추정 함수 추가하기 (PictureUtils.kt) 123456789101112fun getScaledBitmap(path: String, activity: Activity): Bitmap { val size = Point() @Suppress(&quot;DEPRECATION&quot;) activity.windowManager.defaultDisplay.getSize(size) return getScaledBitmap(path, size.x, size.y)}fun getScaledBitmap(path: String, destWidth: Int, destHeight: Int): Bitmap { ...} getScaledBitmap(String, Activity) 함수에서는 화면 크기를 확인해서 해당 크기에 맞춰 이미지 크기를 줄이기 위해 오버로딩된 getScaledBitmap(String, Int, Int) 함수를 호출한다. 다음으로 ImageView에 Bitmap을 로드하기 위해 CrimeFragment에 새로운 함수를 추가하고 photoView를 변경한다. photoView 변경하기 (CrimeFragment.kt) 1234567891011121314151617181920class CrimeFragment : Fragment(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks { ... private fun updateUI() { ... } private fun updatePhotoView() { if (photoFile.exists()) { val bitmap = getScaledBitmap(photoFile.path, requireActivity()) photoView.setImageBitmap(bitmap) } else { photoView.setImageDrawable(null) } } override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { ... } ...} 그다음에 updatePhotoView() 함수를 updateUI()와 onActivityResult(...) 내부에서 호출하게 한다. updatePhotoView() 호출하기 (CrimeFragment.kt) 123456789101112131415161718192021222324class CrimeFragment : Fragment(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks { ... private fun updateUI() { ... if (crime.suspect.isNotEmpty()) { suspectButton.text = crime.suspect } updatePhotoView() } ... override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { when { resultCode != Activity.RESULT_OK -&gt; return requestCode == REQUEST_CONTACT &amp;&amp; data != null -&gt; { ... } requestCode == REQUEST_PHOTO -&gt; { updatePhotoView() } } } 이제는 카메라 앱에서 저장한 사진 파일을 처리할 수 있게 되었다. 따라서 Uri에 파일을 쓸 수 있는 퍼미션을 취소할 수 있다. 카메라 앱에서 정상적으로 사진 파일을 쓴 이후에 URI 퍼미션을 취소하도록 onActivityResult(...)를 변경하고 onDetach()를 추가해보자(onDetach()는 부적합한 응답이 생길 가능성에 대비한 것이다). URI 퍼미션 취소하기 (CrimeFragment.kt) 123456789101112131415161718192021222324class CrimeFragment : Fragment(), DatePickerFragment.Callbacks, TimePickerFragment.Callbacks { ... override fun onStop() { ... } override fun onDetach() { super.onDetach() requireActivity().revokeUriPermission(photoUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION) updatePhotoView() } ... override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { when { ... requestCode == REQUEST_PHOTO -&gt; { requireActivity().revokeUriPermission(photoUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION) updatePhotoView() } } } 앱을 다시 실행해 범죄 리스트에서 한 항목을 클릭한 후 상세 내역 화면에서 카메라 버튼을 눌러 카메라 앱이 실행되면 사진을 찍는다. ‘확인’ 또는 ‘다시 시도’ 선택 버튼이 나타나면 '확인’을 클릭한다. 그러면 아래의 이미지와 같이 사진의 섬네일 이미지가 상세 내역 화면에 나타난다. 상세 내역 화면에 나타난 섬네일 이미지 사용하는 장치 기능 선언하기 사진 관련 기능을 구현해보았다. 그런데 할 일이 한 가지 더 있다. 앱에서 장치마다 다를 수 있는 기능(카메라나 NFC 등)을 사용할 때는 안드로이드에게 알려주는 것이 좋다. 장치가 지원하지 않는 기능을 앱이 사용하면 다른 앱(예를 들어, 플레이스토어)에서 해당 앱의 설치를 거부할 수 있기 때문이다. 카메라 사용을 선언하기 위해 매니페스트에 &lt;uses-feature&gt; 태그를 추가한다. &lt;uses-feature&gt; 태그 추가하기 (manifests/AndroidManifest.xml) 12345678&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.june0122.criminalintent&quot;&gt; &lt;uses-feature android:name=&quot;android.hardware.camera2&quot; android:required=&quot;false&quot; /&gt; ...&lt;/manifest&gt; 여기서는 생략 가능한 속성인 android:required 가 있다. 왜 그랬을까? 이 속성값을 true로 지정하면 해당 기능 없이는 앱이 제대로 동작하지 않음을 의미한다. 그런데 본문의 앱에서는 그렇지 않으므로 false를 지정하였다. 왜냐하면 resolveActivity(...)를 호출해 작동 가능한 카메라 앱이 있는지 확인해서 없으면 카메라 버튼을 사용할 수 없게 비활성화하기 때문이다. 즉, android:required 속성의 값으로 false를 지정하면 카메라 없이도 앱이 잘 실행될 수 있음을 안드로이드에게 알려주는 것이다.","link":"/2021/05/31/android-bnr-16/"},{"title":"[Android] 데이터 바인딩과 MVVM","text":"앱에 포함된 여러 음원을 사용자가 조회하고 들을 수 있는 BeatBox라는 새로운 프로젝트를 통해 데이터 바인딩 data binding 이라는 Jetpack 아키텍처 컴포넌트 라이브러리를 사용하는 방법을 배운다. 그리고 데이터 바인딩을 사용해서 MVVM(Model-View-View Model) 아키텍처를 구현하고 애셋 asset 시스템을 사용해서 음원 파일을 저장하는 방법도 알아본다. 다른 아키텍처가 왜 필요할까? 지금까지 작성했던 모든 앱은 간단한 형태의 MVC 아키텍쳐를 사용해 잘 작동하였다. 그런데 무슨 문제가 있길래 아키텍처를 변경해야 할까? 장점 MVC 아키텍처는 규모가 작고 간단한 앱에는 좋다. 새로운 기능을 추가하기 쉽고 앱의 동적인 부분을 쉽게 알 수 있을 뿐만 아니라 프로젝트의 초기 단계에 확고한 개발 기간을 만들어줘서 앱을 빨리 개발할 수 있다. 단점 그런데 프로젝트가 커지면 문제가 발생한다. MVC의 컨트롤러 역할인 액티비티나 프래그먼트의 규모가 커지면서 작성과 이해가 어려워져서 새로운 기능을 추가하거나 결함을 해결하는 데 시간이 오래 걸린다. 따라서 언젠가는 그런 컨트롤러들을 더 작은 부분으로 분할해야 한다. 해결책 그렇다면 어떻게 해야 할까? 점점 비대해지는 컨트롤러 클래스들이 하는 작업을 파악하여 하나의 거대한 클래스 대신 여러 클래스가 작업을 분담해 협업하게 하면 된다. 그런데 서로 다른 작업을 어떻게 분할해야 할까? 이에 대한 답은 MVVM과 같은 아키텍처를 사용하는 것이다. 단, 작업을 분할하는 것은 전적으로 프로그래머의 일이다. MVVM에서는 뷰와 밀접한 콘트롤러 코드를 레이아웃 파일로 옮길 수 있다. 게다가 동적인(변하는 데이터를 처리하는) 컨트롤러 코드의 일부를 뷰 모델 클래스에 넣어서 앱의 테스트와 검증도 쉽게 할 수 있다. 단, 뷰모델 클래스를 어떤 규모로 할 것인지는 각자의 판단에 달렸다. 뷰모델 클래스가 커지면 작게 분할하면 된다. MVVM 뷰모델 vs Jetpack ViewModel MVVM의 일부인 뷰모델은 여기에서 다뤘던 Jetpack ViewModel(AAC ViewModel) 클래스와 같은 것이 아니다. 따라서 혼동되지 않도록 Jetpack 클래스의 이름을 항상 ViewModel로 나타내고 MVVM 개념 관련해서는 '뷰모델’이라고 한다. 다시 정리하자면, Jetpack ViewModel은 액티비티나 프래그먼트의 생명주기에 걸쳐 데이터를 유지하고 관리하는 클래스다. 반면에 MVVM의 뷰모델은 개념적인 아키텍처의 일부분을 말한다. 뷰모델은 Jetpack ViewModel 클래스를 사용해서 구현할 수 있다. 그런데 곧 본문의 내용을 통해 알 수 있지만, ViewModel 클래스를 사용하지 않고도 구현할 수 있다. BeatBox 프로젝트 준비 작업 BeatBox 앱의 액티비티에서는 RecyclerView에 격자 grid 형태의 버튼을 보여줄 것이다. RecyclerView의 의존성을 build.gradle 파일에 추가하고 res/layout/activity_main.xml의 모든 XML을 삭제하고 아래와 같이 RecyclerView로 교체한다. MainActivity의 레이아웃 파일 변경하기 (res/layout/activity_main.xml) 1234&lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 이 상태에서 앱을 실행하면 빈화면만 나오는데, 이제부터 데이터 바인딩(data binding)을 구현해보자. 단순 데이터 바인딩 구현하기 RecyclerView를 코드와 연결해야 한다. 일반적으로 많이 하는 작업이지만, 이번에는 데이터 바인딩을 사용한다. 데이터 바인딩은 레이아웃을 사용할 때 몇 가지 장점을 제공한다. 곧 보겠지만 간단한 예로, findViewById(...) 를 호출하지 않고 뷰를 사용할 수 있게 해준다(자동으로 뷰에 데이터를 넘겨줌). 진보된 데이터 바인딩의 사용법은 추후에 알아본다. 우선 데이터 바인딩을 활성화 하고 kotlin-kapt 플러그인을 적용하도록 build.gradle 파일에 추가한다. 데이터 바인딩 활성화하기 (build.gradle) 12345678910111213141516plugins { id 'com.android.application' id 'kotlin-android' id 'kotlin-kapt'}android { ... buildTypes { ... } dataBinding { enabled = true } ...} kotlin-kapt 플러그인을 적용하면 데이터 바인딩에서 코틀린의 애노테이션을 처리할 수 있다. 이것이 중요한 이유는 본문의 뒷부분에서 알 수 있다. 레이아웃 파일에서 데이터 바인딩을 사용하려면 &lt;layout&gt; 태그로 레이아웃 XML 전체를 둘러싸서 데이터 바인딩용 레이아웃 파일로 변경하면 된다. activity_main.xml의 파일 이름을 main_activity.xml로 변경하고 코드를 아래와 같이 수정한다(자동으로 생성되는 바인딩 클래스의 이름의 가독성을 올리기 위해 이름 변경). 데이터 바인딩용 레이아웃 파일로 변경하기 (res/layout/main_activity.xml) 123456&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;&lt;/layout&gt; &lt;layout&gt; 태그는 이 레이아웃에 데이터 바인딩을 한다는 것을 나타낸다. 레이아웃에 이 태그가 있으면 데이터 바인딩 라이브러리가 바인딩 클래스(binding class) 를 자동으로 생성한다. 기본적으로 이 클래스 이름은 레이아웃 파일 이름 끝에 Binding이 붙은 채로 지정된다(복합 단어이면 각 단어의 첫 자를 대문자로 사용하는 카멜 명명법이 사용됨). 따라서 여기서는 MainActivityBinding이라는 main_activity.xml의 바인딩 클래스가 자동으로 생성된다. 그리고 이 클래스가 데이터 바인딩에 사용되므로 setContentView(Int)를 사용해서 뷰를 인플레이트하는 대신에 MainActivityBinding의 인스턴스를 인플레이트한다. MainActivityBinding은 root 속성에 뷰 계층(레이아웃 전체)의 참조뿐 아니라 레이아웃 파일에 android:id가 지정된 각 자식 뷰의 참조도 갖는다. 따라서 여기서는 MainActivityBinding 클래스가 두 개의 참조, ① 레이아웃 전체의 참조와 ② RecyclerView를 참조하는 recyclerView(자동 생성됨)을 가진다. 바인딩 클래스 그런데 이 레이아웃은 하나의 뷰만 갖고 있어서 두 개의 참조 모두 RecyclerView를 가리킨다. 이제는 바인딩 클래스를 사용할 수 있다. 우선 DataBindingUtil을 사용해서 MainActivityBinding 인스턴스를 인플레이트하도록 MainActivity의 onCreate(...)을 변경한다. 이때 다른 클래스처럼 MainActivityBinding도 import해야 한다. 바인딩 클래스 인플레이트하기 (MainActivity.kt) 12345678910class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState)// setContentView(R.layout.activity_main) // 바인딩 클래스 인플레이트 val binding: MainActivityBinding = DataBindingUtil.setContentView(this, R.layout.main_activity) }} 바인딩 클래스가 생성되었다. 이제 RecyclerView를 구성한다. RecyclerView 구성하기 (MainActivity.kt) 12345678910111213class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding: MainActivityBinding = DataBindingUtil.setContentView(this, R.layout.main_activity) // RecyclerView 구성 binding.recyclerView.apply { layoutManager = GridLayoutManager(context, 3) } }} RecyclerView가 한 행에 세 개의 격자를 가지며, 각 격자에는 아래의 버튼 레이아웃이 포함된다. 음원 버튼 레이아웃 생성하기 (res/layout/list_item_sound.xml) 123456789&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;120dp&quot; android:layout_marginStart=&quot;5dp&quot; android:layout_marginEnd=&quot;5dp&quot; tools:text=&quot;Sound name&quot; /&gt;&lt;/layout&gt; 이렇게 하면 ListItemSoundBinding 클래스가 자동 생성된다. 그다음으로 이 클래스 인스턴스를 통해서 list_item_sound.xml과 연결되는 SoundHolder를 생성한다. SoundHolder 생성하기 (MainActivity.kt) 12345678class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { ... } private inner class SoundHolder(private val binding: ListItemSoundBinding) : RecyclerView.ViewHolder(binding.root) { }} 이 SoundHolder에서는 자동 생성된 바인딩 클래스인 ListItemSoundBinding을 사용한다. 그다음으로 이 SoundHolder와 연결되는 어댑터를 생성한다. SoundAdapter 생성하기 (MainActivity.kt) 1234567891011121314151617181920212223class MainActivity : AppCompatActivity() { ... private inner class SoundHolder(private val binding: ListItemSoundBinding) : RecyclerView.ViewHolder(binding.root) { } private inner class SoundAdapter() : RecyclerView.Adapter&lt;SoundHolder&gt;() { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): SoundHolder { val binding = DataBindingUtil.inflate&lt;ListItemSoundBinding&gt;( layoutInflater, R.layout.list_item_sound, parent, false ) return SoundHolder(binding) } override fun onBindViewHolder(holder: SoundHolder, position: Int) { } override fun getItemCount(): Int = 0 }} 이제는 onCreate(...)에서 SoundAdapter르 연결하면 된다. SoundAdapter 연결하기 (MainActivity.kt) 123456789override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val binding: MainActivityBinding = DataBindingUtil.setContentView(this, R.layout.main_activity) binding.recyclerView.apply { layoutManager = GridLayoutManager(context, 3) adapter = SoundAdapter() // SoundAdapter 연결하기 }} 드디어 데이터 바인딩을 사용해서 RecyclerView를 설정하였다. 아직은 앱을 실행해도 화면에 아무것도 나오지 않는다. 에셋 가져오기 다음으로 음원 파일들을 프로젝트에 추가해 런타임 시에 사용할 수 있게 한다. 이 작업은 리소스 시스템을 사용하는 대신 애셋 asset 을 사용하는데, 애셋은 리소스 자체라고 생각하면 된다. 즉, 리소스처럼 APK에 포함되지만 시스템에서 특별한 구성(디렉터리 구조화와 참조 생성 등)을 하지 않은 리소스다. 애셋은 구성하는 시스템이 없으므로 원하는 대로 애셋의 이름을 지정하거나 폴더 구조로 구성할 수 있다. 그러나 단점도 있다. 참조를 하기 위한 구성이나 관리하는 시스템이 없으므로 장치의 화면 해상도, 언어, 방향 등이 달라지면 자동으로 대응할 수 없으며, 레이아웃 파일이나 다른 리소스에서 자동으로 사용할 수도 없다. 일반적으로는 리소스를 사용하는 것이 좋다. 그러나 본문의 BeatBox 앱처럼 코드에서 음원 파일들만 사용할 때는 애셋이 유리하다. 대부분의 게임 앱에서는 그래픽과 음원을 애셋으로 사용한다. 음원 애셋을 추가하기 위해 프로젝트에 아래 이미지와 같이 프로젝트 도구 창의 app에서 오른쪽 마우스 버튼을 클릭한 후 New -&gt; Folder -&gt; Assets Folder를 선택한다. 그리고 대화상자에서 'Change Folder Location’을 체크되지 않은 상태로 두고 'Target Source Set’을 main으로 선택한다. Finish 버튼을 클릭하면 app 아래에 assets 폴더가 생성된다. 그다음에 app/assets 폴더에 서브 디렉터리로 'sample_sounds’를 생성한다. 이렇게 하면 assets 폴더에 있는 모든 파일이 이 앱과 함께 배포된다. 여기서는 편리하게 사용하려고 서브 폴더를 생성했지만, 리소스와는 달리 서브 폴더가 없어도 된다. 에셋 폴더의 음원 파일들은 이곳에서 다운로드한다. 에셋 사용하기 BeatBox에서는 애셋 관리와 연관된 많은 일을 하게 된다. 즉, 애셋을 찾아 유지하고 관리하며 음원으로 재생하는 일이다. 이런 일을 하는 새로운 클래스인 BeatBox를 생성하고, 두 개의 상수와 로그 메시지에 사용할 태그 값과 애셋이 저장된 폴더 이름을 추가한다. 새로운 BeatBox 클래스 (BeatBox.kt) 123456private const val TAG = &quot;BeatBox&quot;private const val SOUNDS_FOLDER = &quot;sample_sounds&quot;class BeatBox { } 애셋은 AssetManager 클래스로 사용하며, AssetManager 인스턴스는 어떤 Context에서도 생성할 수 있다. BeatBox 생성자는 AssetManager 인스턴스 참조를 인자로 받는다. AssetManager 인스턴스 참조 받기 (BeatBox.kt) 123456private const val TAG = &quot;BeatBox&quot;private const val SOUNDS_FOLDER = &quot;sample_sounds&quot;class BeatBox(private val assets: AssetManager) {} 애셋을 사용할 때 어떤 Context를 사용할 것인지 고민할 필요는 없다. 어떤 상황이든 모든 Context의 AssetManager가 에셋과 연결될 수 있기 때문이다. 에셋에 있는 파일들의 내역을 얻을 때는 list(String) 함수를 사용한다. 그리고 이 함수를 사용해서 에셋의 파일 내역을 찾는 loadSounds() 함수를 추가한다. 에셋 찾기 (BeatBox.kt) 12345678910111213class BeatBox(private val assets: AssetManager) { fun loadSounds() : List&lt;String&gt; { try { val soundNames = assets.list(SOUNDS_FOLDER)!! Log.d(TAG, &quot;Found ${soundNames.size} sounds&quot;) return soundNames.asList() } catch (e: Exception) { Log.e(TAG, &quot;Could not list assets&quot;, e) return emptyList() } }} AssetManager.list(String)에서는 인자로 전달된 폴더 경로에 포함된 파일들의 이름을 반환한다. 따라서 여기서는 sample_sounds 폴더 이름을 전달해 이 폴더에 넣었던 모든 .wav 파일의 이름을 알 수 있다. 지금까지 추가한 코드가 잘 작동하는지 BeatBox의 인스턴스를 생성하고 loadSounds() 함수를 호출하는 코드를 MainActivity에 추가해 확인한다. BeatBox 인스턴스 생성하기 (MainActivity.kt) 1234567891011121314151617181920class MainActivity : AppCompatActivity() { private lateinit var beatBox: BeatBox override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) beatBox = BeatBox(assets) beatBox.loadSounds() val binding: MainActivityBinding = DataBindingUtil.setContentView(this, R.layout.main_activity) binding.recyclerView.apply { layoutManager = GridLayoutManager(context, 3) adapter = SoundAdapter() } } ...} BeatBox 앱을 실행하고 LogCat을 확인해보면, 현재 애셋 폴더에 22개의 .wav 파일이 있으므로 아래와 같은 메시지가 보인다. 12021-05-31 01:29:02.299 26730-26730/com.june0122.beatbox D/BeatBox: Found 22 sounds 애셋 사용 코드 추가하기 애셋 파일들의 이름을 갖게 되었으니, 이 이름들을 각 버튼에 설정해 사용자에게 보여줄 수 있다. 궁극적으로는 음원 파일을 재생하므로, 파일 이름과 사용자가 볼 수 있는 이름 및 해당 음원 관련 정보를 유지하고 관리하는 객체가 필요하다. 이 모든 것을 갖는 Sound 클래스를 아래와 같이 생성한다. Sound 클래스 생성하기 (Sound.kt) 123456private const val WAV = &quot;.wav&quot;class Sound(val assetPath: String) { val name = assetPath.split(&quot;/&quot;).last().removeSuffix(WAV)} Sound 클래스의 생성자에서는 화면에 보여줄 음원 파일의 이름을 만드는 일을 한다. 즉, String.split(String).last()를 사용해서 경로 문자열 맨 끝에 있는 파일 이름을 얻고, String.removeSuffix(String)을 사용해서 확장자인 .wav를 제거한다. 그다음으로 BeatBox.loadSounds() 함수에서 Sound 인스턴스들의 List를 생성한다. Sound 객체를 저장하는 List 생성하기 (BeatBox.kt) 123456789101112131415161718192021222324252627282930class BeatBox(private val assets: AssetManager) { val sounds: List&lt;Sound&gt; init { sounds = loadSounds() }// fun loadSounds() : List&lt;String&gt; { fun loadSounds(): List&lt;Sound&gt; { val soundNames: Array&lt;String&gt; try { soundNames = assets.list(SOUNDS_FOLDER)!!// val soundNames = assets.list(SOUNDS_FOLDER)!!// Log.d(TAG, &quot;Found ${soundNames.size} sounds&quot;)// return soundNames.asList() } catch (e: Exception) { Log.e(TAG, &quot;Could not list assets&quot;, e) return emptyList() } val sounds = mutableListOf&lt;Sound&gt;() soundNames.forEach { fileName -&gt; val assetPath = &quot;$SOUNDS_FOLDER/$fileName&quot; val sound = Sound(assetPath) sounds.add(sound) } return sounds }} 다음으로 SoundAdapter를 Sound 인스턴스가 저장된 List에 연결한다. 우선 getItemCount() 함수에서 sounds.size를 반환하게 변경한다(sounds.size는 sounds List에 저장된 음원 파일의 개수를 나타냄). 음원 파일의 개수 알아내기 (MainActivity.kt) 12345678910private inner class SoundAdapter(private val sounds: List&lt;Sound&gt;) : RecyclerView.Adapter&lt;SoundHolder&gt;() { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): SoundHolder { ... } override fun onBindViewHolder(holder: SoundHolder, position: Int) { } override fun getItemCount(): Int = sounds.size} 그다음에 onCreate(...)에서 BeatBox의 Sound 인스턴스 List를 어댑터 인자로 전달한다. Sound 인스턴스를 저장한 List를 어댑터에 전달하기 (MainActivity.kt) 1234567override fun onCreate(savedInstanceState: Bundle?) { ... binding.recyclerView.apply { layoutManager = GridLayoutManager(context, 3) adapter = SoundAdapter(beatBox.sounds) }} 마지막으로 onCreate(...)에서 loadSounds() 함수 호출 코드를 삭제한다. loadSounds() 함수 호출 코드 삭제하기 (MainActivity.kt) 123456override fun onCreate(savedInstanceState: Bundle?) { ... beatBox = BeatBox(assets)// beatBox.loadSounds() ...} 이제는 BeatBox의 init 블록 외부에서 BeatBox.loadSounds() 함수가 더 이상 호출되지 않는다. 따라서 이 함수의 가시성 visibility을 public으로 지정할 필요가 없으므로 private로 변경한다. BeatBox.loadSounds()의 가시성을 private로 변경 (BeatBox.kt) 123456class BeatBox(private val assets: AssetManager) { ... private fun loadSounds(): List&lt;Sound&gt; { ... }} 앱을 실행해보면 격자 형태로 나타난 버튼들을 볼 수 있다. 비어 있는 버튼들 이제 각 버튼에 음원 이름을 보여주기 위해 데이터 바인딩을 사용해보자. 데이터 바인딩하기 데이터 바인딩을 사용할 때는 레이아웃 파일에 데이터를 가진 객체를 선언할 수 있다. 앞의 다른 프로젝트에서 알아보았던 범죄 객체 Crime를 예로 들면 다음과 같다. 123456789&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;variable name=&quot;crime&quot; type=&quot;com.june0122.criminalintent.Crime&quot;/&gt; &lt;/data&gt; ...&lt;/layout&gt; 이렇게 하면 다음과 같이 레이아웃 파일에서 해당 데이터 객체의 값을 바인딩 연산자 binding mustache 인 @{}를 사용해서 바로 참조할 수 있다. 1234567&lt;CheckBox android:id=&quot;@+id/list_item_crime_solved_check_box&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:checked=&quot;@{crime.isSolved()}&quot; android:padding=&quot;4dp&quot; /&gt; 데이터 바인딩을 객체 다이어그램으로 나타내면 다음과 같다. 레이아웃과 코틀린 객체 간의 데이터 바인딩 여기서는 음원 이름을 각 버튼에 넣는다. 이때 데이터 바인딩을 사용해서 list_item_sound.xml 레이아웃 파일에 Sound 객체를 직접 바인딩한다. list_item_sound.xml 레이아웃과 Sound 객체의 바인딩 그런데 이렇게 하면 아키텍처 관점에서 문제가 생긴다. 아래의 MVC 모델을 보자. 문제가 있는 MVC 아키텍처 대부분의 아키텍처에서 하나의 클래스는 한 가지 책임 SRP, single responsibility principle 만을 가지게 하는 것이 기본 원리다. MVC도 그렇다. 즉, 모델은 앱이 작동하는 방법을 나타내며, 컨트롤러는 모델과 뷰를 중재하면서 앱의 데이터를 보여주는 방법을 결정하고, 뷰는 화면에 데이터를 보여준다. 위와 같이 데이터 바인딩을 사용하면 각 아키턱처 요소의 역할 분담이 분명하게 이루어지지 않는다. 보여줄 뷰의 데이터를 준비하는 코드를 Sound 모델 객체가 갖게 되어 컨트롤러 역할을 하기 때문이다. 따라서 Sound.kt에는 앱이 작동하는 방법을 나타내는 코드와 보여줄 뷰의 데이터를 준비하는 코드가 뒤섞이게 된다. 그러므로 데이터 바인딩을 제대로 사용하려면 뷰모델이라는 새로운 객체가 필요하다. 그리고 이 객체는 보여줄 뷰의 데이터를 준비하는 방법을 결정하는 책임을 갖는다. 모델-뷰-뷰모델 이런 아키텍처를 MVVM이라고 하며, 보여줄 데이터를 형식화하기 위해 MVC의 컨트롤러 클래스가 런타임 시에 했던 대부분의 일을 뷰모델이 담당한다. 즉, 레이아웃에서 위젯들을 데이터와 바인딩하던 일을 뷰모델이 하게 된다. 그리고 컨트롤러(액티비티나 프래그먼트)는 데이터 바인딩과 뷰모델을 초기화하고 연결하는 일을 맞게 된다. 뷰모델 생성하기 뷰모델인 SoundViewModel 클래스를 생성하고, 사용할 Sound 객체 참조를 갖는 sound 속성을 추가한다. SoundViewModel 생성하기 (SoundViewModel.kt) 1234567class SoundViewModel { var sound: Sound? = null set(sound) { field = sound }} 그리고 각 버튼에 보여줄 제목을 갖는 title 속성도 추가한다. 버튼 제목을 갖는 속성 추가하기 (SoundViewModel.kt) 12345678910class SoundViewModel { var sound: Sound? = null set(sound) { field = sound } val title: String? get() = sound?.name} 뷰모델에 바인딩하기 다음으로 뷰모델을 레이아웃 파일과 연결한다. 우선 레이아웃 파일에 속성을 선언한다. 뷰모델을 바인딩하는 속성 선언하기 (res/layout/list_item_sound.xml) 1234567891011121314151617&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;variable name=&quot;viewModel&quot; type=&quot;com.june0122.beatbox.SoundViewModel&quot; /&gt; &lt;/data&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;120dp&quot; android:layout_marginStart=&quot;5dp&quot; android:layout_marginEnd=&quot;5dp&quot; android:text=&quot;@{viewModel.title}&quot; tools:text=&quot;Sound name&quot; /&gt;&lt;/layout&gt; 바인딩 연산자인 @{} 내부에서는 간단한 코틀린 표현식을 사용할 수 있다. 예를 들어, 함수 연쇄 호출이나 수식 등이다. RecyclerView의 각 항목(여기서는 버튼) 데이터를 갖는 SoundHolder에 다음 코드를 추가한다. 우선 SoundViewModel 인스턴스를 생성하고 이것의 참조를 바인딩 클래스인 ListItemSoundBinding의 viewModel 속성에 설정한다. 그리고 바인딩 함수인 bind(...)를 추가한다. 뷰모델과 바인딩하기 (MainActivity.kt) 12345678910111213private inner class SoundHolder(private val binding: ListItemSoundBinding) : RecyclerView.ViewHolder(binding.root) { init { binding.viewModel = SoundViewModel() } fun bind(sound: Sound) { binding.apply { viewModel?.sound = sound executePendingBindings() } }} 여기서는 init 초기화 블록에서 뷰모델 인스턴스를 생성하고 바인딩 클래스의 ViewModel 속성을 초기화한다. 그리고 바인딩 함수인 bind(Sound)에서는 viewModel 속성을 변경한다. 보통은 executePendingBindings()를 호출할 필요 없다. 그러나 이 앱에서는 RecyclerView에 포함된 바인딩 데이터를 변경해야 하며, RecyclerView는 빠른 속도로 뷰를 변경해야 한다. 따라서 RecyclerView에 포함된 레이아웃을 즉각 변경하도록 executePendingBindings()를 호출한 것이다. 이렇게 함으로써 RecyclerView와 RecyclerView.Adapter가 즉시 동기화되어 화면에서 RecyclerView를 스크롤할 때 훨씬 매끄럽게 보인다. 마지막으로 onBindViewHolder(...)에서 bind(Sound) 함수를 호출하여 뷰모델의 각 Sound 인스턴스를 SoundHolder 인스턴스와 연결한다. bind(Sound) 함수 호출하기 (MainActivity.kt) 123456789101112private inner class SoundAdapter(private val sounds: List&lt;Sound&gt;) : RecyclerView.Adapter&lt;SoundHolder&gt;() { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): SoundHolder { ... } override fun onBindViewHolder(holder: SoundHolder, position: Int) { val sound = sounds[position] holder.bind(sound) } override fun getItemCount(): Int = sounds.size} 앱을 다시 실행하면 이제는 모든 버튼의 제목이 나타난다. 제목이 있는 버튼들 관찰 가능한 데이터 이제는 모든 게 잘되는 것처럼 보인다. 그러나 이 코드에는 문제가 있다. 앱을 실행하여 가로 방향으로 회전해서 스크롤해보자. 이전에 본 데이터가 또다시 나타난다 위에서 '65_CJIPIE’가 보였었는데 아래로 스크롤하니 또다시 '65_CJIPIE’가 보인다. 위아래로 스크롤을 해보면 계속해서 다른 음원 파일의 제목이 보일 것이다. 왜 이런 것일까? 이는 레이아웃이 SoundHolder.bind(sound) 함수 내부에서 SoundViewModel의 Sound 객체를 변경했음을 알 수 있는 방법이 없기 때문이다. MVVM 아키텍처에서는 바로 이 방법을 찾는 것이 중요하다. 따라서 바인딩 데이터가 변경되면 뷰모델이 레이아웃 파일과 소통하게 만드는 것이 다음으로 할 일이다. 이렇게 하려면 뷰모델에서 데이터 바인딩의 Observable 인터페이스를 구현해야 한다. 이 인터페이스를 사용하면 바인딩 클래스가 뷰모델에 리스너를 설정할 수 있다. 따라서 바인딩 데이터가 변경되면 자동으로 콜백 호출을 받을 수 있다. 그런데 Observable 인터페이스의 모든 함수를 구현할 필요는 없으므로 여기서는 데이터 바인딩의 BaseObservable 클래스를 사용하여 다음과 같이 구현한다(이 클래스는 기본적으로 Observable 클래스를 구현하고 있다.). 뷰모델인 SoundViewModel을 BaseObservable의 서브 클래스로 선언한다. SoundViewModel의 바인딩되는 속성에 @Bindable 애노테이션을 지정한다. 바인딩되는 속성의 값이 변경될 때마다 notifyChange() 또는 notifyPropertyChanged(Int)를 호출한다. 여기서는 SoundViewModel에 약간의 코드만 추가하면 된다. SoundViewModel이 관찰 가능하게(observable) 변경한다. 뷰모델이 관찰 가능하게 만들기 (SoundViewModel.kt) 123456789101112131415import androidx.databinding.BaseObservableimport androidx.databinding.Bindableclass SoundViewModel : BaseObservable() { var sound: Sound? = null set(sound) { field = sound notifyChange() } @get:Bindable val title: String? get() = sound?.name} notifyChange()를 호출하면 데이터 객체(여기서는 Sound)의 모든 바인딩 속성값이 변경되었음을 바인딩 클래스(여기서는 ListItemSoundBinding)에 알린다. 따라서 sound 속성의 값(Sound 인스턴스 참조)이 설정되면 list_item_sound.xml의 바인딩 클래스인 ListItemSoundBinding이 알림을 받게 되어 list_item_sound.xml의 버튼 제목이 변경된다(Button.setText(String)이 호출됨). 앞에서 얘기했던 또 다른 함수인 notifyPropertyChanged(Int)도 notifyChange()와 같은 기능을 수행한다. 그러나 모든 바인딩 속성이 아닌 특정 바인딩 속성의 값이 변경되었음을 알려준다는 점이 다르다. 예를 들어, notifyPropertyChanged(BR.title)의 경우는 title 속성값만 변경되었음을 나타낸다. 여기서 BR.title은 데이터 바인딩 라이브러리가 생성한 상수다. 클래스 이름인 BR은 'binding resource’의 단축어다. BR 상수는 @Bindable 애노테이션이 지정된 각 속성에 대해 해당 속성과 같은 이름으로 생성된다. BR 상수 예시 123@get:Bindable val title: String // BR.title 상수가 생성됨@get:Bindable val volumn: Int // BR.volumn 상수가 생성됨@get:Bindable val etcetera: String // BR.etcetera 상수가 생성됨 Observable 인터페이스를 사용하는 것이 데이터베이스와 Room 라이브러리에서 기술한 LiveData를 사용하는 것과 유사하다고 생각할 수 있다. 실제로 Observable 인터페이스 대신 LiveData를 데이터 바인딩에 사용할 수 있다. 이 내용은 궁금증 해소 : LiveData와 데이터 바인딩에서 설명한다. 앱을 다시 실행해보면 이번에는 가로나 세로, 어느 방향에서 스크롤해도 정상적으로 작동한다. 궁금증 해소 💁🏻‍♂️ : 데이터 바인딩 추가로 알아보기 람다식 레이아웃 파일에 지정한 바인딩 연산자인 @{} 내부에는 간단한 코틀린 표현식은 물론이고 **람다식 lambda expression**도 사용할 수 있다. 예를 들면 다음과 같다. 123456&lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;120dp&quot; android:text=&quot;@{viewModel.title}&quot; android:onClick=&quot;@{(view) -&gt; viewModel.onButtonClick()}&quot; tools:text=&quot;Sound name&quot; /&gt; 자바 8의 람다식처럼 이것은 리스너 인터페이스의 구현 코드로 변환한다. 단, 여기처럼 정확한 문법을 사용해야 한다. 즉, 매개변수는 반드시 괄호로 둘러싸야 하고 -&gt; 오른쪽에는 하나의 표현식만 포함할 수 있다. 또한, 자바의 람다식과는 다르게 람다식 매개변수를 생략할 수도 있다. 따라서 다음과 같이 해도 된다. 1android:onClick=&quot;@{() -&gt; viewModel.onButtonClick()}&quot; 더 편리한 문법 데이터 바인딩에는 큰따옴표 안에 백틱 ` 기호도 사용할 수 있다. 1android:text=&quot;@{`File name: ` + viewModel.title}&quot; 여기서 `File name`은 **“File name”**과 같은 의미다. 또한, 데이터 바인딩 표현식에는 null 처리 연산자를 넣을 수 있다. 1android:text=&quot;@{`File name: ` + viewModel.title ?? `No file`}&quot; 여기서 title 값이 null이면 ?? 연산자가 null 대신 'No file’을 결괏값으로 산출한다. 또한, 데이터 바인딩 표현식에는 null 값을 자동으로 처리한다. 심지어는 앞의 코드에서 viewModel이 null일지라도 앱이 중단되지 않게 데이터 바인딩에서 null 값 여부를 검사하고 조치한다. 따라서 viewModel이 null일 때는 viewModel.title의 결과를 &quot;null&quot;로 반환한다. BindingAdapter 기본적으로 데이터 바인딩에서는 바인딩 표현식을 레이아웃 속성의 게터/세터 호출로 변환한다. 예를 들어, 다음 표현식은 text 속성의 세터인 setText(String) 함수 호출로 변환되어 처리된다. 1android:text=&quot;@{`File name: ` + viewModel.title ?? `No file`}&quot; 그러나 이 정도로는 충분치 않고 특정 속성에 나름의 추가 처리가 필요할 때가 있다. 이때는 다음과 같이 BindingAdapter를 사용한다. 1234@BindingAdapter(&quot;app:soundName&quot;)fun bindAssetSound(button: Button, assetFileName: String) { ...} 즉, 프로젝트의 어디서든 파일 수준 함수를 생성하고 @BindingAdapter 애노테이션을 지정하면 된다. 그리고 바인딩할 속성 이름을 @BindingAdapter 애노테이션의 인자로 전달한다(여기서는 app:soundName). 그다음에 @BindingAdapter 애노테이션이 적용되는 View를 해당 함수의 첫 번째 인자로 전달한다. 앞의 예에서는 app:soundName 속성을 갖는 Button을 데이터 바인딩이 접할 때마다 bindAssetSound(...) 함수를 호출한다. 이때 해당 Button과 바인딩 표현식 binding expression 의 결과가 인자로 전달된다(여기서는 나타나지 않았지만, 바인딩 표현식은 app:soundName 속성에 지정되어 있다.). View나 ViewGroup 같은 더 일반화된 뷰의 BindingAdapter도 생성할 수 있다. 이때 BindingAdapter가 해당 View와 이것의 모든 서브 클래스에 적용된다. 예를 들어, Boolean 값을 기준으로 View(와 이것의 모든 서브 클래스 뷰)의 가시성을 설정하는 app:isGone 속성을 정의할 때는 다음과 같이 한다. 1234@BindingAdapter(&quot;app:isGone&quot;)fun bindIsGone(view: View, isGone: Boolean) { view.visibility = if (isGone) View.GONE else View.VISIBLE} 여기서는 View가 bindIsGone(...)의 첫 번째 인자이므로 isGone 속성은 app 모듈의 View와 이것의 모든 서브 클래스 View에 대해 사용할 수 있다. 예를 들면 Button, TextView, LinearLayout 등에서 사용 가능하다. 안드로이드 표준 라이브러리의 위젯에는 이미 바인딩 어댑터가 정의되어 있다. 예를 들어, TextView에는 TextViewBindingAdapter가 정의되어 있어서 TextView의 속성들에 데이터 바인딩을 할 수 있다(TextViewBindingAdapter는 androidx.databinding.adapters 패키지에 있다). 궁금증 해소 💁🏻‍♂️ : LiveData와 데이터 바인딩 ↩ LiveData와 데이터 바인딩은 데이터가 변경되는지 관찰하면서 변경될 때 반응하는 방법을 제공한다는 면에서 서로 유사하다. 실제로 LiveData와 데이터 바인딩을 같이 사용할 수 있다. 다음 코드에서는 Observable 대신 LiveData를 사용해서 title 속성을 SoundViewModel에 바인딩했다. 12345678910111213141516//class SoundViewModel : BaseObservable() {class SoundViewModel { val title: MutableLiveData&lt;String?&gt; = MutableLiveData() var sound: Sound? = null set(sound) { field = sound// notifyChange() title.postValue(sound?.name) }// @get:Bindable// val title: String?// get() = sound?.name} 이때는 SoundViewModel이 BaseObservable의 서브 클래스가 되지 않아도 되며, @Bindable 애노테이션도 지정하지 않아도 된다. LiveData는 자신의 알림 매커니즘을 갖고 있기 때문이다. 그러나 데이터베이스와 Room 라이브러리에서 설명한듯이 LiveData는 LifeCycleOwner가 필요하므로 여기서는 title 속성을 관찰할 때 사용할 LifeCycleOwner를 데이터 바인딩 프레임워크에 알려주어야 한다. 따라서 바인딩 객체가 생성된 후 lifeCycleOwner 속성을 설정하기 위해 SoundAdapter를 변경해야 한다. 12345678910111213141516private inner class SoundAdapter(private val sounds: List&lt;Sound&gt;) : RecyclerView.Adapter&lt;SoundHolder&gt;() { ... override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): SoundHolder { val binding = DataBindingUtil.inflate&lt;ListItemSoundBinding&gt;( layoutInflater, R.layout.list_item_sound, parent, false ) binding.lifecycleOwner = this@MainActivity // lifeCycleOwner 속성 설정 return SoundHolder(binding) }} 여기서는 MainActivity를 LifeCycleOwner로 설정한다. 따라서 속성 이름인 title만 바뀌지 않는다면 뷰를 변경할 필요가 없다.","link":"/2021/06/01/android-bnr-19/"},{"title":"[Kotlin] Coroutine - Cancellation and Timeouts","text":"① Cancelling coroutine execution ↩ 12345678910111213fun main() = runBlocking { val job = launch { repeat(1000) { i -&gt; println(&quot;job: I'm sleeping $i ...&quot;) delay(500L) } } delay(1300L) // delay a bit println(&quot;main: I'm tired of waiting!&quot;) job.cancel() // cancels the job job.join() // waits for job's completion println(&quot;main: Now I can quit.&quot;)} 12345job: I'm sleeping 0 ... [main]job: I'm sleeping 1 ... [main]job: I'm sleeping 2 ... [main]main: I'm tired of waiting! [main]main: Now I can quit. [main] 코루틴을 실행할 떄 launch를 해서 반환된 Job 객체에서 cancel()을 호출할 수 있고, 이를 통해 코루틴 실행을 취소시킬 수 있다. ② Cancellation is cooperative 123456789101112131415161718fun main() = runBlocking { val startTime = System.currentTimeMillis() val job = launch(Dispatchers.Default) { var nextPrintTime = startTime var i = 0 while (i &lt; 5) { // computation loop, just wastes CPU // print a message twice a second if (System.currentTimeMillis() &gt;= nextPrintTime) { println(&quot;job: I'm sleeping ${i++} ...&quot;) nextPrintTime += 500L } } } delay(1300L) // delay a bit println(&quot;main: I'm tired of waiting!&quot;) job.cancelAndJoin() // cancels the job and waits for its completion println(&quot;main: Now I can quit.&quot;) } 1234567job: I'm sleeping 0 ... [DefaultDispatcher-worker-1]job: I'm sleeping 1 ... [DefaultDispatcher-worker-1]job: I'm sleeping 2 ... [DefaultDispatcher-worker-1]main: I'm tired of waiting! [main]job: I'm sleeping 3 ... [DefaultDispatcher-worker-1]job: I'm sleeping 4 ... [DefaultDispatcher-worker-1]main: Now I can quit. [main] 코드의 의도는 코루틴이 3번정도 실행되고 취소되는 것을 기대했을 것이다. 하지만 main: I'm tired of waiting!이 호출된 뒤 코루틴의 실행은 취소되지 않고 5번의 횟수를 채운 뒤 종료된다. 왜 이런 것일까? 이는 코루틴 자체가 취소되는데 협조적 cooperative이지 않았기 때문이다. 코루틴 내부에 suspend function이 존재하지 않는 것과 달리, 첫 번째 예제에서는 코루틴 내부에 delay()라는 suspend function이 존재하므로 취소가 가능했다. 다시 말해, 첫 번째 예제에서는 suspend function이 있었는데 두 번째 예제에서는 단순 연산만 있고 suspend function의 호출이 코루틴 내부에 없기 때문에 취소가 불가능하다는 것이다. 그럼 첫 번째 예제와 같이 두 번째 예제에도 suspend function을 호출하여 취소에 협조적인 코루틴을 만들어보자. 과연 원하는 실행 결과가 나올까? 123456789101112131415161718fun main() = runBlocking { val startTime = System.currentTimeMillis() val job = launch(Dispatchers.Default) { var nextPrintTime = startTime var i = 0 while (i &lt; 5) { if (System.currentTimeMillis() &gt;= nextPrintTime) { delay(1L) // suspend function을 추가 println(&quot;job: I'm sleeping ${i++} ...&quot;) nextPrintTime += 500L } } } delay(1300L) println(&quot;main: I'm tired of waiting!&quot;) job.cancelAndJoin() println(&quot;main: Now I can quit.&quot;)} 12345job: I'm sleeping 0 ... [DefaultDispatcher-worker-1]job: I'm sleeping 1 ... [DefaultDispatcher-worker-1]job: I'm sleeping 2 ... [DefaultDispatcher-worker-1]main: I'm tired of waiting! [main]main: Now I can quit. [main] 실행을 해보면 의도했던대로 0, 1, 2 까지만 출력이되고 종료가 된 것을 확인할 수 있다. suspend function으로써 이런 상황에 delay()가 아닌 더 적합한 함수가 있다. 바로 yield() 이다. yield()를 이용하면 delay(1L)을 이용하지 않고도 취소를 확인할 수 있다. 결과는 위와 동일하다. 123456789101112131415161718fun main() = runBlocking { val startTime = System.currentTimeMillis() val job = launch(Dispatchers.Default) { var nextPrintTime = startTime var i = 0 while (i &lt; 5) { if (System.currentTimeMillis() &gt;= nextPrintTime) { yield() // delay 대신 yield 사용 println(&quot;job: I'm sleeping ${i++} ...&quot;) nextPrintTime += 500L } } } delay(1300L) println(&quot;main: I'm tired of waiting!&quot;) job.cancelAndJoin() println(&quot;main: Now I can quit.&quot;)} 어떻게 해서 cancel이 일어나게 되었을까? 코루틴 가이드에 따르면 Job.cancel을 하게 되면 코루틴 내부에서 suspend가 되었다가 다시 재개(resume)되는 시점에 suspend function(여기서는 yield())이 CancellationException을 던진다고 설명되어 있다. Exception을 체크하기 위해 코루틴 내부에서 try-catch 문을 사용해보자. 1234567891011121314151617181920212223fun main() = runBlocking { val startTime = System.currentTimeMillis() val job = launch(Dispatchers.Default) { try { var nextPrintTime = startTime var i = 0 while (i &lt; 5) { // computation loop, just wastes CPU // print a message twice a second if (System.currentTimeMillis() &gt;= nextPrintTime) { yield() kotlin.io.println(&quot;job: I'm sleeping ${i++} ...&quot;) nextPrintTime += 500L } } } catch (e: Exception) { kotlin.io.println(&quot;Exception [$e]&quot;) } } delay(1300L) // delay a bit kotlin.io.println(&quot;main: I'm tired of waiting!&quot;) job.cancelAndJoin() // cancels the job and waits for its completion kotlin.io.println(&quot;main: Now I can quit.&quot;)} 123456job: I'm sleeping 0 ...job: I'm sleeping 1 ...job: I'm sleeping 2 ...main: I'm tired of waiting!Exception [kotlinx.coroutines.JobCancellationException: StandaloneCoroutine was cancelled; job=StandaloneCoroutine{Cancelling}@54c334f5]main: Now I can quit. 결과를 확인해보면 3번 출력한 뒤 Exception이 출력되었고 그 내용이 kotlinx.coroutines.JobCancellationException이라는 것을 확인할 수 있다. 즉 Job.cancel이 동작하는 방법은 코루틴 내부에서 강제로 Exception을 발생시켜 코루틴이 종료되게 하는 것이다. Coroutine cancellation is cooperative. A coroutine code has to cooperate to be cancellable. 코루틴 문서의 협조적이어야 한다는 말은 코루틴 스스로가 cancel을 체크(CancellationException을 체크)해야한다는 뜻이며 suspend function을 하나라도 실행하지 않으면 코루틴은 종료되지 않는다는 것이다(자신의 로직이 완료되어 리턴이 되지 않는 한에서). ③ Making computation code cancellable 코루틴이 취소되기 위해서 협조적인 방식을 취하는데 크게 2가지 방법이 있다. 주기적으로 suspend function을 호출하기 (suspend 되었다가 다시 재개될 때 cancel 되었는지를 확인해서 Exception을 던져주는 방식) 명시적으로 취소 상태를 확인하기 (isActive라는 상태를 확인하여 false일 때 해당 코루틴을 종료시키는 방식) 2번 예제에서 첫 번째 방법을 알아보았고, 이번 3번 예제에서 두 번째 방법을 알아본다. 123456789101112131415161718fun main() = runBlocking { val startTime = System.currentTimeMillis() val job = launch(Dispatchers.Default) { var nextPrintTime = startTime var i = 0 while (isActive) { // cancellable computation loop // print a message twice a second if (System.currentTimeMillis() &gt;= nextPrintTime) { println(&quot;job: I'm sleeping ${i++} ...&quot;) nextPrintTime += 500L } } } delay(1300L) // delay a bit println(&quot;main: I'm tired of waiting!&quot;) job.cancelAndJoin() // cancels the job and waits for its completion println(&quot;main: Now I can quit.&quot;)} 12345job: I'm sleeping 0 ... [DefaultDispatcher-worker-1]job: I'm sleeping 1 ... [DefaultDispatcher-worker-1]job: I'm sleeping 2 ... [DefaultDispatcher-worker-1]main: I'm tired of waiting! [main]main: Now I can quit. [main] while문을 통해 isActive의 상태를 확인하는 것으로 코루틴이 취소된 것을 확인할 수 있다. isActive가 실제로 잘 동작하였는지 로그를 통해 확인해보자. 12345678910111213141516171819fun main() = runBlocking { val startTime = System.currentTimeMillis() val job = launch(Dispatchers.Default) { var nextPrintTime = startTime var i = 0 kotlin.io.println(&quot;isActive $isActive ...&quot;) // while문에 들어가기 전의 isActive 확인 while (isActive) { if (System.currentTimeMillis() &gt;= nextPrintTime) { println(&quot;job: I'm sleeping ${i++} ...&quot;) nextPrintTime += 500L } } kotlin.io.println(&quot;isActive $isActive ...&quot;) // while문에서 나온 뒤의 isActive 확인 } delay(1300L) println(&quot;main: I'm tired of waiting!&quot;) job.cancelAndJoin() println(&quot;main: Now I can quit.&quot;)} 1234567isActive true ...job: I'm sleeping 0 ... [DefaultDispatcher-worker-1]job: I'm sleeping 1 ... [DefaultDispatcher-worker-1]job: I'm sleeping 2 ... [DefaultDispatcher-worker-1]main: I'm tired of waiting! [main]isActive false ...main: Now I can quit. [main] 출력 결과에서 while문에 들어가기 전과 후에 isActive의 상태값이 변경되는 것을 확인할 수 있다. 이러한 상태값을 통해 코루틴 스스로가 종료할 수 있다. 상태값을 통해 코루틴을 종료시키는 방식은 Exception이 발생하지 않으므로 코루틴 내부를 2번 예제와 같이 코루틴 내부를 try-catch문으로 감싸 예외를 확인해보면 Exception이 발생하지 않는 것을 확인할 수 있다. isActive는 확장 프로퍼티로 내부 구현은 코루틴의 Job이 실제로 종료되었는지를 체크하는 것이다. 123@Suppress(&quot;EXTENSION_SHADOWED_BY_MEMBER&quot;)public val CoroutineScope.isActive: Boolean get() = coroutineContext[Job]?.isActive ?: true ④ Closing resources with finally (코루틴을 종료할 때 리소스를 해제하는 방법) 코루틴에서 네트워크나 DB 등을 사용하다가 갑자기 코루틴이 cancel 되었을 때 코드 상에서 리소스를 해제해줘야 하는 위치를 알아보자. 아래의 코루틴은 delay()를 포함하여 취소하기에 협조적인 형태로 구현되어 있기에 job.cancel을 하면 취소가 될 것이다. 일시 중단이 되었다가 재개되면서 Exception을 던지면 finally 블록에서 리소스를 해제하면 된다. 즉, suspend function으로 취소를 체크할 때 리소스 해제 지역은 finally 블록이다. try {...} finally {...} 1234567891011121314151617fun main() = runBlocking { val job = launch { try { repeat(1000) { i -&gt; println(&quot;job: I'm sleeping $i ...&quot;) delay(500L) } } finally { // 리소스 해제 위치 println(&quot;job: I'm running finally&quot;) } } delay(1300L) // delay a bit println(&quot;main: I'm tired of waiting!&quot;) job.cancelAndJoin() // cancels the job and waits for its completion println(&quot;main: Now I can quit.&quot;) } 123456job: I'm sleeping 0 ... [main]job: I'm sleeping 1 ... [main]job: I'm sleeping 2 ... [main]main: I'm tired of waiting! [main]job: I'm running finally [main]main: Now I can quit. [main] ⑤ Run non-cancellable block 5번 예제는 rare한 케이스이다. 이미 cancel된 코루틴 내부에서 suspend function을 호출해야하는 경우, 즉 finally 블록 안에서 다시 코루틴을 실행하려면 어떻게 해야할까? 이런 경우에는 withContext 함수에 NonCancellable이라는 CoroutineContext를 넘겨서 withContext(NonCancellable) { ... }에서 해당 코드를 래핑할 수 있다. 1234567891011121314151617181920fun main() = runBlocking { val job = launch { try { repeat(1000) { i -&gt; println(&quot;job: I'm sleeping $i ...&quot;) delay(500L) } } finally { withContext(NonCancellable) { println(&quot;job: I'm running finally&quot;) delay(1000L) println(&quot;job: And I've just delayed for 1 sec because I'm non-cancellable&quot;) } } } delay(1300L) // delay a bit println(&quot;main: I'm tired of waiting!&quot;) job.cancelAndJoin() // cancels the job and waits for its completion println(&quot;main: Now I can quit.&quot;)} 1234567job: I'm sleeping 0 ... [main]job: I'm sleeping 1 ... [main]job: I'm sleeping 2 ... [main]main: I'm tired of waiting! [main]job: I'm running finally [main]job: And I've just delayed for 1 sec because I'm non-cancellable [main]main: Now I can quit. [main] ⑥ Timeout 이전 예제들에서는 코루틴 스스로가 내부에서 cancel을 체크하는 2가지 방법을 알아보았다. 그런데 그외에도 다른 방법이 있는데 바로 Timeout이다. Timeout은 launch된 코루틴의 Job을 가지고 cancel하는 것이 아니라, 코루틴을 실행할 때 일정 시간이 지나면 취소되도록 미리 Timeout을 지정하는 방식이다. 12345678fun main() = runBlocking { withTimeout(1300L) { repeat(1000) { i -&gt; println(&quot;I'm sleeping $i ...&quot;) delay(500L) } }} 12345678910I'm sleeping 0 ... [main]I'm sleeping 1 ... [main]I'm sleeping 2 ... [main]Exception in thread &quot;main&quot; kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms at kotlinx.coroutines.TimeoutKt.TimeoutCancellationException(Timeout.kt:186) at kotlinx.coroutines.TimeoutCoroutine.run(Timeout.kt:156) at kotlinx.coroutines.EventLoopImplBase$DelayedRunnableTask.run(EventLoop.common.kt:497) at kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:274) at kotlinx.coroutines.DefaultExecutor.run(DefaultExecutor.kt:69) at java.base/java.lang.Thread.run(Thread.java:834) lauch를 통해 실행시킨 것이 아닌, runBlocking 내부 main에서 실행했기 때문에 CancellationException 발생하여 종료되는 것이다. 이런 경우를 해결하기 위해 withTimeoutOrNull(Long)을 사용한다. withTimeout(Long)이 아닌 withTimeoutOrNull(Long)을 사용하면 Exception이 발생했을 때 결과값이 null이 된다. 12345678910fun main() = runBlocking { val result = withTimeoutOrNull(1300L) { repeat(1000) { i -&gt; println(&quot;I'm sleeping $i ...&quot;) delay(500L) } &quot;Done&quot; // will get cancelled before it produces this result } println(&quot;Result is $result&quot;)} 12345I'm sleeping 0 ... [main]I'm sleeping 1 ... [main]I'm sleeping 2 ... [main]Result is null [main]","link":"/2021/06/03/coroutines-cancellation-timeouts/"},{"title":"[Kotlin] Coroutine - Basics","text":"코루틴 개요 코루틴은 루틴의 일종 협동 루틴이라 할 수 있으며, Coroutine의 Co는 with 또는 together를 뜻한다. 루틴과 코루틴의 차이 코루틴은 이전에 자신의 실행이 마지막으로 중단되었던 지점 다음의 장소에서 실행을 재개한다. (함수의 진입점과 출구점이 여러 개 존재한다) 코루틴의 역사 코루틴은 멜빈 콘웨이에 의해 1958년 처음 만들어진 용어이며, 이를 어셈블리 프로그램에 적용했다. 코루틴은 협력 작업 cooperative tasks, 예외 exceptions, 이벤트 루프 event loops, 반복자 iterators, 무한 리스트 infinite lists 및 파이프 pipes와 같은 친숙한 프로그램 구성 요소를 구현하는 데 적합하다고 소개되어있는데 1 구글 문서에서는 코루틴의 사용 범위를 좀 더 명확하게 제시하고 있다. Android Developers 코틀린 가이드에서의 코루틴 정의 2 코루틴은 비동기적으로 실행되는 코드를 간소화하기 위해 Android에서 사용할 수 있는 동시 실행 설계 패턴(concurrency design pattern)이다. 비동기 처리는 callback, cancel, 리소스 관리 등을 해줘야하므로 어려움이 있는데 코루틴을 이용하면 쉽게 처리할 수 있다. Android에서 코루틴은 메인 스레드를 blocking하여 앱이 응답하지 않게 만들 수도 있는 장기 실행 작업을 관리하는 데 도움이 됩니다. Google Codelabs의 코루틴 정의 3 코루틴은 비동기 콜백 처리를 순차적인 코드로 작성할 수 있게 해주는 코틀린 기능이다. (Coroutines are a Kotlin feature that converts async callbacks for long-running tasks, such as database or network access, into sequential code.) suspend 함수를 사용하여 비동기 코드를 순차적으로 만들어준다. (Use suspend functions to make async code sequential) 코루틴 기초 먼저 코루틴을 사용하기 위해 kotlinx.coroutines.*를 import해야하므로 공식 프로젝트 README를 참고하여 최신 버전을 의존성에 추가한다. ① Thread 123456789fun main() { thread { Thread.sleep(1000L) println(&quot;World!&quot;) } println(&quot;Hello, &quot;) Thread.sleep(2000L) // // block main thread for 2 seconds to keep JVM alive} main()이 println(&quot;World!&quot;)가 실행되기도 전에 종료되는 것을 막기 위해 맨 밑줄에 Thread.sleep(2000L)이 추가되어 있다. ② Your first Coroutine 123456789fun main() { GlobalScope.launch { // launch a new coroutine in background and continue delay(1000L) // non-blocking delay for 1 second println(&quot;World!&quot;) // print after delay } println(&quot;Hello, &quot;) // main thread continues while coroutine is delayed Thread.sleep(2000L) // block main thread for 2 seconds to keep JVM alive} launch는 독립적으로 실행이 불가능하며 CoroutineScope 내에서만 선언된다. ③ Bridging blocking and non-blocking worlds Thread.sleep()과 delay()가 혼용되는 것을 막기 위해 delay()로 통일해보자. 하지만 CoroutineScope 외부에 delay()를 추가하려는데 에러가 발생한다. Thread.sleep(2000L)은 메인 스레드를 blocking하는 형태였으므로, delay()로 변경하기 위해서는 명시적으로 Blocking하는 코루틴을 만들어줘야 한다. 그 역할을 하는 코루틴 빌더가 runBlocking이다. 1234567891011fun main() { GlobalScope.launch { // launch a new coroutine in background and continue delay(1000L) println(&quot;World!&quot;) } println(&quot;Hello, &quot;) // main thread continues here immediately runBlocking { // but this expression blocks the main thread delay(2000L) // ... while we delay for 2 seconds to keep JVM alive }} lauch는 자신을 호출하는 스레드를 Blocking 하지 않는다. runBlocking은 자신을 호출하는 스레드를 Blocking 한다. ④ rewritten in a more idiomatic way(관용적인 형태로 만들기) 이때까지 작성한 코드들은 main 함수 안의 내용이 완료되기 전까지는 return되지 않기를 원하는 것이기 때문에 runBlocking을 마지막에만 사용하는 것이 아니라 코드 전체를 runBlocking으로 감싸는 형태로 작성한다. 1234567891011fun main() { runBlocking { GlobalScope.launch { delay(1000L) println(&quot;World!&quot;) } println(&quot;Hello, &quot;) delay(2000L) }} 메인 함수를 runBlocking으로 감쌌기 때문에 전체 코드가 실행되기 전까지는 메인 스레드가 runBlocking 때문에 return이 되지 않는다. 그리고 위의 코드는 아래와 같이 한 번 더 변경될 수 있다. 123456789fun main() = runBlocking { // // start main coroutine GlobalScope.launch { // launch a new coroutine in background and continue delay(1000L) println(&quot;World!&quot;) } println(&quot;Hello, &quot;) // main coroutine continues here immediately delay(2000L) // delaying for 2 seconds to keep JVM alive} ⑤ Waiting for a job 프로그램이 종료되는 것을 막기 위해 delay를 사용하는 것은 좋은 접근법이 아니다. 명시적으로 job을 생성하여 기다리게 해보자. lauch를 하게 되면 Job이 반환되는데, Job 객체에다가 join()을 하게 되면 해당 Job이 완료될 때까지 기다리게 된다. 123456789fun main() = runBlocking { val job = GlobalScope.launch { delay(1000L) println(&quot;World!&quot;) } println(&quot;Hello, &quot;) job.join()} ⑥ Structured concurrency 이전 예제들에선 코루틴이 완료되는 것을 기다리기 위해 2초동안 sleep()을 실행하거나 Job 객체를 만들어서 join()을 사용하였다. 하지만 앞으로 여러 개의 코루틴을 실행하게 될텐데 이런 형태라면 아래와 같이 Job을 따로 관리해주는 등, 유지 보수하기 어려운 코드가 된다. 12345678910111213141516fun main() = runBlocking { val job1 = GlobalScope.launch { delay(1000L) println(&quot;World!&quot;) } val job2 = GlobalScope.launch { delay(2000L) println(&quot;Let's Go!&quot;) } println(&quot;Hello, &quot;) job1.join() job2.join()} 코틀린에서는 이를 방지하기 위해서 Structured concurrency를 사용하라고 권장한다. runBlocking과 launch에서 실행된 코루틴이 구조적인 관계를 만든다면 서로 기다려주는 일을 할 수 있기 때문이다. GlobalScope.launch를 사용하게 되면, top-level 코루틴을 생성하게 된다. 이렇게 되면 많은 메모리를 소모하게 된다. 그러므로 GlobalScope에서 launch를 하는 것이 아닌 runBlocking을 통해 들어온 CoroutineScope에서 lauch를 한다. 1234567fun main() = runBlocking { // this: CoroutineScope launch { // // launch a new coroutine in the scope of runBlocking (this. 생략 가능) delay(1000L) println(&quot;World!&quot;) } println(&quot;Hello, &quot;)} 즉, Structured concurrency는 top-level 코루틴을 만들지 말고 runBlocking의 자식으로 코루틴을 만들면 부모 코루틴이 자식 코루틴이 완료되는 것까지 다 기다려주기 때문에 구조적인 형태를 이용해서 코루틴을 관리하라는 개념이다. 참고로 GlobalScope는 잘못 사용하기 쉬운 advanced API이므로 Kotlin Coroutines 1.5.0부터 delicate API로 표시되어 컴파일러가 경고를 보낸다. ⑦ Extract function refactoring lauch 내부의 코드를 하나의 함수로 추출해보자. 그러면 아래와 같은 오류가 발생한다. 1234567891011fun main() = runBlocking { launch { doWorld() } println(&quot;Hello&quot;)}fun doWorld() { delay(1000L) println(&quot;World!&quot;)} Suspend function ‘delay’ should be called only from a coroutine or another suspend function. 즉, 일시 중단되는 함수인 delay()는 오직 코루틴이나 다른 suspend function으로부터만 호출될 수 있다는 뜻이다. 이를 해결하기 위해선 suspend 키워드를 함수 앞에 붙여주면 된다. 1234567891011fun main() = runBlocking { launch { doWorld() } println(&quot;Hello&quot;)}suspend fun doWorld() { delay(1000L) println(&quot;World!&quot;)} ⑧ Coroutines ARE light-weight 10만 개의 코루틴을 한 번에 생성하여 1초 뒤에 한 번의 점을 찍게 하는 코드를 실행해본다. 직접 실행해보면 아무런 오류나 성능적 이슈없이 점들이 출력된다. 12345678fun main() = runBlocking { repeat(100_000) { // launch a lot of coroutines launch { delay(5000L) print(&quot;.&quot;) } }} 그렇다면 이번에 코루틴이 아닌 스레드로 바꿔서 똑같은 작업을 해보자. OutOfMemoryError가 발생하는 것을 확인할 수 있다. 12345678fun main() = runBlocking { repeat(100_000) { // launch a lot of coroutines thread { Thread.sleep(5000L) print(&quot;.&quot;) } }} 이 두 코드를 통해 코루틴이 스레드보다 구조적으로 상당히 가볍다는 것을 확인할 수 있다. 많은 스레드를 만들면 부하가 일어날 수 있지만, 코루틴은 많은 양을 생성하여도 크게 부하가 가지 않는 것이다. ⑨ Global coroutines are like daemon threads 12345678910fun main() = runBlocking { GlobalScope.launch { repeat(1000) { i -&gt; println(&quot;I'm sleeping $i ...&quot;) delay(500L) } } delay(1300L)} 12345I'm sleeping 0 ...I'm sleeping 1 ...I'm sleeping 2 ...Process finished with exit code 0 코루틴이 계속 실행되고 있다고해서 프로세스가 유지되지는 않는다라는 것을 보여주는 코드이다. 코루틴은 데몬 스레드처럼 프로세스가 살아있을 동안에만 동작할 수 있다라는 것이다. 즉, 프로세스가 종료되면 코루틴도 끝난다라는 것이다. ⑩ suspend &lt;-&gt; resume 123456789101112131415fun main() = runBlocking { launch { repeat(5) { i -&gt; println(&quot;Coroutine A, $i&quot;) } } launch { repeat(5) { i -&gt; println(&quot;Coroutine B, $i&quot;) } } println(&quot;Coroutine Outer&quot;)} 1234567891011Coroutine OuterCoroutine A, 0Coroutine A, 1Coroutine A, 2Coroutine A, 3Coroutine A, 4Coroutine B, 0Coroutine B, 1Coroutine B, 2Coroutine B, 3Coroutine B, 4 println을 override 하여 어떤 스레드에서 실행되었는지 확인한다. 1234567fun main() = runBlocking { ...}fun &lt;T&gt; println(msg: T) { kotlin.io.println(&quot;$msg [${Thread.currentThread().name}]&quot;)} 1234567891011Coroutine Outer [main]Coroutine A, 0 [main]Coroutine A, 1 [main]Coroutine A, 2 [main]Coroutine A, 3 [main]Coroutine A, 4 [main]Coroutine B, 0 [main]Coroutine B, 1 [main]Coroutine B, 2 [main]Coroutine B, 3 [main]Coroutine B, 4 [main] Help - Edit Custom VM Options...에서 -Dkotlinx.coroutines.debug를 복사한 뒤, 실행 버튼 왼쪽의 탭을 클릭하여 Edit Configurations... 옵션에 들어가 VM options 칸에 복사한 -Dkotlinx.coroutines.debug를 붙여 넣어주면 어느 코루틴에서 실행되었는지까지 확인할 수 있다. 1234567891011Coroutine Outer [main @coroutine#1]Coroutine A, 0 [main @coroutine#2]Coroutine A, 1 [main @coroutine#2]Coroutine A, 2 [main @coroutine#2]Coroutine A, 3 [main @coroutine#2]Coroutine A, 4 [main @coroutine#2]Coroutine B, 0 [main @coroutine#3]Coroutine B, 1 [main @coroutine#3]Coroutine B, 2 [main @coroutine#3]Coroutine B, 3 [main @coroutine#3]Coroutine B, 4 [main @coroutine#3] 첫 번째 코루틴(coroutine#1)은 runBlocking에 의해서 만들어졌고, 나머지 두 번째와 세 번째 코루틴은 launch에 의해 순서대로 만들어졌다. 이제 Coroutine A에 10ms의 delay를 줘보자. 1234567891011121314151617fun main() = runBlocking { launch { repeat(5) { i -&gt; println(&quot;Coroutine A, $i&quot;) delay(10L) // 10ms의 delay } } launch { repeat(5) { i -&gt; println(&quot;Coroutine B, $i&quot;) } } println(&quot;Coroutine Outer&quot;)}... 1234567891011Coroutine Outer [main @coroutine#1]Coroutine A, 0 [main @coroutine#2]Coroutine B, 0 [main @coroutine#3]Coroutine B, 1 [main @coroutine#3]Coroutine B, 2 [main @coroutine#3]Coroutine B, 3 [main @coroutine#3]Coroutine B, 4 [main @coroutine#3]Coroutine A, 1 [main @coroutine#2]Coroutine A, 2 [main @coroutine#2]Coroutine A, 3 [main @coroutine#2]Coroutine A, 4 [main @coroutine#2] A가 모두 출력되고 B가 출력되었던 이전의 코드와 달리 A가 한 번만 출력되고 B가 모두 출력된 다음에야 나머지 A가 출력된다. A가 한 번 출력되고 delay()가 실행되었을 때, A는 중단되고 B로 실행이 넘어간 것이다. B 내부에는 중단점이 없기 때문에 모두 다 호출이 되고나서야 A가 다시 실행된다. 그렇다면 A와 B가 사이좋게 오고가며 실행될 수 있도록 하려면 어떻게 해야할까? B에도 중단점을 추가, 즉 delay를 추가해주면 된다. 123456789101112131415161718fun main() = runBlocking { launch { repeat(5) { i -&gt; println(&quot;Coroutine A, $i&quot;) delay(10L) } } launch { repeat(5) { i -&gt; println(&quot;Coroutine B, $i&quot;) delay(10L) } } println(&quot;Coroutine Outer&quot;)}... 1234567891011Coroutine Outer [main @coroutine#1]Coroutine A, 0 [main @coroutine#2]Coroutine B, 0 [main @coroutine#3]Coroutine B, 1 [main @coroutine#3]Coroutine B, 2 [main @coroutine#3]Coroutine B, 3 [main @coroutine#3]Coroutine B, 4 [main @coroutine#3]Coroutine A, 1 [main @coroutine#2]Coroutine A, 2 [main @coroutine#2]Coroutine A, 3 [main @coroutine#2]Coroutine A, 4 [main @coroutine#2] Coroutine A가 먼저 출력될 것 같은데 Coroutine Outer가 먼저 출력되는 것을 통해 launch { }가 코루틴이 실행되기 위한 스케줄링을 해놓는다는 것을 추측할 수 있다. 정리 코루틴은 일시 중단이 가능한 계산의 인스턴스다(an instance of suspendable computation). 다른 코드와 동시에 작동하는 코드 블록을 실행해야 한다는 점에서 스레드와 개념적으로 유사하다. 하지만 코루틴은 특정 스레드에 바인딩되지 않는다. 한 스레드에서 실행을 일시 중지하고 다른 스레드에서 다시 시작할 수 있다. 코루틴은 경량 스레드라고 생각되어질 수 있지만, 실제 사용하는데 있어 스레드와 매우 다르게 만드는 몇 가지 중요한 차이점이 있다. 123456789import kotlinx.coroutines.*fun main() = runBlocking { // this: CoroutineScope launch { // launch a new coroutine and continue delay(1000L) // non-blocking delay for 1 second (default time unit is ms) println(&quot;World!&quot;) // print after delay } println(&quot;Hello&quot;) // main coroutine continues while a previous one is delayed} 12HelloWorld! launch {} : Main Thread 를 Unblocking 한 채 {} 구문 내 작업을 수행 launch는 코루틴 빌더 coroutine builder 이다. 코루틴 빌더는 새로운 코루틴을 독립적으로 작동하는 나머지 코드들과 동시에 실행시킨다. 이것이 Hello가 가장 먼저 출력되는 이유이다. delay() delay는 특별한 suspending function으로, 코루틴을 특정 시간동안 일시 중단시킨다. 코루틴을 일시 중단시켜도 메인 스레드가 Blocking 되지는 않지만, 다른 코루틴이 코드에 메인 스레드를 실행하고 사용할 수 있습니다. runBlocking {} : Main Thread 를 Blocking 한 채 {} 구문 내 작업을 새 Thread 에 할당하여 수행 runBlocking 또한 코루틴 빌더로써, 코루틴이 아닌 일반적인 fun main() 영역과 runBlocking {} 괄호 안의 코루틴이 있는 코드들을 연결한다. launch는 독립적으로 실행이 불가능하며 CoroutineScope 내에서만 선언되기 때문에, 만약 코드에서 runBlocking을 제거하거나 잊어버린다면 launch를 호출할 때 에러가 발생한다. runBlocking의 이름은 runBlocking {} 내부의 모든 코루틴이 실행을 완료할 때까지 이를 실행하는 스레드(여기선 메인 스레드)가 호출되는 동안 Blocking 된다는 것을 의미한다. 스레드는 값 비싼 리소스이고 스레드를 Blocking하는 것은 비효율적이면서 프로그래머가 종종 원하지 않기 때문에 애플리케이션의 최상위 수준에서 실제 코드 내에서는 거의 사용되지 않는 runBlocking을 자주 볼 수 있을 것이다. 구조화된 동시성 Structured concurrency 코루틴은 구조화된 동시성의 원칙을 따른다. 즉 새로운 코루틴은 코루틴의 수명을 제한하는 특정 CoroutineScope에서만 실행될 수 있다. 위의 예제 코드는 runBlocking이 해당 범위를 설정하며 이것이 *World!*가 1초 지연된 다음 출력되고 종료되는 이유이다. 실제 어플리케이션에서는 많은 코루틴을 실행하게 될 것이다. 구조화된 동시성은 손실이나 누수가 없는 것을 보장한다. 외부 범위는 모든 하위 코루틴이 완료될 때까지는 완료할 수 없다. 구조화된 동시성은 또한 코드 내부의 오류가 제대로 보고되고 손실되지 않는 것을 보장해준다. 함수를 추출하여 리팩토링하기 launch {...} 내부의 코드 블록을 별도의 함수로 추출해보자. 이 코드에 IDE의 Extract Function 기능을 수행하면 아래와 같이 suspend 변경자 modifier가 있는 새 함수가 생성이 된다. 일시 중단 함수 suspending function는 일반 함수와 마찬가지로 코루틴 내부에서 사용할 수 있지만 추가 기능은 다른 일시 중단 함수(delay()와 같은)를 사용하여 코루틴의 실행을 중단시킬 수 있다는 것이다. 12345678910fun main() = runBlocking { // this: CoroutineScope launch { doWorld() } println(&quot;Hello&quot;)}// this is your first suspending functionsuspend fun doWorld() { delay(1000L) println(&quot;World!&quot;)} 추출한 함수의 suspend 변경자를 제거하면? 추출한 함수의 suspend 변경자를 제거하면 Suspend function ‘delay’ should be called only from a coroutine or another suspend function라는 경고문이 뜬다. 즉, 일시 중단되는 함수인 delay()는 오직 코루틴이나 다른 일시 중단 함수로부터만 호출될 수 있다는 뜻이다. References Kotlin Docs, Coroutines basics : https://kotlinlang.org/docs/coroutines-basics.html 새차원, 코틀린 코루틴 : https://youtu.be/14AGUuh8Bp8 1 https://en.wikipedia.org/wiki/Coroutine ↩ 2 https://developer.android.com/kotlin/coroutines?hl=ko ↩ 3 https://developer.android.com/codelabs/kotlin-coroutines#0 ↩","link":"/2021/06/03/coroutines-basics/"},{"title":"[Android] 단위 테스트와 오디오 재생","text":"MVVM 아키텍처가 매력적인 이유 중 하나는 단위 테스트(unit testing)가 쉽기 때문이다. 단위 테스트는 앱의 각 단위가 제대로 작동하는지 검사하는 작은 프로그램들을 작성하는 것이다. 본문에서는 단위 테스트 및 안드로이드 오디오 API를 쉽게 사용하도록 해주는 도구인 SoundPool 클래스를 사용한다. SoundPool 클래스는 많은 음원 파일을 메모리로 로드할 수 있으며, 재생하려는 음원의 최대 개수를 언제든 제어할 수 있다. 따라서 사용자가 앱의 모든 버튼을 동시에 마구잡이로 누르더라도 앱의 실행이나 장치에는 영향을 주지 않는다. SoundPool 생성하기 먼저 BeatBox 클래스 내부에 음원 재생 기능을 추가한다. 우선 SoundPool 객체를 생성하는 코드를 작성하자. SoundPool 생성하기 (BeatBox.kt) 12345678910111213141516private const val TAG = &quot;BeatBox&quot;private const val SOUNDS_FOLDER = &quot;sample_sounds&quot;private const val MAX_SOUNDS = 5class BeatBox(private val assets: AssetManager) { val sounds: List&lt;Sound&gt; private val soundPool = SoundPool.Builder() .setMaxStreams(MAX_SOUNDS) .build() init { sounds = loadSounds() } ...} SoundPool 인스턴스를 생성할 때는 SoundPool.Builder 클래스의 build() 함수를 사용한다. 따라서 여기서는 SoundPool.Builder 인스턴스를 생성한 후 build()를 호출한다. setMaxStreams(Int) 함수에서는 현재 시점에 재생할 음원의 최대 개수를 인자로 전달하여 지정할 수 있다. 코드에서는 5를 전달하는데, 따라서 다섯 개의 음원이 재생 중일 때 여섯 번째 음원을 재생하려고 하면 SoundPool이 가장 오래된 음원의 재생을 중단한다. 또한, setAudioAttributes(AudioAttributes)를 사용하면 오디오 스티름의 다른 속성들을 지정할 수 있다. 자세한 내용은 안드로이드 문서에서! 에셋 사용하기 현재 음원 파일들은 앱의 애셋으로 저장되어 잇는데, 이 파일들을 사용해서 오디오를 재생하기에 앞서 애셋의 작동 원리를 알아보자. Sound 객체는 애셋 파일 경로를 갖고 있다. 그런데 애셋 파일 경로의 파일을 열 때는 File 클래스를 사용할 수 없고 반드시 AssetManager를 사용해야 한다. 12345val assetPath = sound.assetPathval assetManager = context.assetsval soundData = assetManager.open(assetPath) 이렇게 하면 코틀린의 다른 InputStream을 사용할 때처럼 표준 InputStream이 반환된다. 경우에 따라서는 InputStream 대신 FileDescriptor가 필요할 수 있다. SoundPool을 사용할 때가 그렇다. 이때는 AssetManager.openFd(String)을 호출하면 된다. 123456789val assetPath = sound.assetPathval assetManager = context.assets// AssetFileDescriptor는 FileDescriptor와 다르다val assetFileDescriptor = assetManager.openFd(assetPath)// … 그러나 필요하다면 다음과 같이 쉽게 보통의 FileDescriptor를 얻을 수 있다val fileDescriptor = assetFileDescriptor.fileDescriptor 음원 로드하기 SoundPool에 음원을 로드하는 것이 다음으로 할 일이다. 오디오를 재생하는 다른 방법과 달리 SoundPool을 사용하면 응답이 빠르다. 따라서 음원 재생을 요청하면 즉시 재생이 시작된다. 단, 재생에 앞서 SoundPool로 음원을 로드해야 한다. 이때 로드할 각 음원은 자신의 정수 ID를 갖는다. 이 ID를 유지하기 위한 soundId 속성을 Sound 클래스에 추가한다. soundId 속성 추가하기 (Sound.kt) 123class Sound(val assetPath: String, var soundId: Int? = null) { val name = assetPath.split(&quot;/&quot;).last().removeSuffix(WAV)} 여기서는 soundId 속성을 null이 가능한 Int? 타입으로 지정하였다. soundId에 null 값을 지정하여 Sound의 ID 값이 없음을 알려줄 수 있기 때문이다. 다음으로는 음원을 로드한다. SoundPool에 Sound 인스턴스를 로드하기 위해 BeatBox 클래스에 load(Sound) 함수를 추가한다. SoundPool에 음원 로드하기 (BeatBox.kt) 123456789101112class BeatBox(private val assets: AssetManager) { ... private fun loadSounds(): List&lt;Sound&gt; { ... } private fun load(sound: Sound) { val afd: AssetFileDescriptor = assets.openFd(sound.assetPath) val soundId = soundPool.load(afd, 1) sound.soundId = soundId }} 여기서는 soundPool.load(AssetFileDescriptor, Int) 함수를 호출해 나중에 재생할 음원 파일을 SoundPool에 로드한다. 이 함수에서는 정수 ID를 반환하는데, 음원을 유지하고 다시 재생(또는 언로드)하기 위해서다. 그리고 이 값을 앞에서 정의했던 soundId 속성에 저장한다. openFd(String)에서는 IOException을 발생시킬 수 있으므로 load(Sound)도 IOException을 발생시킬 수 있다. 따라서 load(Sound)가 호출될 때는 항상 IOException을 처리해야 한다. 다음으로 load(Sound)를 호출해 모든 음원을 로드하는 코드를 BeatBox.loadSounds() 함수 내부에 추가한다. 모든 음원을 로드하기 (BeatBox.kt) 12345678910111213141516private fun loadSounds(): List&lt;Sound&gt; { ... val sounds = mutableListOf&lt;Sound&gt;() soundNames.forEach { fileName -&gt; val assetPath = &quot;$SOUNDS_FOLDER/$fileName&quot; val sound = Sound(assetPath) // sounds.add(sound) try { load(sound) sounds.add(sound) } catch (ioe: IOException) { Log.e(TAG, &quot;Could not load sound $fileName&quot;, ioe) } } return sounds} BeatBox 앱을 실행해 에러 없이 모든 음원이 로드되는지 확인해본다. 만일 정상적으로 로드되지 않으면 로그캣 창에 붉은색의 예외 메시지가 나타난다(아직 음원은 재생되지 않으며 화면에도 아무 변화가 없다). 음원 재생하기 BeatBox 앱에서 음원 재생이 되어야 하니 음원을 재생하는 play(Sound) 함수를 BeatBox 클래스에 추가한다. 음원 재생하기 (BeatBox.kt) 1234567891011121314class BeatBox(private val assets: AssetManager) { ... init { sounds = loadSounds() } fun play(sound: Sound) { sound.soundId?.let { soundPool.play(it, 1.0f, 1.0f, 1, 0, 1.0f) } } ...} play(Sound) 함수는 음원을 재생하기 전에 해당 음원의 soundId가 null이 아닌지 확인한다. 만일 음원 로드에 실패하면 null이 될 수 있다. 일단 null 값이 아니라고 확인되면 SoundPool.play(Int, Float, Float, Int, Int, Float)를 호출해 음원을 재생한다. 매개 변수들의 내역은 다음과 같다. 음원 ID, 왼쪽 볼륨(0.0 ~ 1.0), 오른쪽 볼륨, 스트림 우선순위(0이면 최저 우선순위), 반복 재생 여부(0이면 반복 안함, -1이면 무한 반복, 그 외의 숫자는 반복 횟수), 재생률(1이면 녹음된 속도 그대로, 2는 두 배 빠르게 재생, 0.5는 절반 느리게 재생)이다. 이제는 음원 재생을 SoundViewModel에 통합할 준비가 되었다. 그 전에 테스트에 실패하도록 단위 테스트를 작성한 후 문제점을 해결하자! 테스트 라이브러리 의존성 추가하기 테스트 코드를 작성하기 전에 테스팅 도구인 Mockito와 Hamcrest를 추가한다. Mockito는 간단한 모의 객체(mock object)를 쉽게 생성해주는 프레임워크다. 모의 객체는 테스트를 독립적으로 할 수 있게 도와주므로, 잘못해서 동시에 다른 객체를 테스트하지 않게 해준다. Hamcrest는 matcher 라이브러리다. Matcher는 코드에 ‘일치(match)’ 조건을 쉽게 만들어주고, 만일 코드가 우리 바람과 일치하지 않으면 실패로 처리하는 도구다. Hamcrest는 JUnit 라이브러리에 자동으로 포함되며, JUnit은 새로운 안드로이드 스튜디오 프로젝트를 생성할 때 의존성에 자동으로 포함된다. 따라서 테스트 빌드에 Mockito 의존성만 추가하면 된다. Mockito 의존성 추가하기 (app/build.gradle) 123456dependencies { ... testImplementation 'junit:junit:4.13.2' testImplementation 'org.mockito:mockito-core:3.3.3' testImplementation 'org.mockito:mockito-inline:3.3.3'} testImplementation은 이 라이브러리 의존성이 이 앱의 테스트 빌드에만 포함됨을 의미한다. 따라서 디버그나 릴리즈 빌드로 생성된 APK에는 포함되지 않는다. mockito-core는 모의 객체를 생성하고 구성하는 데 사용하는 모든 함수를 포함한다. mockito-inlin은 Mockito를 코틀린에서 쉽게 사용하도록 해주는 의존성이다. 기본적으로 모든 코틀린 클래스는 final이다. 즉, 클래스에 open 키워드를 지정하지 않으면 상속받는 서브 클래스를 만들 수 없으며, 함수에 open 키워드를 지정하지 않으면 서브 클래스에서 오버라이드할 수 없다. 그런데 Mockito에서 모의 객체의 클래스를 생성할 때는 클래스 상속을 해야 한다. 이때 mockito-inline 의존성을 지정하면 Mockito가 final 클래스와 함수들의 모의 객체를 생성한다. 따라서 코틀린 클래스 소스 코드를 변경하지 않고 모의 객체를 생성할 수 있다. 테스트 클래스 생성하기 단위 테스트를 작성하는 가장 편리한 방법은 테스트 프레임워크(testing framwork)를 사용하는 것이다. 테스트 프레임워크를 사용하면 안드로이드 스튜디오에서 테스트 코드를 더 쉽게 작성하고 실행할 수 있으며 결과 출력도 볼 수 있다. 안드로이드의 테스트 프레임워크로는 JUnit이 사용되며, 안드로이드 스튜디오와 잘 통합되어 있다. 가장 먼저 할 일은 JUnit 테스트 클래스를 생성하는 것이다. SoundViewModel.kt를 열어 SoundViewModel 클래스를 클릭한 후 안드로이드 스튜디오 메인 메뉴의 Navigate -&gt; Test를 선택한다. 그러면 안드로이드 스튜디오가 SoundViewModel 클래스와 관련된 테스트 클래스로 이동시켜준다. 그러나 여기처럼 테스트 클래스가 없으면 아래와 같이 팝업으로 새로운 테스트 클래스 생성 옵션을 제공한다. 테스트 클래스 생성 팝업 'Create New Test…'를 선택하면 대화상자(좌)가 나타난다. 아래와 같이 테스트 라이브러리를 JUnit4로 선택하고 SetUp/@Before를 체크한 후 다른 필드는 그대로 두고 OK 버튼을 누른다. 그러면 생성하는 테스트 클래스의 종류를 선택하는 대화상자(우) 나타난다. 새로운 테스트 클래스 생성하기(좌), 테스트 클래스의 종류 선택하기(우) 장치 테스트(instrumentation test) androidTest 폴더에 있는 테스트를 장치 테스트(instrumentation test)라고 한다. 장치 테스트는 안드로이드 장치나 에뮬레이터에서 실행된다. 앱이 배포된 후 APK가 실행될 시스템 프레임워크와 API를 대상으로 앱 전체를 테스트할 수 있다는 것이 장치 테스트의 장점이다. 그러나 장치 테스트는 해당 안드로이드 운영체제에서 실행되어서 설정과 실행에 시간이 더 걸린다는 단점이 있다. 단위 테스트(unit test) 이와는 달리 test 폴더에 있는 테스트는 단위 테스트(unit test)라고 한다. 단위 테스트는 안드로이드 런타임이 아닌 로컬 컴퓨터의 JVM(Java Virtual Machine)에서 실행되므로 빠르게 이루어진다. 안드로이드에서는 '단위 테스트’라는 용어가 폭넓게 사용된다. 즉, 하나의 클래스나 단위 기능을 별개로 검사함을 의미하며, 로컬 컴퓨터에서 실행되는 단위 테스트들은 test 폴더에 포함된다. 또한, 앱의 여러 클래스나 기능이 함께 작동하는 것을 테스트하는 통합 테스트(integreation test)를 의미하기도 한다. 통합 테스트는 궁금증 해소: 통합 테스트에서 자세히 알아보자. 본문의 나머지 부분에서는 test 폴더에 있으면서 JVM에서 실행되는 각 타입의 테스트를 JVM 테스트라 하고, 하나의 클래스나 단위 기능을 검사하는 테스트만 단위 테스트라고 칭한다. 단위 테스트는 하나의 컴포넌트(주로 클래스) 자체를 테스트하는 것이므로 작성할 수 있는 가장 작은 종류의 테스트다. 그리고 테스트를 실행하고자 전체 앱이나 장치를 사용할 필요가 없으며, 테스트를 여러 번 실행해도 충분할 만큼 빠르게 실행된다. 따라서 하나의 컴포넌트르 테스트할 때 장치 테스트로 실행하는 경우는 거의 없다. 이 점을 염두에 두고 위의 이미지의 우측 대화상자와 같이 androidTest 폴더가 아닌 test 폴더를 선택하고 OK 버튼을 누른다. 그러면 안드로이드 스튜디오가 SoundViewModelTest.kt를 생성하고 편집기 창에 열어준다. Project 뷰로 보면 app/src 패키지 밑에 test와 androidTest 패키지가 생성되어 있다 테스트 설정하기 자동 생성된 SoundViewModelTest 클래스는 setUp() 함수만 갖고 있다. 123456class SoundViewModelTest { @Before fun setUp() { }} 테스트 클래스에서 특정 클래스를 테스트하는 데 필요한 작업은 대부분 같다. 즉, 테스트할 클래스의 인스턴스와 이 인스턴스가 필요로 하는 다른 객체들도 생성한다. 이에 따라 JUnit에서는 @Before라는 애노테이션을 제공한다. @Before가 지정된 함수 내부의 코드는 각 테스트가 실행되기 전에 한번만 실행되며, JUnit 테스트 클래스는 @Before가 지정된 setUp()이라는 이름의 함수를 갖는다. 테스트 대상 설정하기 setUp() 함수 내부에서는 테스트할 SoundViewModel의 인스턴스와 Sound의 인스턴스를 생성해야 한다. SoundViewModel이 음원 제목을 보여주는 방법을 알려면 Sound 인스턴스를 필요로 하기 때문이다. SoundViewModel과 Sound의 인스턴스를 생성하자. 테스트 대상인 SoundViewModel 인스턴스 생성하기 (SSoundViewModelTest.kt) 123456789101112class SoundViewModelTest { private lateinit var sound: Sound private lateinit var subject: SoundViewModel @Before fun setUp() { sound = Sound(&quot;assetPath&quot;) subject = SoundViewModel() subject.sound = sound }} 지금까지는 SoundViewModel 인스턴스를 참조하는 속성 이름을 soundViewModel로 사용했는데, 여기서는 subject라고 했다. 테스트의 대상이 되는 객체이므로 subject 라고 하는 것이 오히려 알기 쉽고, 테스트 함수를 다른 클래스로 옮기더라도 속성 이름을 변경할 필요가 없기 때문이다. 테스트 작성하기 setUp() 함수가 작성되었으니 이제는 테스트를 작성해본다. @Test 애노테이션이 지정된 테스트 클래스의 함수를 테스트라고 한다. 우선 SoundViewModel의 title 속성값이 Sound의 name 속성값과 일치하는지 검사하는 테스트 함수를 작성하자. title 속성 테스트하기 (SoundViewModelTest.kt) 123456789101112131415161718...import org.junit.Assert.*import org.hamcrest.core.Is.`is`import org.hamcrest.MatcherAssertclass SoundViewModelTest { ... @Before fun setUp() { ... } @Test fun exposesSoundNameAsTitle() { MatcherAssert.assertThat(subject.title, `is`(sound.name)) }} (assertThat(…) 함수와 is(…) 함수는 위의 코드 대로 import해야 한다.) 이 테스트에서는 assertThat(…) 함수와 is(…) 함수를 같이 사용하며, '테스트 대상의 title 속성값이 Sound의 name 속성값과 같아야 함’을 나타낸다. 따라서 두 속성값이 다르면 테스트는 실패한다. 프로젝트 도구 창의 ‘app/java/com.june0122.beatbox (test)’ 밑에 있는 SoundViewModelTest에서 오른쪽 마우스 버튼을 클릭한 후 Run 'SoundViewModelTest’를 선택하면 단위 테스트가 실행되고 안드로이드 스튜디오에서 아래와 같은 실행 결과를 보여준다. 테스트과 통과됨 여기서는 한 개의 테스트가 실행되어 통과되었음을 보여준다(Tests passed: 1). 만일 테스트가 실패하면 이에 관한 자세한 내용도 보여준다. 객체의 상호작용 테스트하기 다음으로 SoundViewModel과 BeatBox.play(Sound) 함수가 잘 연동되는지 검사하는 테스트를 생성한다. 이때는 주로 연동을 테스트하는 함수를 테스트 클래스에 작성한다. 우선 onButtonClicked()를 호출하는 테스트 함수를 작성한다(onButtonClicked() 함수는 잠시 후에 SoundViewModel에 추가한다). onButtonClicked()를 호출하는 테스트 함수 작성하기 (SoundViewModelTest.kt) 123456789101112class SoundViewModelTest { ... @Test fun exposesSoundNameAsTitle() { MatcherAssert.assertThat(subject.title, `is`(sound.name)) } @Test fun callsBeatBoxPlayOnButtonClicked() { subject.onButtonClicked() }} 여기서 onButtonClicked() 함수는 아직 작성되지 않았기에 붉은색의 에러로 표시된다. 이 함수를 클릭한 후 Alt+Enter [Option+Return] 키를 누르고 Create member function 'SoundViewModel.onButtonClicked’를 선택하면 이 함수가 SoundViewModel.kt에 자동 생성된다. 반드시 TODO를 주석으로 처리해주자! 자동 생성된 onButtonClicked() (SoundViewModel.kt) 123456class SoundViewModel : BaseObservable() { fun onButtonClicked() { // TODO(&quot;Not yet implemented&quot;) } ...} 지금은 onButtonClicked() 함수를 비어 있는 상태로 두고 SoundViewModelTest 클래스를 다시 본다. 테스트 함수인 callsBeatBoxPlayOnButtonClicked()에서는 SoundViewModel의 onButtonClicked() 함수를 호출한다. 그러나 이 함수에서 BeatBox.play(Sound)를 호출하는 것을 검사해야 한다. 이것을 구현하기 위해 맨 먼저 할 일은 SoundViewModel에 BeatBox 객체를 제공하는 것이다. 이때 테스트 함수에서 BeatBox 인스턴스를 생성하고 SoundViewModel 생성자에 전달할 수 있다. 그러나 단위 테스트에서 이렇게하면 문제가 생긴다. 만일 BeatBox에서 문제가 생기면 이것을 사용하는 SoundViewModel도 덩달아 문제가 생겨서 SoundViewModel의 단위 테스트가 실패할 수 있기 때문이다. 이것은 우리가 원하는 바가 아니다. SoundViewModel의 단위 테스트는 SoundViewModel에 국한된 문제가 있을 때만 실패해야 한다. 다시 말해서 SoundViewModel 자체의 작동과 다른 클래스와의 상호 작용은 별개로 테스트해야 한다. 이것이 단위 테스트에서 중요한 사항이다. 이런 문제를 해결하고자 BeatBox에 모의 객체(mock object)를 사용한다. 이때 모의 객체는 BeatBox의 서브 클래스가 되며, BeatBox와 같은 함수들을 갖는다. 단, 모든 함수가 아무 일도 하지 않으므로 BeatBox에서는 문제가 생기지 않는다. 따라서 SoundViewModel의 테스트에서는 BeatBox의 작동과는 무관하게 SoundViewModel이 BeatBox를 사용하는 것이 맞는지 검사할 수 있다. Mockito를 사용해서 모의 객체를 생성할 때는 static 함수인 mock(Class)를 호출하며, 이때 모의 객체를 사용할 클래스를 인자로 전달한다. BeatBox의 모의 객체를 생성하고 이 객체의 참조를 갖는 속성을 SoundViewModelTest에 추가한다. BeatBox의 모의 객체 생성하기 (SoundViewModelTest.kt) 1234567891011121314151617import org.mockito.Mockito.mockclass SoundViewModelTest { private lateinit var beatBox: BeatBox private lateinit var sound: Sound private lateinit var subject: SoundViewModel @Before fun setUp() { beatBox = mock(BeatBox::class.java) sound = Sound(&quot;assetPath&quot;) subject = SoundViewModel() subject.sound = sound } ...} mock(Class) 함수는 클래스 참조처럼 import되며, BeatBox의 모의 객체를 자동으로 생성한다. BeatBox의 모의 객체가 준비되었으니 이제는 play(Sound) 함수가 호출되는지 검사하는 테스트 작성을 마무리한다. 모든 Mockito 모의 객체는 자신의 함수들이 호출된 기록은 물론이고, 각 호출에 전달된 매개변수 내역을 유지한다. 그리고 Mockito의 verify(Object) 함수를 사용하면 기대한 대로 모의 객체 함수들이 호출되었는지 확인할 수 있다. SoundViewModel에 연결된 Sound 객체를 사용해서 onButtonClicked()가 BeatBox.play(Sound)를 호출하는지 확인하기 위해 verify(Object)를 호출한다(Sound는 문제가 될 함수가 없는 데이터 객체이므로 모의 객체를 생성할 필요가 없다). BeatBox.play(Sound)가 호출되는지 검사하기 (SoundViewModelTest.kt) 123456789class SoundViewModelTest { ... @Test fun callsBeatBoxPlayOnButtonClicked() { subject.onButtonClicked() verify(beatBox).play(sound) // verify(Object) 호출 }} 여기서는 플루언트 인터페이스(fluent interface)를 사용한다(플루언트 인터페이슨느 코드를 알기 쉽게 해주며, 일반적으로 함수의 연쇄 호출 형태로 구현된다). 즉, verify(beatBox)에서 BeatBox 객체를 반환하므로 연속해서 이 객체의 play(sound) 함수를 호출할 수 있다. verify(beatBox).play(sound)는 다음과 같다. 12verify(beatBox)beatBox.play(sound) 여기서 verify(beatBox)는 'beatBox의 함수가 호출되었는지 검사하려고 함’이라는 의미이며, 그다음 함수 호출인 play(sound)는 ’play(sound) 함수가 이처럼 호출되었는지 검사하라’는 의미로 생각할 수 있다. 결국 verify(beatBox).play(sound)는 sound를 인자로 받는 beatBox의 play(sound) 함수가 호출되었는지 확인하라는 의미다. 물론, 지금은 이런 일이 생기지 않는다. SoundViewModel.onButtonClicked() 함수의 실행 코드가 아직 없어서 beatBox.play(sound)가 호출되지 않았기 때문이다. 또한, SoundViewModel은 beatBox 참조를 갖고 있지 않아서 beatBox의 어떤 함수도 호출할 수 없다. 따라서 테스트는 실패한다. 현재는 테스트를 먼저 작성했으니 이렇게 되는 것이 정상이다. 처음부터 테스트가 실패하지 않는다면 어떤 것도 테스트할 필요가 없다. 테스트를 실행해 아래와 같이 테스트가 실패하는 것을 확인해보자. 테스트 실패 내역 출력 출력 메시지는 다음과 같다. 123456Wanted but not invoked:beatBox.play( com.june0122.beatbox.Sound@1af146);-&gt; at com.june0122.beatbox.BeatBox.play(BeatBox.kt:26)Actually, there were zero interactions with this mock. beatBox.play(sound)의 호출을 기대했지만 호출되지 않았다. assertThat(…)과 마찬가지로 verify(Object)은 내부적으로 어서션(assertion)을 생성한다. 그리고 어서션에 어긋나면 테스트를 실패로 처리하고, 로그에 그 이유를 설명하는 출력을 남긴다. 그리고 어서션에 어긋나면 테스트를 실패로 처리하고, 로그에 그 이유를 설명하는 출력을 남긴다. 이제는 테스트의 결함을 수정할 때가 되었다. 우선 SoundViewModel의 생성자에서 BeatBox 인스턴스를 받도록 속성을 추가한다(여기서 기본 생성자에 선언된 beatBox는 매개변수이면서 속성으로도 생성된다). BeatBox를 SoundViewModel에 제공하기 (SoundViewModel.kt) 123class SoundViewModel(private val beatBox: BeatBox) : BaseObservable() { ...} 이렇게 변경하면 SoundHolder 클래스와 SoundViewModelTest 클래스에서 에러가 발생한다. SoundHolder에서 SoundViewModel 인스턴스를 생성할 때 beatBox 객체를 생성자에 전달하도록 변경 BeatBox의 모의 객체를 SoundViewModel 생성자에 전달 SoundHolder의 에러 수정 (MainActivity.kt) 12345678private inner class SoundHolder(private val binding: ListItemSoundBinding) : RecyclerView.ViewHolder(binding.root) { init { binding.viewModel = SoundViewModel(beatBox) } fun bind(sound: Sound) { ... }} 테스트에 BeatBox 모의 객체 제공 (SoundViewModelTest.kt) 1234567891011class SoundViewModelTest { ... @Before fun setUp() { beatBox = mock(BeatBox::class.java) sound = Sound(&quot;assetPath&quot;) subject = SoundViewModel(beatBox) subject.sound = sound } ...} 다음으로 테스트에서 기대하는 것을 수행하도록 onButtonClicked()를 구현한다. onButtonClicked() 구현하기 (SoundViewModel.kt) 1234567class SoundViewModel(private val beatBox: BeatBox) : BaseObservable() { ... fun onButtonClicked() { sound?.let { beatBox.play(it) } } 테스트를 다시 실행하면 이번에는 테스트과 통과되었음을 Run 도구 창에서 확인할 수 있다. 데이터 바인딩 콜백 이제는 버튼들이 제대로 작동하는지 테스트하는 것만 남았다. 따라서 onButtonClicked()를 버튼과 연결해야 한다. 사용자 인터페이스인 레이아웃에 데이터를 넣을 때 데이터 바인딩을 사용할 수 있듯이, 클릭 리스너를 연결할 때도 람다식으로 데이터 바인딩을 할 수 있다. 버튼 클릭을 SoundViewModel.onButtonClicked()에 연결하기 위해 데이터 바인딩으로 호출되는 콜백 표현식을 추가한다. 버튼을 코드와 연결하기 (list_item_sound.xml) 1234567&lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;120dp&quot; ... android:onClick=&quot;@{() -&gt; viewModel.onButtonClicked()}&quot; android:text=&quot;@{viewModel.title}&quot; tools:text=&quot;Sound name&quot; /&gt; 이제는 BeatBox 앱을 실행하고 음원 제목을 보여주는 버튼을 누르면 음원이 재생되어야 한다. 테스트를 실행한 뒤에는 실행 구성(run configuration)이 변경되므로 실행 구성 드롭다운을 클릭해 app으로 변경한다. 실행 구성을 변경하기 음원 내리기 음원 재생이 잘 작동하지만 아직 마무리해야 할 것이 있다. 음원 재생이 끝나면 SoundPool.release()를 호출해 SoundPool을 클린업(리소스 해제)해야 한다. 이 일을 하는 BeatBox.release() 함수를 추가한다. SoundPool 클린업하기 (BeatBox.kt) 123456789101112131415class BeatBox(private val assets: AssetManager) { ... fun play(sound: Sound) { ... } fun release() { soundPool.release() } private fun loadSounds(): List&lt;Sound&gt; { ... } ...} 그다음에 BeatBox.release() 함수를 호출하는 onDestroy() 함수를 MainActivity에 추가한다. 액티비티가 소멸하면 SoundPool도 클린업해야 하기 때문이다. onDestroy() 함수 추가하기 (MainActivity.kt) 1234567891011121314class MainActivity : AppCompatActivity() { private lateinit var beatBox: BeatBox override fun onCreate(savedInstanceState: Bundle?) { ... } override fun onDestroy() { super.onDestroy() beatBox.release() } ...} BeatBox 앱을 다시 실행해 release() 함수가 제대로 작동하는지 확인해보자. 대부분 짧은 소리만 나지만, 조금 긴 소리의 음원이 재생되는 동안에 장치를 회전하거나 백 버튼을 누르면 재생이 중단된다. 궁금증 해소 💁🏻‍♂️ : 통합 테스트 ↩ 앞의 SoundViewModelTest는 단위 테스트였지만, 통합 테스트(integration test)를 생성할 수도 있다. 통합 테스트가 무엇일까? 단위 테스트에서는 테스트 항목이 개별 클래스이지만, 통합 테스트는 여러 클래스나 컴포넌트가 함께 작동하는 앱의 일부가 테스트 대상이다. 단위 테스트와 통합 테스트 모두 중요하지만, 서로 다른 목적을 갖는다. 단위 테스트에서는 각 단위 클래스가 올바르게 작동하는지, 기대한 대로 다른 단위와 제대로 상호 작용하는지 확인한다. 반면에 통합 테스트에서는 개별적으로 테스트된 단위들과 기능이 올바르게 통합되어 작동하는지 검사한다. 통합 테스트는 데이터베이스 사용과 같은 UI가 아닌 부분을 검사하기 위해 작성한다. 그런데 안드로이드에서는 UI와 상호 작용하면서 기대한 대로 잘 되는지 검사하기 때문에 UI 수준에서 앱을 테스트하고자 이러한 테스트를 작성하는 경우가 많다. 따라서 대개는 화면별로 통합 테스트를 작성한다. 예를 들어, MainActivity 화면이 나타날 때 첫 번째 버튼의 제목이 sample_sounds의 첫 번째 파일 이름(예를 들어, MainActivity) 화면이 나타날 때 첫 번째 버튼의 제목이 sample_sounds의 첫 번째 파일 이름(예를 들어, 65_cjipie)을 보여주는지 테스트할 수 있다. UI 수준의 통합 테스트는 액티비티나 프래그먼트와 같은 프레임워크 클래스가 필요하며, JVM 단위 테스트에서 사용할 수 없는 시스템 서비스, 파일 시스템 등도 필요할 수 있다. 이런 이유로 안드로이드에서는 통합 테스트는 주로 장치 테스트로 구현된다. 통합 테스트는 기대한 대로 앱이 작동하면 통과된다. 구현될 때 통과되는 것이 아니다. 버튼 ID의 이름을 변경해도 앱의 작동에는 영향을 주지 않는다. 그런데 findViewById(R.id.button)을 호출해 해당 버튼이 올바른 텍스트를 보여주는지 확인하는 것은 통합 테스트로 작성할 수 있다. 이때 안드로이드에서는 findViewById(R.id.button) 대신 UI 테스트 프레임워크를 사용해서 통합 테스트를 작성한다. 이렇게 하면 기대하는 텍스트를 갖는 버튼이 화면에 있는지 쉽게 확인할 수 있다. Espresso는 안드로이드 앱을 테스트하는 구글의 UI 테스트 프레임워크다. 안드로이드 스튜디오의 프로젝트 도구 창에서 Gradle Scripts 밑의 build.gradle (Module: BeatBox.app) 파일을 보면 다음과 같이 기본적으로 라이브러리 의존성에 추가되어 있다(맨 끝의 버전 번호는 변경될 수 있다). 1androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0' 이처럼 Espresso가 의존성에 포함되면 통합 테스트를 하기 위해 시작될 액티비티에 관한 어서션을 만들 수 있다. 여기서는 첫 번째 sample_sounds 테스트 파일 이름을 사용하는 뷰(버튼)가 화면에 있어야 한다는 어서션을 만드는 방법을 보여준다. 123456789101112@RunWith(AnbdroidJUnit4::class)class MainActivityTest { @get:Rule val activityRule = ActivityTestRule(MainActivity::class.java) @Test fun showsFirstFileName() { onView(withText(&quot;65_cjipie&quot;)) .check(matches(isDisplayed())) }} 여기서는 두 개의 애노테이션이 코드를 실행한다. @RunWith(AnbdroidJUnit4::class)는 MainActivityTest가 안드로이드 장치 테스트이며, 액티비티 및 다른 안드로이드 런타임 도구와 함께 작동함을 나타낸다. 그다음에 있는 activityRule의 @get:Rule은 각 테스트를 실행하기 전에 MainActivity의 인스턴스를 시작시켜야 함을 JUnit에게 알린다. 테스트가 설정되었으니 이제는 테스트할 MainActivity에 관한 어서션을 만들 수 있다. showsFirstFileName()의 onView(withText(&quot;65_cjipie&quot;))에서는 테스트를 수행하기 위해 *“65_cjipie”*라는 텍스트를 갖는 뷰(버튼)을 찾는다. 그다음에 check(matches(isDisplayed()))를 호출해 해당 뷰가 화면에 보이는지 확인한다. 만일 그런 텍스트를 갖는 뷰가 없다면 check(…)는 실패한다. check(…) 함수는 뷰에 관한 assertThat(…) 형태의 어서션을 만드는 Espresso의 방법이다. 버튼처럼 뷰를 클릭해야 할 때는 클릭한 결과를 검사하는 어서션을 만들면 된다. 이때도 다음과 같이 Espresso를 사용할 수 있다. 12onView(withText(&quot;65_cjipie&quot;)) .perform(click()) 이처럼 뷰와 상호 작용할 때는 Espresso가 테스트를 멈추고 기다리며, UI의 변경이 끝났을 때를 감지한다. 그런데 Espresso를 더 오래 기다리게 할 때는 IdlingResource의 서브 클래스를 사용해 Espresso에게 앱의 작업이 아직 끝나지 않았음을 알린다. Espresso로 UI를 테스트하는 방법에 관한 자세한 정보는 Espresso 문서를 참고하자. 다시 말하지만 통합 테스트와 단위 테스트는 그 목적이 다르다. 대부분의 사람은 단위 테스트를 먼저 시작한다. 앱의 개별적인 부분들의 작동을 정의하고 검사하는데 도움이 되기 때문이다. 통합 테스트는 그런 개별적인 부분들에 의존해 여러 부분이 하나로 함께 잘 작동하는지 검사한다. 두 테스트는 각각 앱의 건강에 관한 서로 다른 중요한 관점을 제공하므로 테스트를 같이 하는 것이 가장 좋다. 궁금증 해소 💁🏻‍♂️ : 모의 객체와 테스트 통합 테스트에서는 모의 객체가 단위 테스트 때와는 다른 역할을 담당한다. 모의 객체는 다른 컴포넌트를 테스트와 관계없는 것처럼 만들어서 테스트할 컴포넌트를 격리하기 위해 존재한다. 단위 테스트는 클래스 단위로 테스트한다. 그런데 각 클래스는 다른 클래스들에 대해 의존성을 가질 수 있으므로 테스트 클래스들은 서로 다른 모의 객체들을 가지며, 모의 객체가 어떻게 작동하는가는 중요하지 않다. 따라서 간단한 모의 객체를 쉽게 생성해주는 모의 프레임워크(예를 들어, Mockito)가 단위 테스트에는 안성맞춤이다. 이와는 달리 통합 테스트는 앱 전체를 한 덩어리로 테스트한다. 따라서 앱의 각 부분을 격리하는 대신에 앱이 상호 작용하는 외부의 것과 격리하기 위한 모의 객체를 사용한다. 예를 들어, 모의 데이터와 응답을 반호나하는 웹 서비스를 제공하는 경우다. BeatBox 앱에서는 특정 음원 파일이 재생되었음을 알려주는 모의 SoundPool을 제공할 수 있을 것이다. 모의 객체는 점점 더 많아지고 여러 테스트에서 공유되며 모의 행동을 구현하므로, 통합 테스트에서는 자동화된 모의 프레임워크를 사용하지 말고 모의 객체를 직접 작성하는 것이 좋다. 어떤 경우든 다음 규칙이 적용된다. 즉, 테스트 중인 컴포넌트의 경계에 있는 개체들을 모의 객체로 만든다. 이렇게 하면 테스트하려는 범위에만 집중할 수 있다. 또한, 테스트 컴포넌트 외의 다른 컴포넌트와는 무관하게 테스트 컴포넌트에 문제가 있을 때만 테스트가 실패하므로 정확하게 테스트할 수 있다.","link":"/2021/06/06/android-bnr-20/"},{"title":"[Android] CustomView &amp; Touch Event","text":"커스텀 뷰 생성하기 안드로이드는 뛰어난 기능의 표준 뷰와 위젯을 많이 제공한다. 그러나 때로는 앱 특유의 비주얼을 보여주는 커스텀(custom) 뷰가 필요하다. 커스텀 뷰에는 여러 종류가 있지만 크게 두 가지 유형으로 분류할 수 있다. 단순(simple) : 단순 뷰는 내부적으로 복잡할 수 있지만, 자식 뷰가 없어서 구조가 간단하다. 대부분 커스텀 렌더링을 수행한다. 복합(composite) : 복합 뷰는 서로 다른 뷰 객체들로 구성된다. 일반적으로 복합 뷰는 자식 뷰들을 관리하지만, 자신은 커스텀 렌더링을 하지 않는다. 대신에 렌더링은 각 자식 뷰에게 위임한다. 커스텀 뷰를 생성하려면 다음의 세 단계를 거친다. 슈퍼 클래스를 선택한다. 단순 커스텀 뷰에서 View는 비어 있는 캔버스와 같아서 가장 많이 사용된다. 복합 커스텀 뷰에서는 FrameLayout과 같이 적합한 레이아웃 클래스를 선택한다. 1번에서 선택한 슈퍼 클래스의 서브 클래스를 만들고, 해당 슈퍼 클래스의 생성자를 오버라이드한다. 슈퍼 클래스의 주요 함수들을 오버라이드해 커스터마이징한다. BoxDrawingView 생성하기 BoxDrawingView는 단순 뷰이면서 View의 직계 서브 클래스가 된다. BoxDrawingView라는 이름의 새로운 클래스를 생성하고 View를 슈퍼 클래스로 지정한다. 그리고 BoxDrawingView.kt에서 아래 코드와 같이 생성사를 추가한다. 이 생성자는 Context 객체 및 null이 가능하면서 기본값이 null인 AttributeSet 객체를 인자로 받는다. BoxDrawingView의 초기 구현 (BoxDrawingView.kt) 12class BoxDrawingView(context: Context, attrs: AttributeSet? = null) : View(context, attrs) {} 이처럼 AttributeSet에 기본값을 지정하면, 실제로는 두 개의 생성자가 제공된다. 우리 뷰의 인스턴스가 ➀ 코드 또는 ➁ 레이아웃 XML 파일로부터 생성될 수 있어야 하기 때문이다. 레이아웃 파일로부터 인스턴스가 생성되어 초기화되는 뷰는 XML에 지정된 속성들을 포함하는 AttributeSet의 인스턴스를 인자로 받는다. 그다음으로 BoxDrawingView를 사용하도록 res/layout/activity_drag_and_drawing.xml 레이아웃 파일을 변경한다. BoxDrawingView를 레이아웃에 추가하기 (res/layout/activity_drag_and_drawing.xml) 1234&lt;com.june0122.draganddraw.BoxDrawingView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 여기서는 레이아웃 인플레이터가 찾을 수 있게 BoxDrawingView 클래스가 속한 패키지의 전체 경로를 지정해야 한다. 인플레이터는 View 인스턴스를 생성하는 데 필요한 레이아웃 파일을 찾는다. 이때 요소로 지정된 클래스 이름에 전체 패키지 경로가 지정되지 않으면 인플레이터가 android.view와 android.widget 패키지에서 해당 이름의 클래스를 찾는다. 따라서 해당 클래스가 다른 곳에 있다면 레이아웃 인플레이터는 그것을 찾지 못하고 앱은 실행이 중단된다. 그러므로 android.view와 android.widget 패키지 외부에 있는 커스텀 클래스나 이외의 다른 클래스들에서는 반드시 전체 패키지 경로가 포함된 클래스 이름을 지정해야 한다. 터치 이벤트 처리하기 터치 이벤트를 리스닝할 때는 다음의 View 함수를 사용해서 터치 이벤트 리스너를 설정한다. 1fun setOnTouchListener(l: View.OnTouchListener) 이 함수는 setOnClickListener(View.OnClickListener)와 같은 방법으로 작동한다. 즉, 함수의 인자로 View.OnClickListener를 구현한 리스너 객체(여기서는 View의 서브 클래스인 BoxDrawingView 인스턴스)를 전달하면 터치 이벤트가 발생할 때마다 이 객체에 구현된 onTouchEvent(…) 함수가 호출된다. 따라서 BoxDrawingView에서는 다음 View 함수를 오버라이드하면 된다. 1override fun onTouchEvent(evenet: MotionEvent): Boolean 이 함수는 MotionEvent 인스턴스를 인자로 받는다. MotionEvent는 터치 이벤트를 나타내는 클래스이며, 화면을 터치한 위치와 액션(action)을 포함한다. 액션은 다음과 같이 이벤트 발생 단계를 나타낸다. 액션 상수 의미 ACTION_DOWN 사용자가 화면을 손가락으로 터치함 ACTION_MOVE 사용자가 화면 위에서 손가락을 움직임 ACTION_UP 사용자가 화면에서 손가락을 뗌 ACTION_CANCEL 부모 뷰가 터치 이벤트를 가로챔 onTouchEvent(MotionEvent)의 구현 코드에서는 MotionEvent 객체의 다음 함수를 호출해 액션의 값을 확인할 수 있다. 1final fun getAction(): Int BoxDrawingView.kt에 아래 코드를 추가하자. 여기서는 이벤트가 제대로 처리되는지 로그캣에서 확인하기 위해 로그 태그 상수와 네 개의 각 액션에 대해 로그 메시지를 출력하는 onTouchEvent(MotionEvent)의 구현 코드도 추가한다. BoxDrawingView 구현하기 (BoxDrawingView.kt) 1234567891011121314151617181920212223242526private const val TAG = &quot;BoxDrawingView&quot;class BoxDrawingView(context: Context, attrs: AttributeSet? = null) : View(context, attrs) { override fun onTouchEvent(event: MotionEvent): Boolean { val current = PointF(event.x, event.y) var action = &quot;&quot; when (event.action) { MotionEvent.ACTION_DOWN -&gt; { action = &quot;ACTION_DOWN&quot; } MotionEvent.ACTION_MOVE -&gt; { action = &quot;ACTION_MOVE&quot; } MotionEvent.ACTION_UP -&gt; { action = &quot;ACTION_UP&quot; } MotionEvent.ACTION_CANCEL -&gt; { action = &quot;ACTION_CANCEL&quot; } } Log.i(TAG, &quot;$action at x=${current.x}, y=${current.y}&quot;) return true }} 여기서는 터치된 위치를 나타내는 X와 Y 좌표를 PointF 객체에 넣는다. 이 장의 나머지 코드에서 두 값을 같이 사용해야 하기 때문이다. PointF는 이런 역할을 하는 안드로이드의 컨테이너 클래스다. Logcat 창의 검색 상자에 I/BoxDrawingView를 입력하고 앱을 실행하여 화면을 터치하고 끌어보는 등 상호 작용을 하면 BoxDrawingView가 받는 모든 터치 액션의 X, Y 좌표가 로그에 실시간으로 출력된다. 앱 화면과 상호 작용을 했을 때 로그에 나타나는 X, Y 좌표값들 모션 이벤트 추적하기 BoxDrawingView에서는 좌표만 로깅하는 게 아니라 화면에 박스들도 그릴 것이다. 이렇게 하려면 몇 가지 해결할 것이 있다. 우선 박스를 정의하기 위해 시작 지점(손가락이 처음 놓인 곳)과 현재 지점(손가락이 현재 있는 곳)이 반드시 필요하다. 그다음에 박스를 정의하려면 하나 이상의 MotionEvent로부터 발생하는 데이터를 추적해야하며, 이 데이터를 Box 객체에 저장해야 한다. 하나의 박스를 정의하는 데이터를 나타내는 Box 클래스를 생성해 아래의 코드를 추가한다. Box 클래스 추가하기 (Box.kt) 123456789101112131415class Box(val start: PointF) { var end: PointF = start val left: Float get() = min(start.x, end.x) val right: Float get() = max(start.x, end.x) val top: Float get() = min(start.y, end.y) val bottom: Float get() = max(start.y, end.y)} 사용자가 BoxDrawingView를 터치하면 새로운 Box 객체가 생성되어 기존 박스 List에 추가되도록 하자. 사용자가 그리는 상태 정보를 추적하기 위해 BoxDrawingView 클래스에 새로운 Box 객체를 사용하는 코드를 추가한다. Box 객체를 사용하는 코드 추가하기 (BoxDrawingView.kt) 12345678910111213141516171819202122232425262728293031323334353637383940class BoxDrawingView(context: Context, attrs: AttributeSet? = null) : View(context, attrs) { private var currentBox: Box? = null private var boxen = mutableListOf&lt;Box&gt;() override fun onTouchEvent(event: MotionEvent): Boolean { val current = PointF(event.x, event.y) var action = &quot;&quot; when (event.action) { MotionEvent.ACTION_DOWN -&gt; { action = &quot;ACTION_DOWN&quot; // 그리기 상태를 재설정한다 currentBox = Box(current).also { boxen.add(it) } } MotionEvent.ACTION_MOVE -&gt; { action = &quot;ACTION_MOVE&quot; updateCurrentBox(current) } MotionEvent.ACTION_UP -&gt; { action = &quot;ACTION_UP&quot; updateCurrentBox(current) currentBox = null } MotionEvent.ACTION_CANCEL -&gt; { action = &quot;ACTION_CANCEL&quot; currentBox = null } } Log.i(TAG, &quot;$action at x=${current.x}, y=${current.y}&quot;) return true } private fun updateCurrentBox(current: PointF) { currentBox?.let { it.end = current invalidate() } }} 여기서는 ACTION_DOWN 모션 이벤트를 받을 때마다 currentBox 속성을 새로운 Box 객체로 설정한다. 이 객체는 이벤트가 발생한 위치를 시작 지점으로 가지며 박스 List에 저장된다(본문의 뒤에서 그리기를 구현할 때 BoxDrawingView에서 이 박스 List에 저장된 모든 Box를 화면에 그린다). 사용자의 손가락이 화면을 이동하거나 화면에서 떨어지면 currentBox.end를 변경한다. 그리고 터치가 취소되거나 사용자의 손가락이 화면에서 떨어지면 그리기를 끝내기 위해 currentBox를 null로 변경한다. 즉, Box 객체는 List에 안전하게 저장되지만, 모션 이벤트에 관해서는 더 이상 변경이 생기지 않는다. updateCurrentBox() 함수에서 invalidate()를 호출한다. invalidate() 함수를 호출하면 뷰가 무효(invalid)라는 것을 안드로이드에게 알려주므로 안드로이드 시스템이 해당 뷰의 변경 사항을 반영해서 다시 그려준다. 여기서는 사용자가 손가락을 움직여서 새로운 박스를 생성하거나 박스 크기를 조정할 때마다 invalidate() 함수를 호출해 BoxDrawingView를 다시 그리게 한다. 이렇게 하면 사용자가 손가락을 끌어서 박스를 생성하는 동안 어떤 모습인지 볼 수 있다. 참고로 앱이 시작되면 앱의 모든 뷰가 무효 상태가 되어 뷰들이 화면에 어떤 것도 그릴 수 없게 된다. 이런 상황을 해결하기 위해 안드로이드는 최상위 수준 View의 draw() 함수를 호출함으로써 부모 뷰가 자신을 그리게 되고, 이것의 자식 뷰들 또한 자신들을 그리게 된다. 뷰 계층을 따라 내려가면서 자식 뷰들의 또 다른 자식 뷰들도 자신들을 그리게 되는 식이다. 결국 뷰 계층의 모든 뷰가 자신을 그리게 되면 최상위 수준 View는 더 이상 무효 상태가 되지 않는다. 다음으로 박스를 화면에 그려보자. onDraw(Canvas) 내부에서 렌더링하기 뷰가 화면에 그려지게 하려면 다음 View 함수를 오버라이드해야 한다. 1protected fun onDraw(canvas: Canvas) onTouchEvent(MotionEvent)의 ACTION_MOVE에 대한 응답에서 호출한 invalidate() 함수는 BoxDrawingView를 다시 무효 상태로 만든다. 그럼으로써 BoxDrawingView는 자신을 다시 그리게 되고 이때 onDraw(Canvas)가 다시 호출된다. 이제는 Canvas 매개변수에 대해 알아보자. Canvas와 Paint 모두 안드로이드의 주요 그리기 클래스다. Canvas 클래스는 모든 그리기 함수를 갖고 있다. 우리가 호출하는 Canvas의 함수들은 그리는 위치와 선, 원, 단어, 사각형 등의 형태를 결정한다. Paint 클래스는 이런 함수들이 어떻게 수행되는지를 결정한다. 즉, 우리가 호출하는 Paint의 함수들은 도형이 채워져야 하는지, 어떤 폰트의 텍스트를 그리는지, 어떤 색의 선인지와 같은 특성을 지정한다. BoxDrawingView 인스턴스가 초기화될 때 두 개의 Paint 객체를 생성하도록 BoxDrawingView.kt를 변경한다. Paint 객체 생성하기 (BoxDrawingView.kt) 123456789101112class BoxDrawingView(context: Context, attrs: AttributeSet? = null) : View(context, attrs) { private var currentBox: Box? = null private var boxen = mutableListOf&lt;Box&gt;() private val boxPaint = Paint().apply { color = 0x22ff0000.toInt() } private val backgroundPaint = Paint().apply { color = 0xfff8efe0.toInt() } ...} 이제는 화면에 박스를 그릴 수 있다. onDraw(Canvas) 오버라이드 하기 (BoxDrawingView.kt) 123456789101112class BoxDrawingView(context: Context, attrs: AttributeSet? = null) : View(context, attrs) { ... override fun onDraw(canvas: Canvas) { // 배경을 채운다 canvas.drawPaint(backgroundPaint) boxen.forEach { box -&gt; canvas.drawRect(box.left, box.top, box.right, box.bottom, boxPaint) } }} 황백색 배경의 Paint를 사용해서 박스의 배경인 캔버스를 채운다. 그다음에 박스 List에 저장된 각 Box 객체에 대해 박스의 두 점을 조사해 직사각형의 왼쪽, 오른쪽, 위, 아래의 꼭지점 위치를 결정한다. 왼쪽과 위의 값은 X와 Y의 최솟값이, 아래쪽과 오른쪽은 최댓값이 된다. 이 값들을 산출한 후 Canvas.drawRect(…)를 호출해 화면에 빨간색의 사각형을 그린다. 궁금증 해소 💁🏻‍♂️ : GestureDetector 터치 이벤트를 처리하는 또 다른 방법으로 GestureDetector 객체가 있다. GestureDetector는 특정 이벤트가 발생하면 알려주는 리스너를 갖고 있다. 예를 들어, GestureDetector.OnGestureListener는 화면을 길게 누르거나 밀거나 스크롤하는 등의 이벤트를 리스닝하는 함수들을 갖고 있다. 그리고 두 번 두드림 이벤트를 리스닝하는 GestureDetector.OnDoubleTapListener도 있다. 대부분은 View의 onTouch(…)나 onTouchEvent(…) 함수를 오버라이드해서 사용하는 다양한 이벤트 처리가 필요하지 않다. 따라서 이러한 함수 대신 GestureDetector를 사용하는 것도 아주 좋은 방법이다.","link":"/2021/06/07/android-bnr-30/"},{"title":"[Kotlin] Coroutine - 코루틴의 내부 구현","text":"코루틴은 JVM에서 내부적으로 어떻게 동작하는 것일까? 아래의 내용은 KotlinConf 2017 - Deep Dive into Coroutines on JVM by Roman Elizarov 영상의 내용들이다. There is no magic 코루틴은 디컴파일되면 일반 코드일 뿐이다. Continuation Passing Style(CPS, 연속 전달 방식) 이라는 형태의 코드로 전환한다. A toy problem 12345fun postItem(item: Item) { val token = requestToken() val post = createPost(token, item) processPost(post)} 서버에서 토큰을 가져와서 게시물을 포스트한 다음, 포스트 완료처리를 하는 세 가지 연산을 코루틴으로 만들면 JVM 혹은 바이트코드에서 내부적으로 어떤 형태로 동작하는 것일까? 이것이 Continuation Passing Style로 내부적으로 컴파일할 때 아래와 같이 바뀐다. Continuation Passing Style 123456fun postItem(item: Item) { requestToken { token -&gt; val post = createPost(token, item) processPost(post) }} Continuation Passing Style은 결과를 호출자에게 직접 반환하는 대신 Callback같은 것 continuation으로 결과를 전달하는 것을 의미한다. Kotlin suspending functions 1suspend fun createPost(token: Token, item: Item): Post { … } createPost(…)라는 suspend 함수를 하나를 만들었을 때, 코루틴에서는 일시 중단이 되었다가 재개가 되는데 어떻게 이것이 가능한 것인지 알아보자. Kotlin suspending functions 1234// suspend fun createPost(token: Token, item: Item): Post { … } ↓// Java/JVM Object createPost(Token token, Item item, Continuation&lt;Post&gt; cont) { … } 내부적으로는 JVM에 들어갈 때 바이트코드로 컴파일되면서 같은 createPost(…)인데 Continuation이 생성되어 Continuation Passing Style로 변환된다. 호출했던 함수의 끝에 매개변수가 하나 추가되서 Continuation이라는 객체를 넘겨주는 것으로 변환되는 것이다. Labels 12345678 suspen fun postItem(item: Item) { // LABEL 0↛ val token = requestToken() // LABEL 1↛ val post = createPost(token, item) // LABEL 2 processPost(post) } 먼저 Labael이라는 작업을 하게 되는데 코루틴에서 순차적으로 작성했던 코드들이 suspend 함수가 되면 컴파일할 때 Label이 찍히게 된다. 이 함수가 재개되어야 하는데, 재개될 때 필요한 Suspention Point(중단 지점과 재개 지점)가 요구된다. 그래서 이 지점들을 Label로 찍어놓는 것이다. 이런 작업을 코틀린 컴파일러가 내부적으로 하게 된다. 대략적으로 아래와 같은 형태가 되는데, 작성했던 함수가 내부적으론 switch-case문처럼 바뀌어 case문이 3개가 생성되고 세 번을 실행하는 것을 알 수 있다. 함수를 실행할 때 0번이든, 1번이든, 2번이든 함수를 재개할 수 있는 지점이 생긴 것이다. 그리고 이 함수를 호출한 지점은 중단점이 될 수도 있는 것이다. 12345678910suspend fun postItem(item: Item) { switch (label) { case 0: val token = requestToken() case 1: val post = createPost(token, item) case 2: processPost(post) }} Label들이 다 완성되고 나면 Continuation Passing Style로 변환을 하게 된다. 1234567891011fun postItem(item: Item, cont: Continuation) { val sm = object : CoroutineImpl { … } switch (sm.label) { case 0: val token = requestToken(sm) case 1: val post = createPost(token, item, sm) case 2: processPost(post) }} Continuation이라는 객체가 있고, 매 번 함수를 호출할 때마다 continuation을 넘겨준다. continuation은 Callback 인터페이스 같은 것으로, 재개를 해주는 인터페이스를 가진 객체인 것이다. 위의 코드에서 sm이라고 하는 것은 state machine을 의미하는데, 각각의 함수가 호출될 때 상태(지금까지 했던 연산의 결과)를 같이 넘겨줘야 한다. 이 state machine의 정체는 결국 Continuation이고, Continuation이 어떠한 정보값을 가진 형태로 Passing이 되면서 코루틴이 내부적으로 동작하게 되는 것이다. 123456789101112131415161718fun postItem(item: Item, cont: Continuation) { val sm = cont as? ThisSM ?: object : ThisSM { fun resume(…) { postItem(null, this) } } switch (sm.label) { case 0: sm.item = item sm.label = 1 requestToken(sm) case 1: createPost(token, item, sm) … }} 각각의 suspend function이 Continuation(위 코드에선 sm)을 마지막 매개변수로 가져가게 된다. 만약 requestToken(sm)이 완료되었다면 sm(continuation)에다가 resume()을 호출하게 된다. 다시 createPost(token, item, sm)가 호출되고 이것이 완료되었을 때도 sm(continuation)에다가 resume()을 호출하는 형태가 반복되는 것이다. 그렇다면 resume()은 정체가 무엇일까? 위의 코드에서 resume()은 결국 자기 자신을 불러주는 것이다. (postItem(…) 내부에서 postItem(…)을 다시 호출하고 있음) 예시로, suspend function인 requestToken(sm)의 연산이 끝났을 때 resume()을 통해 다시 postItem(…)이 호출되는데, 그때 Label 값을 하나 올려서 다른 케이스가 호출되도록 하는 것이다. 이렇게 되면 내부적으로는 마치 suspend function이 호출되고 다음 번 케이스, 그리고 또다시 다음 번 케이스로 넘어가는 형태가 되는 것이다. Decomplie된 코드 살펴보기 12345678910111213fun main(): Unit { GlobalScope.launch { val userData = fetchUserData() val userCache = cacheUserData(userData) updateTextView(userCache) }}suspend fun fetchUserData() = &quot;user_name&quot;suspend fun cacheUserData(user: String) = userfun updateTextView(user: String) = user 위의 코드를 코틀린의 바이트코드로 만든 다음, Decompile하여 Java 코드로 만들어보자. Decomplie된 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public final class Example_nomagic_01Kt { public static final void main() { BuildersKt.launch$default((CoroutineScope)GlobalScope.INSTANCE, (CoroutineContext)null, (CoroutineStart)null, (Function2)(new Function2((Continuation)null) { int label; @Nullable public final Object invokeSuspend(@NotNull Object $result) { Object var10000; label17: { Object var4 = IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch(this.label) { case 0: ResultKt.throwOnFailure($result); this.label = 1; var10000 = Example_nomagic_01Kt.fetchUserData(this); if (var10000 == var4) { return var4; } break; case 1: ResultKt.throwOnFailure($result); var10000 = $result; break; case 2: ResultKt.throwOnFailure($result); var10000 = $result; break label17; default: throw new IllegalStateException(&quot;call to 'resume' before 'invoke' with coroutine&quot;); } String userData = (String)var10000; this.label = 2; var10000 = Example_nomagic_01Kt.cacheUserData(userData, this); if (var10000 == var4) { return var4; } } String userCache = (String)var10000; Example_nomagic_01Kt.updateTextView(userCache); return Unit.INSTANCE; } @NotNull public final Continuation create(@Nullable Object value, @NotNull Continuation completion) { Intrinsics.checkNotNullParameter(completion, &quot;completion&quot;); Function2 var3 = new &lt;anonymous constructor&gt;(completion); return var3; } public final Object invoke(Object var1, Object var2) { return ((&lt;undefinedtype&gt;)this.create(var1, (Continuation)var2)).invokeSuspend(Unit.INSTANCE); } }), 3, (Object)null); } // $FF: synthetic method public static void main(String[] var0) { main(); } @Nullable public static final Object fetchUserData(@NotNull Continuation $completion) { return &quot;user_name&quot;; } @Nullable public static final Object cacheUserData(@NotNull String user, @NotNull Continuation $completion) { return user; } @NotNull public static final String updateTextView(@NotNull String user) { Intrinsics.checkNotNullParameter(user, &quot;user&quot;); return user; }} 코드의 64번째 라인을 보면 fetchUserData(…)와 cacheUserData(…)와 같이 suspend function이었던 함수들이 일반 함수로 변경되고 마지막 매개변수로 Continuation이 들어간 것을 확인할 수 있다. 일시 중단과 재개를 위해서 suspention point를 label로 표시해두는 Labeling 작업이 Decompile되어 11번째 라인과 같이 switch-case문이 생성된 것을 확인할 수 있다. 케이스가 3개 생성되었는데 첫 번째 케이스에서 fetchUserData(…)를 호출하면서 Continuation 객체가 넘어가는 것을 확인할 수 있다. 위의 자료에서 설명했던 부분과는 다른 부분이 존재하지만, 요지는 switch-case 형태로 Decompile되면서 다시 재개될 수 있는 형태로 만들어지고 Continuation 객체가 전달되고 있는 것을 확인할 수 있다는 것이다. 아래 이미지처럼 15번째 라인과 34번째 라인에서 함수의 마지막 매개변수로 Continuation 객체가 this로 전달되고 있다. CPS simulation 해보기 12345 GlobalScope.launch {↛ val userData = fetchUserData()↛ val userCache = cacheUserData(userData) updateTextView(userCache) } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758fun main() { println(&quot;[in] main&quot;) myCoroutine(MyContinuation()) println(&quot;\\n[out] main&quot;)}fun myCoroutine(cont: MyContinuation) { when(cont.label) { 0 -&gt; { println(&quot;\\nmyCoroutine(), label: ${cont.label}&quot;) cont.label = 1 fetchUserData(cont) } 1 -&gt; { println(&quot;\\nmyCoroutine(), label: ${cont.label}&quot;) val userData = cont.result cont.label = 2 cacheUserData(userData, cont) } 2 -&gt; { println(&quot;\\nmyCoroutine(), label: ${cont.label}&quot;) val userCache = cont.result updateTextView(userCache) } }}fun fetchUserData(cont: MyContinuation) { println(&quot;fetchUserData(), called&quot;) val result = &quot;[서버에서 받은 사용자 정보]&quot; println(&quot;fetchUserData(), 작업완료: $result&quot;) cont.resumeWith(Result.success(result))}fun cacheUserData(user: String, cont: MyContinuation) { println(&quot;cacheUserData(), called&quot;) val result = &quot;[캐쉬함 $user]&quot; println(&quot;cacheUserData(), 작업완료: $result&quot;) cont.resumeWith(Result.success(result))}fun updateTextView(user: String) { println(&quot;updateTextView(), called&quot;) println(&quot;updateTextView(), 작업완료: [텍스트 뷰에 출력 $user]&quot;)}class MyContinuation(override val context: CoroutineContext = EmptyCoroutineContext) : Continuation&lt;String&gt; { var label = 0 var result = &quot;&quot; override fun resumeWith(result: Result&lt;String&gt;) { this.result = result.getOrThrow() println(&quot;Continuation.resumeWith()&quot;) myCoroutine(this) }} 1234567891011121314151617[in] mainmyCoroutine(), label: 0fetchUserData(), calledfetchUserData(), 작업완료: [서버에서 받은 사용자 정보]Continuation.resumeWith()myCoroutine(), label: 1cacheUserData(), calledcacheUserData(), 작업완료: [캐쉬함 [서버에서 받은 사용자 정보]]Continuation.resumeWith()myCoroutine(), label: 2updateTextView(), calledupdateTextView(), 작업완료: [텍스트 뷰에 출력 [캐쉬함 [서버에서 받은 사용자 정보]]][out] main 정리 There is no magic CPSContinuation Passing Style == Callbacks CPS Transformation Decompile Labels Callback CPS simulation debugging References 새차원, 코틀틴 코루틴 KotlinConf 2017 - Deep Dive into Coroutines on JVM by Roman Elizarov","link":"/2021/06/09/coroutines-under-the-hood/"},{"title":"[LeetCode] 225. Implement Stack using Queues","text":"[LeetCode] 225. Implement Stack using Queues Kotlin Queue 1개 사용 123456789101112131415161718192021222324252627282930class MyStack() { /** Initialize your data structure here. */ val q1: Queue&lt;Int&gt; = LinkedList&lt;Int&gt;() /** Push element x onto stack. */ fun push(x: Int) { val size = q1.size q1.offer(x) for (i in 0 until size) { q1.offer(q1.poll()) } } /** Removes the element on top of the stack and returns that element. */ fun pop(): Int { return q1.poll() } /** Get the top element. */ fun top(): Int { return q1.peek() } /** Returns whether the stack is empty. */ fun empty(): Boolean { return q1.isEmpty() }} Queue 2개 사용 12345678910111213141516171819202122232425262728293031class MyStack() { /** Initialize your data structure here. */ val q1: Queue&lt;Int&gt; = LinkedList&lt;Int&gt;() val q2: Queue&lt;Int&gt; = LinkedList&lt;Int&gt;() /** Push element x onto stack. */ fun push(x: Int) { q1.add(x); while (!q2.isEmpty()) q1.add(q2.poll()); while (!q1.isEmpty()) q2.add(q1.poll()); } /** Removes the element on top of the stack and returns that element. */ fun pop(): Int { return q2.poll() } /** Get the top element. */ fun top(): Int { return q2.peek() } /** Returns whether the stack is empty. */ fun empty(): Boolean { return q1.isEmpty() &amp;&amp; q2.isEmpty() }}","link":"/2021/06/12/leetcode-225/"},{"title":"[LeetCode] 232. Implement Queue using Stacks","text":"[LeetCode] 232. Implement Queue using Stacks Kotlin 1234567891011121314151617181920212223242526272829303132class MyQueue() { /** Initialize your data structure here. */ val input = Stack&lt;Int&gt;() val output = Stack&lt;Int&gt;() /** Push element x to the back of queue. */ fun push(x: Int) { input.push(x) } /** Removes the element from in front of queue and returns that element. */ fun pop(): Int { peek() return output.pop() } /** Get the front element. */ fun peek(): Int { if (output.isEmpty()) { while(input.isNotEmpty()) { output.push(input.pop()) } } return output.peek() } /** Returns whether the queue is empty. */ fun empty(): Boolean { return input.isEmpty() &amp;&amp; output.isEmpty() }} 12Runtime: 168 ms, faster than 26.03% of Kotlin online submissions for Implement Queue using Stacks.Memory Usage: 35.4 MB, less than 100.00% of Kotlin online submissions for Implement Queue using Stacks.","link":"/2021/06/12/leetcode-232/"},{"title":"[LeetCode] 1. Two Sum","text":"[LeetCode] 1. Two Sum Kotlin Brute Force 12345678910111213class Solution { fun twoSum(nums: IntArray, target: Int): IntArray { var twoNum = 0 to 0 for (i in nums.indices) { for (j in i + 1 until nums.size) { if (nums[i] + nums[j] == target) twoNum = i to j } } return intArrayOf(twoNum.first, twoNum.second) }} 1232 ms 36.5 MB 12345678910class Solution { fun twoSum(nums: IntArray, target: Int): IntArray { for (i in nums.indices) { for (j in i + 1 until nums.size) { if (nums[i] + nums[j] == target) return intArrayOf(i, j) } } throw IllegalArgumentException(&quot;No two sum solution&quot;) }} 1236 ms 36.8 MB 시간 복잡도 : O(n2) 공간 복잡도 : O(1) Two-pass Hash Table 1234567891011121314151617class Solution { fun twoSum(nums: IntArray, target: Int): IntArray { val hashmap = HashMap&lt;Int, Int&gt;() nums.forEachIndexed { index, value -&gt; hashmap[value] = index } nums.forEachIndexed { index, value -&gt; val complement = target - value if (hashmap.containsKey(complement) &amp;&amp; hashmap.getValue(complement) != index) { return intArrayOf(index, hashmap.getValue(complement)) } } throw IllegalArgumentException(&quot;No two sum solution&quot;) }} 1204 ms 37.4 MB 시간 복잡도 : O(n) n개의 요소들을 가지고 있는 리스트를 2번 순회하지만, HashMap을 사용하여 look up time을 O(1)으로 줄였기 때문에 결과적으론 O(n)이다. 공간 복잡도 : O(n) HashMap 사용으로 n개의 요소들을 저장하기 때문에 추가적인 공간이 필요하다. One-pass Hash Table 1234567891011121314class Solution { fun twoSum(nums: IntArray, target: Int): IntArray { val hashmap = HashMap&lt;Int, Int&gt;() nums.forEachIndexed { index, value -&gt; val complement = target - value if (hashmap.containsKey(complement)) { return intArrayOf(hashmap.getValue(complement), index) } hashmap[value] = index } throw IllegalArgumentException(&quot;No two sum solution&quot;) }} 1188 ms 37.9 MB 시간 복잡도 : O(n) n개의 원소들을 가진 리스트를 딱 한 번만 순회하고, HashMap에서의 look up time은 오직 O(1)만 소모하므로 시간 복잡도는 O(n)이다. 공간 복잡도 : O(n) Two-pass Hash Table 방법과 마찬가지로 HashMap 사용으로 n개의 요소들을 저장하기 때문에 추가적인 공간이 필요하다.","link":"/2021/06/13/leetcode-1/"},{"title":"[LeetCode] 2. Add Two Numbers","text":"[LeetCode] 2. Add Two Numbers Kotlin 자리올림(carry) 이용 12345678910111213141516171819202122class Solution { fun ListNode.value() = this?.`val` ?: 0 fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? { var (list1, list2) = l1 to l2 var head = ListNode(0) var cur = head var carry = 0 while (list1 != null || list2 != null || carry &gt; 0) { val x = list1?.value() ?: 0 val y = list2?.value() ?: 0 val sum = (x + y + carry) % 10 carry = (x + y + carry) / 10 cur?.next = ListNode(sum) cur = cur.next if (list1 != null) list1 = list1.next if (list2 != null) list2 = list2.next } return head.next }} 12Runtime: 240 ms, faster than 18.40% of Kotlin online submissions for Add Two Numbers.Memory Usage: 43.6 MB, less than 11.74% of Kotlin online submissions for Add Two Numbers.","link":"/2021/06/15/leetcode-2/"},{"title":"[프로그래머스] 레벨 2 : H-Index","text":"문제 보기 정렬 소스 kotlin 나의 풀이 1234567891011121314151617181920212223class Solution { fun solution(citations: IntArray): Int { var h = 0 var count = 0 val citedList = mutableListOf&lt;Int&gt;() val uncitedList = mutableListOf&lt;Int&gt;() citations.sort() while (count &lt;= citations.size) { citations.forEach { if (it &gt;= count) citedList.add(it) else uncitedList.add(it) if (citedList.size &gt;= count &amp;&amp; uncitedList.size &lt;= count) h = count } count += 1 citedList.clear() uncitedList.clear() } return h }} 다른 사람의 풀이 12345import kotlin.math.minclass Solution { fun solution(citations: IntArray) = citations.sortedDescending().mapIndexed { idx, item -&gt; min(idx + 1, item) }.max()}","link":"/2021/06/25/programmers-42747/"},{"title":"[프로그래머스] 레벨 2 : 튜플","text":"문제 보기 소스 kotlin 나의 풀이 123456789101112131415class Solution { fun solution(s: String): IntArray { val set = mutableSetOf&lt;Int&gt;() val elements = s.replace(&quot;{{&quot;, &quot;&quot;).replace(&quot;}}&quot;, &quot;&quot;).split(&quot;},{&quot;) val arr = elements.map { it.split(&quot;,&quot;) }.sortedBy { it.size } arr.forEach { it.forEach { set.add(it.toInt()) } } return set.toIntArray() }} fold(…) 사용 123456789class Solution { fun solution(s: String): IntArray { return s.split(&quot;},{&quot;) .map { it.replace(&quot;[^0-9,]&quot;.toRegex(), &quot;&quot;).split(&quot;,&quot;).map { it.toInt() } } .sortedBy { it.size } .fold(setOf&lt;Int&gt;()) { acc, list -&gt; acc.union(list) } .toIntArray() }}","link":"/2021/06/25/programmers-64065/"},{"title":"[프로그래머스] 레벨 2 : 카펫","text":"문제 보기 완전탐색 소스 kotlin 첫 시도 123456789101112131415class Solution { fun solution(brown: Int, yellow: Int): IntArray { val total = brown + yellow for (i in 3 .. (total / 2)) { for (j in 3 .. (total / 2)) { if (i &gt;= j &amp;&amp; i * j == total &amp;&amp; checkBrown(i to j, brown)) return intArrayOf(i, j) } } return intArrayOf() } fun checkBrown(pair: Pair&lt;Int, Int&gt;, brown: Int) = (pair.first * 2) + (pair.second * 2) - 4 == brown} (가로 * 2) + (세로 * 2) - 4 = brown 테두리의 갈색 격자의 개수는 가로와 세로를 각각 2를 곱해주고 모서리 부분에서 중복되는 4만큼을 빼서 구할 수 있는 것을 이용하였다. 이렇게 하면 간단하게 구현할 수 있지만 시간 복잡도적인 측면에서 효율적이진 못한 코드라 개선이 필요해보인다. 12345678910111213테스트 1 〉 통과 (0.71ms, 54.8MB)테스트 2 〉 통과 (1.04ms, 55.1MB)테스트 3 〉 통과 (229.05ms, 54.4MB)테스트 4 〉 통과 (30.27ms, 55.2MB)테스트 5 〉 통과 (28.67ms, 54.5MB)테스트 6 〉 통과 (152.95ms, 54.7MB)테스트 7 〉 통과 (688.13ms, 54.2MB)테스트 8 〉 통과 (239.40ms, 54.4MB)테스트 9 〉 통과 (379.53ms, 55MB)테스트 10 〉 통과 (400.44ms, 55.5MB)테스트 11 〉 통과 (0.65ms, 55.4MB)테스트 12 〉 통과 (0.66ms, 55.8MB)테스트 13 〉 통과 (1.30ms, 55MB) 근의 공식 활용 1234567891011import kotlin.math.*class Solution { fun solution(brown: Int, yellow: Int): IntArray { val D = ((brown + 4) / 2).toDouble().pow(2.0) - 4 * (brown + yellow) val width = ((brown + 4) / 2 + sqrt(D)) / 2 val height = ((brown + 4) / 2 - sqrt(D)) / 2 return intArrayOf(width.toInt(), height.toInt()) }} 먼저 문제의 지문에서 아래 두 개의 식을 구할 수 있다. 그 다음 계산의 편의성을 위해 아래와 같이 A와 B로 치환시킨다. 치환한 값을 대입시키면 아래와 같은 이차 방정식을 구할 수 있다. 근의 공식을 이용하면 가로와 세로의 크기를 구할 수 있다. 근의 공식은 다음과 같다. 가로가 세로보다 크거나 같으므로 가로인 w에 sqrt(D)를 더하고 세로인 h에서는 빼면 값을 구할 수 있다. 12345678910111213테스트 1 〉 통과 (0.05ms, 55.3MB)테스트 2 〉 통과 (0.04ms, 55.4MB)테스트 3 〉 통과 (0.04ms, 54.6MB)테스트 4 〉 통과 (0.05ms, 55MB)테스트 5 〉 통과 (0.05ms, 55.1MB)테스트 6 〉 통과 (0.07ms, 54.9MB)테스트 7 〉 통과 (0.06ms, 54.6MB)테스트 8 〉 통과 (0.04ms, 54.8MB)테스트 9 〉 통과 (0.06ms, 54.6MB)테스트 10 〉 통과 (0.05ms, 55.3MB)테스트 11 〉 통과 (0.04ms, 54.7MB)테스트 12 〉 통과 (0.05ms, 55MB)테스트 13 〉 통과 (0.04ms, 54.5MB)","link":"/2021/06/26/programmers-42842/"},{"title":"[코틀린 자료구조] 연결 리스트 (Linked List)","text":"Linked List(연결 리스트)는 선형, 단방향 시퀀스로 배열된 값의 모음이다. linked list는 Kotlin Array, ArrayList와 같은 연속적인 저장소 옵션들(contiguous storage options)에 비해 몇 가지 이론적인 장점이 있다. 리스트의 앞부분에서 상수 시간 삽입 및 제거 수행 안정적인 성능 다이어그램이 보여주듯, linked list는 노드들의 체인이다. 노드는 두 가지의 책임을 가지고 있다. 값을 가지고 있어야한다. 다음 노드에 대한 참조를 가지고 있어야 한다. 다음 노드에 대한 참조가 없다면 null을 통해 리스트의 끝을 나타낸다. Node Node.kt 123456789data class Node&lt;T&gt;(var value: T, var next: Node&lt;T&gt;? = null) { override fun toString(): String { return if (next != null) { &quot;$value -&gt; ${next.toString()}&quot; } else { &quot;$value&quot; } }} 테스트 (Main.kt) 1234567891011fun main() { // 노드 생성 및 연결하기 val node1 = Node(value = 1) val node2 = Node(value = 2) val node3 = Node(value = 3) node1.next = node2 node2.next = node3 println(node1)} 11 -&gt; 2 -&gt; 3 이런 방법으로 리스트를 작성하는 것은 실용적이지 못하다. 이러한 문제를 해결시켜주는 일반적인 방법은 Node 객체들을 관리하는 LinkedList를 사용하는 것이다. LinkedList LinkedList.kt 1234567891011121314151617class LinkedList&lt;T&gt; { private var head: Node&lt;T&gt;? = null private var tail: Node&lt;T&gt;? = null private var size = 0 fun isEmpty(): Boolean { return size == 0 } override fun toString(): String { return if (isEmpty()) { &quot;Empty list&quot; } else { head.toString() } }} Linked list에는 첫 번째와 마지막 노드를 각각 참조하는 head와 tail의 개념이 있다. 또한 size 속성(property)에서 linked list의 크기를 추적할 수 있다. 리스트에 값들을 추가하기 다음으로, Node 객체를 관리하기 위한 인터페이스를 작성한다. 먼저 값 추가를 처리한다. Linked list에 값을 추가하는 방법에는 세 가지가 있으며, 각각 고유한 성능 특징을 지니고 있다. push : 리스트의 맨 앞에 값을 추가 append : 리스트의 끝에 값을 추가 insert : 리스트의 특정 노드 뒤에 값을 추가 이들 각각을 차례로 구현하고 성능 특징을 분석해본다. push 연산 리스트의 맨 앞에 값을 추가하는 것은 push 연산으로 알려져 있다. 또한 head-first insertion이라고도 한다. push 연산의 코드는 매우 간단하다. push(…) (LinkedList.kt) 1234567fun push(value: T) { head = Node(value = value, next = head) if (tail == null) { tail = head } size += 1} 빈 리스트에 값을 push할 경우, 새로운 노드는 리스트의 head와 tail이 된다. 리스트에 새로운 노드가 추가되었기 때문에 size의 값도 증가시켜준다. 테스트 (Main.kt) 123456789fun main() { // push 예시 val list = LinkedList&lt;Int&gt;() list.push(3) list.push(2) list.push(1) println(list)} 11 -&gt; 2 -&gt; 3 이대로도 괜찮지만 더욱 멋지게 개선할 수 있다. Fluent interface 패턴을 사용하여 여러 push 호출을 연결할 수 있다. push()로 돌아가서 LinkedList&lt;T&gt;를 반환 타입으로 추가한다. 그런 다음 마지막 줄에 return this를 추가하여 방금 요소를 push한 목록을 반환한다. Fluent interface pattern push(…) (LinkedList.kt) 12345678fun push(value: T): LinkedList&lt;T&gt; { head = Node(value = value, next = head) if (tail == null) { tail = head } size += 1 return this} 테스트 (Main.kt) 123456fun main() { // fluent interface push 예시 val list = LinkedList&lt;Int&gt;() list.push(3).push(2).push(1) println(list)} Fluent interface 패턴을 통해 복수의 요소들을 리스트의 시작 부분에 쉽게 추가할 수 있게 되었다. append 연산 append 연산은 리스트의 끝에 값을 추가하며, tail-end insertion이라고도 한다. append(…) (LinkedList.kt) 123456789101112fun append(value: T) { // ➀ if (isEmpty()) { push(value) return } // ➁ tail?.next = Node(value = value) // ➂ tail = tail?.next size += 1} 이전과 마찬가지로 리스트가 비어있으면 head와 tail을 모두 새 노드로 업데이트해야한다. 빈 리스트에 추가하는 것은 기능적으로 push와 동일하므로 push를 호출하여 작업을 수행한다. 다른 모든 경우에는 현재 tail 노드 뒤에 새 노드를 만든다. if 문에서 리스트가 비어있는 경우(isEmpty())를 이미 처리 했으므로 tail은 여기서 null이 되지 않는다. tail-end insertion이므로 새 노드도 리스트의 tail이 된다. 테스트 (Main.kt) 1234567fun main() { val list = LinkedList&lt;Int&gt;() list.append(1) list.append(2) list.append(3) println(list)} append도 물론 Fluent interface 패턴을 적용시킬 수 있다! Fluent interface pattern append(…) (LinkedList.kt) 12345678910fun append(value: T): LinkedList&lt;T&gt; { if (isEmpty()) { push(value) return this } tail?.next = Node(value = value) tail = tail?.next size += 1 return this} insert 연산 insert 연산은 리스트의 지정된 위치에 값을 삽입하며 두 단계가 필요하다. 리스트에서 지정된 노드를 찾는다. 지정된 노드의 뒤에 새로운 노드를 삽입한다. 먼저 값을 삽일할 노드를 찾는 코드를 구현하자. nodeAt(…) (LinkedList.kt) 1234567891011fun nodeAt(index: Int): Node&lt;T&gt;? { // ➀ var currentNode = head var currentIndex = 0 // ➁ while (currentNode != null &amp;&amp; currentIndex &lt; index) { currentNode = currentNode.next currentIndex += 1 } return currentNode} nodeAt()은 주어진 인덱스를 기반으로 리스트에서 노드 검색을 시도한다. head 노드에서만 리스트의 노드에 접근할 수 있으므로 반복 순회(iterative traversals)를 수행해야 한다. head에 대한 새 참조를 만들고 현재 순회 수를 추적한다. while 루프를 사용하여 원하는 인덱스에 도달할 때까지 리스트 참조를 다음으로 이동시킨다. 빈 리스트 또는 범위를 벗어난 인덱스는 null을 반환한다. 이제 새로운 노드를 삽입해보자. insert(…) (LinkedList.kt) 12345678910111213fun insert(value: T, afterNode: Node&lt;T&gt;): Node&lt;T&gt; { // ① if (tail == afterNode) { append(value) return tail!! } // ② val newNode = Node(value = value, next = afterNode.next) // ③ afterNode.next = newNode size += 1 return newNode} 수행한 작업은 다음과 같다. 이 메서드가 tail 노드와 함께 호출되는 경우, 기능적으로 동일한 append 메서드를 호출할 수 있다. 이것은 tail의 업데이트를 처리한다. 그렇지 않으면, 새 노드를 만들고 next 속성을 리스트의 다음 노드에 연결한다. 지정된 노드의 next 값을 다시 할당하여 방금 만든 새 노드에 연결한다. 테스트 (Main.kt) 123456789101112fun main() { val list = LinkedList&lt;Int&gt;() list.push(3) list.push(2) list.push(1) println(&quot;Before inserting: $list&quot;) var middleNode = list.nodeAt(1)!! for (i in 1..3) { middleNode = list.insert(-1 * i, middleNode) } println(&quot;After inserting: $list&quot;)} 12Before inserting: 1 -&gt; 2 -&gt; 3After inserting: 1 -&gt; 2 -&gt; -1 -&gt; -2 -&gt; -3 -&gt; 3 성능 분석 push append insert nodeAt 행동 head에 삽입 tail에 삽입 노드 뒤에 삽입 주어진 인덱스의 노드를 반환 시간 복잡도 O(1) O(1) O(1) O(i), i는 주어진 인덱스 리스트에서 값들을 제거하기 노드의 제거에는 3가지 대표적인 연산들이 있다. pop : 리스트 앞부분의 값을 제거 removeLast : 리스트 끝에 있는 값을 제거 removeAfter : 리스트의 어느 곳의 값이든 제거 pop 연산 pop() (LinkedList.kt) 123456789fun pop(): T? { if (!isEmpty()) size -= 1 val result = head?.value head = head?.next if (isEmpty()) tail = null return result} pop()은 리스트에서 제거된 값을 반환한다. 리스트가 비어있을 수 있으므로 이 값은 head를 다음 노드로 이동시켜 리스트의 첫 번째 노드를 효과적으로 제거할 수 있다. 더 이상 연결된 참조가 없기 때문에 가비지 컬렉터는 메서드가 완료되면 메모리에서 이전 노드를 제거한다. 리스트가 비어 있으면 tail도 null로 설정한다. 테스트 (Main.kt) 12345678910fun main() { val list = LinkedList&lt;Int&gt;() list.push(3) list.push(2) list.push(1) println(&quot;Before popping list: $list&quot;) val poppedValue = list.pop() println(&quot;After popping list: $list&quot;) println(&quot;Popped value: $poppedValue&quot;)} 123Before popping list: 1 -&gt; 2 -&gt; 3After popping list: 2 -&gt; 3Popped value: 1 removeLast 연산 리스트의 마지막 노드를 제거하는 것은 다소 번거로운 작업이다. tail 노드에 대한 참조가 있더라도 그 앞에 노드에 대한 참조가 없으면 잘라낼 수 없다. 따라서 마지막 노드 이전의 노드를 찾으려면 전체 리스트를 탐색해야한다. removeLast() (LinkedList.kt) 123456789101112131415161718192021fun removeLast(): T? { // ① val head = head ?: return null // ② if (head.next == null) return pop() // ③ size -= 1 // ④ var prev = head var current = head var next = current.next while (next != null) { prev = current current = next next = current.next } // ⑤ prev.next = null tail = prev return current.value} head가 null이면 제거할 항목이 없으므로 null을 반환한다. 목록이 하나의 노드로만 구성된 경우 removeLast는 기능적으로 pop과 동일하다. pop은 head 및 tail의 참조를 업데이트하는 것을 처리하므로 이 작업을 pop 함수에 위임할 수 있다. 이 시점에서 노드를 제거 할 것임을 알고 있으므로 그에 따라 목록의 크기를 업데이트한다. current.next가 null이 될 때까지 다음 노드를 계속 검색한다. 이것은 current가 목록의 마지막 노드임을 나타낸다. current가 마지막 노드이므로 prev.next 참조를 사용하여 연결을 끊는다. tail의 참조도 업데이트해야 한다. 테스트 (Main.kt) 12345678910fun main() { val list = LinkedList&lt;Int&gt;() list.push(3) list.push(2) list.push(1) println(&quot;Before removing last node: $list&quot;) val removedValue = list.removeLast() println(&quot;After removing last node: $list&quot;) println(&quot;Removed value: $removedValue&quot;)} 123Before removing last node: 1 -&gt; 2 -&gt; 3After removing last node: 1 -&gt; 2Removed value: 3 removeLast()를 사용하려면 리스트를 순회해야 한다. 이것은 비교적 비용이 많이 드는 O(n) 연산을 하게 된다. remove 연산 remove 연산은 리스트의 특정 지점에서 노드를 제거하는 것이다. 이것은 insert()와 매우 유사하다. 먼저 제거하려는 노드의 바로 앞 노드를 찾은 다음 연결을 해제(unlink)해야 한다. removeAfter() (LinkedList.kt) 123456789fun removeAfter(node: Node&lt;T&gt;): T? { val result = node.next?.value if (node.next == tail) tail = node if (node.next != null) size -= 1 node.next = node.next?.next return result} tail 참조를 업데이트해야 하므로 제거된 노드가 tail 노드인 경우 특별한 주의가 필요하다. 테스트 (Main.kt) 123Before removing at particular index: 1 -&gt; 2 -&gt; 3After removing at index 1: 1 -&gt; 3Removed value: 2 insert()와 유사하게 이 작업의 시간 복잡도는 *O(1)*이지만 미리 특정 노드에 대한 참조가 있어야 한다. 성능 분석 pop removeLast removeAfter 행동 head를 제거 tail을 제거 바로 다음 노드를 제거 시간 복잡도 O(1) O(n) O(1) 지금까지 대부분의 프로그래머가 공감할 수 있는 linked list에 대한 인터페이스를 정의했다. 하지만 Kotlin semantic을 더욱 돋보이게 하려면 수행해야 할 작업이 존재한다. 본문의 다음 절반에서는 Kotlin의 관용적(idomatic)인 부분을 활용하여 더 나은 인터페이스를 만드는데 초점을 맞출 것이다. Kotlin collection interfaces Kotlin 표준 라이브러리에는 특정 유형에 대해 예상되는 사항을 정의하는데 도움이 되는 인터페이스 모음이 있다. 이러한 각 인터페이스는 특성과 성능에 대한 특정한 보증을 제공한다. 이러한 인터페이스 모음 중 4개를 컬렉션 인터페이스라고 한다. 다음은 각 인터페이스가 나타내는 작은 예시들이다. Iterable : iterable 타입은 Iterator를 통해 요소들에 대한 순차적 접근을 제공한다. Collection : 컬렉션 타입은 추가 기능을 제공하는 iterable 타입으로, 컬렉션이 특정 요소 또는 요소들의 컬렉션을 포함하고 있는지 확인할 수 있게 해준다. MutableIterable : 주어진 컬렉션에서 항목들을 제거할 수 있는 MutableIterator를 제공한다. MutableCollection : 단순 컬렉션과 달리, MutableCollection 인터페이스는 컬렉션을 변경하는 메서드를 제공한다. 예를 들어, 요소를 추가 및 제거할 수 있으며 전체 컬렉션을 지울 수도 있다. Linked list는 컬렉션 인터페이스의 계층 4에 도달 할 수 있습니다. Linked list는 연결된 노드들이므로(chain of nodes) Iterable 인터페이스를 채택하는 것이 합리적이다. 이미 요소 추가 및 제거를 구현 했으므로 MutableCollection 인터페이스로 이동할 수 있다는 것이 매우 분명하다. Data Structures & Algorithms in Kotlin 서적을 참고하여 작성했습니다.","link":"/2021/06/27/data-structure-linked-list/"},{"title":"[BOJ] 다이나믹 프로그래밍 (Dynamic Programming, DP)","text":"여러 개의 하위 문제를 먼저 푼 후 그 결과를 쌓아올려 주어진 문제를 해결하는 알고리즘 DP를 푸는 과정 테이블 정의하기 점화식 찾기 초기값 정하기 연습 문제 BOJ 1463 : 1로 만들기 DP 123456789101112131415import java.util.*import kotlin.math.*fun main() = with(Scanner(System.`in`)) { val n = nextInt() val d = IntArray(n + 1) for (i in 2..n) { d[i] = d[i - 1] + 1 if (i % 2 == 0) d[i] = min(d[i], d[i / 2] + 1) if (i % 3 == 0) d[i] = min(d[i], d[i / 3] + 1) } println(d[n])} BFS 123456789101112131415161718192021222324252627282930import java.util.*fun main() = with(Scanner(System.`in`)) { val n = nextInt() val queue: Queue&lt;Int&gt; = LinkedList() val dist = IntArray(n + 1) val dx = intArrayOf(1, 2, 3) dist[1] = 0 queue.offer(1) while (queue.isNotEmpty()) { val cur = queue.poll() for (dir in dx.indices) { val next = when (dir) { 0 -&gt; cur + dx[0] else -&gt; cur * dx[dir] } if (next &gt; n) continue if (dist[next] != 0) continue dist[next] = dist[cur] + 1 queue.offer(next) } } println(dist[n])} BOJ 9095 : 1, 2, 3 더하기 12345678910111213141516import java.util.*fun main() = with(Scanner(System.`in`)) { val t = nextInt() val d = IntArray(11) d[1] = 1 d[2] = 2 d[3] = 4 for (i in 4 until 11) { d[i] = d[i - 1] + d[i - 2] + d[i - 3] } repeat(t) { println(d[nextInt()]) }} BOJ 2579 : 계단 오르기 2차원 배열 이용 123456789101112131415161718192021222324252627import java.util.*import kotlin.math.maxfun main() = with(Scanner(System.`in`)) { val n = nextInt() val s = IntArray(n + 1) val d = Array(n + 1) { IntArray(3) } for (i in 1..n) s[i] = nextInt() if (n == 1) { println(s[1]) return@with } d[1][1] = s[1] d[1][2] = 0 d[2][1] = s[2] d[2][2] = s[1] + s[2] for (i in 3..n) { d[i][1] = max(d[i - 2][1], d[i - 2][2]) + s[i] d[i][2] = d[i - 1][1] + s[i] } println(max(d[n][1], d[n][2]))} D[i][j] = 현재까지 j개의 계단을 연속해서 밟고 i번째 계단까지 올라섰을 때 점수 합의 최댓값, 단 i번째 계단은 반드시 밟아야 함 이렇게 2차원 배열을 선언한 이유는 지금까지 몇 개의 계단을 밟았는지에 대한 정보가 추가로 있어야 점화식을 세울 때 계단을 오르는 규칙을 고려할 수 있기 때문이다. 그리고 i번째 계단은 반드시 밟아야 한다는 조건이 있어야 점화식을 이끌어낼 수 있다. 이 2차원 배열에서 j는 어떤 값을 가지냐 보면 i번째 계단을 반드시 밟아야 한다는 조건이 있어서 j = 1 혹은 2이다. 연속된 세 개의 계단을 모두 밟아서는 안된다는 조건으로 인해 j가 3 이상일 수는 없다. 1차원 배열 이용 1234567891011121314151617181920import java.util.*import kotlin.math.maxfun main() = with(Scanner(System.`in`)) { val n = nextInt() val s = IntArray(300) val d = IntArray(300) for (i in 0 until n) s[i] = nextInt() d[0] = s[0] d[1] = max(s[0] + s[1], s[1]) d[2] = max(s[0] + s[2], s[1] + s[2]) for (i in 3 until n) { d[i] = max(d[i - 2] + s[i], d[i - 3] + s[i - 1] + s[i]) } println(d[n - 1])} BOJ 1149 : RGB거리 12345678910111213141516171819202122232425262728import java.util.*import kotlin.math.mindata class RGB(var red: Int, var green: Int, var blue: Int)fun main() = with(Scanner(System.`in`)) { val n = nextInt() val colors = Array(n + 1) { RGB(0, 0, 0) } val d = Array(n + 1) { IntArray(3) } for (i in 0 until n) { colors[i].red = nextInt() colors[i].green = nextInt() colors[i].blue = nextInt() } d[0][0] = colors[0].red d[0][1] = colors[0].green d[0][2] = colors[0].blue for (i in 1 until n) { d[i][0] = min(d[i-1][1], d[i-1][2]) + colors[i].red d[i][1] = min(d[i-1][0], d[i-1][2]) + colors[i].green d[i][2] = min(d[i-1][0], d[i-1][1]) + colors[i].blue } println(minOf(d[n - 1][0], d[n - 1][1], d[n - 1][2]))} BOJ 11726 : 2×n 타일링 1234567891011121314import java.util.*fun main() = with(Scanner(System.`in`)) { val n = nextInt() val d = IntArray(n + 3) val mod = 10007 d[1] = 1 d[2] = 2 for (i in 3..n) d[i] = (d[i - 1] + d[i - 2]) % mod println(d[n])} BOJ 11659 : 구간 합 구하기 4 Prefix Sum 기법 Prefix Sum은 시작 위치부터 현재 위치까지의 원소 합을 저장하는 배열이다. 부분 합(partial sum) 또는 누적 합(cumulative sum)이라고도 한다. Number 1 2 3 4 5 Prefix sum 1 3 6 10 15 Prefix sum은 누적 합을 미리 구하는 전처리 과정을 통해 구간 합(range sum)을 빠르게 구할 때 사용된다. prefix sum : 0 ~ b 까지의 누적합 (반드시 첫번 째 원소를 포함하는 구간) range sum : a ~ b 까지의 구간 합 시간 복잡도 전처리 단계 1차원 : O(n) 2차원 : O(n*m) 계산 : O(1) 123456789101112131415161718import java.util.*fun main() = with(Scanner(System.`in`)) { val (n, m) = nextInt() to nextInt() val d = IntArray(n + 1) val a = IntArray(n + 1) d[0] = 0 for (i in 1..n) { a[i] = nextInt() d[i] = d[i - 1] + a[i] } repeat(m) { val (i, j) = nextInt() to nextInt() println(d[j] - d[i - 1]) }} 12345678910// O(n^2)D[i] = A[i] + A[2] + … + A[i]// O(n)D[i] = D[i-1] + A[i]// O(1)A[i] + A[i+1] + … + A[j]= (A[1] + A[2] + … + A[j]) - (A[1] + A[2] + … + A[i-1])= D[j] - D[i-1] 경로 추적 BOJ 12852 : 1로 만들기 2 123456789101112131415161718192021222324252627282930313233import java.util.*fun main() = with(Scanner(System.`in`)) { val n = nextInt() val d = IntArray(n + 1) val pre = IntArray(n + 1) d[1] = 0 for (i in 2..n) { d[i] = d[i - 1] + 1 pre[i] = i - 1 if (i % 2 == 0 &amp;&amp; d[i] &gt; d[i / 2] + 1) { d[i] = d[i / 2] + 1 pre[i] = i / 2 } if (i % 3 == 0 &amp;&amp; d[i] &gt; d[i / 3] + 1) { d[i] = d[i / 3] + 1 pre[i] = i / 3 } } println(d[n]) var cur = n while (true) { print(&quot;$cur &quot;) if (cur == 1) break cur = pre[cur] }} 위 문제를 BFS로 경로 복원 문제 풀이도 가능하다. 참고 바킹독의 실전 알고리즘 - https://www.youtube.com/watch?v=5leTtB3PQu0 Prefix sum - https://gamedevlog.tistory.com/68","link":"/2021/06/30/boj-dynamic-programming/"},{"title":"[BOJ] BFS (Breadth First Search)","text":"설명 다차원 배열에서 각 칸을 방문할 때 너비를 우선으로 방문하는 알고리즘 시작하는 칸을 큐에 넣고 방문했다는 표시를 남김 큐에서 원소를 꺼내어 그 칸에 상하좌우로 인접한 칸에 대해 3번을 진행 해당 칸을 이전에 방문했다면 아무것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 큐에 삽입 큐가 빌 때까지 2번을 반복 모든 칸이 큐에 1번씩 들어가므로 시간복잡도는 칸이 N개일 때 O(N) BFS 구현 시 자주하는 실수 시작점을 큐에 넣긴하는데 정작 방문했다는 표시를 남기지 않은 채로 진행하는 경우 큐에 넣을 때 해당 칸에 방문했다는 표시를 남기지 않고 큐에서 빼낼 때 남기는 경우 nx, ny가 배열 바깥으로 벗어났는지에 대한 루틴을 아예 빼먹었거나, 아니면 이상하게 구현을 한 상황 예시 및 응용 예시 : Flood Fill BOJ 1926, 그림 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.*import kotlin.math.maxfun main() = with(Scanner(System.`in`)) { val (n, m) = Pair(nextInt(), nextInt()) val (dx, dy) = intArrayOf(1, 0, -1, 0) to intArrayOf(0, 1, 0, -1) // 상하좌우 네 방향을 의미 val paper = Array(n) { IntArray(m) } val visitMap = Array(n) { BooleanArray(m) } // 해당 칸을 방문했는지 여부를 저장 var max = 0 // 그림의 최댓값 var num = 0 // 그림의 개수 for (i in paper.indices) { for (j in paper[i].indices) { paper[i][j] = nextInt() } } for (i in paper.indices) { for (j in paper[i].indices) { if (paper[i][j] == 0 || visitMap[i][j]) continue val queue: Queue&lt;Pair&lt;Int, Int&gt;&gt; = LinkedList() var area = 0 num += 1 visitMap[i][j] = true queue.offer(i to j) while (queue.isNotEmpty()) { area += 1 val cur = queue.poll() for (dir in 0 until 4) { // 상하좌우 칸을 탐색 val nx = cur.first + dx[dir] val ny = cur.second + dy[dir] // nx, ny에 dir에서 정한 방향의 인접한 칸의 좌표가 들어감 if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue // 범위 밖일 경우 넘어감 if (visitMap[nx][ny]|| paper[nx][ny] != 1) continue // 이미 방문한 칸이거나 색칠된 칸이 아닐 경우 visitMap[nx][ny] = true // (nx, ny)를 방문했다고 명시 queue.offer(nx to ny) } } max = max(max, area) } } println(&quot;$num\\n$max&quot;)} 응용 1 : 거리 측정 BOJ 2178번, 미로 탐색 123456789101112131415161718192021222324252627282930313233343536import java.util.*fun main() = with(Scanner(System.`in`)) { val (n, m) = nextInt() to nextInt() val (dx, dy) = intArrayOf(1, 0, -1, 0) to intArrayOf(0, 1, 0, -1) val maze = Array(n) { IntArray(m) } val dist = Array(n) { IntArray(m) { -1 } } for (i in 0 until n) { // 각각의 수들은 '붙어서' 입력으로 주어진다. val line = next() for (j in 0 until m) { maze[i][j] = line[j] - '0' } } val queue: Queue&lt;Pair&lt;Int, Int&gt;&gt; = LinkedList() queue.offer(0 to 0) dist[0][0] = 0 while (queue.isNotEmpty()) { val (curX, curY) = queue.poll() for (dir in 0 until 4) { val nx = curX + dx[dir] val ny = curY + dy[dir] if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue if (dist[nx][ny] &gt;= 0 || maze[nx][ny] != 1) continue dist[nx][ny] = dist[curX][curY] + 1 queue.offer(nx to ny) } } print(dist[n - 1][m - 1] + 1) // 지나는 칸 수를 출력이므로 + 1} 응용 2 : 시작점이 여러 개일 때 BOJ 7576번, 토마토 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.*fun main() = with(Scanner(System.`in`)) { var date = 0 val (m, n) = nextInt() to nextInt() val (dx, dy) = intArrayOf(1, 0, -1, 0) to intArrayOf(0, 1, 0, -1) val box = Array(n) { IntArray(m) } val vis = Array(n) { BooleanArray(m) { false } } for (i in 0 until n) { for (j in 0 until m) { box[i][j] = nextInt() } } val queue: Queue&lt;Pair&lt;Int, Int&gt;&gt; = LinkedList() for (i in 0 until n) { for (j in 0 until m) { if (box[i][j] == 1) { queue.offer(i to j) vis[i][j] = true } } } val temp = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;() while (queue.isNotEmpty()) { for (rottenNum in 0 until queue.size) { val (curX, curY) = queue.poll() for (dir in 0 until 4) { val (nx, ny) = curX + dx[dir] to curY + dy[dir] if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue if (box[nx][ny] == 1 || box[nx][ny] == -1 || vis[nx][ny]) continue vis[nx][ny] = true box[nx][ny] = 1 temp.add(nx to ny) } } temp.forEach { queue.offer(it) } temp.clear() date += 1 } for (i in 0 until n) { for (j in 0 until m) { if (box[i][j] == 0) date = 0 } } print(date - 1)} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.*import kotlin.math.maxfun main() = with(Scanner(System.`in`)) { var date = 0 val (m, n) = nextInt() to nextInt() val (dx, dy) = intArrayOf(1, 0, -1, 0) to intArrayOf(0, 1, 0, -1) val box = Array(n) { IntArray(m) } val dist = Array(n) { IntArray(m) } // 익은 토마토가 들어있거나 토마토가 없는 칸은 값이 0 val queue: Queue&lt;Pair&lt;Int, Int&gt;&gt; = LinkedList() for (i in 0 until n) { for (j in 0 until m) { box[i][j] = nextInt() when (box[i][j]) { 1 -&gt; queue.offer(i to j) // 익은 토마토, 즉 거리가 0인 칸을 큐에 넣음 0 -&gt; dist[i][j] = -1 // 익지 않은 토마토의 dist값을 -1로 설정 } } } while (queue.isNotEmpty()) { val (curX, curY) = queue.poll() for (dir in 0 until 4) { val (nx, ny) = curX + dx[dir] to curY + dy[dir] if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue if (dist[nx][ny] &gt;= 0) continue dist[nx][ny] = dist[curX][curY] + 1 queue.offer(nx to ny) } } for (i in 0 until n) { for (j in 0 until m) { if (dist[i][j] == -1) { // 익지 않은 토마토가 있다면 -1 출력 print(-1) return } date = max(date, dist[i][j]) } } print(date)} 응용 3 : 시작점이 두 종류일 때 BOJ 4179번, 불! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.*fun main() = with(Scanner(System.`in`)) { val (row, col) = nextInt() to nextInt() val (dx, dy) = intArrayOf(1, 0, -1, 0) to intArrayOf(0, 1, 0, -1) val maze = Array(row) { CharArray(col) } val fireDist = Array(row) { IntArray(col) { -1 } } // 불의 전파 시간 val jihoonDist = Array(row) { IntArray(col) { -1 } } // 지훈이의 이동 시간 val fireQueue: Queue&lt;Pair&lt;Int, Int&gt;&gt; = LinkedList() val jihoonQueue: Queue&lt;Pair&lt;Int, Int&gt;&gt; = LinkedList() for (i in 0 until row) { val line = next() for (j in 0 until col) { maze[i][j] = line[j] if (maze[i][j] == 'F') { fireQueue.offer(i to j) fireDist[i][j] = 0 } if (maze[i][j] == 'J') { jihoonQueue.offer(i to j) jihoonDist[i][j] = 0 } } } // 불에 대한 BFS while (fireQueue.isNotEmpty()) { val (curX, curY) = fireQueue.poll() for (dir in 0 until 4) { val (nx, ny) = curX + dx[dir] to curY + dy[dir] if (nx &lt; 0 || nx &gt;= row || ny &lt; 0 || ny &gt;= col) continue if (fireDist[nx][ny] &gt;= 0 || maze[nx][ny] == '#') continue fireDist[nx][ny] = fireDist[curX][curY] + 1 fireQueue.offer(nx to ny) } } // 지훈이에 대한 BFS while (jihoonQueue.isNotEmpty()) { val (curX, curY) = jihoonQueue.poll() for (dir in 0 until 4) { val (nx, ny) = curX + dx[dir] to curY + dy[dir] // 범위를 벗어난 것은 탈출에 성공했다는 의미. 큐에 거리 순으로 들어가므로 최초에 탈출한 시간을 출력하면 됨. if (nx &lt; 0 || nx &gt;= row || ny &lt; 0 || ny &gt;= col) { println(jihoonDist[curX][curY] + 1) return } if (jihoonDist[nx][ny] &gt;= 0 || maze[nx][ny] == '#') continue if (fireDist[nx][ny] != -1 &amp;&amp; fireDist[nx][ny] &lt;= jihoonDist[curX][curY] + 1) continue // 불의 전파 시간을 조건에 추가. 지훈이 도착한 시간과 동시에, 혹은 더 빨리 불이 도착하는 자리로는 갈 수 없음. jihoonDist[nx][ny] = jihoonDist[curX][curY] + 1 jihoonQueue.offer(nx to ny) } } print(&quot;IMPOSSIBLE&quot;)} fireDist[nx][ny] != -1 조건이 필요한 이유를 설명해주는 input 케이스 12343 4###F.J#.###. continue를 사용하지 않고 조건을 만족할 떄 로직을 실행 123456789...if (jihoonDist[nx][ny] == -1 &amp;&amp; maze[nx][ny] != '#') { if (fireDist[nx][ny] == -1 || fireDist[nx][ny] &gt; jihoonDist[curX][curY] + 1) { jihoonDist[nx][ny] = jihoonDist[curX][curY] + 1 jihoonQueue.offer(nx to ny) }}... maze 초기화 시 forEachIndeded 사용하는 방법 123456for (i in 0 until row) { next().forEachIndexed { j, char -&gt; maze[i][j] = char ... } } 이렇게 시작점이 두 종류인 문제를 해결할 수 있게 되었다. 하지만 시작점이 두 종류인 문제에 관해서 생각해야 할 점이 추가로 존재한다. 본 문제는 지훈이의 이동은 불의 전파에 영향을 받지만 불의 전파는 지훈이의 이동에 영향을 받지 않아서 불만 먼저 전파를 쭉 시키는게 가능했다. 그러나 시작점이 A, B 두 종류가 있고, A의 전파에 B가 영향을 주고 B의 전파에도 A가 영향을 준다고 가정해본다면 어느 하나를 먼저 끝까지 전파시키는게 불가능하다. (예를 들어, 불과 소방수 내지는 불과 물이 전파되는 문제여서 둘이 만나면 뭔가 상호작용이 발생하는 케이스) 위의 케이스를 다루는 문제가 바로 BOJ 18809번, Gaaaaaaaaaarden 문제이다. 아쉽게도 이 문제는 백트래킹 기법을 추가로 알고 있어야 해결이 가능하기 때문에 당장 풀어볼 수는 없지만, 두 종류의 BFS에서 BFS를 돌 때 어느 하나가 독립적이지 않고 서로에게 영향을 준다면 위의 방법으로는 해결할 수 없다는 것을 꼭 이해해야 한다. 그런 상황에서는 시간 순으로 A와 B를 동시에 진행시켜야 한다. 응용 4 : 1차원에서의 BFS BOJ 1697번, 숨바꼭질 123456789101112131415161718192021222324252627import java.util.*fun main() = with(Scanner(System.`in`)) { val (n, k) = nextInt() to nextInt() val line = Array(100001) { -1 } val queue: Queue&lt;Int&gt; = LinkedList() line[n] = 0 queue.offer(n) while (queue.isNotEmpty()) { val current = queue.poll() val dx = intArrayOf(1, -1, current) for (dir in dx.indices) { val next = current + dx[dir] if (next &lt; 0 || next &gt; 100000) continue if (line[next] != -1) continue line[next] = line[current] + 1 queue.offer(next) } } print(line[k])} References [바킹독의 실전 알고리즘] 0x09강 - BFS","link":"/2021/07/01/boj-bfs/"},{"title":"[코틀린 자료구조] 스택 (Stack)","text":"스택의 연산들 스택에는 오직 두 개의 필수적인 연산들이 존재한다. push : 스택 맨 위에 요소를 추가 pop : 스택 맨 위의 요소를 제거 즉, 스택은 한 쪽에서만 요소의 추가나 제거가 가능한 자료구조이다. Computer science에선 스택은 LIFO(last-in first-out) 자료구조라고도 한다. 마지막에 들어간(push) 요소들은 가장 먼저 나온다(pop). stack 패키지 내부에 Stack 인터페이스 선언 (stack/Stack.kt) 1234interface Stack&lt;T : Any&gt; { fun push(element: T) fun pop(): T?} 1※ 위의 Stack 인터페이스는 Vector 클래스를 상속받고 본문에서 필요로 하지 않는 메서드들을 제공하는 Kotlin과 Java의 Stack 클래스와 다르다. 스택은 다음과 같은 프로그래밍 분야에서 눈에 띄게 사용된다. 안드로이드는 fragment stack을 사용하여 Activity의 안팎으로 fragment들을 push 및 pop을 한다. 메모리 할당은 아키텍처 수준에서 스택을 사용한다. 지역 변수의 메모리도 스택을 사용하여 관리된다. 미로에서 길을 찾는 것과 같은 Search and conquer 알고리즘은 스택을 사용하여 백트래킹을 용이하게 한다. 구현 다양한 방식으로 Stack 인터페이스를 구현할 수 있는데 올바른 storage type을 선택하는 것이 중요하다. ArrayList는 마지막 인덱스를 매개변수로 사용하여 add 및 removeAt을 통해 한쪽 끝에서 O(1)(상수 시간) 삽입 및 삭제를 제공하므로 확실한 선택이다. 이 두 연산을 사용하면 스택의 LIFO 특성이 쉽게 구현된다. StackImpl 클래스에 toString 재정의 (StackImpl.kt) 12345678910class StackImpl&lt;T : Any&gt; : Stack&lt;T&gt; { private val storage = arrayListOf&lt;T&gt;() override fun toString() = buildString { appendLine(&quot;----top----&quot;) storage.asReversed().forEach { appendLine(&quot;$it&quot;) } appendLine(&quot;-----------&quot;) }} 데이터에 대해 ArrayList 유형의 private property를 정의하고 디버그 목적으로 해당 내용을 표시하기 위해 toString 메서드를 재정의한다. (이 코드를 사용하면 아직 push 및 pop 연산을 구현하지 않았기에 오류가 발생한다.) push 및 pop 연산 push 및 pop 추가 (StackImpl.kt) 12345678910override fun push(element: T) { storage.add(element)}override fun pop(): T? { if (storage.size == 0) { return null } return storage.removeAt(storage.size - 1)} push 메서드에서 ArrayList의 add 메서드를 이용해서 매개변수로 전달된 값을 ArrayList의 끝에 추가한다(append). pop 메서드는 ArrayList가 비어 있으면 null을 반환하고 그렇지 않다면 마지막에 삽입한 요소를 제거하고 반환한다. 아래의 코드를 통해 직접 구현한 스택이 올바르게 작동하는지 확인한다. 테스트용 코드 작성 (Main.kt) 123456789101112131415fun main() { val stack = StackImpl&lt;Int&gt;().apply { push(1) push(2) push(3) push(4) } print(stack) val poppedElement = stack.pop() if (poppedElement != null) { println(&quot;Popped: $poppedElement&quot;) } print(stack)} 123456789101112----top----4321-----------Popped: 4----top----321----------- push 및 pop은 둘 다 O(1) 시간 복잡도를 가진다. 유용한 추가 연산들 스택을 더 쉽게 사용할 수 있는 몇 가지 유용한 연산들을 추가한다. Stack 인터페이스에 peek 추가 (stack/Stack.kt) 1234567891011interface Stack&lt;T : Any&gt; { ... fun peek(): T? val count: Int get val isEmpty: Boolean get() = count == 0} peek의 개념은 내용을 변경하지 않고 스택의 맨 위 요소를 보는 것이다. count 속성은 스택의 요소 수를 반환하며 isEmpty 속성을 구현하는데 사용된다. peek 구현하기 (StackImpl.kt) 12345override fun peek(): T? { return storage.lastOrNull()}override val count: Int get() = storage.size peek을 구현함으로써 pop의 구현을 더 깔끔한 코드로 변경할 수 있다. pop 코드를 더 깔끔하게 수정 123456override fun pop(): T? { if (isEmpty) { return null } return storage.removeAt(storage.size - 1)} 스택과 Kotlin Collection Interfaces 스택에 Kotlin Collection 인터페이스를 채택할 수 있을지 궁금할 수 있다. 스택의 목적은 데이터에 액세스하는 방법의 수를 제한하는 것인데, Iterable과 같은 인터페이스를 채택하면 iterator를 통해 모든 요소들을 노출함으로써 당초의 목표와 어긋나게 된다. 액세스 순서가 보장되도록 기존의 List를 가져와 스택으로 변환하는 것을 원할 수 있다. 물론 배열의 요소들을 순회하고 각 요소들을 push 할 수 있다. 하지만 이러한 요소를 Stack 구현에 직접적으로 추가하는 정적 팩토리 메서드(static factory method)를 작성할 수 있다. 정적 팩토리 메서드 사용하기 (StackImpl.kt) 123456789companion object { fun &lt;T : Any&gt; create(items: Iterable&lt;T&gt;): Stack&lt;T&gt; { val stack = StackImpl&lt;T&gt;() for (item in items) { stack.push(item) } return stack } } 테스트용 코드 (Main.kt) 123456fun main() { val list = listOf(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;) val stack = StackImpl.create(list) print(stack) println(&quot;Popped: ${stack.pop()}&quot;)} 1234567----top----DCBA-----------Popped: D 이 코드는 문자열 스택을 생성하고 최상위 요소인 &quot;D&quot;를 pop 한다. 한 단계 더 나아가 listOf() 및 기타 표준 라이브러리 collection factory 함수와 유사한 요소를 나열하여 스택을 초기화할 수 있다. 이를 Stack.kt의 Stack을 구현한 클래스 외부에 추가한다. 스택 초기화 함수 추가 (Stack.kt) 123fun &lt;T : Any&gt; stackOf(vararg elements: T): Stack&lt;T&gt; { return StackImpl.create(elements.asList())} 테스트용 코드 (Main.kt) 12345fun main() { val stack = stackOf(1.0, 2.0, 3.0, 4.0) print(stack) println(&quot;Popped: ${stack.pop()}&quot;)} 1234567----top----4.03.02.01.0-----------Popped: 4.0 이렇게 하면 Double의 스택이 생성되고 최상위 값인 4.0이 표시된다. 코틀린 컴파일러의 타입 추론 기능 덕분에 stackOf 함수 호출의 제네릭 타입 인자를 지정하지 않아도 된다. 스택은 트리와 그래프를 검색하는 문제에 매우 중요하다. 미로를 통해 길을 찾는다고 상상할 때, 왼쪽, 오른쪽 또는 직진을 결정해야 하는 지점에 올 때마다 가능한 모든 결정들을 스택에 넣을 수 있다. (When you hit a dead end, backtrack by popping from the stack and continuing until you escape or hit another dead end.) 스택의 활용 LinkedList 뒤집기 12345678910111213fun &lt;T : Any&gt; LinkedList&lt;T&gt;.printInReverse() { val stack = StackImpl&lt;T&gt;() for (node in this) { stack.push(node) } var node = stack.pop() while (node != null) { println(node) node = stack.pop() }} 괄호 확인 12345// 1h((e))llo(world)() // balanced parentheses// 2(hello world // unbalanced parentheses 1234567891011121314fun String.checkParentheses(): Boolean { val stack = StackImpl&lt;Char&gt;() for (char in this) { when (char) { '(' -&gt; stack.push(char) ')' -&gt; { if (stack.isEmpty) return false else stack.pop() } } } return stack.isEmpty} 스택은 괄호 관련 코딩 테스트 문제에 자주 등장하므로 사용 방법을 숙지할 필요가 있다. 프로그래머스 레벨 2 - 괄호 변환 프로그래머스 레벨 2 - 괄호 회전하기","link":"/2021/07/05/data-structure-stack/"},{"title":"[프로그래머스] 레벨 2 : 행렬 테두리 회전하기","text":"문제 보기 2021 Dev-Matching: 웹 백엔드 개발자(상반기), 완전 탐색 소스 kotlin 연결 리스트 이용 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.LinkedListclass Solution { fun solution(rows: Int, columns: Int, queries: Array&lt;IntArray&gt;): IntArray { if (queries.size == 1) return intArrayOf(1) var answer = mutableListOf&lt;Int&gt;() val board = Array(rows) { i -&gt; IntArray(columns) { j -&gt; (i * columns) + j + 1 } } queries.forEach { val list = LinkedList&lt;Pair&lt;Int, Int&gt;&gt;() val values = mutableListOf&lt;Int&gt;() val (row1, col1) = it[0] - 1 to it[1] - 1 val (row2, col2) = it[2] - 1 to it[3] - 1 var (tempRow, tempCol) = row1 to col1 while (tempCol &lt; col2) { list.add(tempRow to tempCol) values.add(board[tempRow][tempCol]) tempCol += 1 } while (tempRow &lt; row2) { list.add(tempRow to tempCol) values.add(board[tempRow][tempCol]) tempRow += 1 } while (tempCol &gt; col1) { list.add(tempRow to tempCol) values.add(board[tempRow][tempCol]) tempCol -= 1 } while (tempRow &gt; row1) { list.add(tempRow to tempCol) values.add(board[tempRow][tempCol]) tempRow -= 1 } list.add(list.removeAt(0)) var cnt = 0 list.forEach { pos -&gt; board[pos.first][pos.second] = values[cnt] cnt += 1 } answer.add(values.min()!!) } return answer.toIntArray() }} 첫 시도에는 연결 리스트를 이용하는 방법으로 풀이하였지만 코드의 복잡도만 올라가는데다 효율성도 그리 좋지 못하여 아래와 같이 배열만을 이용하는 방법으로 풀이하였다. 배열만 이용 12345678910111213141516171819202122232425262728293031323334353637import kotlin.math.minclass Solution { fun solution(rows: Int, columns: Int, queries: Array&lt;IntArray&gt;): IntArray { var answer = intArrayOf() val board = Array(rows) { i -&gt; IntArray(columns) { j -&gt; (columns * i) + j + 1 } } queries.forEach { val (r1, c1) = it[0] - 1 to it[1] - 1 val (r2, c2) = it[2] - 1 to it[3] - 1 val a1 = IntArray(c2 - c1) { i -&gt; board[r1][c1 + i] } val a2 = IntArray(r2 - r1) { i -&gt; board[r1 + i][c2] } val a3 = IntArray(c2 - c1) { i -&gt; board[r2][c1 + 1 + i] } val a4 = IntArray(r2 - r1) { i -&gt; board[r1 + 1 + i][c1] } var min = rows * columns a1.forEachIndexed { i, v -&gt; board[r1][c1 + i + 1] = v min = min(min, v) } a2.forEachIndexed { i, v -&gt; board[r1 + i + 1][c2] = v min = min(min, v) } a3.forEachIndexed { i, v -&gt; board[r2][c1 + i] = v min = min(min, v) } a4.forEachIndexed { i, v -&gt; board[r1 + i][c1] = v min = min(min, v) } answer += min } return answer }}","link":"/2021/07/11/programmers-77485/"},{"title":"[프로그래머스] 레벨 2 : 전화번호 목록","text":"문제 보기 해시 소스 java 정확성 테스트 통과, 효율성 테스트 실패 코드 1234567891011121314151617181920import java.util.Arrays;import java.util.Comparator;class Solution { public boolean solution(String[] phone_book) { boolean answer = true; Arrays.sort(phone_book, Comparator.comparing(String::length)); for (int i = 0; i &lt; phone_book.length; i++) { for (int j = i + 1; j &lt; phone_book.length; j++) { if (phone_book[i].equals(phone_book[j].substring(0, phone_book[i].length()))) { answer = false; break; } } } return answer; }} Hash 사용 해시를 사용해야 효율성 통과를 할 수 있다. 12345678910111213141516171819202122import java.util.HashMap;import java.util.Arrays;import java.util.Collections;class Solution { public boolean solution(String[] phone_book) { Arrays.sort(phone_book, Collections.reverseOrder()); HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;(); for (String s : phone_book) { if (hashMap.get(s) != null) { return false; } for (int i = 0; i &lt; s.length(); i++) { hashMap.put(s.substring(0, i), 0); } } return true; }} 123456789101112131415import java.util.HashMap;class Solution { public boolean solution(String[] phone_book) { HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;(); for (String s : phone_book) hashMap.put(s, 0); for (String s : phone_book) { for (int i = 1; i &lt; s.length(); i++) { if (hashMap.containsKey(s.substring(0, i))) return false; } } return true; }} kotlin 1234567891011fun solution(phone_book: Array&lt;String&gt;): Boolean { val hashMap = HashMap&lt;String, Int&gt;() phone_book.forEach { hashMap[it] = 0 } phone_book.forEach { for (i in 1 until it.length) { if (hashMap.containsKey(it.substring(0, i))) return false } } return true}","link":"/2021/07/12/programmers-42577/"},{"title":"[프로그래머스] 레벨 2 : 가장 큰 수","text":"문제 보기 정렬 소스 kotlin 123456789101112131415161718192021222324class Solution { fun solution(numbers: IntArray): String { var answer = &quot;&quot; var tempArray = numbers.map { it.toString() }.toTypedArray() tempArray.sortWith(Comparator&lt;String&gt; { a, b -&gt; when { a.length == b.length -&gt; b.compareTo(a) else -&gt; (b + a).compareTo(a + b) } }) if (tempArray[0] == &quot;0&quot;) { answer = &quot;0&quot; return answer } tempArray.forEach { answer += it } return answer }}","link":"/2021/07/13/programmers-42746/"},{"title":"[LeetCode] 495. Teemo Attacking","text":"문제 보기 Kotlin 시간 초과 코드 12345678910111213class Solution { fun findPoisonedDuration(timeSeries: IntArray, duration: Int): Int { val poisonedTimes = mutableSetOf&lt;Int&gt;() timeSeries.forEach { t -&gt; for (i in t until t + duration) { poisonedTimes.add(i) } } return poisonedTimes.size }} easy 난이도의 문제였기에 간단히 set을 이용하여 중복을 제거하는 식으로 문제를 해결하려 하였으나 시간 초과가 발생하였다. 제약 사항을 보니 아래와 같았다. 입력값의 범위를 보고 문제 접근 방법을 고려할 수 있어야 하는데 연습이 많이 부족하다. 제약 사항 1 &lt;= timeSeries.length &lt;= 104 0 &lt;= timeSeries[i], duration &lt;= 107 timeSeries is sorted in non-decreasing order. 해답 123456789101112131415import kotlin.math.minclass Solution { fun findPoisonedDuration(timeSeries: IntArray, duration: Int): Int { val n = timeSeries.size if (n == 0) return 0 var total = 0 for (i in 0 until n - 1) { total += min(timeSeries[i + 1] - timeSeries[i], duration) } return total + duration }} 일반적으로 이러한 유형의 문제들은 입력 값이 정렬되어 있을 경우 O(N), 그렇지 않을 경우 O(nlogn)의 시간 복잡도를 가진다. 두 개의 공격 사이의 간격과 duration 중 작은 값을 독에 중독된 시간에 더해나가는 식으로 값을 구할 수 있다. 두 개의 공격 사이의 간격이 duration보다 작다는 것은 중첩되는 구간이 있다는 뜻으로 다음 공격 시간과 현재 공격 시간의 차이(timeSeries[i + 1] - timeSeries[i])만큼만 총 중독 시간에 더한다. duration이 두 공격 사이 간격보다 클 경우는 중첩 구간이 없다는 뜻이므로 duration 값 그대로를 총 중독 시간에 더한다. 마지막 공격은 비교군에서 제외되므로 총 중독 시간에 따로 duration을 한 번만 더해준다. 복잡도 분석 시간 복잡도 : O(N) 공간 복잡도 : O(1)","link":"/2021/07/15/leetcode-495/"},{"title":"[LeetCode] 56. Merge Intervals","text":"문제 보기 Kotlin 123456789101112131415161718import kotlin.math.maxclass Solution { fun merge(intervals: Array&lt;IntArray&gt;): Array&lt;IntArray&gt; { intervals.sortWith(compareBy { it[0] }) val merged = mutableListOf&lt;IntArray&gt;() for (interval in intervals) { if (merged.isEmpty() || merged.last()[1] &lt; interval[0]) { merged.add(interval) } else { merged.last()[1] = max(merged.last()[1], interval[1]) } } return merged.toTypedArray() }} 복잡도 분석 시간 복잡도 : O(nlogn) 정렬로 인한 시간복잡도 java.util.Collections.sort()의 API 문서에 정렬 알고리즘으로 개선된 합병정렬(a modified mergesort)을 사용하고 시간 복잡도는 O(nlogn)으로 명시되어 있다. 공간 복잡도 : O(n)","link":"/2021/07/15/leetcode-56/"},{"title":"[LeetCode] 57. Insert Interval","text":"문제 보기 Kotlin O(nlogn) 시간 복잡도 해결법 1234567891011121314151617181920import kotlin.math.maxclass Solution { fun insert(intervals: Array&lt;IntArray&gt;, newInterval: IntArray): Array&lt;IntArray&gt; { val new = intervals + newInterval new.sortWith(compareBy {it[0]}) val arr = mutableListOf&lt;IntArray&gt;() for (interval in new) { if (arr.isEmpty() || arr.last()[1] &lt; interval[0]) { arr.add(interval) } else { arr.last()[1] = max(arr.last()[1], interval[1]) } } return arr.toTypedArray() }} O(n) 시간 복잡도 해결법 1234567891011121314151617181920212223242526272829import kotlin.math.*class Solution { fun insert(intervals: Array&lt;IntArray&gt;, newInterval: IntArray): Array&lt;IntArray&gt; { val merged = mutableListOf&lt;IntArray&gt;() var i = 0 for (interval in intervals) { if (interval[1] &gt;= newInterval[0]) break merged.add(interval) i++ } while (i &lt; intervals.size &amp;&amp; intervals[i][0] &lt;= newInterval[1]){ newInterval[0] = min(newInterval[0], intervals[i][0]) newInterval[1] = max(newInterval[1], intervals[i][1]) i++ } merged.add(newInterval) while (i &lt; intervals.size){ merged.add(intervals[i]) i++ } return merged.toTypedArray() }}","link":"/2021/07/16/leetcode-57/"},{"title":"[프로그래머스] 레벨 2 : JadenCase 문자열 만들기","text":"문제 보기 소스 kotlin 나의 풀이 123456789101112131415class Solution { fun solution(s: String): String { val words = s.toLowerCase().toCharArray() words[0] = words[0].toUpperCase() for (i in 1 until words.size) { if (words[i].isLowerCase() &amp;&amp; words[i - 1] == ' ') { words[i] = words[i].toUpperCase() } } return String(words) // words.joinToString(&quot;&quot;) 사용 가능 }} capitalize() 1234567class Solution { fun solution(s: String): String { return s.toLowerCase().split(&quot; &quot;).map { it.capitalize() }.joinToString(&quot; &quot;) }}","link":"/2021/07/16/programmers-12951/"},{"title":"[LeetCode] 1688. Count of Matches in Tournament","text":"문제 보기 Kotlin 123456789101112131415161718class Solution { fun numberOfMatches(n: Int): Int { var remains = n var cnt = 0 while (remains &gt; 1) { if (remains % 2 == 0) { cnt += remains / 2 remains /= 2 } else { cnt += (remains - 1) / 2 remains = (remains - 1) / 2 + 1 } } return cnt }}","link":"/2021/07/16/leetcode-1688/"},{"title":"[코틀린 자료구조] 큐 (Queue)","text":"우리는 모두 줄을 서서 기다리는 것에 익숙하다. 좋아하는 영화의 티켓을 구매하기 위해 줄을 서는 것과 같은 실생활의 예시들은 큐(Queue) 자료구조를 모방한다. 큐는 FIFO(first in, first out)의 형태로, 처음 추가된 요소가 제일 먼저 제거되는 요소가 된다. 큐는 나중에 처리할 요소의 순서를 유지해야 할 때 편리하다. 큐의 일반적인 연산들 먼저 큐에 대한 인터페이스를 설정한다. base 패키지 내부에 Queue.kt라는 파일을 만들고 Queue 인터페이스를 정의하는 다음 코드를 추가한다. 큐 인터페이스 정의 (base/Queue.kt) 1234567891011121314interface Queue&lt;T : Any&gt; { fun enqueue(element: T): Boolean fun dequeue(): T? val count: Int get val isEmpty: Boolean get() = count == 0 fun peek(): T?} 이제부터 구현하는 모든 것은 큐의 핵심 작업을 설명하는 위의 인터페이스의 규약을 따른다. 큐의 핵심 연산들은 다음과 같다. enqueue : 대기열(queue)의 뒤에 요소를 삽입하고 연산이 성공하면 true를 반환한다. dequeue : 대기열의 맨 앞 요소를 제거하고 반환한다. isEmpty : count 속성을 사용하여 대기열이 비어있는지 확인한다. peek : 대기열의 맨 앞에 있는 요소를 제거하지 않고 값만 반환한다. 큐는 앞쪽에서 제거하고 뒤쪽에서 삽입하는 것에만 관심이 있다. 그 사이에 내용이 무엇인지 알 필요가 없다. 큐의 이해 큐의 작동 방식을 이해하는 가장 쉬운 방법은 작동 예제를 보는 것이다. 영화 티켓을 위해 줄을 서서 기다리는 사람들을 상상해보자. 이 대기열에는 현재 Ray, Brian, Sam 및 Mic이 있다. Ray는 티켓을 받으면 줄에서 나간다. dequeue()를 호출하면 Ray가 대기열의 앞쪽에서 제거된다. peek()을 호출하면 Brian이 현재 맨앞에 있기 때문에 Brian이 반환된다. 이제 막 표를 사기 위해 비키가 줄에 합류한다. enqueue(&quot;Vicki&quot;)를 호출하면 Vicki가 대기열 뒤에 추가된다. 큐의 구현 방법들 본문에선 네 가지 방법의 큐 구현 방법들을 알아본다. 배열 기반 리스트(array based list) 사용 이중 연결 리스트(doubly linked list) 사용 ring buffer 사용 두 개의 스택 사용 1. 리스트 기반 구현 코틀린 표준 라이브러리에는 더 높은 수준의 추상화를 구축하는데 사용할 수 있는 고도로 최적화된 자료구조의 핵심 세트가 함께 제공된다. 이들 중 하나가 연속적이고(contiguous) 정렬된 요소들의 리스트를 저장하는 자료구조인 ArrayList이다. ArrayList를 이용해서 큐를 구현해보자. list 패키지 내부에 ArrayListQueue.kt 파일을 생성하고 아래의 코드를 추가한다. 123class ArrayListQueue&lt;T : Any&gt; : Queue&lt;T&gt; { private val list = arrayListOf&lt;T&gt;()} Queue 인터페이스를 구현하는 제네릭 ArrayListQueue 클래스를 정의했다. 인터페이스 구현은 저장하는 요소에 대해 동일한 제네릭 타입인 T를 사용한다. 다음으로 ArrayListQueue 구현을 완료하여 Queue 인터페이스의 규약을 만족시키자. ArrayList 활용 ArrayListQueue 클래스에 다음 코드를 추가한다. 12345678class ArrayListQueue&lt;T : Any&gt; : Queue&lt;T&gt; { ... override val count: Int get() = list.size override fun peek(): T? = list.getOrNull(0)} ArrayList의 기능들을 사용하면 다음을 간단히 구현할 수 있다. 리스트의 동일한 속성을 사용하여 큐의 크기를 가져온다. 큐의 맨 앞에 요소가 존재한다면 값을 반환한다. 이 연산들은 모두 *O(1)*이다. Enqueue 큐의 뒤에 요소를 추가하는 것은 간단하다. ArrayList의 끝에 요소를 추가하기만 하면 된다. 1234override fun enqueue(element: T): Boolean { list.add(element) return true} 리스트의 크기에 관계없이 요소를 큐에 추가하는 것은 O(1) 연산이다. 리스트 뒤에 빈 공간이 있기 때문이다. 위의 예시에서 Mic를 추가하면 리스트에 두 개의 빈 공간이 있다. 여러 요소를 추가한 후에는 ArrayList 내부 배열이 결국 가득 차게 된다. 할당된 공간보다 더 많이 사용하려면 추가 공간을 만들기 위해 배열의 크기를 조정해야만 한다. 크기 조정(resizing)은 O(n) 연산이다. 크기를 조정하려면 리스트에서 새 메모리를 할당하고 기존의 모든 데이터를 새 리스트에 복사해야 한다. 매번 크기를 두 배로 늘리는 덕분에 자주는 발생하지 않으며, 시간 복잡도는 여전히 Amortized O(1)으로 동작한다. Dequeue 전면에서 항목(item)을 제거하려면 약간 더 많은 작업이 필요하다. 12override fun dequeue(): T? = if (isEmpty) null else list.removeAt(0) 큐가 비어 있으면 dequeue()는 단순히 null을 반환한다. 그렇지 않다면 리스트의 맨 앞에서 요소를 제거하고 반환한다. 큐의 전면에서 요소를 제거하는 연산은 O(n) 시간 복잡도를 가진다. 대기열에서 요소를 제거하려면 리스트 시작 부분에서 요소를 제거해야 한다. 리스트의 나머지 모든 요소를 메모리에서 이동시켜야하므로 항상 선형 시간(Linear time, O(n))의 연산이다. 테스트 디버깅을 위해 구현한 큐가 toString()을 재정의하도록 한다. 1override fun toString(): String = list.toString() 이제 구현한 큐를 직접 사용해보도록 하자. 1234567891011fun main() { val queue = ArrayListQueue&lt;String&gt;().apply { enqueue(&quot;Ray&quot;) enqueue(&quot;Brian&quot;) enqueue(&quot;Eric&quot;) } println(queue) queue.dequeue() println(queue) println(&quot;Next up: ${queue.peek()}&quot;)} 123[Ray, Brian, Eric][Brian, Eric]Next up: Brian 이 코드는 Ray, Brian 및 Eric을 큐에 넣는다(enqueue). 그런 다음 Ray를 제거하고(dequeue()) Brian을 들여다 보지만 제거하지는 않는다(peek()). 장점과 단점 다음은 ArrayList 기반 큐 구현의 알고리즘 및 복잡도에 대해 요약하고 있다. 대부분의 작업은 선형 시간이 걸리는 dequeue()를 제외하고는 상수 시간을 가진다. 공간 복잡도는 O(n) 이다. Kotlin ArrayList를 활용하여 리스트 기반 큐를 간단하게 구현하였다. O(1) 추가 연산 덕분에 큐에 넣는 것이 매우 빠르다. 하지만 이 구현에는 몇 가지 단점들이 있다. 항목을 제거하면 모든 요소가 하나씩 이동하므로 큐에서 항목을 제거하는 것은 비효율적일 수 있다. 이것은 매우 큰 큐에서 차이를 만든다. 리스트가 가득 차면 크기를 조정해야 하며 사용하지 않는 공간이 있을 수 있다. 이것은 시간이 지남에 따라 메모리 사용량을 증가시킬 수 있다. 이러한 단점을 어떻게 해결할 수 있을까? 연결 리스트 기반 구현을 살펴보고 ArrayListQueue와 비교해보도록 하자. 2. 이중 연결 리스트(doubly linked list) 기반 구현 linkedlist 패키지 내부에 LinkedListQueue.kt 파일을 생성한다. 12345678class LinkedListQueue&lt;T : Any&gt; : Queue&lt;T&gt; { private val list = DoublyLinkedList&lt;T&gt;() private var size = 0 override val count: Int get() = size} 위 구현은 ArrayListQueue와 유사하지만 ArrayList 대신 DoublyLinkedList를 생성한다. DoublyLinkedList가 제공하지 않는 count 속성 아래로 Queue 인터페이스의 구현을 시작한다. Enqueue 큐의 뒤에 요소를 추가하기 위해 아래의 코드를 작성한다. 12345override fun enqueue(element: T): Boolean { list.append(element) size += 1 return true} 이중 연결 리스트는 내부에서 새 노드에 대한 꼬리 노드의 이전(prev) 및 다음(next) 참조를 업데이트하고 크기를 늘린다. 이 과정은 O(1) 연산이다. Dequeue 큐에서 요소를 제거하기 위해서 아래의 코드를 추가한다. 간단한 구현 1override fun dequeue(): T? = list.pop() 원서는 DoublyLinkedList에 대한 코드가 제공되지 않은 상태에서 위의 코드를 예시로 들어놓았는데, 직접 구현한 LinkedList를 기반으로 Queue를 구현한다면 dequeue()를 리스트에서 첫 번째 노드를 제거하는 메서드를 호출하는 것으로 간단히 구현할 수 있다. 원서의 코드 12345override fun dequeue(): T? { val firstNode = list.first ?: return null size-- return list.remove(firstNode)} 원서의 코드는 큐의 첫 번째 요소가 존재하는지 확인하고 존재하지 않는다면 null을 반환한다. 큐에 첫 번째 요소가 존재한다면 맨 앞에 있는 요소를 제거하고 이를 반환한다. 크기도 감소한다. 리스트 맨 앞을 제거하는 것 또한 O(1) 연산이다. ArrayList 구현과 비교할 때 요소를 하나씩 이동할 필요가 없는 대신, 위의 이미지처럼 연결 리스트의 처음 두 노드 사이의 전(prev) 및 다음(next) 포인터를 업데이트하기만 하면 된다. Peek ArrayList 기반 구현과 유사하게, DoublyLinkedList의 속성을 이용하여 peek()을 간단히 구현할 수 있다. 1override fun peek(): T? = list.first?.value 테스트 디버깅을 위해 아래의 코드를 클래스에 추가하고 테스트 해보자. 1override fun toString(): String = list.toString() 1234567891011fun main() { val queue = LinkedListQueue&lt;String&gt;().apply { enqueue(&quot;Ray&quot;) enqueue(&quot;Brian&quot;) enqueue(&quot;Eric&quot;) } println(queue) queue.dequeue() println(queue) println(&quot;Next up: ${queue.peek()}&quot;)} 이 테스트 코드는 ArrayListQueue 구현과 동일한 결과를 생성한다. 장점과 단점 ArrayListQueue의 주요 문제점 중 하나는 항목을 대기열에서 빼는데 O(n)이 걸리는 것이다. 연결 리스트 구현을 통해 노드의 이전 및 다음 포인터를 업데이트하는 것만으로 시간 복잡도를 O(1)으로 축소시켰다. LinkedListQueue의 주요 단점은 위의 표에서 분명하게 나타나지 않는다. O(1) 성능에도 불구하고 높은 오버헤드가 존재하는데, 각 요소는 이전과 다음의 참조를 위한 추가 공간이 있어야 한다(공간 복잡도 증가). 또한 새 요소를 만들 때마다 상대적으로 비용이 많이 드는 동적 할당이 필요하다. 이에 비해, ArrayListQueue는 더 빠른 대량 할당을 수행한다. 할당에 대한 오버헤드를 제거하고 O(1)의 dequeue를 유지할 수 있을까? 큐가 고정된 크기 이상으로 커지는 것에 대해 걱정할 필요가 없는 경우 링 버퍼와 같은 다른 접근 방식을 사용할 수 있다. 예를 들어, 5명의 플레이어가 참여하는 모노폴리 게임에 링 버퍼를 기반으로 한 큐를 사용하여 다음에 올 차례를 추적할 수 있다. 다음으로 링 버퍼 구현을 살펴보자. 3. 링 버퍼(Ring Buffer) 기반 구현 원형 버퍼(circular buffer)라고도 불리는 링 버퍼(ring buffer)는 고정 크기 배열이다. 이 자료구조는 마지막에 제거할 항목이 없을 때 시작 부분으로 래핑된다. 링 버퍼를 사용하여 큐를 구현하는 방법에 대한 간단한 예를 아래의 이미지들로 살펴보자. 링 버퍼 생성 먼저 고정 크기가 4인 링 버퍼를 만든다. 링 버퍼에는 두 개의 포인터가 존재한다. 읽기(read) 포인터 : 큐의 앞쪽을 추적 쓰기(write) 포인터 : 사용 가능한 다음 칸을 추적하여 이미 읽어 들인 기존 요소를 재정의할 수 있다. 대기열에 항목 추가 대기열에 항목을 추가할 때마다 쓰기 포인터가 1씩 증가한다. 항목 2개를 더 추가 쓰기 포인터가 두 자리 더 이동하여 읽기 포인터보다 3칸 앞서 있는 것을 확인 할 수 있다. 이는 대기열이 비어 있지 않다는 것을 의미한다. 대기열에서 두 개의 항목을 빼기 대기열에서 항목을 빼는 것을 링 버퍼를 읽는 것과 동일하다. 읽기 포인터가 어떻게 두 번 이동했는지 주목하자. 대기열을 채우기 위해 항목을 하나 더 추가 쓰기 포인터가 끝에 도달했으므로 시작 인덱스로 다시 랩핑된다. 마지막으로 남은 두 개의 항목을 대기열에서 빼기 남은 두 항목도 대기열에서 빼면서 읽기 포인터도 시작 부분으로 돌아온다. 위 이미지를 통해 읽기와 쓰기 포인터가 동일한 인덱스에 있을 경우 대기열, 즉 큐가 비어 있다는 것을 알 수 있다. 링 버퍼를 통한 큐의 구현은 개념만 확인하고 구현은 생략하였다. 장점과 단점 링 버퍼 기반 큐는 연결 리스트 기반 구현과 enqueue와 dequeue의 시간 복잡도가 동일하다. 유일한 차이점은 공간 복잡도인데, 링 버퍼의 크기는 고정되어 있으므로 큐에 넣는 것 자체가 실패할 수 있는 단점이 존재한다. 지금까지 배열, 연결 리스트, 링 버퍼 기반까지 총 세 가지의 구현 방법을 보았는데 마지막으로 두 개의 스택을 사용하여 구현된 큐를 알아 볼 것이다. 이중 스택 기반 구현 큐는 메모리 상의 공간적 지역성이 연결 리스트보다 훨씬 우수하고, 링 버퍼와 같이 고정된 크기가 필요하지 않다는 장점이 있다. 4. 이중 스택(Double-Stack) 기반 구현 doublestack 패키지 내부에 StackQueue.kt를 추가한다. 1234class StackQueue&lt;T : Any&gt; : Queue&lt;T&gt; { private val leftStack = StackImpl&lt;T&gt;() private val rightStack = StackImpl&lt;T&gt;()} 두 개의 스택을 사용하는 아이디어는 요소를 큐에 넣을 때마다 오른쪽 스택으로 이동하고, 요소를 큐에서 뺄 때는 FIFO 순서를 사용하여 요소를 검색할 수 있도록 오른쪽 스택을 반대로 뒤집어서 왼쪽 스택에 넣는다. 스택 활용하기 그러면 아래의 코드를 추가하여 큐의 공통 기능들을 구현해본다. 12345override val count: Int get() = leftStack.count + rightStack.count override val isEmpty: Boolean get() = leftStack.isEmpty &amp;&amp; rightStack.isEmpty 큐가 비어 있는지 확인하려면 왼쪽과 오른쪽의 스택이 모두 비어 있는지 확인하면 된다. 큐에 있는 요소의 개수는 두 스택에 있는 요소 개수의 합이다. 이중 스택으로 구현한 큐는 위에서 설명했듯이 오른쪽 스택에서 왼쪽 스택으로 요소를 전달해야 할 때가 있다. 이는 왼쪽 스택이 비어 있을 때마다 발생한다. 다음의 헬퍼 메서드를 추가하자. 오른쪽 스택에서 왼쪽 스택으로 요소 이동 1234567private fun transferElements() { var nextElement = rightStack.pop() while (nextElement != null) { leftStack.push(nextElement) nextElement = rightStack.pop() }} 위 코드를 통해 오른쪽 스택으로부터 요소를 꺼내어 왼쪽 스택에 넣을 수 있다. 스택은 LIFO 방식으로 작동하기 때문에 추가적인 작업 없이 역순으로 요소들을 가져올 수 있다. peek() 123456override fun peek(): T? { if (leftStack.isEmpty) { transferElements() } return leftStack.peek()} peek()은 최상위 요소를 보는 메서드이다. 만약 왼쪽 스택이 비어 있지 않다면 이 스택의 맨 위에 있는 요소가 큐의 맨 앞에 있다. 왼쪽 스택이 비어 있으면 transferElements()를 사용한다. 그렇게 하면 leftStack.peek()은 항상 올바른 요소 또는 null을 반환한다. isEmpty()는 여전히 O(1) 작업인 반면 peek()은 O(n)이다. 이러한 peek()의 구현이 비싼 비용을 요구하는 것처럼 보이지만, 큐의 각 요소는 오른쪽 스택에서 왼쪽 스택으로 한 번만 이동하면 되기 때문에 amortized O(1)이다. 왼쪽 스택이 비어 있을 때 peek() 호출은 오른쪽 요소들을 모두 왼쪽 스택으로 이동시키므로 O(n)이지만, 그 외 추가적인 호출에 대해선 O(1)이 된다. Enqueue 1234override fun enqueue(element: T): Boolean { rightStack.push(element) return true} 요소를 큐에 추가할 때는 오른쪽 스택이 사용된다. 스택에 요소를 넣는 push()는 O(1)이다. Dequeue 123456override fun dequeue(): T? { if (leftStack.isEmpty) { transferElements() } return leftStack.pop()} 동작 원리는 다음과 같다. 왼쪽 스택이 비어 있는지 확인한다. 왼쪽 스택이 비어 있으면 오른쪽 스택의 요소를 역순으로 이동시킨다. 왼쪽 스택에서 맨 위의 요소를 제거한다. 왼쪽 스택이 비어 있을 때에만 오른쪽 스택의 요소를 이동시키므로 dequeue()는 peek()처럼 amortized O(1) 연산이다. 테스트 123override fun toString(): String { return &quot;Left stack: \\n$leftStack \\nRight stack: \\n$rightStack&quot;} 1234567891011fun main() { val queue = StackQueue&lt;String&gt;().apply { enqueue(&quot;Ray&quot;) enqueue(&quot;Brian&quot;) enqueue(&quot;Eric&quot;) } println(queue) queue.dequeue() println(queue) println(&quot;Next up: ${queue.peek()}&quot;)} 12345678910111213141516171819202122Left stack: ----top--------------- Right stack: ----top----EricBrianRay-----------Left stack: ----top----BrianEric----------- Right stack: ----top---------------Next up: Brian 장점과 단점 리스트 기반 구현과 비교했을 때, 두 개의 스택을 활용하면 dequeue()의 구현을 amortized O(1) 연산으로 변환할 수 있다. 또한 이중 스택 기반 구현은 완전히 동적이고 링 버퍼 기반 구현처럼 고정된 크기로 제한되지도 않는다. 마지막으로 공간적 지역성(spatial locality, 메모리 상 인접 데이터의 재이용률이 높음) 측면에서 연결 리스트 기반 구현을 능가하는데, 이는 리스트이 요소가 메모리 블록에서 서로 옆에 있기 때문이다. 따라서 많은 수의 요소가 한 번의 접근(access)으로 캐시에 로드된다. 연속된 배열에 있는 요소들 메모리 전체에 흩어져 있는 연결 리스트의 요소들 연결 리스트에서 요소는 메모리 블록에 연속적으로 존재하지 않는다. 이로 인해 더 많은 캐시 미스가 발생하여 접근 시간이 늘어난다. Github에서 본문의 코드 확인하기 Data Structures & Algorithms in Kotlin 서적을 참고하여 작성했습니다.","link":"/2021/07/16/data-structure-queue/"},{"title":"[코틀린 자료구조] 트리 (Tree)","text":"트리(tree)는 매우 중요한 자료구조로 다음과 같이 소프트웨어 개발에서 반복되는 많은 문제를 해결하는 데 사용한다. 계층적 관계를 표현 정렬된 데이터 관리 빠른 조회 작업을 용이하게 함 트리와 관련된 용어들(Terminology) 노드(Node) 연결 리스트와 마찬가지로 트리도 노드로 구성된다. 각 노드는 일부 데이터를 캡슐화하고 자식을 추적한다. 부모와 자식(Parent and child) 트리는 거꾸로 뒤집힌 실제 나무처럼 위에서 시작하여 아래쪽으로 가지를 뻗어 나간다. 첫 번째 노드를 제외한 모든 노드는 부모 노드라고 하는 위의 단일 노드에 연결된다. 바로 아래에 있고 부모 노드에 연결된 노드를 자식 노드라 한다. 트리에서 모든 자식은 정확히 한 명의 부모를 가진다. 뿌리(Root) 트리의 최상위 노드를 트리의 뿌리(루트, root)라고 한다. 부모가 없는 유일한 노드이기도 하다. 잎(Leaf) 자식이 없는 노드를 리프라고 한다. 구현 트리는 노드로 구성되어 있으므로 제일 처음해야 할 작업은 TreeNode 클래스를 생성하는 것이다. TreeNode.kt 123class TreeNode&lt;T&gt;(val value: T) { private val children: MutableList&lt;TreeNode&lt;T&gt;&gt; = mutableListOf()} 각 노드는 값을 담당하고 MutableList를 사용하여 모든 자식에 대한 참조를 저장한다. 다음으로 TreeNode 내부에 아래의 메서드를 추가하자 1fun add(child: TreeNode&lt;T&gt;) = children.add(child) 이 메서드는 노드에 자식 노드를 추가한다. 12345678fun main() { val hot = TreeNode(&quot;Hot&quot;) val cold = TreeNode(&quot;Cold&quot;) val beverages = TreeNode(&quot;Beverages&quot;).run { add(hot) add(cold) }} 계층 구조는 트리 구조의 자연스러운 형태 중 하나이다. 위의 코드는 아래와 같은 구조를 가지고 있다. Traversal algorithms 배열이나 리스트와 같은 선형 컬렉션을 반복(iterating)하는 것은 간단하다. 선형 컬렉션에는 명확한 시작과 끝이 있다. 트리를 반복하는 것은 조금 더 복잡하다. 왼쪽에 있는 노드가 우선 순위를 가져야 할까? 노드의 깊이는 우선 순위와 어떤 관련이 있을까? 순회 전략은 해결하려는 문제에 따라 다르게 가져가야 한다. 서로 다른 트리와 문제에 대해 여러 전략이 존재한다. 이 모든 방법은 노드를 방문하고 노드 내부의 정보를 사용할 수 있게 해준다. TreeNode 클래스의 외부에 정의 추가 12345typealias Visitor&lt;T&gt; = (TreeNode&lt;T&gt;) -&gt; Unitclass TreeNode&lt;T&gt;(val value: T) { ...} Depth-first traversal(Depth-first search, DFS, 깊이 우선 탐색) 깊이 우선 탐색은 루트 노드에서 시작하여 리프에 도달한 다음 백트래킹하기 전에 각 분기를 따라 가능한 멀리 트리를 탐색한다. TreeNode 내부에 다음을 추가한다. 123456fun forEachDepthFirst(visit: Visitor&lt;T&gt;) { visit(this) children.forEach { it.forEachDepthFirst(visit) }} 이 간단한 코드는 재귀를 사용하여 다음 노드를 처리한다. 재귀적인 구현을 사용하지 않으려면 스택을 사용할 수 있으나 재귀를 이용한 방법이 더 간단하다. 재귀 깊이 우선 탐색 테스트 12345678910111213141516171819202122232425262728fun makeBeverageTree(): TreeNode&lt;String&gt; { val tree = TreeNode(&quot;Beverages&quot;) val hot = TreeNode(&quot;hot&quot;) val cold = TreeNode(&quot;cold&quot;) val tea = TreeNode(&quot;tea&quot;) val coffee = TreeNode(&quot;coffee&quot;) val chocolate = TreeNode(&quot;cocoa&quot;) val blackTea = TreeNode(&quot;black&quot;) val greenTea = TreeNode(&quot;green&quot;) val chaiTea = TreeNode(&quot;chai&quot;) val soda = TreeNode(&quot;soda&quot;) val milk = TreeNode(&quot;milk&quot;) val gingerAle = TreeNode(&quot;ginger ale&quot;) val bitterLemon = TreeNode(&quot;bitter lemon&quot;) tree.add(hot) tree.add(cold) hot.add(tea) hot.add(coffee) hot.add(chocolate) cold.add(soda) cold.add(milk) tea.add(blackTea) tea.add(greenTea) tea.add(chaiTea) soda.add(gingerAle) soda.add(bitterLemon) return tree} makeBeverageTree()는 아래와 같은 트리를 생성한다. 트리를 생성한 다음 main()에서 다음과 같은 코드를 실행한다. 1234fun main() { val tree = makeBeverageTree() tree.forEachDepthFirst { println(it.value) }} 이 코드의 출력 결과는 깊이 우선 탐색이 각 노드를 방문하는 순서를 보여준다. 12345678910111213Beverageshotteablackgreenchaicoffeecocoacoldsodaginger alebitter lemonmilk Level-order traversal Level-order traversal은 노드의 깊이를 기반으로 트리의 각 노드를 방문하는 방법이다. 루트에서 시작하여 하위 레벨로 이동하기 전에 같은 레벨의 모든 노드를 방문한다. TreeNode 내부에 다음을 추가한다. 직접 구현한 Queue를 사용할 시 123456789101112fun forEachLevelOrder(visit: Visitor&lt;T&gt;) { visit(this) val queue = StackQueue&lt;TreeNode&lt;T&gt;&gt;() children.forEach { queue.enqueue(it) } var node = queue.dequeue() while (node != null) { visit(node) node.children.forEach { queue.enqueue(it) } node = queue.dequeue() }} java.util 패키지 내부의 Queue 사용 1234567891011fun forEachLevelOrder(visit: Visitor&lt;T&gt;) { visit(this) val queue: Queue&lt;TreeNode&lt;T&gt;&gt; = LinkedList() children.forEach { queue.offer(it) } var node = queue.poll() while (node != null) { visit(node) node.children.forEach { queue.offer(it) } node = queue.poll() }} forEachLevelOrder()는 각 노드를 레벨 순으로 방문한다. 노드가 올바른 레벨 순서로 방문되도록 큐를 사용하는 방법에 유의한다. 현재 노드를 방문하여 모든 자식을 큐에 넣는다. 그런 다음 비어 있을 때까지 큐를 사용하기 시작한다. 노드를 방문할 때마다 노드의 모든 자식들도 큐에 넣는다. 이렇게 하면 같은 레벨의 모든 노드를 차례로 방문할 수 있다. 1234fun main() { val tree = makeBeverageTree() tree.forEachLevelOrder { println(it.value) }} 12345678910111213beverageshotcoldteacoffeecocoasodamilkblackgreenchaiginger alebitter lemon 검색 노드를 반복하는 메서드를 이미 구현했으므로 검색 알고리즘을 구현하는데 오래 걸리지 않는다. TreeNode 내부에 아래의 코드를 추가한다. 1234567891011fun search(value: T): TreeNode&lt;T&gt;? { var result: TreeNode&lt;T&gt;? = null forEachLevelOrder { if (it.value == value) { result = it } } return result} 코드를 테스트하기 위해 main()에 아래의 코드를 추가한다. 12345678910fun main() { val tree = makeBeverageTree() tree.search(&quot;ginger ale&quot;)?.let { println(&quot;Found node: ${it.value}&quot;) } tree.search(&quot;WKD Blue&quot;)?.let { println(it.value) } ?: println(&quot;Couldn't find WKD Blue&quot;)} main()을 실행하면 다음과 같은 출력 결과를 볼 수 있다. 12Found node: ginger aleCouldn't find WKD Blue 위에서 level-order traversal 알고리즘을 사용했는데, 모든 노드를 방문하기 때문에 일치하는 항목이 여러 개일 경우 마지막으로 일치하는 항목이 채택된다. 이것은 사용하는 순회 방법에 따라 다른 객체를 얻을 수 있음을 의미한다. 챌린지 아래 트리의 값을 레벨에 따라 순서대로 출력하시오. 같은 레벨에 속하는 노드는 같은 줄에 출력해야 합니다. 123151 17 201 5 0 2 5 7 예제 트리 생성 코드 1234567891011121314151617fun makeSampleTree(): TreeNode&lt;Int&gt; { val tree = TreeNode(15) val one = TreeNode(1) val seventeen = TreeNode(17) val twenty = TreeNode(20) tree.add(one) tree.add(seventeen) tree.add(twenty) one.add(TreeNode(1)) one.add(TreeNode(5)) one.add(TreeNode(0)) seventeen.add(TreeNode(2)) twenty.add(TreeNode(5)) twenty.add(TreeNode(7)) return tree} 레벨 별 노드 출력 코드 (java.util 패키지 내부의 Queue 사용) 12345678910111213141516171819202122fun printEachLevel() { // 1 val queue: Queue&lt;TreeNode&lt;T&gt;&gt; = LinkedList() var nodesLeftInCurrentLevel = 0 queue.offer(this) // 2 while (queue.isNotEmpty()) { // 3 nodesLeftInCurrentLevel = queue.size // 4 while (nodesLeftInCurrentLevel &gt; 0) { val node = queue.poll() node?.let { print(&quot;${node.value} &quot;) node.children.forEach { queue.offer(it) } nodesLeftInCurrentLevel-- } ?: break } // 5 println() }} 레벨 별 노드 출력 코드 (직접 구현한 Queue를 사용) 12345678910111213141516171819202122fun printEachLevel() { // 1 val queue = StackQueue&lt;TreeNode&lt;T&gt;&gt;() var nodesLeftInCurrentLevel = 0 queue.enqueue(this) // 2 while (queue.isEmpty.not()) { // 3 nodesLeftInCurrentLevel = queue.count // 4 while (nodesLeftInCurrentLevel &gt; 0) { val node = queue.dequeue() node?.let { print(&quot;${node.value} &quot;) node.children.forEach { queue.enqueue(it) } nodesLeftInCurrentLevel-- } ?: break } // 5 println() }} 레벨 순서 순회를 용이하게 하기 위해 큐를 초기화하는 것으로 시작한다. 또한 새 줄을 출력하기 전에 작업해야하는 노드의 수를 추적하기 위해 nodesLeftInCurrentLevel을 만든다. 레벨 순서 순회는 큐가 빌 때까지 계속된다. 첫 번째 while 루프 내에서 nodesLeftInCurrentLevel을 큐의 현재 요소로 설정하여 시작한다. 다른 while 루프를 사용하여 nodesLeftInCurrentLevel의 수만큼 큐에서 요소를 빼낸다. 큐에서 빼는 모든 요소는 다음 줄로 넘어가지 않고 출력되며, 노드의 모든 자식을 큐에 넣는다. 이 시점에서 println()을 사용하여 새 줄을 생성한다. 다음 반복에서 nodesLeftInCurrentLevel은 이전 반복의 자식 수를 나타내는 queue.count로 업데이트된다. 요약 트리는 연결 리스트와 몇 가지 유사점을 공유한다. 그러나 트리의 노드는 무한히 많은 노드에 연결할 수 있는 반면 연결 리스트의 노드는 하나의 다른 노드에만 연결할 수 있다. 깊이 우선 및 레벨 순서 순회는 일반적인 유형의 트리에만 국한되지 않는다. 트리 구조에 따라 구현이 약간 다르지만 다른 유형의 트리에서도 작동할 수 있다. Github에서 본문의 코드 확인하기 Data Structures & Algorithms in Kotlin 서적을 참고하여 작성했습니다.","link":"/2021/07/19/data-structure-trees/"},{"title":"[BOJ] 10819번 : 차이를 최대로","text":"문제 보기 소스 kotlin 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.*import kotlin.math.absimport kotlin.math.maxvar n = 0val nums = IntArray(10)val visited = BooleanArray(10)var result = 0fun main() = with(Scanner(System.`in`)) { n = nextInt() for (i in 0 until n) { nums[i] = nextInt() } val arr = mutableListOf&lt;Int&gt;() dfs(arr, 0) println(result)}fun dfs(arr: MutableList&lt;Int&gt;, count: Int) { if (count == n) { result = max(arr.value(), result) return } for (i in 0 until n) { if (!visited[i]) { visited[i] = true arr.add(nums[i]) dfs(arr, count + 1) arr.removeAt(arr.size - 1) visited[i] = false } }}fun MutableList&lt;Int&gt;.value() : Int { var sum = 0 for (i in 0 until n - 1) { sum += abs(this[i] - this[i + 1]) } return sum}","link":"/2021/07/23/boj-10819/"},{"title":"[BOJ] 14888번 : 연산자 끼워넣기","text":"문제 보기 소스 kotlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.Scannerimport kotlin.math.*var n = 0var min = Int.MAX_VALUEvar max = Int.MIN_VALUElateinit var nums: IntArraylateinit var visit: BooleanArraylateinit var opers: MutableList&lt;String&gt;fun main() = with(Scanner(System.`in`)) { n = nextInt() nums = IntArray(n) visit = BooleanArray(n - 1) opers = mutableListOf() for (i in 0 until n) { nums[i] = nextInt() } repeat(nextInt()) { opers.add(&quot;+&quot;) } repeat(nextInt()) { opers.add(&quot;-&quot;) } repeat(nextInt()) { opers.add(&quot;*&quot;) } repeat(nextInt()) { opers.add(&quot;/&quot;) } dfs(&quot;&quot;) println(max) println(min)}fun dfs(comb: String) { if (comb.length == n - 1) { min = min(min, comb.result()) max = max(max, comb.result()) return } for (i in 0 until n - 1) { if (visit[i]) continue visit[i] = true dfs(comb + opers[i]) comb.removeRange(comb.length - 1, comb.length - 1) visit[i] = false }}fun String.result(): Int { var temp = nums[0] for (i in 0 until n - 1) { temp = calc(temp, nums[i+1], this[i]) } return temp}fun calc(a: Int, b: Int, c: Char): Int { return when (c) { '+' -&gt; a + b '-' -&gt; a - b '*' -&gt; a * b '/' -&gt; a / b else -&gt; 0 }} 메모리 시간 304432 KB 1548 ms 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Scannerimport kotlin.math.*var n = 0var min = Int.MAX_VALUEvar max = Int.MIN_VALUEval opers = IntArray(4)lateinit var nums: IntArraylateinit var visit: BooleanArrayfun main() = with(Scanner(System.`in`)) { n = nextInt() nums = IntArray(n) visit = BooleanArray(n - 1) for (i in 0 until n) { nums[i] = nextInt() } for (i in 0 until 4) { opers[i] = nextInt() } dfs(nums[0], 1) println(max) println(min)}fun dfs(acc: Int, count: Int) { if (count == n) { min = min(min, acc) max = max(max, acc) return } for (i in 0 until 4) { if (opers[i] &lt;= 0) continue opers[i]-- dfs(calc(acc, nums[count], i), count + 1) opers[i]++ }}fun calc(a: Int, b: Int, oper: Int): Int { return when (oper) { 0 -&gt; a + b 1 -&gt; a - b 2 -&gt; a * b 3 -&gt; a / b else -&gt; 0 }} 메모리 시간 13684 KB 140 ms","link":"/2021/07/23/boj-14888/"},{"title":"[BOJ] 14889번 : 스타트와 링크","text":"문제 보기 소스 kotlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.*import kotlin.math.absimport kotlin.math.minvar n = 0var result = Int.MAX_VALUElateinit var status: Array&lt;IntArray&gt;lateinit var visited: BooleanArrayfun main() = with(Scanner(System.`in`)) { n = nextInt() status = Array(n) { IntArray(n) } visited = BooleanArray(n) for (i in 0 until n) { for (j in 0 until n) { status[i][j] = nextInt() } } dfs(0, 0) println(result)}fun dfs(index: Int, count: Int) { if (count == n / 2) { statusGap() return } for (i in index until n) { if (!visited[i]) { visited[i] = true dfs(i + 1, count + 1) visited[i] = false } }}fun statusGap() { var startSum = 0 var linkSum = 0 for (i in 0 until n - 1) { for (j in i + 1 until n) { if (visited[i] &amp;&amp; visited[j]) { startSum += status[i][j] + status[j][i] } else if (!visited[i] &amp;&amp; !visited[j]) { linkSum += status[i][j] + status[j][i] } } } result = min(result, abs(startSum - linkSum))} 스타트 팀과 링크 팀을 구분 짓는 자료구조를 따로 선언하지 않고 BooleanArray인 visited의 값을 통해 구분하므로 dfs 함수의 첫 번째 인자로 index를 사용하였다.","link":"/2021/07/23/boj-14889/"},{"title":"[BOJ] 15649번 : N과 M","text":"문제 보기 소스 kotlin 12345678910111213141516171819202122232425262728293031import java.util.*var n = 0var m = 0val arr = IntArray(10)val isUsed = BooleanArray(10)fun main() = with(Scanner(System.`in`)) { n = nextInt() m = nextInt() backTrack(0)}fun backTrack(k : Int) { if (k == m) { for (i in 0 until m) { print(&quot;${arr[i]} &quot;) } println() return } for (i in 1 .. n) { if (isUsed[i].not()) { arr[k] = i isUsed[i] = true backTrack(k+1) isUsed[i] = false } }}","link":"/2021/07/23/boj-15649/"},{"title":"[BOJ] 2661번 : 좋은수열","text":"문제 보기 풀이 백트래킹 문제이며 좋은 수열인지 나쁜 수열인지 검사하는 코드를 구현하는 것이 핵심이다. 문자열에서 동일한 요소의 중복은 요소의 길이가 1 ~ N/2의 범위에 있을 때만 발생한다. 백트래킹을 통해 수열을 늘려나가는 식이므로 맨 뒷자리를 기준으로 맨 뒤 1자리의 수가 그 앞의 1자리 수와 동일한지 맨 뒤 2자리의 수가 그 앞의 2자리 수와 동일한지 맨 뒤 3자리의 수가 그 앞의 3자리 수와 동일한지 맨 뒤 4자리의 수가 그 앞의 4자리 수와 동일한지 … 맨 뒤 N/2자리의 수가 그 앞의 N/2자리 수와 동일한지 비교하는 식으로 한 번이라도 동일한 경우가 발생한다면 그 수열은 나쁜 수열로 판단할 수 있다. 가장 첫 번째로 나오는 백트래킹 알고리즘의 결과가 결과값들 중 가장 작은 수이기 때문에 기본적인 백트래킹 문제들과 같이 만들어진 결과값들끼리 최대나 최소를 비교할 필요가 없다. 그렇기 때문에 프로세스를 종료하는 코드 혹은 플래그를 이용하는 코드가 사용이 된다. 가장 작은 수를 나타내는 수열을 구하는 것이기 때문에 첫 번째 자리는 무조건 1이 나온다. 그러므로 dfs의 첫 탐색 정점 기준을 &quot;1&quot;로 잡고 시작하는 것이 더 효율적인 코드이지만 쉬운 이해를 위해 dfs(&quot;&quot;)을 사용하였다. 소스 kotlin 1234567891011121314151617181920212223242526272829303132import java.util.Scannerimport kotlin.system.exitProcessvar n = 0fun main() = with(Scanner(System.`in`)) { n = nextInt() dfs(&quot;&quot;) // dfs(&quot;1&quot;)이 더 효율적}fun dfs(s: String) { if (s.length == n) { println(s) exitProcess(0) } for (i in 1..3) { if ((s + i).isGood()) { dfs(s + i) } }}fun String.isGood(): Boolean { val len = this.length / 2 for (i in 1..len) { if (this.substring(this.length - i) == this.substring(this.length - i * 2, this.length - i)) return false } return true} 자바에서 프로세스를 강제 종료하는 System.exit(0)는 코틀린에선 exitProcess(0)를 사용한다. 하지만 exitProcess(0)를 사용하면 kotlin.system 패키지를 import 해줘야하는 번거로움이 있기에 시간이 제한되고 긴장되는 코딩 테스트 환경에서는 아래 코드와 같이 플래그 변수를 사용하거나 자바의 System.exit(0)를 사용하는 것이 나을 수도 있다. 12345678910111213141516171819202122232425262728293031323334import java.util.Scannervar n = 0var exit = falsefun main() = with(Scanner(System.`in`)) { n = nextInt() dfs(&quot;&quot;)}fun dfs(s: String) { if (exit) return if (s.length == n) { println(s) exit = true } for (i in 1..3) { if ((s + i).isGood()) { dfs(s + i) } }}fun String.isGood(): Boolean { val len = this.length / 2 for (i in 1..len) { if (this.substring(this.length - i) == this.substring(this.length - i * 2, this.length - i)) return false } return true} References https://bellog.tistory.com/43","link":"/2021/07/23/boj-2661/"},{"title":"[BOJ] 2798번 : 블랙잭","text":"문제 보기 소스 kotlin 1234567891011121314151617181920212223242526272829303132333435363738import java.util.*import kotlin.math.maxvar n = 0var m = 0var result = 0val nums = IntArray(101)val visited = BooleanArray(101)fun main() = with(Scanner(System.`in`)) { n = nextInt() m = nextInt() for (i in 0 until n) { nums[i] = nextInt() } val arr = mutableListOf&lt;Int&gt;() dfs(arr, 0) println(result)}fun dfs(arr: MutableList&lt;Int&gt;, count: Int) { if (count == 3) { if (arr.sum() &lt;= m) result = max(result, arr.sum()) return } for (i in 0 until n) { if (!visited[i]) { visited[i] = true arr.add(nums[i]) dfs(arr, count + 1) arr.removeAt(arr.size - 1) visited[i] = false } }} 단순히 3중 for문을 이용하여 간단하게 해결할 수 있는 문제이지만 백트래킹에 익숙해지기 위해 위와 같이 풀이하였다.","link":"/2021/07/23/boj-2798/"},{"title":"[Android] View Binding (뷰 바인딩)","text":"뷰 바인딩(View Binding) 기능은 뷰와 상호작용하는 코드를 쉽게 작성할 수 있게 해준다. 모듈에서 사용 설정(enable)된 뷰 바인딩은 각 XML 레이아웃 파일의 바인딩 클래스(binding class)를 생성한다. 바인딩 클래스의 인스턴스는 상응하는 레이아웃에 ID가 있는 모든 뷰의 직접 참조가 포함된다. 대부분의 경우, 뷰 바인딩이 findViewById를 대체한다. 설정 방법 뷰 바인딩은 모듈 별로 사용 설정이 된다(enabled on a module by module). 모듈에서 뷰 바인딩을 사용 설정(enable) 하려면, module 레벨의 build.gradle 파일에 viewBinding 빌드 옵션을 아래의 예시와 같이 true로 변경한다. 123456android { ... viewBinding { enabled = true } } 바인딩 클래스를 생성하는 동안 레이아웃 파일을 무시하려면 tools:viewBindingIgnore=&quot;true&quot; 속성을 레이아웃 파일의 루트 뷰에 추가해야 한다. 사용법 모듈에 뷰 바인딩이 사용 설정되면, 모듈에 포함된 각 XML 레이아웃 파일의 바인딩 클래스가 생성된다. 각 바인딩 클래스에는 루트 뷰와 ID가 있는 모든 뷰에 대한 참조를 포함한다. 생성된 바인딩 클래스의 이름은 XML 파일의 이름을 카멜 표기법으로 변환하고 끝에 'Binding’이 추가된다. result_profile.xml 이름을 가진 레이아웃 파일의 예시 123456&lt;LinearLayout ... &gt; &lt;TextView android:id=&quot;@+id/name&quot; /&gt; &lt;ImageView android:cropToPadding=&quot;true&quot; /&gt; &lt;Button android:id=&quot;@+id/button&quot; android:background=&quot;@drawable/rounded_button&quot; /&gt; &lt;/LinearLayout&gt; 생성된 바인딩 클래스의 이름은 ResultProfileBinding이 된다. 이 클래스에는 name이라는 TextView와 button이라는 Button 등 두 개의 필드가 있다. 레이아웃의 ImageView에는 ID가 없으므로 바인딩 클래스에 참조가 없다. 모든 바인딩 클래스는 getRoot() 메서드를 포함하고 있는데, 상응하는 레이아웃 파일의 루트 뷰에 대한 직접 참조를 제공한다. 위의 예시 코드에서는 ResultProfileBinding 클래스의 getRoot() 메서드가 LinearLayout 루트 뷰를 반환한다. 액티비티에서의 뷰 바인딩 사용법 액티비티에 사용할 바인딩 클래스 인스턴스를 설정하려면, 액티비티의 onCreate() 메서드에서 다음 두 단계를 따라야 한다. 생성된 바인딩 클래스에 포함된 static inflate() 메서드를 호출한다. 이를 통해 액티비티에서 사용할 바인딩 클래스의 인스턴스를 생성한다. getRoot()메서드를 호출하거나 Kotlin property syntax를 사용하여 루트 뷰의 참조를 가져온다. 루트 뷰를 setContentView()에 전달(pass)하여 화면 상의 활성 뷰로 만든다. 12345678private lateinit var binding: ResultProfileBindingoverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = ResultProfileBinding.inflate(layoutInflater) val view = binding.root setContentView(view)} 이제 바인딩 클래스의 인스턴스를 사용하여 뷰를 참조할 수 있다. 12binding.name.text = viewModel.namebinding.button.setOnClickListener { viewModel.userClicked() } 프래그먼트에서의 뷰 바인딩 사용법 프래그먼트에서 사용할 바인딩 클래스의 인스턴스를 설정하려면, 프래그먼트의 onCreateView() 메서드에서 다음 단계를 따라야 한다. 생성된 바인딩 클래스에 포함된 static inflate() 메서드를 호출한다. 그러면 프래그먼트에서 사용할 바인딩 클래스의 인스턴스가 생성된다. getRoot()메서드를 호출하거나 Kotlin property syntax를 사용하여 루트 뷰의 참조를 가져온다. onCreateView() 메서드에서 루트 뷰를 반환하여 화면 상의 활성 뷰를 만든다. ★ 참고 : inflate() 메서드를 사용하려면 layout inflator를 전달해야 한다. 레이아웃이 이미 inflate 되었다면, 바인딩 클래스의 static bind() 메서드를 호출하면 된다. 자세한 내용은 본문의 하단이나 뷰 바인딩 깃허브 샘플의 예시에서 볼 수 있다. 12345678910111213141516171819private var _binding: ResultProfileBinding? = null// This property is only valid between onCreateView and// onDestroyView.private val binding get() = _binding!!override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { _binding = ResultProfileBinding.inflate(inflater, container, false) val view = binding.root return view}override fun onDestroyView() { super.onDestroyView() _binding = null} 이제 바인딩 클래스의 인스턴스를 사용하여 뷰를 참조할 수 있다. 12binding.name.text = viewModel.namebinding.button.setOnClickListener { viewModel.userClicked() } ★ 참고 : 프래그먼트는 뷰보다 오래 지속된다(Fragments outlive their views). 프래그먼트의 onDestroyView() 메서드에서 바인딩 클래스 인스턴스에 대한 참조를 정리해야 한다. 다른 구성(configuration)에 대한 힌트 여러 구성(configuration)에서 뷰를 선언할 때, 특정 레이아웃에 따라 다른 뷰 타입을 사용하는 것이 더 합리적이다. 12345# in res/layout/example.xml&lt;TextView android:id=&quot;@+id/user_bio&quot; /&gt;# in res/layout-land/example.xml&lt;EditText android:id=&quot;@+id/user_bio&quot; /&gt; 이러한 경우, TextView가 공통된 기본 클래스(common base class)이기 때문에 생성된 클래스가 TextView 타입의 userBio 필드를 노출할 것으로 예상할 것이다. 하지만 기술적인 한계로 인해 뷰 바인딩 코드 생성기는 이러한 결정을 내릴 수 없으며, 대신에 단순히 View 필드를 생성한다. 이를 위해서는 나중에 binding.userBio as TextView를 사용하여 필드를 캐스팅해야 한다. 이 제한 사항을 해결하기 위해, 뷰 바인딩은 tools:viewBindingType 속성을 지원하여 생성된 코드에서 어떤 타입을 사용할 것인지 컴파일러에게 알릴 수 있다. tools:viewBindingType 속성을 사용하여 컴파일러가 필드를 TextView로 생성하게 하기 12345# in res/layout/example.xml (unchanged)&lt;TextView android:id=&quot;@+id/user_bio&quot; /&gt;# in res/layout-land/example.xml&lt;EditText android:id=&quot;@+id/user_bio&quot; tools:viewBindingType=&quot;TextView&quot; /&gt; 다른 예시로, 하나는 BottomNavigationView를 포함하고 다른 하나는 NavigationRailView를 포함하는 두 개의 레이아웃이 있다고 가정해보자. 두 클래스 모두 구현의 세부 정보가 포함된 NavigationBarView를 확장한다. 코드가 현재 레이아웃에 어떤 하위 클래스가 있는지 정확히 알 필요가 없는 경우, tools:viewBindingType를 사용하여 생성된 타입을 두 레이아웃 모두에서 NavigationBarView로 설정할 수 있다. 12345# in res/layout/navigation_example.xml&lt;BottomNavigationView android:id=&quot;@+id/navigation&quot; tools:viewBindingType=&quot;NavigationBarView&quot; /&gt;# in res/layout-w720/navigation_example.xml&lt;NavigationRailView android:id=&quot;@+id/navigation&quot; tools:viewBindingType=&quot;NavigationBarView&quot; /&gt; 참고로 뷰 바인딩은 코드를 생성할 때 속성 값의 유효성을 검사할 수 없다. 컴파일 타임과 런타임 오류를 방지하려면 값이 다음 조건들을 충족해야 한다. 값은 android.view.View에서 상속되는 클래스여야 한다. 값은 해당 값이 배치된 태그의 슈퍼 클래스여야 한다. 예를 들어 다음 값들은 작동하지 않는다. &lt;TextView tools:viewBindingType=&quot;ImageView&quot; /&gt; : ImageView는 TextView와 관련이 없다. &lt;TextView tools:viewBindingType=&quot;Button&quot; /&gt; : Button은 TextView의 슈퍼 클래스가 아니다. 최종 타입은 모든 구성에서 일관되게 해결되어야 한다. findViewById와의 차이점 뷰 바인딩은 findViewById를 사용하는 것에 비해 중요한 장점이 있다. 널 안정성 뷰 바인딩운 뷰에 대한 직접 참조를 생성하므로, 유효하지 않은 view ID로 인해 null pointer exception이 발생할 위험이 없다. 또한 레이아웃의 일부 구성에서만 뷰가 있는 경우, 바인딩 클래스에서 참조를 포함하는 필드가 @Nullable로 표시된다. 타입 안정성 각 바인딩 클래스에 있는 필드는 XML 파일에서 참조하는 뷰와 일치하는 타입을 가진다. 즉, 클래스 변환 예외(class cast exception)이 발생할 위험이 없다. 이러한 차이점은 레이아웃과 코드 사이의 비호환성으로 인해 findViewById가 런타임에 오류가 발생하는 반면, 뷰 바인딩은 런타임이 아닌 컴파일 타임에 빌드가 실패하게 된다는 것을 의미한다. 연산 속도 면에서도 findViewById는 레이아웃 태그를 순회하여 일치하는 뷰를 찾아가기 때문에 연산 속도에 영향을 미치고, 단순 바인딩 코드가 길어진다. 데이터 바인딩과의 비교 뷰 바인딩과 데이터 바인딩은 모두 뷰를 직접 참조하는 데 사용할 수 있는 바인딩 클래스를 생성한다. 하지만 뷰 바인딩은 보다 단순한 사용 사례를 처리하기 위한 것이며 데이터 결합에 비해 다음과 같은 이점을 제공한다. 더 빠른 컴파일 뷰 바인딩은 주석 처리(annotation processing)이 필요하지 않으므로 컴파일 시간이 더 짧다. 사용 편의성 뷰 바인딩은 특별히 태그된 XML 레이아웃 파일이 필요하지 않으므로 앱에서 더 신속하게 채택될 수 있다. 모듈에서 뷰 바인딩을 사용 설정하면 모듈의 모든 레이아웃에 뷰 바인딩이 자동으로 적용된다. 반대로 뷰 바인딩에는 데이터 바인딩과 비교해서 다음과 같은 제한 사항들이 있다. 뷰 바인딩은 레이아웃 변수 또는 레이아웃 표현식을 지원하지 않으므로, XML 레이아웃 파일에서 직접 동적 UI 콘텐츠를 선언하는 데 사용할 수 없다. 뷰 바인딩은 양방향 데이터 바인딩을 지원하지 않는다. 위 사항을 고려할 때, 일부 사례에서는 뷰 바인딩과 데이터 바인딩을 모두 사용하는 것이 가장 좋다. 고급 기능이 필요한 레이아웃에는 데이터 바인딩을, 고급 기능이 필요 없는 레이아웃에는 뷰 바인딩을 사용할 수 있다. 레이아웃이 이미 인플레이트된 상황에서의 뷰 바인딩 ↩ 12345678910111213141516171819202122/** * View Binding example with a fragment that uses the alternate constructor for inflation and * [onViewCreated] for binding. */class BindFragment : Fragment(R.layout.fragment_blank) { // Scoped to the lifecycle of the fragment's view (between onCreateView and onDestroyView) private var fragmentBlankBinding: FragmentBlankBinding? = null override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) val binding = FragmentBlankBinding.bind(view) fragmentBlankBinding = binding binding.textViewFragment.text = getString(string.hello_from_vb_bindfragment) } override fun onDestroyView() { // Consider not storing the binding instance in a field, if not needed. fragmentBlankBinding = null super.onDestroyView() }} 위 코드는 인플레이션을 위해 Alternate constructor를 사용하고 onViewCreated를 바인딩에 사용하는 프래그먼트의 뷰 바인딩 예시이다. 레이아웃이 이미 인플레이트 되었기에 바로 바인딩 클래스의 static bind() 메서드를 호출하면 된다. Additional resources Samples View binding sample Blogs Use view binding to replace findViewById Why Are Kotlin Synthetics Deprecated and What Are the Alternatives? Videos Android Jetpack: Replace findViewById with view binding References Android Docs - View Binding : https://developer.android.com/topic/libraries/view-binding","link":"/2021/07/24/android-docs-view-binding/"},{"title":"[BOJ] 이분 탐색 (Binary Search)","text":"설명 정렬되어 있는 배열에서 특정 데이터를 찾기 위해 모든 데이터를 순차적으로 확인하는 대신 탐색 범위를 절반으로 줄여가며 찾는 탐색 방법 선형 탐색 : O(N) 이분 탐색 : O(logN) 구현 BOJ 1920, 수 찾기 M개의 수에 대해 선형 탐색을 한다면 시간복잡도는 O(NM) 미리 배열 A를 정렬해둔 다음 이분 탐색을 수행하면 시간복잡도는 O(NlogN + MlogN) NlogN은 정렬에 필요한 시간복잡도, MlogN은 이분탐색에 필요한 시간복잡도 이분 탐색 직접 구현 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Scannervar n = 0var m = 0lateinit var a: IntArraylateinit var b: IntArrayfun main() { init() a.sort() b.forEach { println(binarySearch(it)) }}fun binarySearch(target: Int): Int { var st = 0 // start var en = n - 1 // end while (st &lt;= en) { val mid = (st + en) / 2 when { a[mid] &lt; target -&gt; st = mid + 1 a[mid] &gt; target -&gt; en = mid - 1 else -&gt; return 1 } } return 0}fun init() = with(Scanner(System.`in`)) { n = nextInt() a = IntArray(n) for (i in 0 until n) { a[i] = nextInt() } m = nextInt() b = IntArray(m) for (i in 0 until m) { b[i] = nextInt() }} kotlin.collections의 binarySearch 사용 JVM을 기반으로 하는 코틀린에서의 컬렉션은 자바에서 제공하는 클래스들을 그대로 사용한다. 1234b.forEach { if (a.binarySearch(it) &gt;= 0) println(1) else println(0)} contains 사용 1234b.forEach { if (a.contains(it)) println(1) else println(0)} BOJ를 기준으로 binarySearch를 이용한 풀이는 2164ms, contains는 4940ms 시간이 소요되었다. kotlin.collections의 contains 함수의 내부 구현은 다음과 같다. 123456789101112public operator fun IntArray.contains(element: Int): Boolean { return indexOf(element) &gt;= 0}public fun IntArray.indexOf(element: Int): Int { for (index in indices) { if (element == this[index]) { return index } } return -1} 내부적으로 indexOf 함수를 사용하여 모든 인덱스를 순회하는 형태로 구현되어 있으며, O(N) 시간복잡도를 가진다. 그에 반해 binarySearch의 경우 O(logN)의 시간복잡도를 가지므로 더 좋은 성능을 보여준다. 다음 코드는 java.util.Arrays의 binarySearch 코드이다. 123456789101112131415161718192021public static int binarySearch(int[] a, int fromIndex, int toIndex, int key) { rangeCheck(a.length, fromIndex, toIndex); return binarySearch0(a, fromIndex, toIndex, key);}private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key) { int low = fromIndex; int high = toIndex - 1; while(low &lt;= high) { int mid = low + high &gt;&gt;&gt; 1; int midVal = a[mid]; if (midVal &lt; key) { low = mid + 1; } else { if (midVal &lt;= key) { return mid; } high = mid - 1; } } return -(low + 1);} BOJ 10816, 숫자 카드2 삽입하는 수가 주어질 때, 오름차순 순서가 유지되는 제일 왼쪽 인덱스와 제일 오른쪽의 인덱스의 차이가 해당 배열에서 그 수의 등장 횟수가 되는 성질을 이용 start ~ end의 범위가 0 ~ a.size인 것에 유의 while의 조건문이 start &lt;= end가 아니라 start &lt; end Scanner를 통한 입력 받기 (시간 초과) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Scannervar n = 0var m = 0lateinit var a : IntArraylateinit var b : IntArrayfun main() { init() a.sort() b.forEach { print(&quot;${upperBound(it) - lowerBound(it)} &quot;) }}fun lowerBound(target: Int): Int { var st = 0 var en = a.size while (st &lt; en) { val mid = (st + en) / 2 if (a[mid] &gt;= target) en = mid else st = mid + 1 } return st}fun upperBound(target: Int): Int { var st = 0 var en = a.size while (st &lt; en) { val mid = (st + en) / 2 if (a[mid] &gt; target) en = mid else st = mid + 1 } return st}fun init() = with(Scanner(System.`in`)) { n = nextInt() a = IntArray(n + 1) for (i in 0 until n) { a[i] = nextInt() } m = nextInt() b = IntArray(m) for (i in 0 until m) { b[i] = nextInt() }} readLine()을 통한 입력 받기 (통과) 가독성이 좋아 Scanner를 통해 입력을 받는 방식을 BOJ에서 자주 사용하지만 다른 입력 방식들에 비해 느리기 때문에 시간 초과가 발생할 경우 readLine()을 이용하는 방법 등을 사용한다. 1234567891011121314151617181920212223242526272829303132lateinit var a: IntArrayfun main() { readLine() a = readLine()!!.split(&quot; &quot;).map { it.toInt() }.sorted().toIntArray() readLine() print(readLine()!!.split(&quot; &quot;).map { it.toInt() }.map { upperBound(it) - lowerBound(it) }.joinToString(&quot; &quot;))}fun lowerBound(target: Int): Int { var st = 0 var en = a.size while (st &lt; en) { val mid = (st + en) / 2 if (a[mid] &gt;= target) en = mid else st = mid + 1 } return st}fun upperBound(target: Int): Int { var st = 0 var en = a.size while (st &lt; en) { val mid = (st + en) / 2 if (a[mid] &gt; target) en = mid else st = mid + 1 } return st} 주의사항 이분 탐색을 하고자 한다면 주어진 배열은 정렬되어 있어야 한다. 무한 루프에 빠지지 않게 mid 값을 정해야 한다. 연습 문제 BOJ 18870, 좌표 압축 중복을 제외하고 자신보다 작은 수가 몇 개 있는지를 물어보는 문제 이분 탐색 - lowerBound 사용 12345678910111213141516171819202122232425262728lateinit var list: List&lt;Int&gt;fun main() { init() val sb = StringBuilder() val sorted = list.distinct().sorted() for (i in list.indices) { sb.append(lowerBound(sorted, list[i])).append(&quot; &quot;) }}fun lowerBound(list: List&lt;Int&gt;, target: Int): Int { var st = 0 var en = list.lastIndex while (st &lt; en) { val mid = (st + en) / 2 if (list[mid] &gt;= target) en = mid else st = mid + 1 } return st}fun init() { readLine() list = readLine()!!.split(&quot; &quot;).map { it.toInt() }} HashMap 사용 12345678910111213141516171819202122lateinit var list: List&lt;Int&gt;fun main() { init() val sorted = list.sorted() val map = HashMap&lt;Int, Int&gt;() var idx = 0 for (i in sorted) { if (!map.containsKey(i)) map[i] = idx++ } val sb = StringBuilder() for (i in list) { sb.append(map[i]).append(&quot; &quot;) } println(sb)}fun init() { readLine() list = readLine()!!.split(&quot; &quot;).map { it.toInt() }} 문제의 예제인 좌표 [2, 4, -10, 4, -9]을 위와 같은 알고리즘으로 압축하면 [2, 3, 0, 3, 1]이 되는데 위 그림 처럼 압축된 점들도 같은 동일선 상 안에 놓이게 된다. 이렇게 범위가 매우 넓은 좌표의 경우에 좌표를 인덱싱해서 처리 할 경우 손쉽게 처리 할 수 있게 된다. 좌표 압축 알고리즘에 대한 설명 BOJ 2295, 세 수의 합 a[i] + a[j] + a[k] = a[l]을 만족하는 a[l] 중에서 최댓값을 구하기 O(N4) 풀이 : i, j, k, l에 대한 4중 for문 O(N3logN) 풀이 : i, j, k에 대한 3중 for문을 돌리고, 배열 a 안에 a[i] + a[j] + a[k]가 있는지 이분 탐색 O(N2logN) 풀이 미리 a에서 두 원소의 합을 다 묶어놓은 배열 two 생성 two[m] + a[k] = a[l] k, l에 대한 2중 for문을 돌리고 a[l] - a[k]가 배열 two 안에 있는지 이분 탐색 two의 길이는 N2인데 log(N2)은 2logN 이어서 O(N2log(N2)) = O(N2 * 2logN) = O(N2logN) 123456789101112131415161718192021222324252627282930import java.util.Scannervar n = 0val list = mutableListOf&lt;Int&gt;()val two = mutableListOf&lt;Int&gt;()fun main() { init() list.sort() for (i in 0 until n) { for (j in i until n) { two.add(list[i] + list[j]) } } two.sort() for (i in n - 1 downTo 0) { for (j in 0 until i) { if (two.binarySearch(list[i] - list[j]) &gt;= 0) { println(list[i]) return } } }}fun init() = with(Scanner(System.`in`)) { n = nextInt() repeat(n) { list.add(nextInt()) }} 2개의 값을 묶은 후 어느 한쪽의 값을 이분탐색으로 찾아서 시간복잡도를 낮추는 아이디어는 이분탐색 관련 응용문제에서 핵심적으로 많이 나오므로 여러 문제들을 풀어보며 익숙해질 필요가 있다. Parametric Search (매개 변수 탐색) 조건을 만족하는 최소∙최대값을 구하는 문제(최적화 문제)를 결정 문제로 변환해 이분 탐색을 수행하는 방법 parametric search는 꽤 어려운 난이도를 가지고 있다. 애초에 문제가 parametric search인 것을 눈치채기가 어렵고, DP나 그리디 등의 유형과 결합을 해서 나오는 경우도 빈번하다. BOJ 1654, 세 수의 합 [최적화 문제] : N개를 만들 수 있는 랜선의 최대 길이 [결정 문제] : 랜선의 길이가 X일 때 랜선이 N개 이상인가 아닌가? 이 문제의 상황은 N개를 만들 수 있는 랜선의 최대 길이를 구하는 최적화 문제이다. 이걸 결정 문제로 바꾸면 반대로 우리가 구해야 하는 답이 인자로 들어가고, 조건의 참/거짓 여부를 판단하는 문제로 만들 수 있다. 랜선의 길이가 줄어들수록 개수가 많아지므로 간단하게 그래프를 그려보면 랜선의 길이가 x축에 놓이고 개수가 y축에 놓인다. 그리고 그래프는 x가 커질수록 y가 감소하는 형태이다. 그래프에서 답은 표시한 지점으로, 개수가 N개 이상인 지점들 중에서 가장 길이가 긴 곳이다. 이 답을 기점으로 왼쪽은 개수가 N 이상이고 오른쪽은 N 미만이다. 랜선의 길이는 최소 1, 최대 231-1인데, 우리는 여기서 이분탐색으로 답을 빠르게 찾아낼 수 있다. 이렇게 st, mid, en을 놓고 범위를 줄여가며 답을 찾는다. 최대 길이를 구해야하는 문제에서 랜선의 길이가 X일 때 조건을 만족하는지 확인하는 문제로 변환해서 풀이를 해낼 수 있다. 이 문제의 경우, 랜선의 길이를 X로 두고나면 조각의 개수를 구하는건 O(N)이고 랜선의 길이로 가능한 범위는 231이어서 시간복잡도는 O(log(231N)) = O(31N) 여기서 주의해야하는건, 지금처럼 이분탐색을 수행할 변수를 가지고 함수를 세웠을 때 그 함수가 감소함수거나 증가함수여야 한다. 만약 위의 그래프처럼 함수가 감소 혹은 증가함수 형태가 아니라 뒤죽박죽이면 이분탐색 자체가 불가능하다. 그래서 parametric search를 할 때에는 최적화 문제를 결정 문제로 바꿀 수 있는지 생각하고 그 결정 문제로 얻어낸 함수가 감소 혹은 증가함수인지를 따져봐야 한다. 문제에서 최소 혹은 최대 얘기가 있고 범위가 무지막지하게 크거나, 시간복잡도에서 값 하나를 로그로 어떻게 잘 떨구면 될 것 같을 때 parametric search 풀이가 가능하지는 않을까 고민을 해볼 필요가 있다. 123456789101112131415161718192021222324252627282930313233import java.util.Scannervar k = 0var n = 0lateinit var arr: IntArrayfun main() { init() var st: Long = 1 var en = Int.MAX_VALUE.toLong() // 2^31 - 1 while (st &lt; en) { val mid = (st + en + 1) / 2 if (solve(mid)) st = mid else en = mid - 1 } println(st)}fun solve(x: Long): Boolean { // 결정 문제 var cur = 0L for (i in 0 until k) cur += arr[i] / x return cur &gt;= n}fun init() = with(Scanner(System.`in`)) { k = nextInt() n = nextInt() arr = IntArray(k) for (i in 0 until k) { arr[i] = nextInt() }} mid = (st + en + 1) / 2로 둬야 무한 루프에 빠지지 않는다. mid = (st + en) / 2로 두면 st와 en이 1 차이날 때 st가 계속 값이 똑같아버릴 수 있다. Reference [바킹독의 실전 알고리즘] 0x13강 - BFS https://jungguji.github.io/2020/12/15/백준-18870번-좌표-압축/","link":"/2021/07/29/boj-binary-search/"},{"title":"[BOJ] 10815번 : 숫자 카드","text":"문제 보기 소스 kotlin 이분 탐색 구현 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Scannervar n = 0var m = 0lateinit var a: IntArraylateinit var b: IntArrayfun main() { init() a.sort() b.forEach { print(&quot;${binarySearch(it)} &quot;) }}fun binarySearch(target: Int): Int { var st = 0 var en = n - 1 while (st &lt;= en) { val mid = (st + en) / 2 when { a[mid] &gt; target -&gt; en = mid - 1 a[mid] &lt; target -&gt; st = mid + 1 else -&gt; return 1 } } return 0}fun init() = with(Scanner(System.`in`)) { n = nextInt() a = IntArray(n) for (i in 0 until n) { a[i] = nextInt() } m = nextInt() b = IntArray(m) for (i in 0 until m) { b[i] = nextInt() }} kotlin.collections의 binarySearch 사용 JVM을 기반으로 하는 코틀린에서의 컬렉션은 자바에서 제공하는 클래스들을 그대로 사용한다. 1234567891011121314151617181920212223242526272829import java.util.Scannervar n = 0var m = 0lateinit var a: IntArraylateinit var b: IntArrayfun main() { init() a.sort() b.forEach { if (a.binarySearch(it) &lt; 0) print(&quot;0 &quot;) else print(&quot;1 &quot;) }}fun init() = with(Scanner(System.`in`)) { n = nextInt() a = IntArray(n) for (i in 0 until n) { a[i] = nextInt() } m = nextInt() b = IntArray(m) for (i in 0 until m) { b[i] = nextInt() }}","link":"/2021/08/02/boj-10815/"},{"title":"[BOJ] 1756번 : 피자 굽기","text":"문제 보기 풀이 이중 for문으로 문제를 접근하기엔 300,0002으로 시간 초과가 발생할 것을 예상할 수 있다. 이분탐색으로 문제를 해결하고 싶어도 주어진 배열은 정렬된 형태가 아니므로 입력값 그대로는 이분탐색을 사용할 수 없다. 이분탐색을 사용하기 위해 주어진 배열(오븐의 지름값들)을 내림차순으로 정렬되도록 값을 변경해준다. 오븐 깊이 오븐 지름 통과할 수 있는 반죽의 최대 크기 1 5 5 2 6 5 3 4 4 4 3 3 5 6 3 6 2 2 7 3 2 위의 표와 같이 지름이 순서대로 5 6 4 3 6 2 3인 오븐을 예로 들면(오븐의 최상단이 1, 최하단이 D이므로 깊이는 인덱스에 1을 더한다), 깊이 2에서 오븐의 지름이 6이라도 바로 위인 깊이 1의 오븐의 지름이 5이므로 통과할 수 있는 피자 반죽의 지름은 5보다 클 수가 없다. 오븐의 지름은 이전 깊이의 오븐의 지름보다 작거나 같아야하므로 아래와 같은 코드로 오븐의 지름을 변경한다. 12345var min = oven[0]for (i in 0 until depth) { min = min(min, oven[i]) oven[i] = min} 이제 정렬된 배열이 있으니 이분탐색을 할 수 있다. 각 피자 반죽의 위치는 찾고자 하는 피자 반죽의 지름보다 작은 값이 처음으로 나타나는 위치에서 1을 뺀 값이다. 즉, 찾고자 하는 값보다 작은 값이 처음으로 나타나는 위치를 반환하는 upperBound 구현을 응용하여 피자 반죽의 위치를 알아낼 수 있다(lowerBound는 내림차순 기준, 찾고자하는 값 이하가 처음으로 나타나는 위치). 탐색 구간의 끝점을 가장 최근 오븐에 들어간 피자 반죽의 위치로 설정하여 모든 반죽들의 위치를 탐색하면 마지막 반죽의 위치에 1을 더한 값(1-based indexing이므로)이 맨 위의 피자가 들어가 있는 깊이이다. 소스 kotlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Scannerimport kotlin.math.minvar d = 0var n = 0var st = 0var en = 0lateinit var a: IntArraylateinit var b: IntArrayfun main() { init() sortOvenDiameter(a) println(lastIndex())}fun lastIndex(): Int { st = 0 en = d for (i in 0 until n) { depthOfPizza(b[i]) if (en &lt; 0) break st = 0 } return en + 1 // 1-based indexing : 오븐의 최상단이 1, 최하단이 D이므로}fun depthOfPizza(target: Int) { // 내림차순의 upperBound 사용 while (st &lt; en) { val mid = (st + en) / 2 if (a[mid] &lt; target) en = mid else st = mid + 1 } en--}fun sortOvenDiameter(a : IntArray) { var min = a[0] for (i in 0 until d) { min = min(min, a[i]) a[i] = min }}fun init() = with(Scanner(System.`in`)) { d = nextInt() n = nextInt() a = IntArray(d) b = IntArray(n) for (i in 0 until d) a[i] = nextInt() for (i in 0 until n) b[i] = nextInt()} 정렬 순서에 따른 upperBound와 lowerBound 구현 BOJ 10816번, 숫자 카드 2 기준으로 설명 오름차순 정렬 오름차순 정렬일 경우 lowerBound는 찾고자 하는 값 이상이 처음으로 나타나는 위치인 반면에, upperBound는 찾고자 하는 값보다 큰 값이 처음으로 나타나는 위치이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Scannervar n = 0var m = 0lateinit var a : IntArraylateinit var b : IntArrayfun main() { init() a.sort() // 오름차순 정렬 b.forEach { print(&quot;${upperBound(it) - lowerBound(it)} &quot;) }}fun lowerBound(target: Int): Int { var st = 0 var en = a.size while (st &lt; en) { val mid = (st + en) / 2 if (a[mid] &gt;= target) en = mid else st = mid + 1 } return st}fun upperBound(target: Int): Int { var st = 0 var en = a.size while (st &lt; en) { val mid = (st + en) / 2 if (a[mid] &gt; target) en = mid else st = mid + 1 } return st}fun init() = with(Scanner(System.`in`)) { n = nextInt() a = IntArray(n + 1) for (i in 0 until n) { a[i] = nextInt() } m = nextInt() b = IntArray(m) for (i in 0 until m) { b[i] = nextInt() }} 내림차순 정렬 내림차순 정렬일 경우 lowerBound는 찾고자 하는 값 이하가 처음으로 나타나는 위치인 반면에, upperBound는 찾고자 하는 값보다 작은 값이 처음으로 나타나는 위치이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Scannervar n = 0var m = 0lateinit var a : IntArraylateinit var b : IntArrayfun main() { init() a.sortDescending() // 내림차순 정렬 b.forEach { print(&quot;${upperBound(it) - lowerBound(it)} &quot;) }}fun lowerBound(target: Int): Int { var st = 0 var en = a.size while (st &lt; en) { val mid = (st + en) / 2 if (a[mid] &lt;= target) en = mid else st = mid + 1 } return st}fun upperBound(target: Int): Int { var st = 0 var en = a.size while (st &lt; en) { val mid = (st + en) / 2 if (a[mid] &lt; target) en = mid else st = mid + 1 } return st}fun init() = with(Scanner(System.`in`)) { n = nextInt() a = IntArray(n + 1) for (i in 0 until n) { a[i] = nextInt() } m = nextInt() b = IntArray(m) for (i in 0 until m) { b[i] = nextInt() }}","link":"/2021/08/02/boj-1756/"},{"title":"[BOJ] 1939번 : 중량제한","text":"문제 보기 소스 kotlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import kotlin.math.maxvar n = 0var m = 0var start = 0var end = 0var result = 0lateinit var graph: Array&lt;ArrayList&lt;Info&gt;&gt;lateinit var visit: BooleanArraylateinit var factory: Pair&lt;Int, Int&gt;fun main() { init() binarySearch()}fun binarySearch() { while (start &lt;= end) { val mid = (start + end) / 2 visit = BooleanArray(n + 1) if (dfs(factory.first, mid)) { start = mid + 1 result = mid } else { end = mid - 1 } } println(result)}fun dfs(cur: Int, limit: Int): Boolean { if (visit[cur]) return false visit[cur] = true if (cur == factory.second) return true for (island in graph[cur]) { val (next, weight) = island.dest to island.weight if (weight &gt;= limit) { if (dfs(next, limit)){ return true } } } return false}fun init() { val br = System.`in`.bufferedReader() val firstLine = br.readLine().split(&quot; &quot;) n = firstLine[0].toInt() m = firstLine[1].toInt() graph = Array(n + 1) { ArrayList() } for (i in 0 until m) { val (a, b, c) = br.readLine().split(&quot; &quot;).map { it.toInt()} graph[a].add(Info(b, c)) graph[b].add(Info(a, c)) end = max(end, c) } val lastLine = br.readLine().split(&quot; &quot;) factory = lastLine[0].toInt() to lastLine[1].toInt()}data class Info(val dest: Int, val weight: Int) BFS/DFS와 이분탐색을 함께 적용해서 풀어야하는 문제이다. 아직 BFS/DFS 문제에 익숙하지 않다보니 시간도 많이 소요되고 결국 다른 사람의 코드를 봐야했다. BFS/DFS 관련 문제를 많이 풀어보고 다시 이 문제를 풀어야겠다.","link":"/2021/08/02/boj-1939/"},{"title":"[프로그래밍 용어] 리터럴(literal)과 상수(constant)란?","text":"코틀린에서 &quot;람다 표현식과 익명 함수는 함수 리터럴(function literals)이다&quot;라는 설명을 보면서 리터럴이 정확히 무엇인지 정확히 이해하고 있지 않은 것 같아 개념을 글로 정리하게 되었다. 위키백과에서 리터럴(literal)은 소스 코드의 고정된 값을 표현하는 용어라 설명한다. In computer science, a literal is a notation for representing a fixed value in source code. 고정된 값이라는 표현 때문에 우리가 흔히 사용하던 상수(constant)의 개념과 혼란이 왔는데, 실제로 구글에 literal vs constant에 대한 검색 결과가 많이 존재하는 것을 보아 이 용어들이 헷갈리는 건 나뿐만이 아니었나 보다. 위키백과에서 상수에 대해선 실행 중에 프로그램에 의해 변경되어선 안되는 값이라 설명한다. In computer programming, a constant is a value that should not be altered by the program during normal execution. 리터럴은 고정된 값, 상수는 변경되어선 안되는 값이라니 위키백과의 설명만 봐서는 이 용어들에 대해 감을 잡기가 어려웠기에 스택오버플로우의 답변을 살펴보았다. 설명 1 리터럴 &quot;hey&quot; (a string) false (a boolean) 3.14 (a real number) [1,2,3] (a list of numbers) (x) =&gt; x*x (a function) /^1?$|^(11+?)\\1+$/ (a RegExp) 리터럴이 아닌 것 std::cout (an identifier) foo = 0; (a statement) 1 + 2 (an expression) 가장 많은 채택을 받은 답변이지만 뭔가 모호하다. 다른 답변들을 살펴보자. 설명 2 기본적으로 상수는 값을 변경할 수 없는 변수이다. 리터럴은 고정값을 나타내는 표기법이다. 이 값은 문자열, 숫자 등이 될 수 있다. 리터럴은 변수에 할당될 수 있다. 123var a = 10;var name = &quot;Simba&quot;;const pi = 3.14; a와 name은 변수이고, pi는 상수다. 10, &quot;Simba&quot;, 3.14는 리터럴이다. 123int y = 2; // 2는 리터럴이지만, y는 아니다.int z = y + 4; // y랑 z는 리터럴이 아니지만 4는 리터럴이다.int a = 1 + 2; // 1 + 2 는 리터럴이 아니지만 (표현식이다), 1과 2 각각은 리터럴이다. 이제 리터럴이 무엇인지 감이 올 것 같지만 좀 더 보충해보자. 설명 3 12const DRINKING_AGE = 21;const VOTING_AGE = 18; 위의 코드에서 18과 21은 리터럴이다. 리터럴은 if(age &gt; 18) 또는 if(age &lt; 21)과 같이 프로그램의 모든 영역에서 사용될 수 있다. 하지만 상수를 이용하면 if(age &gt; VOTING_AGE)와 같이 코드를 더 이해하기 쉽게 만들 수 있다. 프로그래밍을 하면서 매직 넘버를 사용하지 마라 와 같은 말을 들어봤을 것이다. 상수를 사용하면 프로그래머가 각 리터럴이 무엇인지, 어떠한 의미를 지녔는지를 일일이 기억하고 유추할 필요가 없어진다. 비즈니스 요구 사항에 따라 상수를 변경해야 하는 경우(예를 들어, 향후 음주 연령을 20세로 낮추는 경우) 프로그램에 변경 사항을 적용하는 것이 훨씬 쉬워진다. 프로그램 전체에서 리터럴을 사용했다면 변경하기도 어렵고 일부 인스턴스는 수정이 누락될 위험도 있다. 결론 스택오버플로우 등을 검색하여 리터럴과 상수의 차이점이 무엇인지 정리하였다. 이제 리터럴이 무엇인지 이해하였는데 코틀린 등의 언어에서 이야기하는 함수 리터럴의 정의는 무엇인지 알아볼 필요가 있다고 생각한다. 함수 리터럴에 대해선 아래의 글들을 참고하여 정리할 예정이다. Kotlin Programmer Dictionary: Function Type vs Function literal vs Lambda expression vs Anonymous function Kotlin의 Extension은 어떻게 동작하는가 part 3 References Wikipedia - Literal MDN - Literals stackoverflow - Confusion between constants and literals? stackoverflow - What does the word “literal” mean? stackoverflow - What is the difference between literals and non-literals … Constant vs. Literal","link":"/2021/08/04/term-literal/"},{"title":"[프로그래밍 용어] 멱등성(idempotent)이란?","text":"전산학이나 수학에서 사용하는 용어로 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질, 연산을 여러 번 반복하여도 한 번만 수행된 것과 같은 성질을 의미한다. 함수 f(x)를 예를 들면 다음과 같은 등식이 성립된다. 즉 메서드가 여러 번 실행되어도, 결과는 같으므로 안전하게 사용할 수 있는 성질이기도 하다. 1f(f(x)) = f(x) 등식으로만 처음 보면 감이 오지 않을 수 있는데 절대값을 구하기 위해 사용하는 abs() 함수가 바로 멱등성을 가지고 있다. 모든 x에 대해 abs(abs(x)) = abs(x)이기 대문이다. 수학적 정의에서 x가 객체의 상태를 나타내고, f가 해당 객체를 변경할 수 있는 연산이라는 점을 고려해보자. 예를 들어, 파이썬의 set이 있고, 이것의 discard 메서드는 set에서 요소를 제거하고, 요소가 존재하지 않으면 아무 작업도 수행하지 않는다. 그러므로 1my_set.discard(x) 는 동일한 작업을 두 번 수행하는 것과 정확히 동일한 효과가 있다. (참고로 array.pop()은 멱등적이지 않다) 12my_set.discard(x)my_set.discard(x) 멱등 연산은 작업 수행 요청이 최소 한 번 발생하도록 보장되지만 두 번 이상 발생할 수도 있는 네트워크 프로토콜 설계에 자주 사용된다. 작업이 멱등적이면 작업을 두 번 이상 수행해도 결과는 한 번만 수행된 것과 동일하기 때문에 문제가 없기 때문이다. 멱등은 RESTful 웹 서비스의 맥락에서 많이 언급된다. REST는 HTTP를 최대한 활용하여 프로그램에 웹 콘텐츠에 대한 액세스 권한을 부여하고, 일반적으로 HTTP 요청 및 응답 내에서 원격 프로시저 호출 스타일 서비스를 터널링하는 SOAP 기반 웹 서비스와 대조적으로 설정된다. REST는 웹 애플리케이션을 리소스(예: Twitter 사용자 또는 Flickr 이미지)로 구성한 다음 POST, PUT, GET 및 DELETE의 HTTP 메서드를 사용하여 해당 리소스를 생성, 업데이트, 읽기 및 삭제한다. 이중 POST를 제외한 나머지 HTTP 메서드를 사용하는 API(GET, PUT, DELETE)들이 멱등성이 유지되어야 한다. 멱등성은 REST에서 중요한 역할을 한다. REST 리소스 표현을 GET하고(예: Flickr에서 jpeg 이미지 가져오기) 작업이 실패하면 작업이 성공할 때까지 GET을 계속해서 반복할 수 있다. 웹 서비스의 경우 이미지를 몇 번 가져왔는지는 중요하지 않다. 마찬가지로 RESTful 웹 서비스를 사용하여 Twitter 계정 정보를 업데이트하는 경우 웹 서비스에서 확인을 받기 위해 필요한 만큼 새 정보를 PUT 할 수 있다. 천 번 PUT 하는 것은 한 번 PUT 하는 것과 같다. 마찬가지로 REST 리소스를 천 번 DELETE하는 것은 한 번 DELETE하는 것과 같다. 따라서 멱등성을 사용하면 통신 오류에 탄력적인 웹 서비스를 훨씬 쉽게 구성할 수 있다. References Stackoverflow : What is an idempotent operation? NHN Cloud Meetup! : 지속 가능한 소프트웨어를 위한 코딩 방법 Wikipedia : Idempotence","link":"/2021/08/05/term-idempotent/"},{"title":"[Android] Jetpack Compose 기초 - Compose 이해하기","text":"Jetpack Compose Android를 위한 현대적인 선언형 UI 도구 키트 Compose는 프론트엔드 뷰를 명령형으로 변형하지 않고도 앱 UI를 렌더링할 수 있게 하는 선언형 API(declarative API)를 제공 -&gt; 앱 UI를 더 쉽게 작성하고 유지관리할 수 있도록 지원 선언형 프로그래밍 패러다임 지금까지 Android 뷰 계층 구조는 UI 위젯의 트리로 표시해옴. 사용자 상호작용 등의 이유로 인해 앱의 상태가 변경되면, 현재 데이터를 표시하기 위해 UI 계층 구조를 업데이트해야 함 UI를 업데이트하는 가장 일반적인 방법 : findViewById()와 같은 함수를 사용하여 트리를 탐색하고 button.setText(String), container.addChild(View) 또는 img.setImageBitmap(Bitmap)과 같은 메서드를 호출하여 노드를 변경. 이러한 메서드는 위젯의 내부 상태를 변경한다. 뷰를 수동으로 조작하면 오류 발생 가능성이 커진다. 일반적으로 업데이트에 필요한 뷰의 수가 많을수록 유지보수 복잡성이 증가한다. 데이터를 여러 위치에서 렌더링하면 데이터를 표시하는 뷰 중 하나의 업데이트를 누락할 수도 있음 두 업데이트가 충돌하여 잘못된 상태를 야기할 수도 있음 Compose는 선언형 UI 프레임워크로, 지난 몇 년 간 업계 전반으로 선언형 UI 모델로 전환하기 시작 -&gt; 사용자 인터페이스 빌드 및 업데이트와 관련된 엔지니어링이 크게 간소화됨. 이 기법은 처음부터 화면 전체를 개념적으로 재생성한 후 필요한 변경사항만 적용하는 방식으로 작동 이러한 접근 방식은 상태를 가진(Stateful) 뷰 계층 구조를 수동으로 업데이트할 때의 복잡성을 방지할 수 있음 선언형 UI 모델에서 화면 전체를 재생성하는 데 있어 한 가지 문제는 시간, 컴퓨팅 성능 및 배터리 사용량 측면에서 잠재적으로 비용이 많이 든다는 것 이 비용을 줄이기 위해, Compose는 특정 시점에 UI의 어떤 부분을 다시 그려야 하는지를 지능적으로 선택함 이는 재구성(Recomposition)에 설명된 대로 UI 구성요소를 디자인하는 방식에 몇 가지 영향을 미친다. 간단한 composable 함수 Compose를 사용하면, 데이터를 받아서 UI 요소를 내보내는 composable 함수들을 정의해서 사용자 인터페이스를 빌드할 수 있다. String을 받아서 인사말 메시지를 표시하는 Text 위젯을 내보내는 Greeting composable function Greeting 함수에 관해 주목할 만한 참고 사항들 이 함수는 @Composable 애노테이션으로 애노테이션이 지정된다. 모든 composable 함수에는 이 애노테이션이 있어야 한다. 이 애노테이션은 이 함수가 데이터를 UI로 변환하기 위한 함수라는 것을 Compose 컴파일러에 알린다. 이 함수는 데이터를 받는다. composable 함수는 매개변수를 받을 수 있으며 이 매개변수를 통해 앱 로직이 UI를 형성(describe)할 수 있다. 이 함수는 UI에 텍스트를 표시한다. 이를 위해 실제로 텍스트 UI 요소를 생성하는 Text() composable 함수를 호출한다. composable 함수는 다른 composable 함수를 호출하여 UI 계층 구조를 내보낸다(emit). 이 함수는 아무것도 반환하지 않는다. UI를 내보내는 Compose 함수는 UI 위젯을 구성하는 대신 원하는 화면 상태를 설명하므로 아무것도 반환할 필요가 없다. 이 함수는 빠르고, 멱등성(idempotent)이며 부수효과(side-effect)가 없다. 이 함수는 동일한 인자로 여러 번 호출될 때 동일한 방식으로 작동하며, 전역 변수 또는 random() 호출과 같은 다른 값을 사용하지 않는다. 이 함수는 속성 또는 전역 변수 수정과 같은 부수효과 없이 UI를 형성한다. 일반적으로 모든 composable 함수는 재구성에서 설명한 이유로 인해 이러한 속성을 사용하여 작성해야 한다. 선언형 패러다임 전환 많은 명령형 객체 지향(imperative object-oriented) UI 툴킷을 사용하여 위젯의 트리를 인스턴스화함으로써 UI를 초기화 한다. 흔히 XML 레이아웃 파일을 인플레이팅해서 이 작업을 한다. 각 위젯은 자체의 내부 상태를 유지하고 앱 로직이 위젯과 상호작용할 수 있도록 하는 getter와 setter 메서드를 노출한다. Compose의 선언형 접근 방식에서 위젯은 비교적 상태를 가지고 있지 않으며(stateless) setter 또는 getter 함수를 노출하지 않는다. 사실상 위젯은 객체로 노출되지 않는다. 동일한 composable 함수를 다른 인수로 호출하여 UI를 업데이트한다. 이렇게 하면 앱 아키텍처 가이드에 설명된 대로 ViewModel과 같은 아키텍처 패턴에 상태를 쉽게 제공할 수 있다. 그런 다음 컴포저블은 observable data가 업데이트될 때마다 현재 애플리케이션 상태를 UI로 변환한다. 앱 로직은 최상위의 composable 함수에 데이터를 제공한다. 그러면 함수는 데이터를 사용하여 다른 컴포저블을 호출함으로써 UI를 형성하고 적절한 데이터를 해당 컴포저블 및 계층 구조 아래로 전달한다. 사용자가 UI와 상호작용할 때, UI는 onClick과 같은 이벤트를 발생시킨다. 이러한 이벤트를 앱 로직에 알려서 앱의 상태를 변경해야 한다. 상태가 변경되면 composable 함수는 새 데이터와 함께 다시 호출된다. 이렇게 하면 UI 요소가 다시 그려진다. 이 프로세스를 재구성(recomposition)이라 한다. 사용자가 UI 요소와 상호작용하며 이에 따라 이벤트가 트리거된다. 앱 로직이 이벤트에 응답하면, composable 함수가 필요한 경우 새 매개변수를 사용하여 자동으로 다시 호출된다. 동적 콘텐츠 composable 함수는 XML이 아닌 Kotlin으로 작성되기 때문에, 다른 Kotlin 코드와 마찬가지로 동적일 수 있다. 예를 들어 사용자 목록으로 환영하는 UI를 빌드한다고 가정해보자. 123456@Composablefun Greeting(names: List&lt;String&gt;) { for (name in names) { Text(&quot;Hello $name&quot;) }} 이 함수는 이름 목록을 받아서 각 사용자에 대한 인사말을 생성한다. Composable 함수는 상당히 정교할 수 있다(sophisticated). if 문을 사용하여 특정 UI 요소를 표시할지 여부를 결정할 수 있고, 루프를 사용할 수도, 헬퍼 함수를 호출할 수도, 기본 언어의 유연성을 완전히 활용할 수도 있다. 이러한 성능과 유연성은 Jetpack Compose의 주요 이점 중 하나이다. 재구성(Recomposition) 명령형 UI 모델에서 위젯을 변경하려면 위젯에서 setter를 호출하여 내부의 상태를 변경한다. Compose에서는 새 데이터를 사용하여 composable 함수를 다시 호출한다. 이렇게 하면 함수가 재구성되며, 필요한 경우 함수에서 내보낸 위젯이 새 데이터로 다시 그려진다. Compose 프레임워크는 변경된 구성요소만 지능적으로 재구성할 수 있다. 예를 들어 다음과 같이 버튼을 표시하는 composable 함수를 고려해보자. 123456@Composablefun ClickCounter(clicks: Int, onClick: () -&gt; Unit) { Button(onClick = onClick) { Text(&quot;I've been clicked $clicks times&quot;) }} 버튼이 클릭될 때마다 호출자는 clicks 값을 업데이트한다. Compose는 Text 함수를 사용해 람다를 다시 호출하여 새 값을 표시한다. 이 프로세스를 재구성이라 한다. 값에 종속되지 않은 다른 함수들은 재구성되지 않는다. 앞서 논의했듯이 전체 UI 트리를 재구성하는 하는 작업은 컴퓨팅 성능 및 배터리 수명을 사용한다는 측면에서 컴퓨팅 비용이 많이 들 수 있다. Compose는 지능적 재구성을 통해 이 문제를 해결한다. 재구성은 입력이 변경될 때 composable 함수를 다시 호출하는 프로세스다. 이는 함수의 입력이 변경될 때 발생한다. Compose는 새 입력을 기반으로 재구성할 때, 변경되었을 수 있는 함수 또는 람다만 호출하고 나머지는 건너뛴다. 매개변수가 변경되지 않는 함수 또는 람다를 모두 건너뜀으로써 Compose는 재구성을 효율적으로할 수 있다. 함수의 재구성을 건너뛸 수 있으므로 composable 함수 실행의 부수효과에 의존해서는 안된다. 그렇게 하면 사용자가 앱에서 이상하고 예측 불가능한 동작을 경험할 수 있다. 부수효과는 앱의 나머지 부분에 표시되는 변경사항이다. 예를 들어 다음 작업은 모두 위험한 부수효과이다. 공유 객체의 속성에 쓰기 ViewModel에서 observable을 업데이트 Shared preferences 업데이트 composable 함수는 애니메이션이 렌더링될 때와 같이 모든 프레임에서 같은 빈도로 재실행될 수 있다. 애니메이션 도중 버벅거림을 방지하려면 composable 함수가 빨라야 한다. Shared preferences에서 읽기와 같이 비용이 많이 드는 작업을 실행해야 하는 경우 백그라운드 코루틴에서 작업을 실행하고 값 결과를 composable 함수의 매개변수로 전달해야한다. 예를 들어 다음 코드는 컴포저블을 생성하여 SharedPreferences의 값을 업데이트한다. 대신 이 코드는 백그라운드 코루틴의 ViewModel로 읽기 및 쓰기를 이동한다. 앱 로직은 콜백과 함께 현재 값을 전달하여 업데이트를 트리거한다. 1234567891011@Composablefun SharedPrefsToggle( text: String, value: Boolean, onValueChanged: (Boolean) -&gt; Unit) { Row { Text(text) Checkbox(checked = value, onCheckedChange = onValueChanged) }} 이 문서에서는 Compose에서 프로그래밍할 때 알아야 할 여러 가지 사항을 설명한다. Composable 함수는 순서와 관계없이 실행할 수 있다. Composable 함수는 동시에(parallel) 실행할 수 있다. 재구성은 최대한 많은 수의 Composable 함수 및 람다를 건너뛴다. 재구성은 낙관적이며 취소될 수 있다. Composable 함수는 애니메이션의 모든 프레임에서와 같은 빈도로 매우 자주 실행될 수 있다. 다음 섹션에서는 Composable 함수를 빌드하여 재구성을 지원하는 방법을 설명한다. 어떤 경우든 Composable 함수를 빠르고, 멱등성이며, 부수효과가 없는 상태로 유지하는 것이 좋다. Composable 함수는 순서와 관계없이 실행할 수 있음 Composable 함수의 코드를 살펴보면 코드가 표시된 순서대로 실행된다고 가정할 수도 있다. 하지만 코드가 반드시 표시된 순서대로 실행되는 것은 아니다. Composable 함수에 다른 Composable 함수 호출이 포함되어 있다면 그 함수는 순서와 관계없이 실행될 수 있다. Compose에는 일부 UI 요소가 다른 UI 요소보다 우선순위가 높다는 것을 인식하고 그 요소를 먼저 그리는 옵션이 있다. 예를 들어 탭 레이아웃에 세 개의 화면을 그리는 다음과 같은 코드가 있다고 가정해 보자. 12345678@Composablefun ButtonRow() { MyFancyNavigation { StartScreen() MiddleScreen() EndScreen() }} StartScreen, MiddleScreen 및 EndScreen 호출은 순서와 관계없이 발생할 수 있다. 즉, 예를 들어 StartScreen()이 일부 전역 변수(부수효과)를 설정하고 MiddleScreen()이 이러한 변경사항을 활용하도록 할 수 없음을 의미한다. 대신 이러한 각 함수는 독립적이어야 한다. Composable 함수는 동시에(parallel) 실행할 수 있음 Compose는 composable 함수들을 동시에 실행하여 재구성을 최적화할 수 있다. 이를 통해 Compose가 다중 코어를 활용하고, 화면에 없는 composable 함수를 낮은 우선순위로 실행할 수 있다. 이 최적화는 composable 함수가 백그라운드 스레드 풀 내에서 실행될 수 있음을 의미한다. composable 함수가 ViewModel에서 함수를 호출하면, Compose는 동시에 여러 스레드에서 이 함수를 호출할 수 있다. 애플리케이션이 올바르게 작동하도록 하려면 모든 composable 함수에 부수효과가 없어야 한다. 대신 UI 스레드에서 항상 실행되는 onClick과 같은 콜백에서 부수효과를 트리거한다. composable 함수가 호출될 때, 호출자(caller)와 다른 스레드에서 호출(invocation)이 발생할 수 있다. 즉, composable 람다의 변수를 수정하는 코드는 피해야 한다. 이러한 코드는 thread-safe하지 않을 뿐만 아니라 composable 람다의 허용되지 않는 부수효과이기 때문이다. 다음은 목록과 개수를 표시하는 컴포저블을 보여주는 예시다. 1234567891011@Composablefun ListComposable(myList: List&lt;String&gt;) { Row(horizontalArrangement = Arrangement.SpaceBetween) { Column { for (item in myList) { Text(&quot;Item: $item&quot;) } } Text(&quot;Count: ${myList.size}&quot;) }} 이 코드는 부수효과가 없으며, 입력 목록을 UI로 변환한다. 이 코드는 작은 목록을 표시할 때 유용한 코드다. 그러나 함수가 로컬 변수에 쓰는 경우, 이 코드는 thread-safe 하지 않거나 적절하지 않다. 123456789101112131415@Composable@Deprecated(&quot;Example with bug&quot;)fun ListWithBug(myList: List&lt;String&gt;) { var items = 0 Row(horizontalArrangement = Arrangement.SpaceBetween) { Column { for (item in myList) { Text(&quot;Item: $item&quot;) items++ // column의 재구성으로 인한 부수효과 때문에 이러한 코드는 피해야 한다. } } Text(&quot;Count: $items&quot;) }} 이 예에서 items는 모든 재구성을 통해 수정된다. 수정은 애니메이션의 모든 프레임에서 또는 목록이 업데이트될 때 실행될 수 있다. 어느 쪽이든 UI에 잘못된 개수가 표시된다. 이 때문에 이와 같은 쓰기는 Compose에서 지원되지 않는다. 이러한 쓰기를 금지함으로써 프레임워크가 composable 람다를 실행하도록 스레드를 변경할 수 있다. 재구성은 가능한 많이 건너뜀 UI의 일부가 잘못된 경우, Compose는 업데이트해야 하는 부분만 재구성하기 위해 최선을 다한다. 즉, UI 트리에서 위 또는 아래에 있는 컴포저블을 실행하지 않고 단일 버튼의 컴포저블을 다시 실행하도록 건너뛸 수 있다. 모든 composable 함수 및 람다는 자체적으로 재구성할 수 있다. 다음은 목록을 렌더링할 때 재구성이 일부 요소를 건너뛸 수 있는 방법을 보여주는 예이다. 123456789101112131415161718192021222324252627282930313233/** * 헤더와 함께 사용자가 클릭할 수 있는 이름 목록 표시 */@Composablefun NamePicker( header: String, names: List&lt;String&gt;, onNameClicked: (String) -&gt; Unit) { Column { // 이 코드는 [header]가 변경될 때 재구성될 것이다. 하지만 [names]가 변경될 땐 재구성되지 않는다. Text(header, style = MaterialTheme.typography.h5) Divider() // LazyColumn은 RecyclerView의 Compose 버전이다. // items()에 전달된 람다는 RecyclerView.ViewHolder와 유사하다. LazyColumn { items(names) { name -&gt; // item의 [name]이 업데이트될 때, 해당 item의 adapter가 재구성된다. // adapter는 [header]가 변경된다고 재구성되지 않는다. NamePickerItem(name, onNameClicked) } } }}/** * Display a single name the user can click. */@Composableprivate fun NamePickerItem(name: String, onClicked: (String) -&gt; Unit) { Text(name, Modifier.clickable(onClick = { onClicked(name) }))} 이러한 각 범위는 재구성 도중에 실행할 유일한 사항일 수 있다. Compose는 header가 변경될 때 상위 요소 중 어느 것도 실행하지 않고 Column 람다로 건너뛸 수 있다. 그리고 Column을 실행할 때 Compose는 names가 변경되지 않았다면 LazyColumnItems를 건너뛰도록 선택할 수 있다. 다시 말하지만, 모든 composable 함수 또는 람다를 실행하는 작업에는 부수효과가 없어야 한다. 부수효과를 실행해야 할 때는 콜백에서 부수효과를 트리거해야 한다. 재구성은 낙관적임 재구성은 Compose가 컴포저블의 매개변수가 변경되었을 수 있다고 생각할 때마다 시작된다. 재구성은 낙관적이다. 즉, Compose는 매개변수가 다시 변경되기 전에 재구성을 완료할 것으로 예상한다. 재구성이 완료되기 전에 매개변수가 변경되면 Compose는 재구성을 취소하고 새 매개변수를 사용하여 재구성을 다시 시작할 수 있다. 재구성이 취소되면 Compose는 재구성에서 UI 트리를 삭제한다. 표시되는 UI에 종속되는 부수효과가 있다면 구성이 취소된 경우에도 부수효과가 적용된다. 이로 인해 일관되지 않은 앱 상태가 발생할 수 있다. 낙관적 재구성을 처리할 수 있도록 모든 composable 함수 및 람다가 멱등성이고 부수효과가 없는지 확인해야 한다. Composable 함수는 매우 자주 실행될 수 있음 경우에 따라, composable 함수는 UI 애니메이션의 모든 프레임에서 실행될 수 있다. 함수가 기기 저장소에서 읽기와 같이 비용이 많이 드는 작업을 실행하면 이 함수로 인해 UI 버벅임(jank)이 발생할 수 있다. 예를 들어 위젯이 기기 설정을 읽으려고 하면 잠재적으로 이 설정을 초당 수백 번 읽을 수 있으며 이는 앱 성능에 치명적인 영향을 줄 수 있다. composable 함수에 데이터가 필요하다면 데이터의 매개변수를 정의해야 한다. 그런 다음, 비용이 많이 드는 작업을 구성(composition) 외부의 다른 스레드로 이동하고, mutableStateOf 또는 LiveData를 사용하여 Compose에 직접 데이터를 전달할 수 있다. References Android Developers : Jetpack Compose Foundation - Thinking in Compose","link":"/2021/08/05/android-compose-thinking-in-compose/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Codility","slug":"Codility","link":"/tags/Codility/"},{"name":"RecyclerView","slug":"RecyclerView","link":"/tags/RecyclerView/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"Room","slug":"Room","link":"/tags/Room/"},{"name":"Fragment","slug":"Fragment","link":"/tags/Fragment/"},{"name":"DiffUtil","slug":"DiffUtil","link":"/tags/DiffUtil/"},{"name":"Executors","slug":"Executors","link":"/tags/Executors/"},{"name":"Dialog","slug":"Dialog","link":"/tags/Dialog/"},{"name":"AppCompat","slug":"AppCompat","link":"/tags/AppCompat/"},{"name":"App Bar","slug":"App-Bar","link":"/tags/App-Bar/"},{"name":"Action Bar","slug":"Action-Bar","link":"/tags/Action-Bar/"},{"name":"Toolbar","slug":"Toolbar","link":"/tags/Toolbar/"},{"name":"Menu","slug":"Menu","link":"/tags/Menu/"},{"name":"Intent","slug":"Intent","link":"/tags/Intent/"},{"name":"Content Provider","slug":"Content-Provider","link":"/tags/Content-Provider/"},{"name":"File Provider","slug":"File-Provider","link":"/tags/File-Provider/"},{"name":"Bitmap","slug":"Bitmap","link":"/tags/Bitmap/"},{"name":"Data Binding","slug":"Data-Binding","link":"/tags/Data-Binding/"},{"name":"MVVM","slug":"MVVM","link":"/tags/MVVM/"},{"name":"Coroutine","slug":"Coroutine","link":"/tags/Coroutine/"},{"name":"Unit Test","slug":"Unit-Test","link":"/tags/Unit-Test/"},{"name":"Mockito","slug":"Mockito","link":"/tags/Mockito/"},{"name":"Espresso","slug":"Espresso","link":"/tags/Espresso/"},{"name":"SoundPool","slug":"SoundPool","link":"/tags/SoundPool/"},{"name":"CustomView","slug":"CustomView","link":"/tags/CustomView/"},{"name":"TouchEvent","slug":"TouchEvent","link":"/tags/TouchEvent/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Programmers","slug":"Programmers","link":"/tags/Programmers/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"완전탐색","slug":"완전탐색","link":"/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"},{"name":"Data Structure","slug":"Data-Structure","link":"/tags/Data-Structure/"},{"name":"Linked List","slug":"Linked-List","link":"/tags/Linked-List/"},{"name":"BOJ","slug":"BOJ","link":"/tags/BOJ/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"바킹독","slug":"바킹독","link":"/tags/%EB%B0%94%ED%82%B9%EB%8F%85/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"완전 탐색","slug":"완전-탐색","link":"/tags/%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89/"},{"name":"해시","slug":"해시","link":"/tags/%ED%95%B4%EC%8B%9C/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Simulation","slug":"Simulation","link":"/tags/Simulation/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"백트래킹","slug":"백트래킹","link":"/tags/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9/"},{"name":"View Binding","slug":"View-Binding","link":"/tags/View-Binding/"},{"name":"findViewById","slug":"findViewById","link":"/tags/findViewById/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"이분탐색","slug":"이분탐색","link":"/tags/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"그래프","slug":"그래프","link":"/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"},{"name":"Terminology","slug":"Terminology","link":"/tags/Terminology/"},{"name":"Idempotent","slug":"Idempotent","link":"/tags/Idempotent/"},{"name":"RESTful","slug":"RESTful","link":"/tags/RESTful/"},{"name":"Jetpack","slug":"Jetpack","link":"/tags/Jetpack/"},{"name":"Compose","slug":"Compose","link":"/tags/Compose/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Memo","slug":"Android/Memo","link":"/categories/Android/Memo/"},{"name":"Guide","slug":"Android/Guide","link":"/categories/Android/Guide/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Codility","slug":"Algorithm/Codility","link":"/categories/Algorithm/Codility/"},{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"},{"name":"Coroutine","slug":"Kotlin/Coroutine","link":"/categories/Kotlin/Coroutine/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","link":"/categories/Algorithm/LeetCode/"},{"name":"Programmers","slug":"Algorithm/Programmers","link":"/categories/Algorithm/Programmers/"},{"name":"Data Structure","slug":"Data-Structure","link":"/categories/Data-Structure/"},{"name":"BOJ","slug":"Algorithm/BOJ","link":"/categories/Algorithm/BOJ/"},{"name":"Documentation","slug":"Android/Documentation","link":"/categories/Android/Documentation/"},{"name":"Terminology","slug":"Terminology","link":"/categories/Terminology/"},{"name":"Compose","slug":"Android/Compose","link":"/categories/Android/Compose/"}]}