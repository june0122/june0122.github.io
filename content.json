{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"안드로이드 뷰, 인플레이트, 리스너","text":"안드로이드 지원 라이브러리에서 제트팩으로 기존의 안드로이드 지원(support) 라이브러리들은 그 수가 많고 독립적인 개발 및 버전 관리 때문에 어려움이 많았다. 따라서 안드로이드 10부터는 모든 지원 라이브러리를 androidx라는 네임스페이스 namespace 를 갖는, 몇 개의 더 큰 라이브러리로 통합하게 되었다. 그렇고 이렇게 통합된 라이브러리를 Jetpack이라고 한다. 뷰 계층 구조(view hierarchy) 뷰(View) 뷰는 UI를 만드는데 사용되는 구성 요소 장치 화면에 보이는 모든 것이 뷰 사용자가 화면을 보며 상호 작용하는 뷰 -&gt; 위젯 widget 위젯(Widget) 안드로이드 SDK에는 많은 위젯이 포함되어 원하는 UI(화면에 보이는 모습과 앱과의 상호작용)을 구성 가능 모든 위젯은 View 클래스의 인스턴스이거나 View의 서브 클래스 TextView나 Button 중 하나의 인스턴스 뷰그룹(ViewGrop) View의 일종 다른 뷰를 포함하고 배치해 화면에 보여주지만 그 자신은 화면에 나타나지 않음 레이아웃도 뷰그룹, 뷰그룹의 서브 클래스에는 ConstraintLayout이나 FrameLayout 등이 있음 ConstraintLayout이 뷰그룹이며, 유일한 자식이 TextView 위젯인 레이아웃 activity_main.xmlxml123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 레이아웃 XML에서 뷰 객체로 xml 파일 내에 정의된 XML 요소들이 어떻게 View 객체가 될까? GeoQuiz 프로젝트를 생성하면 MainActivity라는 이름의 Activity 서브 클래스가 자동으로 생성된다. MainActivity 클래스 파일은 app/java 디렉터리의 com.june0122.geoquiz 패키지 아래에 있다. 안드로이드는 원래 자바 코드만 지원했기 때문에 현재 소스 코드 파일이 있는 디렉터리의 이름은 java다. 코틀린 소스 파일도 java 디렉터리에 저장된다. 물론 koltin이라는 이름의 새 디렉터리를 생성해 이 디렉터리에 코틀린 소스 파일들을 따로 저장할 수 있지만 해당 소스 파일들이 프로젝트에 포함되도록 kotlin 디렉터리에 있다는 것을 안드로이드 스튜디오에 알려줘야 한다. 하지만 사용 언어마다 소스 파일을 별개의 디렉터리에 두는 것은 그리 유용하지 않으므로 코틀린 소스 파일도 java 디렉터리에 두는 것이 좋다. (괜히 상호 호환성이 큰 장점이 아니다!) AppCompatActivity 란? 12345678910class MainActivity : AppCompatActivity() { private lateinit var trueButton: Button private lateinit var falseButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) }} AppCompatActivity는 안드로이드 Activity 클래스의 서브 클래스 과거 안드로이드 버전과의 호환성을 지원하기 위해 제공 'AppCompat’은 'application compatibility’의 단축어 Jetpack의 AppCompat 라이브러리는 안드로이드 버전이 달라도 일관된 UI를 유지하는 데 핵심이 되는 클래스와 리소스들을 포함한다. AppCompat의 각 하위 패키지들 12345androidx.appcompat.appandroidx.appcompat.content.resandroidx.appcompat.graphics.drawableandroidx.appcompat.viewandroidx.appcompat.widget app/build.gradle 파일에 추가되어있는 AppCompat 라이브러리 의존성 12345dependencies { ... implementation 'androidx.appcompat:appcompat:1.2.0' ...} Activity 함수 onCreate(Bundle?) 액티비티 서브 클래스의 인스턴스가 생성될 때 자동으로 호출됨 이때 이 함수에서는 액티비티가 UI를 화면에 보여주고 처리할 수 있도록 다음 함수를 호출함 Activity.setContentView(layoutResID: Int) 이 함수는 레이아웃을 인플레이트 inflate 해 화면에 나타낸다. 인플레이트 : 뷰 계층 구조를 따라 객체로 생성하는 것 레이아웃이 인플레이트되면 레이아웃 파일에 있는 각 위젯이 자신의 속성에 정의된 대로 인스턴스로 생성됨 이 함수를 호출할 때는 인플레이트될 레이아웃의 리소스 ID(resource ID)를 인자로 전달 리소스와 리소스 ID 레이아웃은 리소스(resource) 이다. 리소스는 애플리케이션의 일부이며, 코드가 아닌 이미지 파일이나 오디오 파일 및 XML 파일 같은 것들이다. 프로젝트의 리소스들은 app/res 디렉터리 아래의 서브 디렉터리에 존재한다. 코드에서는 리소스의 리소스 ID를 지정해야 사용 가능하며 모든 리소스 ID는 앱을 빌드할 때마다 안드로이드 빌드 도구가 R.class에 자동으로 생성한다(안드로이드 스튜디오 3.6 이전 버전에서는 소스 코드 파일인 R.java를 임시로 생성했지만, 3.7 이상 버전에서는 이 파일을 생성하지 않고 R.class만 생성). 레이아웃은 하나의 리소스 ID가 생성되고, 문자열은 각각에 대해 하나의 리소스 ID가 생성된다.하지만 레이아웃에 포함된 각 위젯에서는 코드에서 참조해 사용할 필요가 있는 것에만 리소스 ID가 필요하므로 직접 지정한 것만 생성된다. (GeoQuiz 레이아웃의 리소스 ID인 R.layout.activity_main에서 activity_main은 R 클래스의 내부 클래스인 layout 안에 정수형 상수로 정의되어 있다. 문자열도 리소스 ID를 가지며, R 클래스의 내부 클래스인 string 안에 정수형 상수로 정의되어 있다. 따라서 strings.xml 파일에 기본으로 정의도니 앱 이름의 문자열은 R.string.app_name으로 참조할 수 있다.) 123456&lt;Button android:id=&quot;@+id/true_button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginRight=&quot;10dp&quot; android:text=&quot;@string/true_button&quot; /&gt; XML 파일에서 버튼의 android:id 속성값에는 +가 있지만, android:text 속성값에는 없다는 것에 주목 android:id 속성은 ID를 생성하고, android:text 속성은 문자열을 참조만 하기 때문이다. 위젯을 코드와 연결하기 코트 연결의 두 단계 인플레이트된 View 객체들의 참조를 얻는다. 이 객체들에 리스너를 설정해 사용자 액션에 응답한다. 위젯의 참조 얻기 버튼들이 리소스 ID를 가지면 MainActivity에서 사용할 수 있다. 12345678910111213class MainActivity : AppCompatActivity() { private lateinit var trueButton: Button private lateinit var falseButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) trueButton = findViewById(R.id.true_button) falseButton = findViewById(R.id.false_button) }} 위의 코드에 있듯이, 액티비티에서는 Activity.findViewById(Int)를 호출해 View 객체로 인플레이트된 위젯의 참조를 얻는다. 이 함수는 위젯의 리소스 ID를 인자로 받아서 해당 위젯(여기서는 Button)의 객체를 반환한다(이때 View 타입을 Button 타입으로 반환해준다). 리스너 설정하기 안드로이드 애플리케이션은 이벤트 기반(event-driven) 으로 구동된다. 이벤트에 응답하기 위해 생성하는 객체를 리스너 listener 라고 하며, 리스너는 해당 이벤트의 리스너 인터페이스 listener interface 를 구현한다. 안드로이드 SDK에는 다양한 이벤트의 리스너 인터페이스가 존재하여 따로 만들 필요가 없다. 버튼이 눌러졌는지에 대한 이벤트를 리스닝하기 위해서, 아래 예제 코드의 리스너는 View.OnClickListener 인터페이스를 구현한다. 12345678910override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) trueButton = findViewById(R.id.true_button) falseButton = findViewById(R.id.false_button) trueButton.setOnClickListener { view: View -&gt; // 버튼 클릭의 응답을 여기서 처리 } trueButton의 리스너는 OnClickListener 인터페이스를 구현하는 익명 클래스의 인스턴스이며 중괄호 {} 안에 정의한다. 그리고 setOnClickListener 함수로 등록한다. 안드로이드 프레임워크에는 onClick(View) 메서드만 갖는 인터페이스인 View.OnClickListener가 정의되어 있다. 이처럼 단일 추상 메서드 Single Abstract Method, SAM 를 갖는 자바 인터페이스를 SAM이라고 하며, 주로 익명의 내부 클래스를 사용해서 구현한다. 코틀린에서는 자바와 호환성을 유지하기 위해 특별한 형태로 SAM을 지원한다. 즉, 함수 리터럴 또는 람다식으로 SAM을 작성하면 이것을 해당 인터페이스의 구현 객체로 변환한다(코틀린에선 함수 리터럴이나 람다식으로 익명 함수 정의 가능). 이와 같은 내부 처리를 SAM 변환 SAM conversion 이라고 한다. 위의 예제는 람다식을 이용하여 OnClickListener 인터페이스를 구현한 것이다. View.OnClickListener 인터페이스 문서 12345678910111213package android.view;/** * Interface definition for a callback to be invoked when a view is clicked. */public interface OnClickListener { /** * Called when a view has been clicked. * * @param v The view that was clicked. */ void onClick(View v);} 12345trueButton.setOnClickListener(object : View.OnClickListener { override fun onClick(v: View?) { TODO(&quot;Not yet implemented&quot;) }}) trueButton이라는 뷰 객체에 setOnClickListener라는 메소드가 있는데, 이 메소드는 View.OnClickListener 인터페이스 객체를 받는 메소드이다. 인터페이스를 객체로 넘길 때, 구현체 부분이 있어야 하므로 익명 객체의 구현체를 만들어서 같이 넘기게 된다. 안드로이드 앱 빌드 절차 빌드를 하는 동안 안드로이드 도구가 리소스와 코드 그리고 AndroidManifest.xml 파일(애플리케이션에 관한 메타데이터를 포함)을 가지고 하나의 .apk 파일로 만든다. 그리고 이 파일은 실제 장치나 에뮬레이터에서 실행될 수 있게 디버그 키가 부여된다(.apk를 구글 플레이 스토어에서 배포하려면 구글에서 릴리즈 키를 받아 앱에 포함시켜야 한다). 안드로이드 스튜디오에서는 프로젝트의 빌드와 관리에 필요한 모든 것을 그래들(Gradle) 자동화 빌드 도구를 사용해 처리하므로 신경 쓰지 않아도 된다. 그런데 레이아웃 파일인 activity_main의 내용은 어떻게 애플리케이션의 View 객체로 변환될까? 빌드 절차의 일부로 aapt2 Android Asset Packaging Tool 2가 레이아웃 파일의 리소스들을 좀 더 압축된 형태로 컴파일한다. 그리고 이렇게 컴파일된 리소스들이 .apk 파일로 통합된다. 그 다음에 MainActivity의 onCreate(Bundle?) 메서드에서 setContentView(…) 메서드가 호출되면, MainActivity는 LayoutInflater 클래스를 사용해서 레이아웃 파일에 정의된 각 View의 인스턴스를 생성한다. activity_main.xml을 인플레이트(XML 요소를 뷰 객체로 생성)하기 뷰 클래스를 XML로 정의하는 대신에 액티비티에서 코틀린이나 자바 코드로 생성할 수도 있다. 하지만 이것은 그리 좋은 방법이 아니다. 뷰 클래스를 XML로 정의하면 프레젠테이션(사용자 인터페이스) 계층을 애플리케이션 로직과 분리할 수 있기 때문이다. MVC 패턴","link":"/2021/05/08/01%20%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%20%EB%B7%B0,%20%EC%9D%B8%ED%94%8C%EB%A0%88%EC%9D%B4%ED%8A%B8,%20%EB%A6%AC%EC%8A%A4%EB%84%88/"},{"title":"안드로이드와 모델-뷰-컨트롤러","text":"데이터 클래스(data class) 1data class Question(@StringRes val texResId: Int, val answer: Boolean) @StringRes 애노테이션은 없어도 되지만, 다음 두 가지 이유로 지정하는 것이 좋다. 생성자에서 유효한 문자열 리소스 ID를 제공하는지를 컴파일 시점에서 Lint(안드로이드 스튜디오에 내장된 코드 검사기)가 검사한다. 따라서 유효하지 않은 리소스 ID가 생성자에 사용되어 런타임 시에 앱이 중단되는 것을 방지해준다. 애노테이션을 지정함으로써 다른 개발자가 쉽게 코드를 알 수 있다. texResId의 타입이 String이 아니고 Int인 이유는 texResId 변수는 질문 문자열 리소스의 리소스 ID(항상 Int 타입)를 갖기 때문이다. Question과 같은 클래스처럼 주로 데이터를 갖는 클래스가 많이 있으며, 그중에는 업무에 관련된 것도 있고 프로그램에서 필요해서 생성한 것도 있다. 이런 클래스들은 비즈니스 로직을 처리하는 함수보다는 주로 데이터를 저장하는 속성을 갖는다. 따라서 클래스 인스턴스끼리 각 속성의 값을 비교하거나(equals() 함수) 인스턴스를 컬렉션(HashMap 등)에 저장할 때 사용할 키 값(해시 코드)을 생성하는(hashCode() 함수) 기능이나 속성값을 문자열로 쉽게 출력하는(toString 함수) 기능이 공통으로 필요하다. 이런 이유로 코틀린에서는 데이터 클래스(data class)라는 개념을 추가하였다. 즉, 클래스를 정의할 때 data 키워드를 지정하면 이 클래스를 데이터 클래스로 간주하며, 방금 설명했던 기능들을 처리해주는 함수들을 해당 클레스에 맞게 코틀린 컴파일러가 자동으로 생성해준다. GeoQuiz의 객체 다이어그램 모델-뷰-컨트롤러와 안드로이드 위 그림의 객체들은 세 부분, 즉 모델(Model), 컨트롤러(Controller), 뷰(View)로 분리됨에 주목하자. 안드로이드 API는 모델-뷰-컨트롤러(MVC)라는 아키텍처에 맞추어 설계되었다. 애플리케이션의 어떤 객체든 모델 객체 또는 뷰 객체 또는 컨트롤러 객체가 되어야 한다는 것이 MVC의 주요 관점이다. 모델 객체 (Model Object) 모델 객체는 애플리케이션의 '데이터’와 '비즈니스 로직’을 갖는다. 모델 클래스는 앱과 관계가 있는 것들을 모델링한다. ex) 사용자, 상품, 서버에 저장된 사진 등 모델 객체는 UI를 모른다. 데이터를 보존하고 관리하는 것이 유일한 목적이다. 애플리케이션의 모든 모델 객체들은 모델 계층(model layer) 을 구성한다. GeoQuiz의 모델 계층은 Question 클래스로 구성된다. 뷰 객체 (View Object) 뷰 객체는 자신을 화면에 그리는 방법과 터치와 같은 사용자의 입력에 응답하는 방법이다. 쉽게 말해, 화면에서 볼 수 있는 것이라면 그것은 뷰 객체다. 안드로이드는 구성 가능한 뷰 클래스를 풍부하게 제공하지만, 직접 커스텀 클래스를 생성할 수도 있다. 애플리케이션의 뷰 객체들은 뷰 계층(view layer) 을 구성한다. GeoQuiz의 뷰 계층은 res/layout/activity_main.xml 요소들로부터 인플레이트되는 위젯들로 구성된다. 컨트롤러 객체 (Controller Object) 컨트롤러 객체는 뷰와 모델 객체를 결속하여 '애플리케이션 로직’을 포함한다. 컨트롤러 객체는 뷰 객체에 의해 촉발되는 다양한 이벤트에 응답하고 모델 객체 및 뷰 계층과 주고받는 데이터의 흐름을 관리한다. 안드로이드에서 컨트롤러는 일반적으로 Activity나 Fragment의 서브 클래스이다. GeoQuiz의 컨트롤러 계층은 MainActivity만으로 구성되어 있다. 사용자 입력의 MVC 처리 흐름 MVC 사용하기 애플리케이션 기능이 많아지면 너무 복잡해져 이해하기 어려울 수 있다. 따라서 코드를 클래스로 분리하면 설계에 도움이 되고 전체를 이해하기도 쉬워진다. 개별적인 변수와 함수 대신 클래스 관점으로 생각할 수 있기 때문이다. 이와 유사하게 클래스들을 모델과 뷰 그리고 컨트롤러 계층으로 분리하면 애플리케이션을 설계하고 이해하는 데 도움이 된다. 개별적인 클래스 대신 계층의 관점으로 생각할 수 있기 때문이다. MVC는 클래스를 재사용하기 쉽도록 해준다. 여러 일을 혼자서 처리하는 클래스보다는 제한된 책임을 갖는 클래스를 재사용하는 것이 더 쉽기 때문이다. MVC는 큰 앱은 물론 작고 같단한 앱에도 잘 적용되지만, 더 크고 복잡한 앱에서는 컨트롤러 계층이 훨씬 커지거나 복잡해질 수 있다. 대게는 액티비티나 다른 컨트롤러들을 가볍게(thin) 유지하려고 한다. 가벼운 액티비티는 가능한 한 비즈니스 로직을 적게 포함하기 때문이다. 그리고 앱의 컨트롤러를 가볍게 만드는 데 MVC가 더 이상 적합하지 않을 때는 MVVM(모델-뷰-뷰모델) 아키텍처가 그 대안이 될 수 있다. tools 네임스페이스 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot;&gt; // 레이아웃의 루트 태그에 tools 네임스페이스 추가 &lt;TextView android:id=&quot;@+id/question_text_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:padding=&quot;24dp&quot; tools:text=&quot;@string/question_australia&quot; /&gt; // tools 네임스페이스로 지정 ... 이 네임스페이스를 사용하면 TextView 위젯의 속성을 오버라이드해 레이아웃 디자인에 해당 문자열 리소스를 보여줄 수 있다. TextView에 tools:text 속성을 추가하면, 안드로이드 스튜디오가 tools:text 속성을 알 수 있게 레이아웃의 루트 태그에 tools 네임스페이스를 추가해야 한다. tools 네임스페이스 속성들은 앱이 장치에서 실행되어 위젯들이 화면에 나타날 때는 무시된다. android:text로 지정된 값은 런타임 시에 나타나고, tools:text로 지정된 값은 디자인 시에 보기 위해 사용된다. 화면 픽셀 밀도 안드로이드는 밀도에 독립적인 크기 단위를 제공한다. 따라서 서로 다른 화면 밀도에서 일정한 크기를 갖도록 그 단위를 사용하면 된다. 그리고 안드로이드가 그 단위를 런타임 시에 픽셀로 변환하므로 신경 쓸 필요도 없다. px: pixel(픽셀) 의 줄임말이다. 화면 밀도와는 무관하게 1픽셀은 화면의 1픽셀과 일치한다. 픽셀은 장치의 화면 밀도에 적합하게 조정되지 않으므로 사용을 권장하지 않는다, dp: density-independent pixel(밀도 독립적 필셀) 의 줄임말이다. 마진과 패딩 등의 크기를 픽셀 값으로 지정하지 않을 때 사용한다. 1dp는 항상 장치 화면의 1/160인치이며, 화면 밀도와 무관하게 일정한 크기를 갖는다. 따라서 장치의 화면이 고밀도일 때는 더 많은 수의 화면 픽셀을 채우기 위해 dp를 사용한다. sp: scale-independent pixel(크기 독립적 픽셀) 의 줄임말이다. sp는 사용자의 폰트 크기 선택도 고려한 dp다. 주로 화면에 나타나는 텍스트의 크기를 설정하기 위해 사용한다. pt, mm, in: 포인트(1/72인치), 밀리미터, 인치로 크기를 지정할 수 있는 크기 단위이다. 그런데 모든 장치에 잘 맞도록 구성되지 않아 사용을 권장하지 않는다. 실무에서는 dp와 sp를 사용하며, 안드로이드는 이 값들을 런타임 시에 픽셀로 변환한다.","link":"/2021/05/08/02%20%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%20%EB%AA%A8%EB%8D%B8%20%EB%B7%B0%20%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC/"},{"title":"액티비티 생명주기","text":"액티비티 상태와 생명주기 콜백 Activity의 모든 인스턴스는 생명주기를 갖는다. 그리고 생명주기 동안에 액티비티는 네 가지 상태, 즉 실행 재개(resumed), 일시 중지(paused), 중단(stopped), 존재하지 않음(non-existent)으로 상호 전환된다. 또한, 각 전환이 발생할 때 액티비티에 상태 변경을 알려주는 Activity 함수들이 있으며, 이 함수들은 안드로이드가 자동 호출한다. 액티비티 상태 다이어그램 액티비티 상태 상태 메모리에 있음? 사용자에게 보임? 포그라운드에서 실행? 존재하지 않음 아니오 아니오 아니오 중단 예 아니오 아니오 일시 중지 예 예(부분적)* 아니오 실행 재개 예 예 예 * 당시 상황에 따라 일시 중지된 액티비티의 전체 또는 일부가 사용자에게 보일 수 있다 ↩ ‘존재하지 않음’ 상태 액티비티가 아직 론칭되지 않았거나 소멸되었음(예를 들어, 사용자가 백 버튼을 눌러서)을 나타낸다. 이 때문에 때로는 이 상태를 ‘소멸(destroyed)’ 상태라고도 한다. 이때 액티비티 인스턴스는 메모리에 존재하지 않으며, 사용자가 보거나 상호 작용하기 위한 뷰도 없다. ‘중단’ 상태 액티비티 인스턴스가 메모리에 있지만, 이것의 뷰는 화면에서 볼 수 없다는 것을 나타낸다. 액티비티가 처음 시작될 때 거쳐가는 상태이며, 액티비티 인스턴스의 뷰가 화면에서 완전히 가려졌을 때 언제든 다시 진입하는 상태다. 예를 들어, 전체 화면을 사용하는 다른 액티비티를 사용자가 시작하거나 홈 버튼을 누를 때 등이다. ‘일시 중지’ 상태 액티비티가 포그라운드(foreground)에서 작동하지는 않지만, 액티비티 인스턴스의 뷰 전체 또는 일부를 화면에서 볼 수 있음을 나타낸다. 예를 들어, 이 액티비티 위에 새로운 대화상자나 투명 액티비티가 사용자에 의해 시작된다면 이 액티비티는 일부만 화면에 보이게 된다. 만일 사용자가 다중 창 모드(분활 화면 모드)로 두 개의 액티비티를 같이 보고 있다면 액티비티 전체가 화면에 보일 수 있지만, 포그라운드에 존재하지 않을 수도 있다. ‘실행 재개’ 상태 액티비티가 메모리에 있으면서 화면에서 전체를 볼 수 있고 포그라운드에 있음을 나타낸다. 사용자가 현재 상호 작용하고 있는 액티비티가 바로 이 상태다. ‘실행 재개’ 상태는 장치의 전체 시스템에 걸쳐 하나의 액티비티만 될 수 있다. 즉, 한 액티비티가 ‘실행 재개’ 상태가 되면 직전에 실행 중이던 액티비티는 다른 상태로 바뀐다는 의미다. 상단의 액티비티 상태 다이어그램 이미지에 있는 함수들을 사용해 액티비티 생명주기의 전환 시점에 필요한 일을 처리할 수 있다. 이 함수들을 생명주기 콜백(lifecycle callback) 이라고 한다. 이미 생명주기 콜백 함수 중 하나인 onCreate(Bundle?)을 알고 있을 것이다. 액티비티 인스턴스가 생성되고 화면에 나타나기 전에 안드로이드 운영체제가 이 함수를 호출한다. UI를 준비하기 위해 액티비티에서는 다음과 같이 onCreate(Bundle?) 함수를 오버라이드(override)한다. 위젯을 인플레이트해 뷰 객체로 생성한 후 화면에 보여준다. (setContentView(Int)를 호출) 인플레이트된 위젯의 객체 참조를 얻는다. 사용자와의 상호 작용을 처리하기 위해 위젯에 리스너를 설정한다. 외부의 모델 데이터를 연결한다. 액티비티 생명주기 로깅하기 로그 메세지 만들기 안드로이드에서 android.util.Log 클래스는 공유되는 시스템 수준의 로그에 로그 메시지를 전달한다. Log 클래스는 메시지를 로깅하기 위한 함수들을 갖고 있다. 메시지의 내용은 물론, 메시지의 중요도를 나타내는 레벨(level)도 제어할 수 있다. 안드로이드는 다섯 개의 로그 레벨을 지원 로그 레벨과 함수 로그 레벨 함수 용도 ERROR Log.e(…) 에러 WARNING Log.w(…) 경고 INFO Log.i(…) 정보성 메시지 DEBUG Log.d(…) 디버깅 출력이며 필터링할 수 있다. VERBOSE Log.v(…) 개발 전용 각 로깅 함수는 두 개의 시그니처(signature)를 갖는다. 하나는 태그 문자열과 메시지 문자열로 된 두 개의 인자를 받고 일반적으로 태그 문자열에는 클래스 이름을 값으로 갖는 TAG 상수를 지정한다. 이렇게 하면 메시지의 근원을 알기 쉽다. 다른 하나는 이 두 인자에 Throwable 인스턴스를 추가로 받는다. Throwable 인스턴스는 앱이 발생시킬 수 있는 특정 예외에 관한 정보를 쉽게 로깅할 수 있게 한다. TAG 상수 추가하기 (MainActivity.kt) 1234567import ...private const val TAG = &quot;MainActivity&quot;class MainActivity : AppCompatActivity() { ...} 참고로, 이처럼 .kt 파일 내부에서 클래스 바깥쪽에 선언한 변수를 코틀린에서는 최상위 수준 속성이라고 한다. 최상위 수준 속성은 다음 두 가지 상황에 사용할 수 있다. 특정 클래스의 인스턴스를 생성하지 않고 바로 사용할 수 있으므로 애플리케이션이 실행되는 동안 속성값을 계속 보존해야 할 때다. 애플리케이션 전체에서 사용하는 상수를 정의할 때 유용하다. 안드로이드에서 로깅하는 방법 123456789// DEBUG 로그 레벨로 메시지를 로깅한다Log.d(TAG, &quot;Current question index: $currentIndex&quot;)try { val question = questionBank[currentIndex]} catch (ex: ArrayIndexOutOfBoundsException) { // 스택에 저장된 예외의 기록과 함께 ERROR 로그 레벨로 메시지를 로깅한다 Log.e(TAG, &quot;Index was out of bounds&quot;, ex)} 생명주기 함수를 추가로 오버라이드하기(MainActivity.kt) 12345678910111213141516171819202122232425262728293031323334353637class MainActivity : AppCompatActivity() { ... override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) Log.d(TAG, &quot;onCreate(Bundle?) called&quot;) setContentView(R.layout.activity_main) ... } override fun onStart() { super.onStart() Log.d(TAG, &quot;onStart() called&quot;) } override fun onResume() { super.onResume() Log.d(TAG, &quot;onResume() called&quot;) } override fun onPause() { super.onPause() Log.d(TAG, &quot;onPause() called&quot;) } override fun onStop() { super.onStop() Log.d(TAG, &quot;onStop() called&quot;) } override fun onDestroy() { super.onDestroy() Log.d(TAG, &quot;onDestroy() called&quot;) } ...} Log.d(…)를 호출해 메시지를 로깅하기 전에 오버라이드되는 슈퍼 클래스 함수를 호출한다는 점에 유의하자. 오버라이드하는 각 콜백 함수에서는 오버라이드되는 슈퍼 클래스 함수를 호출하는 코드가 맨 앞에 있어야 한다. 각 함수에 override 키워드가 있는 이유는 오버라이드하는 함수가 슈퍼 클래스에 있는지 컴파일러에게 확인하라고 요청하기 위해서다. 액티비티 생명주기가 사용자 액션에 어떻게 응답하는지 살펴보기 GeoQuiz 앱이 설치 및 실행될 때는 생명주기 함수 onCreate(Bundle?), onStart(), onResume()가 차례대로 호출되고 MainActivity 인스턴스가 생성된다. 즉, MainActivity 인스턴스가 ‘실행 재개’ 상태가 된다(메모리에 로드되고, 사용자에게 보이며, 포그라운드에서 작동함). 앱 설치 및 실행 시, onCreate(Bundle?), onStart(), onResume()가 차례대로 호출된다. 일시적으로 액티비티 떠나기 홈 버튼을 누르면 MainActivity는 onPause(), onStop() 호출을 받지만, onDestroy()는 호출되지 않는다. 그러면 MainActivity는 어떤 상태일까? 홈 버튼을 누르면 onPause(), onStop()가 호출된다. 장치의 홈 버튼을 누르면 안드로이드 운영체제에 '나는 다른 작업을 하려고 한다. 그런데 현재의 액티비티 화면에서 볼일이 다 끝나지 않았으므로 다시 돌아올 수 있다.'라고 알리는 셈이 된다. 따라서 안드로이드 운영체제는 현재 액티비티를 일시 중지했다가 중단시킨다. 즉, GeoQuiz 앱에서 홈 버튼을 누른 후에는 MainActivity의 인스턴스가 ‘중단’ 상태가 된다(메모리에는 있지만 사용자에게는 보이지 않으며, 포그라운드에서 실행되지 않는다). 그러나 사용자가 나중에 GeoQuiz 앱으로 돌아오면 안드로이드 운영체제는 재빨리 MainActivity 인스턴스를 다시 시작한다. 다시 앱을 키면 onStart(), onResume()이 차례로 호출된다. (onPause(), onStop()는 홈 버튼 클릭 시 호출된 것) 오버뷰 화면(overview screen)에서의 동작은? 아래의 이미지와 같이 오버뷰 화면의 각 카드는 이전에 사용자가 사용했던 앱을 나타낸다. 오버뷰 화면은 ‘최근 앱 화면’ 또는 '태스크 매니저’라고도 한다. 여기서는 개발자 문서에서 얘기하는 '오버뷰 화면’이라고 칭한다. 오버뷰 화면에서 태스크 클릭 시에는 onStart(), onResume()이 호출 오버뷰 화면에서 GeoQuiz 태스크를 클릭하면 MainActivity가 화면에 나타난다. 이때 로그캣 창의 메시지를 보면 onStart(), onResume()이 호출되었음을 알 수 있다. 하지만 onCreate(...)는 호출되지 않았는데 홈 버튼을 누른 후에 MainActivity는 ‘중단’ 상태가 되었기 때문이다. 따라서 MainActivity 인스턴스는 여전히 메모리에 있으므로 다시 생성될 필요가 없다. 그리고 오버뷰 화면에서 선택되면 액티비티만 다시 시작되어('일시 정지’이면서 화면에 볼 수 있는 상태) 실행이 재개된다(포그라운드로 '실행 재개’되는 상태). 액티비티는 ‘일시 중지’ 상태에 머물러 있을 수도 있는데, 이때는 일부만 화면에 보이거나(예를 들어, 투명한 백그라운드를 갖거나 더 작은 화면 크기를 갖는 다른 액티비티가 '일시 중지’된 액티비티 화면 위에 있을 때) 또는 전체 화면이 보일 수도 있다(다중 창 모드일 때). 다중 창 모드(multi window mode)에서의 동작은? &emsp;&emsp;&emsp;&emsp; 아래 창에 열린 다른 앱을 클릭하고 로그캣의 메시지를 보면 GeoQuiz의 MainActivity에서 onPause()가 호출되었음을 알 수 있다. 즉, MainActivity는 현재 ‘일시 중지’ 상태다. 그리고 위의 창에 열린 GeoQuiz를 클릭하면 MainActivity의 onResume()가 호출된다. 이제는 MainActivity가 ‘실행 재개’ 상태가 되었기 때문이다. 액티비티 끝내기 장치의 백 버튼을 누른 후 로그캣의 메시지를 확인해보자. MainActivity의 onPause(), onStop(), onDestroy()가 호출되었을 것이다. MainActivity의 인스턴스가 존재하지 않는 상태다(메모리에 없고 화면에도 보이지 않으며, 포그라운드에서도 동작하지 않음). 백 버튼을 누르면 액티비티 인스턴스가 소멸되어 onPause(), onStop(), onDestroy()가 호출된다. 장치의 백 버튼을 눌렀다는 것은 앱의 사용자가 해당 액티비티를 끝냈다는 의미다. 달리 말해, 안드로이드 운영체제에 '나는 이 액티비티를 다 사용했으므로 더 이상 필요 없다.'라고 알리는 셈이다. 그러면 안드로이드 운영체제는 해당 액티비티를 소멸시키고 메모리로부터 모든 흔적을 지운다. 이것이 바로 장치의 제한된 리소스를 절약하는 안드로이드의 방식이다. 또한, 오버뷰 화면에서 해당 앱의 카드를 옆으로 밀어내도 앱을 끝낼 수 있으며, 코드에서는 Activity.finish()를 호출해 액티비티를 끝낼 수 있다. 오버뷰 화면에서 앱 종료 시, onDestroy() 호출 액티비티 회전시키기 장치를 회전하면 onPause(), onStop(), onDestroy(), onCreate(...), onStart(), onResume()이 차례로 호출된다. 장치 회전 시, MainActivity가 죽었다가 다시 살아난다! 위 메시지를 보면 알 수 있듯, 장치를 회전하면 보고 있던 MainActivity 인스턴스는 소멸되었다가 다시 새로운 인스턴스로 생성된다. 현재 인스턴스의 currentIndex에 저장된 값이 메모리에서 지워지므로, 장치를 회전하면 그 당시 사용자가 어떤 문제를 보고 있었는지 GeoQuiz가 모르게 된다는 의미다. 장치가 회전될 때 안드로이드는 완전히 새로운 MainActivity 인스턴스를 생성한다. 따라서 onCreate(Bundle?)에서 currentIndex이 값이 0으로 초기화되므로 사용자는 첫 번째 문제를 다시 보게 된다. 장치 구성 변경과 액티비티 생명주기 장치를 회전하면 장치 구성(device configuration) 이 변경된다. 장치 구성은 각 장치의 현재 상태를 나타내는 특성들의 집합이다. 장치 구성을 이루는 특성에는 화면 방향, 화면 밀도, 화면 크기, 키보드 타입, 도크(dock) 모드, 언어 등이 있다. 일반적으로 앱에서는 서로 다른 장치 구성에 맞추기 위해 대체 리소스를 제공한다. 장치마다 다른 화면 밀도를 고려해 여러 화살표 아이콘을 프로젝트에 추가했을 때 이미 이런 예를 보았다. 런타임 구성 변경(runtime configuration change) 이 생길 때는 새로운 구성에 더 잘 맞는 리소스들이 있을 수 있다. 따라서 안드로이드는 현재의 액티비티 인스턴스를 소멸시키고 새로운 구성에 가장 적합한 리소스를 찾는다. 그리고 그런 리소스를 사용해서 해당 액티비티의 새 인스턴스를 다시 빌드한다. 예로 장치의 화면 방향이 가로 방향으로 변경될 때 안드로이드가 찾아 사용할 대체 리소스를 생성할 수 있다. 가로 방향 레이아웃 activity_main.xml (land) 생성 방향에 따른 레이아웃이 나온다 &emsp;&emsp;&emsp;&emsp;","link":"/2021/05/08/03%20%EC%95%A1%ED%8B%B0%EB%B9%84%ED%8B%B0%20%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Guide","slug":"Android/Guide","link":"/categories/Android/Guide/"}]}